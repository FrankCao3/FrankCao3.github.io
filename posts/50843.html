<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>C/C++ 基础知识 | CCB</title><meta name="keywords" content="计算机基础"><meta name="author" content="ccb"><meta name="copyright" content="ccb"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="C/C++ 基础知识"><meta name="application-name" content="C/C++ 基础知识"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="C/C++ 基础知识"><meta property="og:url" content="https://frankcao3.github.io/posts/50843.html"><meta property="og:site_name" content="CCB"><meta property="og:description" content="C&amp;#x2F;C++[TOC] 1. 数组一维数组可以用于实现线性表的顺序存储、哈希表等，二维数组可用来保存图的邻接矩阵等。 没有引用数组，但数组可以有引用。 有指针数组和数组指针。 1.1 一维数组初始化在函数体外定义的内置类型数组（全局数组），元素会被初始化为0； 在函数体外定义的内置类型数组，"><meta property="og:locale" content="en"><meta property="og:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta property="article:author" content="ccb"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta name="description" content="C&amp;#x2F;C++[TOC] 1. 数组一维数组可以用于实现线性表的顺序存储、哈希表等，二维数组可用来保存图的邻接矩阵等。 没有引用数组，但数组可以有引用。 有指针数组和数组指针。 1.1 一维数组初始化在函数体外定义的内置类型数组（全局数组），元素会被初始化为0； 在函数体外定义的内置类型数组，"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://frankcao3.github.io/posts/50843"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"copy":true,"copyrightEbable":true,"limitCount":50,"languages":{"author":"Author: ccb","link":"Link: ","source":"Source: CCB","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.","copySuccess":"Copy success, copy and reprint please mark the address of this article"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'CCB',
  title: 'C/C++ 基础知识',
  postAI: '',
  pageFillDescription: 'Cx2FC++, 1. 数组, 1.1 一维数组, 初始化, C风格字符串, 1.2 二维数组, 初始化, 1.3 指针, 指针运算, 指针数组与数组指针, 1.4 数组的应用, 2. 字符串, 2.1 基础操作, 2.2 字符串包含问题, 串的模式匹配算法KMP, 字符串移位包含问题, 2.3 字符串转数字, 2.4 其他问题, 3. 结构体、共用体和枚举, 3.1 结构体的定义, 3.2 结构体中的位字段, 3.3 共用体, 3.4 大小端存储, 字节序, 位序, 3.5 枚举, 3.6 sizeof运算符, 使用方法, 使用结果, struct的空间计算, 含位域的结构体的空间计算, union的空间计算, 枚举的空间计算, 4.  运算符及其优先级, 赋值语句, 自增与自减运算符, 关系与逻辑运算符, 位运算符, 赋值转换, 表达式转换, 显示转换（强制类型转换）, 运算符优先级表, 5.  C预处理器、作用域、static、const以及内存管理, 5.1 C预处理器, 宏定义与宏替换, 文件包含, 条件编译, 5.2 全局变量与局部变量, 5.3 static, static的作用, 类中static的作用, 5.4 const, 常量, 指针和const, const修饰函数参数与返回值, cosnt在类中的应用, 5.5 内存管理与释放, C语言内存操作函数, C++内存管理, 6. 函数, 参数传递, 内联函数, 默认参数, 函数重载, 函数模板与泛型, 函数模板, 类模板, 函数的递归, 7. 指针与引用, 指针, 指针的声明, typedef, void* 指针, 指向指针的指针, 函数指针, 野指针, 引用, const引用（常引用）, 引用做类的数据成员, 8. 类, 8.1 访问标号, 8.2 类成员简介, 成员函数, 构造函数, 成员初始化列表, 拷贝构造函数, x3Dx3D浅复制与深复制x3Dx3D, 析构函数, 构造函数与析构函数调用顺序, 操作符重载, 赋值操作符重载, operator new和operator delete的重载, 8.3 成员函数的重载、覆盖与隐藏, 成员函数的重载, 成员函数的覆盖, 成员函数的隐藏, 9. 面向对象编程, 9.1 继承, 基类成员在派生类中的访问属性, 继承时导致的二义性, 类间的转换, 多基继承, 菱形继承, 转换构造函数, 类型转换函数, 9.2 虚函数多态, 静态联编与动态联编, 虚函数的访问, 构造函数和析构函数中的虚函数, 虚函数表指针（vptr）及虚基类表指针（bptr）, 虚函数表指针, 含静态变量、虚函数的类的空间计算, 虚函数表的实现, 虚基类表指针, 虚拟继承时构造函数的书写, 纯虚函数, 9.3 动态运行时类型识别与显式转换, typeid, 显示转换, reinterpret_cast, const_cast, static_cast, dynamic_cast数组一维数组可以用于实现线性表的顺序存储哈希表等二维数组可用来保存图的邻接矩阵等没有引用数组但数组可以有引用有指针数组和数组指针一维数组初始化在函数体外定义的内置类型数组全局数组元素会被初始化为在函数体外定义的内置类型数组元素不会被初始化但是若初始化了部分元素其后的元素也会被初始化为若不是内置类型不管在何处定义均调用其默认构造函数为其初始化若无默认构造函数则报错大小未知时使用动态声明使用完毕后释放内存空间表示释放所指数组的内存如果是类对象分别调用每个数组元素的析构函数风格字符串字符串常量以双引号括起的字符序列且中均在末尾自动添加一个空字符注意表示单个字符表示字符串常量其表示和两个字符字符数组可以使用初始化最后一个元素必须为空字符以其作为字符串结束标志也可以使用双引号括起的字符串初始化自动在末尾添加不是风格字符串末尾没有是风格字符串长度为是风格字符串末尾自动添加长度为是风格字符串报错因为字符串末尾其实还有一个空字符长度为而不是注意使用风格字符串的标准库函数时牢记参数必须以空字符结束若一数组变量的末尾没有但是又使用了风格字符串的标准库函数比如进行处理那么程序就会在该变量的内存空间中一直寻找空字符直到恰好遇到为止导致程序出错二维数组初始化按行初始化使用两层花括号初始化每一个花括号代表一行顺序初始化使用一个花括号初始化逐行填入缺少的默认初始化为在声明和初始化二维数组时若对所有元素都赋值可以省略第一维但声明更高维数组时最多也只能省略第一维逐行填入缺少的默认初始化为部分初始化每行缺少的默认初始化为初始化所有元素时可以省略第一维中二维数组按照行优先顺序存储所以二维数组在内存空间中的地址顺序有如下关系列数就等于另外由于是行优先顺序存储所以也不会报错会直接顺延到下一行指向值动态声明行列手动动态声明的数组需要手动释放内存指针指针运算在中指针虽然经常被当作整数来处理但是其支持的操作非常有限合法的运算包括指针与整数的加减同类型指针的比较同类型两指针相减当指针与一个整数量进行算数运算时整数在执行加法运算前始终会根据合适的大小进行调整相乘比如字符指针加则运算结果产生的指针指向内存中的下一个字符整数量乘如果指针指向类型的变量由于类型占据个字节所以指针加时实际加到指针上的整型值为整数量乘即增加一个大小所以指针的大小与所指变量类型相关其运算中指针增加的值也与这个类型相关指针的算数运算的指针的算术运算只局限于两种形式第种形式是指针整数这种形式用于指向数组中某个元素的指针第二种类型的指针运算具有如下的形式指针指针只有当两个指针都指向同一个数组中的元素时才允许从一个指针减去另一个指针减法运算的值是两个指针在内存中的距离以数组元素的长度为单位而不是以字节为单位即相差多少个元素就是多少如果两个指针所指向的不是同一个数组中的元素那么它们之间相减的结果是未定义的程序员无从知道两个数组在内存中的相对位置如果不知道这一点两个指针之间的距离就毫无意义指针的关系运算还可以进行运算不过前提是它们都指向同个数组中的元素根据你所使用的操作符比较表达式将告诉你哪个指针指向数组中更前或更后的元素指针数组与数组指针指针数组由指针作为元素组成的数组定义数组指针一个指向数组的指针定义为指向有个元素的整形数组的指针因为的优先级高于所以要有括号用表示指向的数组有个元素数组指针运算时以一整个数组大小为单位对于二维数组定义一个与等价的数组指针变成变成把存放该字符串的首地址装入指针变量该语句错误最后一个语句错误是数组内存分配在栈上故可以通过数组名或指向数组的指针进行修改而指向的是位于文字常量区的字符串是不允许被修改的故通过指针修改错误但使用访问相应元素是正确的只是不能修改指针和数组密切相关特别是在表达式中使用数组名时该名字会自动转换为指向数组首元素第元素的指针但是注意数组的首地址是常量不可以进行赋值操作编译错误数组首地址为常量不可变更可以使用实现修改第四个元素为可使用如下操作注意对于来说等价于为指向数组首元素的指针每加就跳过个字节类型而为指向数组的指针与的类型不同的类型为但是指向的单元相同例题在二维数组中同理其可以看成由个数组作为元素组成的数组那么的第一个元素为数组然后是数组表示指向数组首元素的指针即数组指针而本身为包含个元素的数组所以表示指向数组首元素的指针因此类型为整个二维数组的数组指针等价于直接跳到二维数组末尾类型为为的第一个数组元素的数组指针且为常量不可以进行赋值运算指向加将直接跳过个元素即相当于或类型为指针指向数组的首元素或指向数组首元素的指针为数组的第二个元素例题数组的应用线性表的顺序存储线性表是一种逻辑结构线性表的顺序存储成为顺序表注意线性表中元素的位序是从开始的而数组元素下标是从开始的时间复杂度存取访问通过首地址和元素序号可以在内找到指定元素插入表尾插入表头插入平均复杂度删除表尾插入表头插入平均复杂度按值查找目标就在表头目标在表尾平均复杂度字符串基础操作子串串种任意个连续字符组成的子序列字符串本身以及空串也属于字符串的子串子序列不要求字符连续但是顺序与其在主串中相一致以整数格式输出字符时会输出其他字符会输出相应的码的十进制因此可以以来判断是否到达字符串末尾返回的长度以作为结束标志但是不包括字符串结束符比较两个字符串是否相同两个字符串自左向右逐个字符比较直到出现不同的字符或遇到为止若相等则返回若大于则返回正数若小于则返回负数字符串比较不能用该语句比较的是首地址而不是内容将字符串连接到之后并返回覆盖末尾的且处必须要有足够的空间存放新生成的字符串将复制给并返回复制的内容到结束处理不好容易溢出将的前个字符连接到后面并返回将的前个字符复制给并返回从源所指内存地址的起始位置拷贝个字节到目标所指的内存地址的起始位置必须指定拷贝长度且可用于各种数据类型而仅用于字符串将中前个字节用替换并返回作用是在一段内存中填充某个给定的值它是对较大的结构体或数组进行清零操作的一种最快方法字符串包含问题串的模式匹配算法算法时间复杂度算法时间复杂度算法每当一趟匹配过程中出现字符比较不等时不需回溯主串主串的指针一直向后移动不回退而是利用已经得到的部分匹配结果将模式串向右滑动尽可能远的一段距离后继续进行比较且此时并不一定是拿模式串的第一位继续比较数组的作用当匹配失败时查看最后一个匹配成功的字符所对应的数值下次匹配时在模式串中跳过前个字符继续比对数组已知主串的指针子串的指针永远递增该字符匹配指针后移匹配失败时直接使用与继续比较即跳过模式串中的个字符返回匹配成功的子串开头匹配失败下面给出计算数组的函数思想在匹配成功的那段模式串中寻找最长的相同前后缀这个长度就是那么对于匹配成功的那部分字符串模式串的前缀就可以匹配到主串的后缀所以可以跳过个字符这个最长的相同前后缀不包括匹配成功的部分模式串本身第位前面没有字符串也无法找最长相同前后缀所以初始化为记录字符之前的字符串中最长相同前后缀的位置就是判断确定最长相同前后缀长度相等时加即在前一位字符的上加得到目前的字符的判断如何给赋值位置的字符是否相同不相同就等于下次与主串继续比较处的字符而不是从模式串开头开始相同的话因为和处的字符相等主串接着比较处的字符依然是不相等的所以改为继续比较处的字符不相等时回退直到找到处的字符与处相等或者改为判断位置的字符是否相等即查看相同前缀的前缀继续判断相同前缀的前缀等于相同后缀的后缀直到不存在任何相同的前后缀以模式串为例数组下标为到对于来说不存在更短的前后缀所以直接为接着对于之前的字符串此时所以进入判断和加由于所以为为与的不匹配而与不相等所以可以右滑到与的继续匹配接着对于之前的字符串此时所以进入判断回退为为接着继续判断和加最长相同前后缀的长度所以为为与的不匹配那右滑到的也是仍然不匹配的所以为对于之前的字符串此时所以进入判断和加最长相同前后缀的长度由于为为与的不匹配那右滑到的也是仍然不匹配的所以为对于之前的字符串此时所以进入判断和加最长相同前后缀的长度所以为为与的不匹配那右滑到的继续匹配的字符串移位包含问题假设有一个函数其功能是判断一个字符串是不是另外一个字符串的子串现在给你两个字符串与请仅使用函数判断是否能够被做循环移位得到的字符串包含解答思想是如果字符串的长度小于的长度则返回否则连接与其自身得到新字符串然后判断是否是的子串若是返回若不是返回字符串转数字将字符串的字符逐个转为数字乘以然后加上下一个字符表示的数字另外还需要考虑特殊字符比如首字符是否为或者是否包含非法字符最后要以结束以及中间结果是否大于上限大数乘法其他问题字符串中的单词逆转使用指针交换字符在主串中删除模式串中出现的字符遍历也可以给每个字母分配一个素数从开始以此类推这样将会是将会是将会是等等然后得出模式串的乘积现在遍历字符串把每个字母代表的素数除若能整除则将其删除删除字符串开头和末尾的空格并将中间的连续空格转化为个在字符串中找到第一个只出现一次的字符使用数组实现的表即可下标存放码值可以直接作为整数处理元素存放出现次数在第二次遍历时取首个为的元素即可判断字符串中所有字符都不相同同样使用表即可值统一为若出现一个字符在表中存在则表明该字符重复结构体共用体和枚举与数组的不同结构体可以在一个结构中声明不同的数据类型相同结构的结构体变量可以相互赋值与的不同的成员访问权限默认为而成员的访问权限默认为结构体的定义不允许结构体本身的递归定义但可以使用指针指向本类型结构体定义中可以包含另外的结构体即可以嵌套指向本类型的指针同时声明一个结构体的变量声明一个结构体变量构造函数结构体变量可以在定义时初始化赋值在对结构体变量初始化时应将各成员所赋初值依照结构体类型说明中成员的顺序依次放在一对大括号中不允许跳过前面的成员给后面的成员赋值但可以只给前面若干成员赋初值后面未赋初值的成员中数值型和字符型的数据系统自动赋值零也可以用创建新类型现在可以用作为类型声明新的结构体变量结构体中的位字段允许指定占用特定位数的数据成员声明时位字段的类型为整型或枚举然后是冒号和指定位数的数字如下占位占位共用体结构体和共用体都是由多个不同的数据类型成员组成但在任何同一时刻共用体中只存放了一个被选中的成员而结构体的所有成员都存在对于共用体的不同成员赋值将会对其他成员重写原来成员的值就不存在了而对于结构体的不同成员赋值是互不影响的结构体占用内存可能超过各成员内存量总和共用体占用内存为各成员中占用最大者内存共用体的用途之一是当数据项使用两种或更多种格式但不会同时使用时可节省空间成员从低地址开始存放上运行一下程序由于是小端模式转为二进制为所以高地址到低地址的内存空间为而成员都是从低地址开始存放故分别分配给低地址的然后是的最后是的高地址的大小端存储字节序大端存储格式字数据的高字节存储在低地址中而字数据的低字节则存放在高地址中小端存储格式低地址中存放的是字数据的低字节高地址存放的是字数据的高字节注意函数是最右侧的元素先入栈若入栈元素为占个字节占个字节等小于个字节的类型入栈时也占个字节这里的一个关键点是等类型入栈时由于入栈字节数为比它们实际占用的内存数要多那么高位是补还是补呢当数是无符号类型时如高位总是补当数是有符号类型时如高位补符号位例题数组后个元素默认初始化为的输出从右到左先依次入栈输出时依次出栈首先为类型的指针所以运算时个字节一个单位的值为为类型指针运算时个字节一个单位又系统为小端低位在低地址字节所以为为类型指针运算时个字节一个单位所以为由于入栈时不足个字节所以高位补得到这些值依次入栈得到如下栈空间高位先入栈位序在字节内部也存在大小端问题对于位字段位数据相应的大小端定义为第一步将位字段组成的字节低字节存放在低地址高字节存放在高地址第二步然后按照大小端格式的定义在每个字节中分配位地址大端存储格式首先将位数据的高位存储在字节的高位中之后低位数据存放在低位中小端存储格式首先将位数据的低位存储在字节的低位中之后高位数据存放在高位中注意若位数据如大于个字节则先在位数据组成的字节序中先按字节序中的大小端的定义分配相应大小的位数据到相应的字节中此过程位数据可能被拆分到不同字节中然后再在每个字节中按位序大小端的定义分配到相应的位地址在上述代码中结构体表示的是由三个位字段组成的两个字节是高位域员是低位域员在大端存储格式中优先将位数据的高位存储在字节的高位中所以位的和的三位高位分配到高位字节剩下的位和位分配到低位字节因此高位字节的位序为低位字节位序为在小端存储格式中优先将位数据的低位存储在字节的低位中所以位和的三位低位分配到高位字节的两位高位和位分配到低位字节因此高位字节的位序为低位字节位序为因此上述代码中所在内存为由于时小端存储所以转换为十六进制为所以输出应该为枚举的工具提供了另一种创建符号常量的方式可以用于代替语句如下枚举类型名枚举常量整形常数枚举常量整形常数变量名列表花括号的内容称为枚举表包含多个枚举常量声明时可以为其赋初值若不赋初值编译器会为每一个枚举常量赋一个不同的整型值第一个为第二个为等当枚举表中某个常量赋值后其后的成员则按依次加的规则确定其值为为为为为为为运算符使用方法属于运算符而不是函数以字节形式给出其操作数的存储大小操作数可以是一个表达式或括在括号内的类型名操作数是类型名时必须加括号比如的计算发生在编译时刻可以直接作为常量表达式使用所以其操作数中的运算会被忽略比如其中的并不执行实际上计算对象的大小也是转换成对对象类型的计算也就是说同种类型的不同对象其值都是一致的这里对象可以进一步延伸至表达式即可以对一个表达式求值编译器根据表达式的最终结果类型来确定大小一般不会对表达式进行计算比如等价于等价于函数位域成员不能被计算值使用结果操作符的结果类型是它被定义为类型该类型保证能容纳实现所建立的最大对象的字节大小数据类型占据字节长度编译器占据字节长度编译器占据字节长度编译器指针引用取决于被引用对象取决于被引用对象取决于被引用对象若有则而可见计算数据包括数组变量类型结构体等所占内存空间用字节数表示故将内容为的数组元素也会计算在内而计算字符数组的字符数以为结束标志且不将计算在字符数内注意指针可视为变量类型的一种在位机器系统下所有指针变量的操作结果均为若在位机器系统下所有指针变量的操作结果为数组可以使用计算其大小等于元素个数元素类型的的空间计算的空间计算总体遵循两个原则整体空间是占用空间最大的成员的类型所占字节数的整数倍但在位环境下若最大成员类型所占字节数超过如是则整体空间是的倍数即可数据对齐原则内存按结构体成员的先后顺序排列当排到该成员变量时其前面已摆放的空间大小必须是该成员类型大小的整数倍当排到子结构体时其前面已摆放的空间大小必须是该子结构体成员中最大类型大小的整数倍如果不够则补齐依次向后类推但在环境下若某成员类型所占字节数超过如是则前面已摆放的空间大小是的整数倍即可不够则补齐对齐问题使结构体的变得比较复杂注意结构体中数组时按照单个单个变量一个一个进行摆放而不是视为整体空结构体的占用空间大小为含位域的结构体的空间计算使用位域的主要目的是压缩存储其大致规则为如果相邻位域字段的类型相同且其位宽之和小于类型的大小则后面的字段将紧邻前一个字段存储直到不能容纳为止所占字节数以其实际占用字节数为准也就是进行压缩如果相邻位域字段的类型相同但其位宽之和大于类型的大小则后面的字段将从新的存储单元开始其偏移量为其类型大小的整数倍不进行压缩如果相邻的位域字段的类型不同则各编译器的具体实现有差异采取不压缩方式与采取压缩方式如果位域字段之间穿插着非位域字段则不进行压缩整个结构体的总大小为最宽基本类型成员大小的整数倍环境为比如上述结构体中占个非位域类型所以占用个字节总共占用个字节最后由于整个结构体的总大小为最宽基本类型成员大小的整数倍所以总共要占用个字节的空间计算结构体在内存组织上是顺序式的而联合体是重叠式的各成员共享一段内存所以整个联合体的也就是每个成员的最大值且整体空间是占用空间最大的成员的类型所占字节数的整数倍即取占用内存最多的成员的空间作为自己的空间且需要考虑对齐上述代码的中数组占用个字节占用个考虑占用内存最大的成员所以应该是占用个字节又需要考虑对齐占用空间应该是占用空间的整数倍所以补齐为枚举的空间计算仅定义一个常量集合里面没有元素而枚举类型均作为类型存储因此枚举类型的均为运算符及其优先级赋值语句略自增与自减运算符以操作为例对于变量表示取的地址增加它的内容然后把值放在寄存器中表示取的地址把它的值装入寄存器然后增加内存中的值前缀运算是先变后用而后缀运算是先用后变注意只能位于等号的右边而可以位于等号的左边负号运算符与自增减运算符的优先级相同结合方向是从右向左比如等价于特别的对于指针变量实现了先输出所指地址处的数据值然后指针后移到下一指针处实现了先将指针指向后移再输出此时指针所指处的数据的值实现的是将指针所指向地址处的数据值比如输出后再自增得到关系与逻辑运算符关系操作符具有左结合性质先执行左边的部分但是不建议将多个关系操作符串接使用在这种写法中只要大于上述表达式的值就为这是因为第二个小于操作符的左操作数是第一个小于操作符的结果或也就是该条件将与整数或做比较为了实现我们想要的条件检验应重写上述表达式如下逻辑与和逻辑或操作符总是先计算其左操作数然后再计算其右操作数只有在仅靠左操作数的值无法确定该逻辑表达式的结果时才会求解其右操作数我们常常称这种求值策略为短路求值位运算符位运算符使用整型操作数将其视为二进制位的集合用于判断的二进制表示是否仅有一位为异或运算满足交换律两相同的数异或结果为可用于寻找数成对出现时缺失的某一个数例给你一个由个整数组成的未排序的序列其元素都是到中的不同的整数请写出一个寻找序列中缺失整数的线性时间算法解答求这个数的和然后计算可得此种解法当很大时加法运算有可能溢出用异或运算可以解决首先求得从到共个数的异或结果即然后用题目中的序列依次与求异或最后得到的数就是丢失的整数例不使用第三方变量交换两个变量的值运算符的优先级移位运算符的优先级与或异或运算符的优先级赋值转换赋值转换指的是将一种类型的值赋给另一种类型的变量这时值将会转换为接收变量的类型比如得到的为中型的转换为类型的空指针当把一个超出其取值范围的值赋给一个指定类型的对象时比如将一个类型的数赋值为类型的数当前大多数的系统都是将低字节赋值给而将高位舍去相当于取余当把一个取值范围小的值赋给一个取值范围大的值则进行符号位扩展表达式转换整型提升在表达式计算中将和型值都会自动转换成型对类型而言转换为则转换为同一类型的无符号类型与有符号类型所占内存空间相同只不过无符号类型将符号位作为数值位而已所以在中有符号数与无符号数转换时内存中的内容并没改变只是对内存中相同的数据解释不同而已和混合运算时会被转换为内存的内容不变但是符号位被当作数值所表示的数值发生改变且恒大于等于比如类型的的字节是共位第一位为符号位由于在计算机中用补码表示数值负数的补码为其符号位之外的位数求反然后加所以在内存中为其补码当其转为时所有位均表示数值那么此数就是所以类型的变量一直减结果也不会小于运算时的转换当运算涉及两种类型时较小的类型将会被转换成较大的类型换言之表达力低的类型将会被转换成表达力高的类型各类型表达能力从低到高排列为等价于等价与其余例题见例显示转换强制类型转换略运算符优先级表运算符优先级有几个简单的规则括号下标和成员最高单目的比双目的高算术双目的比其他双目的高移位运算高于关系运算关系运算高于按位运算与或异或按位运算高于逻辑运算三目的只有一个条件运算低于逻辑运算赋值运算仅比高且所有的赋值运算符优先级相同结合访问位从右向左预处理器作用域以及内存管理预处理器宏定义与宏替换宏定义不分配内存变量定义才会分配内存宏定义末尾不加分号指示接受一个名字并定义该名字为预处理器变量符号常量的宏定义及宏替换标识符字符串带有参数的宏定义及宏替换如为避免宏替换时发生错误参数最好加上括号标识符参数列表字符串宏替换的本质很简单文本替换关于宏定义与宏替换请注意以下几点宏名一般用大写避免名字冲突宏名和参数的括号间不能有空格宏定义末尾不加分号宏替换只作替换不做语法检查不做计算不做表达式求解宏替换在编译前进行不分配内存函数调用在编译后程序运行时进行并且分配内存函数只有一个返回值利用宏则可以设法得到多个值宏替换使源程序变长函数调用不会宏替换不占运行时间只占编译时间函数调用占运行时间分配内存保留现场值传递返回值注意应尽量少用宏替换在中宏替换实现的符号常量功能由代替带参数的宏替换可由模版内联函数代替文件包含标准头文件非系统头文件条件编译提供条件编译措施使同一源程序可以根据不同编译条件参数产生不同的目标代码其作用在于便于调试和移植条件编译控制语句有不同形式检测指定的预处理器变量是否未定义如果预处理器变量未定义那么跟在其后的所有语句都被处理直到出现如果预处理器变量已定义那么跟在其后直到出现的所有语句都被忽略全局变量与局部变量全局变量在函数外部定义的变量属于源程序文件作用域为整个源程序在函数中使用全局变量时需要说明使用的是全局变量在不同文件中引用一个已经定义过的全局变量可以用引用头文件的方式也可以用关键字下面的代码给出了使用引用已经定义过的全局变量的例子定义使用中的使中的自增局部变量在程序中只在特定过程或函数中可以访问的变量局部变量可以与全局变量同名且屏蔽全局变量在语句的控制结构中定义的变量尽在定义它们的块语句结束前有效这种变量的作用域限制在语句体内比如比如中的在同一个文件中当局部变量屏蔽了全局变量而又想要使用全局变量时有两种方法一种是使用做用域操作符一种是使用或者的作用隐藏使变量不能被其他文件访问对于函数和全局变量当编译多个文件时所有未加前缀的全局变量和函数都具有全局可见性其他的源文件也能访问如果加了前缀就会对其他源文件隐藏利用这一特性可以在不同的文件中定义同名函数和同名变量不必担心命名冲突默认初始化为未初始化的全局静态变量和局部静态变量初始化的全局变量和静态变量存放在段未初始化的全局变量和静态变量存放在段未初始化数据段在段中内存中所有的字节默认值都是某些时候这一特点可以减少程序员的工作量比如初始化一个稀疏矩阵我们可以一个个地把所有元素都置然后把不是的几个元素赋值如果定义成静态的就省去了一开始置的操作再比如要把一一个字符数组当字符串来用但又觉得每次在字符数组末尾加太麻烦如果把字符串定义成静态的就省去了这个麻烦因为那里本来就是函数体外的内置数组不管有没有前缀均会将各元素初始化为在函数体内定义的内置函数若没有前缀各元素未初始化其值不确定保持局部变量内容的持久函数内的自动局部变量当调用时就存在退出函数时就消失但静态局部变量虽然在函数内定义但静态局部变量始终存在着也就是说它的生存期为整个源程序其特点是只进行一次初始化且具有记忆性静态局部变量的生存期虽然为整个源程序但是其作用域仍与局部变量相同即只能在定义该变量的函数内使用该变量退出该函数后尽管该变量还继续存在但不能使用它外部变量局部静态变量只初始化一次此处为外部变量即第一行的语句第一次循环第二次循环语句此处为局部静态变量第一次循环第二次循环此处为第三行的输出结果为类中的作用用于表示属于一个类而不属于此类的任何特定对象的变量和函数与中此关键字的含义相同静态数据成员在类内数据成员的声明前加上关键字静态数据成员独立于该类的任意对象而存在即当某个类的实例修改了该静态成员变量其修改值为该类的其他所有实例所见静态数据成员和普通数据成员一样遵从访问规则由于静态数据成员定义时需要分配空间所以不能在类声明中定义数据成员必须在类定义体的外部定义一般而言类的成员像普通数据成员一样不能在类的定义体中初始化数据成员通常在类定义体的外部定义时才初始化即在类定义体中对静态变量赋初值是错误的仅声明需要在类外定义错误不可以在类定义体中对静态变量赋初值在类外定义例外数据成员可以在类的定义体中进行初始化基本整型数据成员在类的定义体中初始化时该数据成员仍必须在类的定义体之外进行定义只不过定义时不再需要初始化相当于在类外定义在类定义体中进行声明和初始化例中关于对象成员内存分布的描述正确的是不管该类被产生多少个对象静态成员变量永远只有一个实例且在没有对象实例的情况下已经存在费静态成员数据在类中的排列顺序将和其被声明的顺序相同任何中间介入的静态成员都不会被放进对象的内存布局中在同一访问段也就是等区间段内数据成员的排列符合较晚出现的成员在对象中有较高的内存地址带有虚函数的类对象占用的内存大小跟虚函数的个数成正比解析类中数据成员的布局情况非静态成员在类对象中的排列顺序和声明顺序一致任何在其中间声明的静态成员都不会被放进对象布局中静态数据成员存放在程序的全局静态存储中和个别类对象无关标准规定在同一个访问块即等区段中成员的排列只需符合较晚出现的成员在类对象中有较高的地址即可静态成员函数静态成员函数同样属于类定义的一部分为类服务而不是某个具体对象普通成员函数总是具体的属于某个类的具体对象所以普通的成员函数一般都隐含了一个指针指针指向类的对象本身但是静态成员由于不与任何的对象相关联因此不具有指针因而它无法访问类对象的非静态数据成员也无法访问非静成员函数它只能调用其余的静态成员函数与访问静态数据成员成员函数不是任何对象的组成部分因此成员函数不能声明毕竟将成员函数声明为后就承诺不会修改函数所属的对象而成员函数不属于任何对象成员函数也不能被声明为虚函数关于静态成员函数可以总结为以下几点静态成员之间可以相互访问包括静态成员函数访问静态数据成员和访问静态成员函数静态成员函数不能访问非静态成员函数和非静态数据成员非静态成员函数可以任意地访问静态成员函数和静态数据成员静态成员变量可被该类的所有方法访问由于没有指针的额外开销因此静态成员函数与类的非静态成员函数相比速度上会有少许的增长常量限定符将一个对象转换为一个常量常量在定义后就不能被修改所以在定义时必须进行初始化在全局作用域里定义非变量时它在整个程序中都可以访问但是除非特别说明在全局作用域声明的变量是定义该对象的文件的局部变量此变量只存在于那个文件中不能被其他文件访问通过指定变更为就可以在整个程序中访问对象定义使常量可以被其他文件访问使用中的在语言中多使用进行常量声明如果在中使用下面的语句在语言中编译错误因为在中意思是一个不能被改变的普通变量即它被放在内存中编译器不知道它在编译时的值但在中下面的语句是可行的相比的优势常量有数据类型而宏常量没有数据类型编译器可以对前者进行类型安全检查而对后者只进行字符替换没有类型安全检查使用常量可能比使用导致产生更小的目标代码这是因为预处理器盲目地将宏名称替换为其代替的值可能导致目标代码出现多份的备份但常量就不会出现这种情况还可以执行常量折叠常量折叠是在编译时间简单化常量表达的一个过程简单来说就是将常量表达式计算求值并用求得的值来替换表达式放入常量表也就是说编译器在编译时可以通过必要的计算把一一个复杂的常量表达式缩减成简单的综上在中我们应该用取代指针和在指针的声明中需要区分指向对象的指针和指针指向对象的指针如果指针指向对象则不允许用指针来改变其所指的值为了保证这个特性强制要求指向对象的指针也必须具有特性等价于是一个指向类型的指针的值可以改变但是不能通过改变的值指针使指针本身成为一个指针所指向的值可以改变但是地址不变声明时必须把标明的部分放在的右边如由于指针是所以编译时必须有初始化的值不可以改变但是可以通过改变的值修饰函数参数与返回值修饰返回值修饰返回值常用在处理用户定义的类型时当处理用户定义的类型时返回值不为常量有时会对用户造成困扰函数除了返回值类型外还可以返回指针函数不能返回指向局部栈变量的指针这是因为在函数返回后它们是无效的而且栈也被清理了栈会自动分配和释放可返回的指针是指向堆中分配的存储空间的指针或指向静态存储区的指针在函数返回后它仍然有效比如数组内存分配在栈上返回指向栈内存的指针但是由于是局部变量返回时原来的内容已被清除指向的新内容不可知输出可能是乱码可以改为如下内容数组位于静态存储区生存周期为整个源程序可通过函数返回位于文字常量区所以是指向全局静态存储区的指针可通过函数返回是指向堆中分配存储空间的指针可通过函数返回但需要以后调用释放内存否则会造成内存泄露修饰函数参数使参数值在函数体内不会发生改变主要是用来修饰地址使地址不发生改变若使用值或者函数返回值作为函数参数那么传递给函数的均为临时变量会被函数作为常量编译器会为其分派临时存储单元并产生一个地址和其引用捆绑在一起存储的内容是常量所以实参必须是在类中的应用只能作用于成员函数不能作用于全局函数成员函数确保该成员函数可作用于对象默认会有对象的指针作为形参声明时末尾的使得所指向的对象也为这使得该函数可作用于对象因为对象只能调用其成员函数无法调用其非成员函数非对象可以调用所有成员函数数据成员常量数据成员常量成员变量必须在构造函数的成员初始化列表中进行初始化并且必须有构造函数因为数据成员只在某个对象生存期内是常量而对于整个类而言却是可变的而类可以创建多个对象不同的对象其数据成员的值可以不同所以不能在类的声明中初始化数据成员因为类的对象没被创建时编译器不知道数据成员的值是什么使用构造函数初始化列表对数据成员进行初始化例外当整型数据成员同时被声明为时可以使用外部初始化因为使得该数据成员为类所有而不是对象只能在类外进行定义如果想要建立在整个类中都恒定的常量除了使用上面的外还可以使用枚举常量实现如在构造函数初始化列表中对数据成员进行初始化只能在构造函数初始化列表中初始化在类的实现文件中即类定义体的外部定义并初始化与相同为整型故也可在此处初始化但仍需在类定义体外进行定义注意为非整型时不能在此处初始化整型包括成员变量不能在构造函数初始化列表中初始化因为它不属于某个对象注意给成员变量赋值时不需要加修饰符但要加内存管理与释放一个的程序用户使用的内存主要分为以下几个部分堆手动分配和释放与数据结构中的堆不是同一个概念分配方式类似链表一般速度较慢容易产生内存碎片不过用起来方便中由操作中由操作若不手动释放则在程序结束后由系统释放与是语言的标准库函数是的运算符申请个字节空间由释放由释放但是注意指针本身是在栈中的它们指向在堆上分配的内存回收用分配的一组对象的内存空间时用栈区由编译器自动分配和释放存放函数的参数值局部变量的值等操作方式类似数据结构中的栈速度较快全局静态存储区存放全局变量和静态变量初始化的全局变量和静态变量存放在段未初始化的存放在段程序结束后由系统释放段的特点是在程序执行之前段会自动清所以未初始化的全局变量和静态变量在程序执行前已经为文字常量区存储常量字符串程序结束后由系统释放程序代码区存放函数体的二进制代码语言内存操作函数运行错误上述程序会运行错误开始时是指向文字常量区的指针函数并不会为新分配空间如上图所示函数调用传参时和形参的虽然指向相同但它们自身的地址不同是两个不同的变量如上图所示在执行之后就指向不同的位置了随后因为是局部变量而被释放的空间没有成为无法引用的空间了一直指向的是的文字常量区而文字常量是不允许修改的故调用时会出错内存管理动态创建对象如果不是显示初始化如那么对于类类型的对象用该类默认构造函数初始化而内置类型的对象则无法初始化如调用默认构造函数初始化调用默认构造函数初始化指向的内容未初始化显式初始化指向一个初始化为的值可见对于提供了默认构造函数的类类型如没有必要对其对象进行显式初始化因为无论程序是明确地不初始化还是要求进行初始化都会自动调用其默认构造函数初始化该对象而对于内置类型或没有定义默认构造函数的类型采用不同初始化方式则有显著的差别内置类型对象或未提供默认构造函数的类类型对象必须显式初始化的执行过程是首先调用名为的标准库函数分配足够大的原始未类型化的内存以保存指定类型的一个对象接下来运行该类型的一个构造函数用指定初始化式构造对象最后返回指向新分配并构造的对象的指针的执行过程是首先对指向的对象运行适当的析构函数然后通过调用名为的标准库函数释放该对象所用内存与的区别是语言的标准库函数是运算符自动计算需要分配的空间而需要手工计算字节数是类型安全的而则不是调用分配足够的空间并调用相关对象的构造函数而只负责分配空间不能调用构造函数将调用实例的析构函数然后调用以释放该实例占用的控件而只负责释放空间不能调用析构函数需要库文件支持不需要函数一般的来说函数是可以返回局部变量的局部变量的作用域只在函数内部在函数返回后局部变量的内存已经释放了因此如果函数返回的是局部变量的值不涉及地址程序不会出错但是如果返回的是局部变量的地址指针的话程序运行后会出错因为函数只是把指针复制后返回了但是指针指向的内容已经被释放了这样指针指向的内容就是不可预料的内容调用就会出错准确的来说函数不能通过返回指向栈内存的指针注意这里指的是栈返回指向堆内存的指针是可以的参数传递形参和实参用作数据传送形参出现在函数定义中仅在函数体中可以使用实参出现在主调函数中进入被调函数后实参变量也不能使用主调函数只是把实参的值传送给被调函数的形参只有引用才会改变实参语言的函数参数传递可以分为传递值和传递地址指针中可以分为传递值传递指针传递引用为指针传递为引用传递给函数传递实参遵循变量初始化的规则非引用类型的形参以相应实参的副本值初始化若是对象还会调用拷贝构造函数对非引用形参的任何修改仅作用于局部副本并不影响实参本身为了避免传递副本的开销可将形参指定为引用类型这时内存中不会产生实参的副本对引用形参的任何修改会直接影响实参本身应将不需要修改相应实参的引用形参定义为引用要使引用代表变量则的初始化语句为使用指针和解引用来交换变量的值交换指针所指向地址的内容内联函数通常编译时调用内联函数的地方将不进行函数调用而是使用函数体替换调用处的函数名形式类似宏替换这种替换称为内联扩展内联扩展可以消除函数调用时的时间开销将函数指定为函数通常就是将它在程序中每个调用点上内联地展开一般来说内联机制适用于优化小的只有几行的而且经常被调用的函数大多数的编译器都不支持递归函数的内联成员函数成为内联函数在类中定义的成员函数全部默认为内联函数可以显式加上标识符或者不加在类中声明的成员函数如果加了则其为内联函数如果没加而在类外定义该成员函数时加了该成员函数也为内联函数普通函数成为内联函数在普通函数声明或定义前加使其成为内联函数注意宏定义与内联函数的区别首先宏定义是在预处理阶段进行代码替换而内联函数是在编译阶段插入代码其次宏定义没有类型检查而内联函数有类型检查默认参数默认参数只可以在函数声明中设定一次只有在无函数声明时才可以在函数定义中设定默认参数定义的顺序为自右到左即如果一个参数设定了默认值其右边的参数都要有默认值默认值可以是全局变量全局常量甚至一个函数但不可以是局部变量因为默认参数是在编译时确定的而局部变量位置与默认值在编译时无法确定接受可变参数的函数实现多个数的相加函数重载进行函数重载时要求同名函数在参数个数上不同或者参数类型上不同操作符重载本质上也是函数重载它大大丰富了已有操作符的含义方便使用如可用于连接字符串等函数模板与泛型在泛型编程中我们所编写的类和函数能够多态地用于跨越编译时不相关的类型一个类或一个函数可以用来操纵多种类型的对象标准库中的容器迭代器和算法是很好的泛型编程的例子标准库用独立于类型的方式定义每个容器迭代器和算法因此几乎可以在任意类型上使用标准库的类和函数函数模板在中模板是泛型编程的基础模板是创建类或函数的蓝图或公式模板定义以关键字开始后接模板形参表模板形参表是用尖括号括住的一个或多个模板形参的列表形参之间以逗号分隔模板形参表不能为空同样模板形参表示可以在类或函数的定义中使用的类型或值关键字使用或者表示哪个实际类型由编译器根据所用的函数参数而确定类模板使用类模板时必须为模板形参显式指定实参编译器使用实参来实例化这个类的特定类型版本即编译器用用户提供的实际特定类型比如代替重新编写函数的递归必须注意递归模型不能是循环定义的其必须满足下面的两个条件递归表达式递归体边界条件递归出口递归的精髓在于能否将原始问题转换为属性相同但规模较小的问题在递归调用的过程中系统为每一层的返回点局部变量传入实参等开辟了递归工作栈来进行数据存储递归次数过多容易造成栈溢出等而其效率不高的原因是递归调用过程中包含很多重复的计算指针与引用指针指针的声明一个有效的指针必然是以下三种状态之一保存一个特定对象的地址指向某个对象后面的另一对象或者是值若指针保存值表明它不指向任何对象未初始化的指针是无效的直到给该指针赋值后才可使用它特别的对于指针变量实现了先输出所指地址处的数据值然后指针后移到下一指针处实现了先将指针指向后移再输出此时指针所指处的数据的值实现的是将指针所指向地址处的数据值比如输出后再自增得到语言允许用说明一种新类型名来代替已有类型名形式为类型名标识符并未产生新的数据类型它的作用仅仅是给已存在的类型名起一个别名且原有类型名依然有效例和这两句在使用上有什么区别腾讯解答前者声明一个类型的别名在编译时处理有类型检查后者是一个简单的替换在预编译时处理无类型检查从使用上来说中和都是类型的但中只有是类型的是型的指针指针是一种特殊类型的指针其可以保存任何类型对象的地址表明该指针与一地址有关但是不清楚此地址上的对象的类型故仅支持几种有限的操作与另一个指针进行比较向函数传递指针或从函数返回指针给另一个指针赋值不允许使用指针操纵它所指向的对象指向指针的指针指针本身也是占用内存空间的存放其值的所以也可用指针指向指向指针的指针位系统下有如下代码表示数组指针指向一个二维数组而数组的元素是类型指针占用个字节二维数组有个元素每个元素元素类型为指针占个字节为二维数组就是即第一个元素内容为一维数组得为一个一维数组就是类型为为类型所以为取指针指向地址的内容存储大小为的大小即函数指针函数指针指向某个特定的函数类型函数类型由其返回类型以及形参决定函数指针变量的声明类型为这个语句将声明为指向函数的指针它所指向的函数带有两个类型的形参和类型的返回值注意两侧的圆括号是必须的且形参只需写类型名由于函数指针类型冗长所以可以使用简化函数指针的定义定义一个空的函数指针使用前一行定义的函数指针类型在要使用这种函数指针类型时只需直接使用即可不必每次都把整个类型声明全部写出来在引用函数名但又没有调用该函数时函数名将被自动解释为指向函数的指针等效于在函数名上应用取地址符可使用函数名对函数指针做初始化或赋值有一同返回类型以及形参的函数声明使用该函数名初始化函数指针注意函数指针只能通过同类型的函数或函数指针或值常量表达式进行初始化或赋值指向不同函数类型的指针之间不存在转换将函数指针初始化为表示该指针不指向任何函数函数指针的使用指向函数的指针可用于调用它所指向的函数可以不需要使用解引用操作符直接通过指针调用函数若有则使用函数名使用函数指针未使用使用函数指针使用函数指针形参函数的形参可以是指向函数的指针这种形参可以用以下两种形式编写上述定义等价于返回指向函数的指针函数可以返回指向函数的指针声明返回类型为函数指针的函数这个语句中函数为其返回值类型为的函数指针这样子比较难理解使用更简明返回类型为函数指针例用变量给出下面的定义一个有个指针的数组每个指针指向一个函数该函数有一个整型参数并返回一个整型解答例定义一个函数指针指向的函数有两个形参并且返回一个函数指针返回的指针指向一个有一个形参且返回的函数解答变量为类型为野指针野指针是指向不可用内存的指针任何指针变量在创建时不会自动成为指针空指针其默认值是随机的此时的指针就是野指针当指针调用或者释放后未能将其设置为也会导致该指针便成为野指针此时虽然或把指针所指的内存释放掉了但它们并没有把指针本身释放掉第三个造成野指针的原因是指针操作超越了变量的作用范围引用中规定一旦定义了引用就必须把它跟一个变量绑定起来并且不能修改这个绑定定义的引用输出注意这里是将修改为而不是修改使其绑定到上输出输出虽然使用引用和指针都可以间接访问另一个值但它们之间有几个重要区别引用不能为空当引用被创建时必须被初始化而指针可以为空值可以在任何时候被初始化一旦一个引用被初始化为指向一个对象他就不能被改变为对另外一个对象的引用指针则可以在任何时候指向另一个对象不可能有引用必须保证引用是一块合法的存储单元关联引用所得到的的是指向的变量对象的大小而指针得到的是指针本身的大小通常为给引用赋值修改的是该引用所关联的对象的值而并不是使用引用于另一个对象关联引用使用时不需要解引用而指针需要解引用引用和指针的自增操作运算符意义不一样如果返回动态分派的对象或内存必须使用指针引用可能引起内存泄漏当使用运算符去一个引用的地址时其值为所引用变量的地址而对指针使用运算符取的是指针变量的地址引用常引用引用是指对象的引用当引用的对象是对象时引用也必须是如下正确错误如果既要利用引用提高程序的效率又要保护传递给函数的数据不再函数中被改变就应该使用常引用常引用主要用于定义一个普通变量的只读属性的别名作为函数的传入形参避免实参在调用函数中被意外改变引用做类的数据成员引用是可以作为类的数据成员的引用类型数据成员的初始化有以下特点不能直接在构造函数里初始化必须用到初始化列表凡是有引用类型的数据成员的类必须定义构造函数如下与必须在成员初始化列表中初始化因此必须自定义构造函数书写成员初始化列表类在中模板是泛型编程的基础模板是创建类或函数的蓝图或公式访问标号访问标号可以多次出现在类定义中给定的访问标号应用到下一个访问标号出现时为止对于在第一个访问标号之前定义的成员其访问级别依赖于类是如何定义的如果类是用关键字定义的则在第一个访问标号之前的成员是公有的如果类是用关键字定义的则这些成员是私有的类对其成员的访问形式主要有以下两种内部访问由类中的成员函数对类的成员的访问对象访问在类外部通过类的对象对类的成员的访问类的成员可以有三种访问属性类的成员函数内部访问以及友元函数可以访问类中所有成员但是在类外通过类的对象对象访问就只能访问该类的公有成员上述权限说明并未考虑有继承的情况有继承的情况将在下章详细说明类成员简介空类默认产生默认构造函数复制构造函数析构函数赋值运算符重载函数取址运算符重载函数取址运算符重载函数等成员函数在类内部声明成员函数是必需的而定义成员函数则是可选的在类内部定义的函数默认为内联函数调用成员函数时实际上是使用对象来调用的每个成员函数除了成员函数外都有一个额外的隐含的形参在调用成员函数时形参初始化为调用函数的对象的地址构造函数特殊的成员函数与类同名没有返回类型主要用来在创建对象时初始化对象即为对象成员变量赋初始值总与运算符一起使用在创建对象的语句中一个类可以有多个构造函数构造函数可以重载每个构造函数必须有与其他构造函数不同的数目或类型的形参若没有定义显式的构造函数编译器将自动为这个类生成默认构造函数不带参数或者所有的形参都有默认实参若使用编译器自动生成的默认构造函数或自己定义一个未进行任何操作的默认构造函数则类中每个成员使用与初始化变量相同的规则来进行初始化类成员运行该类型的默认构造函数来初始化内置或复合类型的成员的初始值依赖于对象的作用域在局部作用域中这些成员不被初始化而在全局作用域中它们被初始化为上述代码中与的都调用类的默认构造函数初始化运行该类型的默认构造函数来初始化中和初始化为而是局部对象故中和不被初始化为垃圾值成员初始化列表构造函数的成员初始化列表为类的一个或多个数据成员指定初值在中成员变量的初始化顺序与变量在类型中的声明顺序相同而于它们在构造函数的初始化列表中的顺序无关构造函数的初始化列表仅仅指定用于初始化成员的值并不指定这些初始化执行的次序按照声明顺序初始化先初始化此时还未初始化所以是个垃圾值后初始化为省略初始化列表在构造函数的函数体内对数据成员赋值是合法的从概念上讲可以认为构造函数分两个阶段执行初始化阶段成员初始化列表普通的计算阶段计算阶段由构造函数函数体中的所有语句组成类类型的数据成员总是在初始化阶段初始化使用其构造函数内置和复合类型的尘谷氨只对定义在全局作用域中的对象才初始化初始化为定义在局部作用域中的对象包含包含的内置等类型和复合类型数组指针等的成员没有初始化没有默认构造函数的类类型的成员以及类型的成员变量和引用类型的成员变量都必须在构造函数初始化列表中进行初始化假定有一个类它没有定义自己的默认构造函数却有一个接受一个实参的构造函数因为该类定义了一个构造函数因此编译器将不合成默认构造函数编译器将不会为具有类型成员的类合成默认构造函数如果这样的类希望提供默认构造函数就必须显式地定义并且默认构造函数必须显式地初始化其成员在成员初始化列表中通过传递一个初始的值给构造函数拷贝构造函数拷贝构造函数赋值操作符和析构函数总称为复制控制编译器自动实现这些操作但类也可以定义自己的版本如果类需要析构函数则它也需要赋值操作符和拷贝构造函数这是一个有用的经验法则这个规则常称为三法则指的是如果需要析构函数则需要所有这三个复制控制成员有一种特别常见的情况需要类定义自己的复制控制成员的类具有指针成员概念只有单个形参而且该形参是对本类类型对象的引用常用修饰这样的构造函数称为拷贝构造函数或复制构造函数如果拷贝构造函数的形参不是引用那么就相当于采用了传值的方式而传值的方式会调用该类的拷贝构造函数从而造成无穷递归地调用拷贝构造函数因此拷贝构造函数的参数必须是一个引用与默认构造函数一样拷贝构造函数可由编译器隐式调用拷贝构造函数可用于根据另一个同类型的对象初始化一个对象支持两种初始化形式直接初始化和复制初始化复制初始化使用符号而直接初始化将初始化式放在圆括号中直接初始化复制初始化复制初始化复制初始化等号右侧相当于一个风格字符串作为形参创建的临时对象会产生新的对象不是调用复制构造函数而是利用赋值运算符将赋值给因为之前已经创建了空字符串对象属于赋值运算符重载没有产生新的对象复制一个对象将它作为实参传给一个函数或从函数返回时复制一个对象当函数的形参或返回值为类类型时将由拷贝构造函数进行复制函数的形参为类类型时将由复制构造函数进行复制使用复制构造函数来初始化对象复制构造函数进行初始化上述代码的输出为调用了三次拷贝构造函数第一次是中第二次是实参到形参第三次是函数中的语句初始化顺序容器中的元素拷贝构造函数可用于初始化顺序容器中的元素例如可以用表示容量的单个形参来初始化容器容器的这种构造方式使用默认构造函数和拷贝构造函数编译器首先使用默认构造函数创建一个临时值来初始化然后使用拷贝构造函数将临时值复制到的每个元素根据元素初始化列表初始化数组元素如果用常规的花括号括住的数组初始化列表来提供显式元素初始化式则使用复制初始化来初始化每个元素根据指定值创建适当类型的元素然后用复制构造函数将该值复制到相应元素浅复制与深复制浅复制被复制对象的所有变量都含有与原来的对象相同的值而变量中所有的对其他对象的引用仍然指向原来的对象换言之浅复制仅仅复制所考虑的对象而不复制它所引用的对象深复制被复制对象的所有变量都含有与原来的对象相同的值除去那些引用其他对象的变量那些引用其他对象的变量将指向被复制过的新对象也就是把引用变量所引用的对象也复制一遍浅复制可能会导致运行时错误特别是在对象的创建与删除过程中析构函数析构函数进行资源的回收作为类构造函数的补充当对象超出作用域或动态分配的对象被删除时将自动应用析构函数析构函数可用于释放对象构造时或在对象的生命期中所获取的资源不管类是否定义了自己的析构函数编译器都自动执行类中非数据成员的析构函数虽然构造函数不能被定义成虚函数但析构函数可以定义为虚函数一般来说如果类中定义了虛函数析构函数也应被定义为虚析构函数尤其是类内有申请的动态内存需要清理和释放的时候与复制构造函数和赋值操作符不同无论类是否定义了自己的析构函数都会创建和运行合成析构函数如果类定义了析构函数则在类定义的析构函数结束之后运行合成析构函数合成析构函数按对象创建时的逆序撤销每个非成员因此它按成员在类中声明次序的逆序撤销成员对于类类型的每个成员合成析构函数调用该成员的析构函数来撤销对象调用了拷贝构造函数用对象初始化对象拷贝构造函数自动生成无输出输出为构造过程那么析构过程为注意之所以构造了两个是因为调用了拷贝构造函数对类对象中初始化而拷贝构造函数采用的是系统自动生成的版本没有输出构造函数与析构函数调用顺序单继承派生时构造函数和析构函数是不能继承的为了对基类成员进行初始化必须对派生类重新定义构造函数和析构函数并在构造函数的初始化列表中调用基类的构造函数由于派生类对象通过继承而包含了基类数据成员因此创建派生类对象时系统首先通过派生类的构造函数来调用基类的构造函数完成基类成员的初始化而后对派生类中新增的成员进行初始化必须将基类的构造函数放在派生类的初始化列表中以调用基类构造函数完成基类数据成员的初始化若无则调用基类的默认构造函数派生类构造函数实现的功能或者说调用顺序为完成对象所占整块内存的开辟由系统在调用构造函数时自动完成调用基类的构造函数完成基类成员的初始化若派生类中含对象成员成员或引用成员则必须在初始化表中完成其初始化派生类构造函数体执行类继承自类调用了拷贝构造函数用对象初始化对象拷贝构造函数自动生成无输出语句语句输出为构造过程那么析构过程为首先语句构造一个的对象输出然后语句中由于有父类所以先调用父类的构造函数输出然后的构造函数初始化列表调用了拷贝构造函数构造一个的对象而拷贝构造函数采用的是系统自动生成的版本没有输出但是析构的时候会输出最后执行的构造函数输出析构时与构造顺序相反多继承多继承时派生类的构造函数初始化列表需要调用各个基类的构造函数注意此时构造函数初始化列表只能控制用于初始化基类的值不能控制基类的构造次序基类构造函数按照基类构造函数在类派生列表中的出现次序调用虚继承首先调用虚基类的构造函数虚基类如果有多个则虚基类构造函数的调用顺序是此虚基类在当前类派生表中出现的顺序而不是它们在成员初始化表中的顺序操作符重载操作符重载函数的名字为后跟着所定义的操作符的符号像任何其他函数一样操作符重载函数有一个返回值和一个形参表形参表必须具有与该操作符数目相同的形参如果操作符是一个类成员则包括隐式形参大多数操作符可以定义为成员函数或非成员函数当操作符为成员函数时它的第一个操作数隐式绑定到指针有些操作符包括赋值操作符必须是类的成员函数比如赋值就必须是类的成员所以绑定到指向左操作数的指针因此赋值操作符接受单个形参且该形参是同一类类型的对象右操作数一般作为引用传递并非所有操作符都是可重载的下表给出可重载和不可重载的操作符带点的都不能重载赋值操作符重载在写赋值操作符重载函数时需要注意返回值类型为引用允许连续赋值形参为常量引用避免调用拷贝构造函数产生无谓的消耗记得判断传入实例和当前实例是否为同一实例释放实例自身已有的内存否则可能引起内存泄露例子如下自定义构造函数自定义拷贝构造函数自定义析构函数赋值运算符的重载函数名为形参为返回类型为自定义构造函数自定义拷贝构造函数赋值运算符重载函数注意返回值类型为引用形参为常量引用记得判断传入实例和当前实例是否为同一实例记得释放实例自身已有的内存否则可能引起内存泄露并不是出现就是调用赋值构造函数赋值运算符重载的情况没有新对象产生而拷贝构造函数是生成新的对象直接初始化复制初始化复制初始化复制初始化等号右侧相当于一个风格字符串作为形参创建的临时对象产生新的对象不是调用复制构造函数而是利用赋值运算符将赋值给因为之前已经创建了空字符串对象属于赋值运算符重载没有产生新的对象复制构造函数与赋值运算符的区别是否有新对象产生首先要说明的是若用户没有定义隐式声明一个拷贝构造函数和一个赋值运算符拷贝构造函数涉及对象实例化只在对象实例化时才会被调用也就是说在复制构造函数调用期间这个对象处于一个未决状态直到复制构造函数被成功调用而赋值运算符对现存对象进行赋值操作拷贝构造函数不返回任何值都没有而赋值运算符则在一个现存的对象被赋予新的值时被调用并且它有返回值和的重载的执行过程是首先调用名为的标准库函数分配足够大的原始未类型化的内存以保存指定类型的一个对象接下来运行该类型的一个构造函数用指定初始化式构造对象最后返回指向新分配并构造的对象的指针的执行过程是首先对指向的对象运行适当的析构函数然后通过调用名为的标准库函数释放该对象所用内存和运算符的重载实际上是对标准库函数和的重载重载操作符第一个参数为分配的空间大小字节类型为返回类型必须为只分配所要求的空间不调用相关对象的构造函数调用分配空间然后再调用构造函数先调用析构函数再调用释放空间如何禁止产生堆对象禁用也就是使为同时为了对称最好将也重载为如何禁止产生栈对象将构造函数或析构函数设为成员函数的重载覆盖与隐藏成员函数的重载在同一类中定义的同名函数重载函数的形参类型和数目有所不同重载和成员函数是否为虚函数无关成员函数的覆盖在派生类中覆盖基类中的同名函数要求基类函数必须是虚函数且与基类的虚函数有相同的参数个数与基类的虚函数有相同的参数类型与基类的虚函数有相同的返回类型或者都返回指针或引用并且派生类虚函数所返回的指针或引用类型是基类中被替换的虚函数所返回的指针或引用类型的子类型派生类型虚函数具有相同的函数名参数个数参数类型返回类型覆盖了中的覆盖的特征如下不同的范围分别位于派生类与基类相同的函数名字相同的参数基类函数必须有关键字重载与覆盖的区别如下覆盖是子类和父类之间的关系是垂直关系重载是同一个类中不同方法之间的关系是水平关系覆盖要求参数列表相同重载要求参数列表不同覆盖要求返回类型相同重载则不要求覆盖关系中调用方法体是根据对象的类型来决定的重载关系是根据调用时的实参表与形参表来选择方法体的成员函数的隐藏隐藏指的是在某些情况下派生类中的函数屏蔽了基类中的同名函数这些情况包括两个函数参数相同但基类函数不是虚函数和覆盖的区别在于基类函数是否是虚函数例如成员函数非虚函数类由类派生而来参数相同但是基类函数不是虚函数所以隐藏父类的函数调用中的函数调用中的函数两个函数参数不同无论基类函数是否是虚函数基类函数都会被屏蔽和重载的区别在于两个函数不在同一类中例如非虚成员函数参数为型类由类派生而来参数不同隐藏父类的函数错误参数类型错误通过调用中的函数面向对象编程继承基类的构造函数包括拷贝构造函数析构函数赋值操作符重载函数都不能被派生类继承一个派生类可以从一个或多个基类派生单继承多继承多继承的定义格式如下派生类继承方式基类名继承方式基类名派生类新定义成员派生类对象由多个部分组成派生类本身定义的非成员加上由基类非成员组成的子对象如果一个类有多个直接基类而这些直接基类又有一个共同的基类则在最低层的派生类中会保留这个间接的共同基类数据成员的多份同名成员为了解决这个问题提出了虚继承的概念虚继承时公共基类在对象模型中只有一份拷贝基类成员在派生类中的访问属性派生类可以继承基类中除了构造函数与析构函数赋值运算符重载函数也不能被继承之外的成员但是这些成员的访问属性在派生过程中是可以调整的从基类继承来的成员在派生类中的访问属性是由继承方式控制的公有继承父类的成员成为子类的成员可以被该子类中的函数内部访问及其友元函数访问除此之外也可以由该子类的对象属于外部访问访问父类的成员仍旧是父类的成员子类成员不可以访问这些成员包括子类中的函数及其友元函数子类对象父类的成员成为子类的成员可以被该子类中的函数及其友元函数访问除此之外不可以由该子类的对象访问不允许外部访问私有继承私有继承的特点是基类的公有成员和保护成员都作为派生类的私有成员并且不能被这个派生类的子类所访问在私有继承时基类的成员只能由直接派生类访问而无法再往下继承保护继承保护继承的特点是基类的所有公有成员和保护成员都成为派生类的保护成员并且只能被它的派生类成员函数或友元访问基类的私有成员仍然是私有的继承时导致的二义性类间的转换在公有继承方式私有保护继承时不能隐式转换下派生类的对象对象指针对象引用可以赋值给基类的对象对象指针对象引用发生隐式转换上行转换基类的对象对象指针对象引用不能赋值给派生类的对象对象指针对象引用因为派生类包含了基类的所有信息而基类缺乏派生类中的信息如合法派生类向基类隐式转换向上转换错误基类向派生类转换语句合法隐式转换派生类指针转换为基类指针错误语句合法隐式转换错误语句允许把基类对象指针引用强制转换显式成派生类的对象指针引用下行转换如中代码语句可以改为语句可以改为但是语句不能通过强制转换完成一个指向基类的指针可以用来指向该基类公有派生类的任何对象这是实现程序运行时的多态性的关键若存在多重继承由于对象在往上转换期间派生类转换为基类出现多个类因而对象会存在多个指针为本类对象的地址调用继承自的函数调用继承自的函数派生对象的指针赋值给基类指针发生隐式转换输出为每一个类都有打印一个指针函数这些类通过多重继承和组合被装配成类它打印自己和其他所有子对象的地址有主程序调用这些打印功能可以清楚地看到能在一个相同的对象中获得两个不同的指针派生对象的起始地址和它的基类列表中的第一个类的地址是一致的第二个类的地址随后接着根据声明的次序安排成员对象的地址当向和进行上行转换时语句和语句产生的指针表面上是指向同一个对象而实际上有不同的指针指向类的子对象指向类的子对象派生对象的地址空间在上述代码中加入如下语句实际上与的比较过程中由于两者类型不同会发生隐式类型转换类型会被隐式转换为派生类被隐式转换为基类这是能与比较的基础反过来转换不成立然后与进行比较同理与的比较过程中会被转换为然后与进行比较故实际输出为多基继承一般来说在派生类中对基类成员的访问应当具有唯一性但在多基继承时如果多个基类中存在同名成员的情况造成编译器无从判断具体要访问哪个基类中的成员则称为对基类成员访问的二义性问题若两个基类中具有同名的数据成员或成员函数应使用成员名限定来消除二义性比如或者实现对基类同名成员函数的隐藏见节菱形继承公共基类类由类派生而来类由类派生而来类由类和类派生而来声明一个类对象其含有个基类对象一个基类对象一个基类对象上行转换产生二义性语句具有二义性系统不知道是调用类的还是类的函数语句上述代码的语句编译错误可改为以下的其中一种但是不能改为因为对象中有个类对象故编译会报基类不明确而语句产生的二义性也是因为对象中有个类对象转换时不知道让指向哪个子对象可以改为以下的一种事实上使用关键字将共同基类声明为虚基类可有效解决上述二义性的问题转换构造函数转换构造函数可以用单个实参来调用其定义从形参类型到该类类型的一个隐式转换转换构造函数调用转换构造函数将转换为类的对象转换构造函数需满足以下条件之一类的定义和实现中给出了仅包括只有一个类型参数的构造函数类的定义和实现中给出了包含一个类型参数且其他参数都有缺省值的构造函数类的定义和实现中虽然不包含类型参数但包含一个非类型参数如类型此外没有其他参数或者其他参数都有缺省值且类型参数可隐式转换为类型参数可以通过将构造函数声明为来禁止隐式转换类型转换函数类型转换函数的作用是将一个类的对象转换成另一类型的数据与转换构造函数作用相反在类中定义类型转换函数的一般格式为转换构造函数类型转换函数函数名为指明转换的目标类型为调用转换构造函数将型的转换为类的对象调用类型转换函数将转换为类型定义类型转换函数需要注意以下几点转换函数必须是成员函数不能是友元形式转换函数不能指定返回类型但在函数体内必须用语句以传值方式返回一个目标类型的变量转换函数不能有参数非内建型别和在以下几种情况下能隐式转化为公有继承自可以是间接继承的此时若有则合法中有类型转换函数类型转换函数将类对象强制转换为类类型此时若有则合法实现了非的参数为可以有其他带默认值的参数的构造函数转换构造函数此时若有则合法虚函数多态通俗地说多态性是指同一个操作作用于不同的对象就会产生不同的响应多态性分为静态多态性和动态多态性静态多态性函数重载和运算符重载动态多态性虛函数静态联编与动态联编以函数重载为例编译器根据传递给函数的参数和函数名决定具体要使用哪一个函数称为联编或绑定编译器可以在编译过程中完成这种联编在编译过程中进行的联编叫静态联编或早期联编在一些场合下编译器无法在编译过程中完成联编必须在程序运行时完成选择因此编译器必须提供一套称为动态联编的机制也叫晚期联编通过虚函数来实现动态联编如果一个基类的成员函数定义为虚函数那么它在所有派生类中也保持为虚函数即使在派生类中省略了关键字也仍然是虚函数派生类中可根据需要对虚函数进行重定义重定义的格式有一定的要求与基类的虚函数有相同的参数个数与基类的虚函数有相同的参数类型与基类的虚函数有相同的返回类型或者都返回指针或引用并且派生类虚函数所返回的指针或引用类型是基类中被替换的虚函数所返回的指针或引用类型的子类型派生类型虚函数的访问虚函数可以通过对象名来调用此时编译器采用的是静态联编通过对象名访问虚函数时调用哪个类的函数取决于定义对象名的类型使用指针访问非虚函数时编译器根据指针本身的类型决定要调用哪个函数而不是根据指针指向的对象类型使用指针访问虚函数时编译器根据指针所指对象的类型决定要调用哪个函数动态联编而与指针本身的类型无关因此这里虚函数的作用就是使得指向基类的指针在操作它的多态类对象时是根据不同的类对象来调用相应的函数而不是调用基类的函数使用引用访问虚函数与使用指针访问虚函数类似不同的是引用一经声明后引用变量本身无论如何改变其调用的函数就不会再改变始终指向其开始定义时的函数因此在使用上有一定限制但这在一定程度上提高了代码的安全性总结如下中的函数调用默认不使用动态绑定要触发动态绑定需满足两个条件第一只有指定为虚函数的成员函数才能进行动态绑定成员函数默认为非虚函数非虚函数不进行动态绑定第二必须通过基类类型的引用或指针进行函数调用虚函数默认为非虚函数覆盖基类的虚函数派生类地址给基类指针赋值发生隐式转换通过指针访问虚函数根据指针所指对象的类型决定调用的函数指向类类型通过指针访问非虚函数根据指针本身的类型决定调用的函数为类类型上述代码的输出为常见的不能声明为虚函数的有普通函数非成员函数静态成员函数构造函数友元函数而内联成员函数赋值操作符重载函数即使声明为虚函数也无意义析构函数可以被声明为虚函数因为销毁对象时需要识别对象类型构造函数不能为虚函数若基类的构造函数为虚函数那么派生类的构造函数会覆盖基类的构造函数使得基类无法构造且虚函数旨在在不同类型的对象上产生不同动作而构造函数运行时对象还未产生普通函数不能为虚函数普通函数只能被重载不能被覆盖声明为虚函数没有意义静态函数不能为虚函数静态函数属于类而不是对象所以没有动态绑定的需要友元函数不能为虚函数不支持友元函数的继承上述代码输出为由于中的函数为虚函数所以会动态联编到所引用的对象的函数上因此输出之所以变量为是因为缺省实参是编译时确定的在动态联编之前构造函数和析构函数中的虚函数构造派生类对象时首先运行基类构造函数初始化对象的基类部分在执行基类构造函数时对象的派生类部分是未初始化的实际上此时对象还不是一个派生类对象撤销派生类对象时首先撤销它的派生类部分然后按照与构造顺序的逆序撤销它的基类部分在这两种情况下运行构造函数或析构函数时对象都是不完整的为了适应这种不完整编译器将对象的类型视为在构造或析构期间发生了变化在基类构造函数或析构函数中将派生类对象当作基类类型对象对待如果在构造函数或析构函数中调用虚函数则运行的是为构造函数或析构函数自身类型定义的版本静态联编解析构造函数不需要是虚函数也不允许是虚函数因为创建一个对象时我们总是要明确指定对象的类型尽管我们可能通过实验室的基类的指针或引用去访问它但析构却不一定我们往往通过基类的指针来销毁对象这时候如果析构函数不是虚函数就不能正确识别对象类型从而不能正确调用析构函数虚函数表指针及虚基类表指针在布局以及存取时间上主要的额外负担是由引起的包括机制用以支持一个有效率的执行期绑定用以实现多次出现在继承体系中的基类有一个单一而被共享的实体虚函数表指针中数据成员可以分为静态和非静态以及三种类成员函数静态非静态和虚函数其中非数据成员被配置于每一个对象之内数据成员则被存放在所有的对象之外通常被放置在程序的全局静态存储区内故不会影响个别的对象大小和非函数也被放在所有的对象之外函数则以两个步骤支持之每一个类产生出一堆指向的指针放在表格之中这个表格被称为每一个对象被添加了一个指针指向相关的通常这个指针被称为虚函数表指针的设定和重置都由每一个类的构造函数析构函数和复制构造函数自动完成每个虚函数的存在会为类的内存空间增加一个虚函数表指针含静态变量虚函数的类的空间计算应用在类和结构的处理情况是相同的但需要注意结构或者类中的静态成员不对结构或者类的大小产生影响因为静态变量的存储位置与单个对象的地址无关空类的大小为个字节含有虚函数的类会多出虚函数表指针的空间占用空类占个字节有一个虚函数因此中有指针占个字节大小为对其为的和为设置编译器按照个字节对齐大小为的和为设置编译器按照个字节对齐上述代码中各类的结果为虚函数表的实现使用指针访问虚函数时编译器根据指针所指对象的类型决定要调用哪个函数动态联编比如有基类及其派生类基类中有一个虚函数派生类也有一个函数进行覆盖若有一类对象对于语句其运行时会发生动态联编调用的为指针所指的类对象的函数而不是类但是此过程中父类指针是如何根据虚函数表找到子类的虚函数的首先父类指针所指空间为对象其中存在虚函数表指针通过其可以找到对象的虚函数表进而找到类的函数例如上述代码中类的对象的虚函数表如下每个各自记录一个函数的地址由于继承自所以其定义的也为虚函数类的对象的虚函数表如下可见单基继承时仅有一个派生类的函数覆盖了基类的同名函数虚函数表中相应位置也替换为了新函数的地址通过对象的虚函数表指针就可以找到所属类的函数了类的对象的虚函数表如下可见多基继承时有几个基类就有几个类中的函数与覆盖了类中的同名函数故虚函数表中对应位置替换为新函数的地址类中的函数与覆盖了类中的同名函数故虚函数表中对应位置替换为新函数的地址虚基类表指针继承也可以指定为虚拟在虚拟继承的情况下基类不管在继承串链中被派生多少次永远只会存在一个实体在虚拟继承基类的子类中子类会增加某种形式的指针或者指向虚基类子对象或者指向一个相关的表格表格中存放的不是虚基类子对象的地址就是其偏移量此指针被称为如下图所示注意在同时存在与时某些编译器会将其进行优化合并为一个指针空类占个字节虚拟继承需要虚基表指针的空间个字节继承自的字节被优化为继承占个字节继承占个字节总共占个字节虚拟继承时构造函数的书写对普通的多层继承而言构造函数的调用是嵌套的如由类派生类类又派生类时则各个构造函数有如下形式总参数表参数表总参数表参数表而对虚基派生来说如果按照上述规则若类虚拟派生类类类继承类类则各个构造函数有如下形式总参数表参数表总参数表参数表总参数表参数表参数表参数表根据虚基派生的性质类中只有一份虚基类的拷贝因此类的构造函数在类中只能被调用一次所以从类直接虚拟派生和和间接派生的类中其构造函数的初始化列表中都要列出对虚基类构造函数的调用这种机制保证了不管有多少层继承虚基类的构造函数必须且只能被调用一次若在初始化列表中没有显式调用虚基类的构造函数则将调用虚基类的默认构造函数若虚基类没有定义默认构造函数则编译出错纯虚函数纯虚函数是一一种特殊的虚函数它的一般格式如下类名类型函数名参数表在许多情况下在基类中不对虚函数给出有意义的实现而把它声明为纯虚函数它的实现留给该基类的派生类去做这就是纯虚函数的作用纯虚函数可以让类先具有一个操作名称而没有操作内容让派生类在继承时再去具体地给出定义凡是含有纯虚函数的类称为抽象类这种类不能声明对象只是作为基类为派生类服务除非在派生类中完全实现基类中所有的纯虚函数否则派生类也是抽象类不能实例化对象只定义了型构造函数的类也是抽象类对一个类来说如果只定义了型的构造函数而没有提供构造函数无论是在外部还是在派生类中都不能创建该类的对象但可以由其派生出新的类这种能派生新类却不能创建自己对象的类是另一种形式的抽象类抽象类不能声明对象但是可以作为指针或者引用类型使用动态运行时类型识别与显式转换通过运行时类型识别程序能够使用基类的指针或引用来检索这些指针或引用所指对象的实际类型通过下面两个操作符提供操作符返回指针或引用所指对象的实际类型操作对象为指针所指对象操作符将基类类型的指针或引用安全地转换为派生类型的指针或引用操作符使程序能够询问一个表达式的类型表达式形如这里是任意表达式或者是类型名用法如下所示比较所指对象与所指对象的实际类型判断所指对象是否为比较类型和类型两类型不相等测试失败只有当的操作数是带虚函数的类类型的对象的时才返回动态类型信息测试指针相对于指针指向的对象返回指针的静态的编译时类型显示转换也叫强制类型转换包括以下强制类型转换操作符命名的强制类型转换符号的一般形式如下其中为和之一为转换的目标类型而则是被强制转换的表达式强制转换的类型指定了在上执行某种特定类型的转换在引入命名的强制类型转换操作符之前显式强制转换用圆括号将类型括起来实现效果与使用符号相同将转换掉表达式的性质只有使用才能将性质转换掉在这种情况下试图使用其他三种形式的强制转换都会导致编译时的错误类似地除了添加或删除特性用符来执行其他任何类型转换都会引起编译错误编译器隐式执行的任何类型转换都可以由显式完成等价于仅当类型之间可隐式转换时除类层次间的下行转换以外的转换才是合法的否则将出错类层次间的下行转换属于强制转换是不能通过隐式转换完成的请看下例下行转换错误基类对象不能给派生类赋值编译不正确该运算符把转换成类型的对象必须是类的指针类的引用或者如果是指针类型那么也必须是一个指针如果是一个引用那么也必须是一个引用与其他强制类型转换不同涉及运行时类型检查运行时的类型检查需要运行时的类型信息而这个类型信息存储在类的虚函数表中只有定义了虚函数的类才有虚函数表没有定义虚函数的类是没有虚函数表的对没有虚函数表的类使用会导致编译错误如果绑定到引用或指针的对象的类型不是目标类型则失败如果转换到指针类型的失败则的结果是值如果转换到引用类型的失败则抛出一个类型的异常因此操作符一次执行两个操作它首先验证被请求的转换是否有效只有转换有效然后操作符才实际进行转换一般而言引用或指针所绑定的对象的类型在编译时是未知的基类的指针可以赋值为指向派生类对象同样基类的引用也可以用派生类对象初始化因此操作符执行的验证必须在运行时进行定义类型的指针指向类类型的对象针对上述代码下列语句的执行情况如何通过本来就是类型实际上不需要转换类型编译错误运行时的操作数必须包含多态类类型而类没有虚函数通过本来就是类型实际上不需要转换类型通过派生类对象赋值给基类对象发生隐式转换编译错误用进行转换时待转换的类型只能是指针或引用主要用于类层次间的上行转换和下行转换运算符可以在执行期决定真正的类型如果下行转换是安全的也就说如果基类指针或者引用确实指向一个派生类对象这个运算符会传回转型过的指针如果不安全这个运算符会传回空指针也就是说基类指针或者引用没有指向一个派生类对象在类层次间进行上行转换时和的效果是一样的在进行下行转换时具有类型检查的功能比更安全',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-06 17:09:05',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="CCB" type="application/atom+xml">
</head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">CCB</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> Newest Comments</span></div><div class="aside-list"><span>loading...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/DVWA%E9%9D%B6%E5%9C%BA/" style="font-size: 1.05rem;">DVWA靶场<sup>10</sup></a><a href="/tags/%E5%AE%9E%E8%AE%AD-%E7%BD%91%E7%BB%9C%E5%BB%BA%E8%AE%BE%E9%83%A8%E5%88%86/" style="font-size: 1.05rem;">实训-网络建设部分<sup>7</sup></a><a href="/tags/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/" style="font-size: 1.05rem;">搭建博客<sup>1</sup></a><a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 1.05rem;">机器学习<sup>1</sup></a><a href="/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/" style="font-size: 1.05rem;">渗透测试<sup>15</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" style="font-size: 1.05rem;">计算机基础<sup>5</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>Archives</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">October 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/08/"><span class="card-archive-list-date">August 2022</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">15</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/07/"><span class="card-archive-list-date">July 2022</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/08/"><span class="card-archive-list-date">August 2021</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2020/08/"><span class="card-archive-list-date">August 2020</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">18</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>计算机基础</span></a></span></div></div><h1 class="post-title" itemprop="name headline">C/C++ 基础知识</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2021-08-14T16:00:00.000Z" title="Created 2021-08-15 00:00:00">2021-08-15</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-10-06T09:09:05.985Z" title="Updated 2023-10-06 17:09:05">2023-10-06</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为长沙"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>长沙</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://frankcao3.github.io/posts/50843"><header><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" tabindex="-1" itemprop="url">计算机基础</a><h1 id="CrawlerTitle" itemprop="name headline">C/C++ 基础知识</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">ccb</span><time itemprop="dateCreated datePublished" datetime="2021-08-14T16:00:00.000Z" title="Created 2021-08-15 00:00:00">2021-08-15</time><time itemprop="dateCreated datePublished" datetime="2023-10-06T09:09:05.985Z" title="Updated 2023-10-06 17:09:05">2023-10-06</time></header><h1 id="C-x2F-C"><a href="#C-x2F-C" class="headerlink" title="C&#x2F;C++"></a>C&#x2F;C++</h1><p>[TOC]</p>
<h2 id="1-数组"><a href="#1-数组" class="headerlink" title="1. 数组"></a>1. 数组</h2><p>一维数组可以用于实现线性表的顺序存储、哈希表等，二维数组可用来保存图的邻接矩阵等。</p>
<p>没有引用数组，但数组可以有引用。</p>
<p>有指针数组和数组指针。</p>
<h3 id="1-1-一维数组"><a href="#1-1-一维数组" class="headerlink" title="1.1 一维数组"></a>1.1 一维数组</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>在函数体外定义的内置类型数组（全局数组），元素会被初始化为0；</p>
<p>在函数体外定义的内置类型数组，元素不会被初始化。但是若初始化了部分元素，其后的元素也会被初始化为0；</p>
<p>若不是内置类型，不管在何处定义，均调用其默认构造函数为其初始化。若无默认构造函数，则报错。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x[<span class="number">4</span>]=&#123;<span class="number">0</span>&#125;;   <span class="comment">//&#123;0,0,0,0&#125;</span></span><br><span class="line"><span class="type">int</span> y[<span class="number">4</span>]=&#123;<span class="number">1</span>&#125;;   <span class="comment">//&#123;1,0,0,0&#125;</span></span><br><span class="line"><span class="type">int</span>* a=<span class="keyword">new</span> <span class="type">int</span>[n];   <span class="comment">//大小未知时使用new动态声明</span></span><br><span class="line"><span class="keyword">delete</span> []a;          <span class="comment">//使用完毕后释放内存空间,[]a表示释放a所指数组的内存，如果a是类对象，分别调用每个数组元素a[i]的析构函数</span></span><br></pre></td></tr></table></figure>

<h4 id="C风格字符串"><a href="#C风格字符串" class="headerlink" title="C风格字符串"></a>C风格字符串</h4><ul>
<li><p>字符串常量</p>
<p>以<strong>双引号</strong>括起的字符序列，且C++中**均在末尾自动添加一个空字符’\0’**。注意’A’表示单个字符，”A”表示字符串常量，其表示A和\0两个字符。</p>
</li>
<li><p>字符数组</p>
<p>可以使用{}初始化（**最后一个元素必须为空字符’\0’**，以其作为字符串结束标志），也可以使用双引号括起的字符串初始化（自动在末尾添加’\0’）。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ca1[]=&#123;<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;+&#x27;</span>&#125;;        <span class="comment">//不是C风格字符串，末尾没有&#x27;\0&#x27;</span></span><br><span class="line"><span class="type">char</span> ca2[]=&#123;<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;   <span class="comment">//是C风格字符串，长度为4</span></span><br><span class="line"><span class="type">char</span> ca3[]=<span class="string">&quot;C++&quot;</span>;                <span class="comment">//是C风格字符串，末尾自动添加&#x27;\0&#x27;，长度为4</span></span><br><span class="line"><span class="type">char</span> *cp2=ca2;                   <span class="comment">//是C风格字符串</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> ch3[<span class="number">6</span>]=<span class="string">&quot;Daniel&quot;</span>;      <span class="comment">//报错，因为字符串&quot;Daniel&quot;末尾其实还有一个空字符，长度为7而不是6</span></span><br></pre></td></tr></table></figure>

<p><strong><u><em>注意：使用C风格字符串的标准库函数时，牢记参数必须以空字符’\0’结束。</em></u></strong></p>
<p>若一char数组变量的末尾没有’\0’，但是又使用了C风格字符串的标准库函数（比如strcpy、strcat，strlen）进行处理，那么程序就会在该变量的内存空间中一直寻找空字符’\0’，直到恰好遇到为止，导致程序出错。</p>
<hr>
<h3 id="1-2-二维数组"><a href="#1-2-二维数组" class="headerlink" title="1.2 二维数组"></a>1.2 二维数组</h3><h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><ul>
<li><p>按行初始化：使用两层花括号初始化，每一个花括号代表一行。</p>
</li>
<li><p>顺序初始化：使用一个花括号初始化，逐行填入，缺少的默认初始化为0。</p>
<p>C++在声明和初始化二维数组时，若对所有元素都赋值，可以省略第一维。但声明更高维数组时，最多也只能省略第一维。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[<span class="number">2</span>][<span class="number">4</span>]=&#123;</span><br><span class="line">	&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">	&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> ia[<span class="number">2</span>][<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;  <span class="comment">// 逐行填入，缺少的默认初始化为0</span></span><br><span class="line"><span class="type">int</span> ia[<span class="number">2</span>][<span class="number">4</span>]=&#123;&#123;<span class="number">0</span>&#125;,&#123;<span class="number">4</span>&#125;&#125;;    <span class="comment">// 部分初始化，每行缺少的默认初始化为0</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">3</span>,<span class="number">6</span>&#125;;     <span class="comment">// &#123;0，3，6，0，0，0，0，0&#125;</span></span><br><span class="line"><span class="type">int</span> ia[][<span class="number">3</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;  <span class="comment">//初始化所有元素时，可以省略第一维</span></span><br></pre></td></tr></table></figure>

<p>C&#x2F;C++中二维数组按照行优先顺序存储，所以二维数组a在内存空间中的地址顺序b有如下关系：<code>a[x][y] = b[x*列数+y]</code>  。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> M 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 4</span></span><br><span class="line"><span class="type">int</span> a[M][N] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;, &#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;, &#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;&#125;;</span><br><span class="line">p = &amp;a[<span class="number">0</span>][<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p><strong><code>a[i][j]</code>就等于*(p+i*N+j)</strong></p>
<p>另外由于是行优先顺序存储，所以<code>a[1][5]</code>也不会报错，会直接顺延到下一行，指向值10。</p>
</li>
<li><p>动态声明</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> **a = <span class="keyword">new</span> <span class="type">int</span>* [m];  <span class="comment">// m行</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">    a[i] = <span class="keyword">new</span> <span class="type">int</span> [n];  <span class="comment">// n列</span></span><br><span class="line"><span class="comment">// 手动动态声明的数组需要手动释放内存</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    <span class="keyword">delete</span> []a[i];</span><br><span class="line"><span class="keyword">delete</span> []a;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="1-3-指针"><a href="#1-3-指针" class="headerlink" title="1.3 指针"></a>1.3 指针</h3><h4 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h4><p>在C&#x2F;C++中，指针虽然经常被当作整数来处理，但是其支持的操作非常有限，合法的运算包括：指针与整数的加减、同类型指针的比较、同类型两指针相减。</p>
<p><strong>当指针与一个整数量进行算数运算时，整数在执行加法运算前始终会根据合适的大小进行调整（相乘）。</strong>比如，字符指针加1，则运算结果产生的指针指向内存中的下一个字符（整数量乘1）；如果指针指向float类型的变量，由于float类型占据4个字节，所以指针加1时实际加到指针上的整型值为4（整数量乘4），即增加一个float大小。<strong>所以指针的大小与所指变量类型相关，其运算中指针增加的值也与这个类型相关。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-20220613141312988.png" alt="image-20220613141312988"></p>
<ul>
<li><strong>指针的算数运算</strong></li>
</ul>
<p>C的指针的算术运算只局限于两种形式。第-种形式是: <strong>指针+ &#x2F; - 整数</strong>。这种形式用于指向数组中某个元素的指针。</p>
<p>第二种类型的指针运算具有如下的形式: <strong>指针-指针</strong>。只有当两个指针都指向同一个数组中的元素时，才允许从一个指针减去另一个指针。减法运算的值是两个指针在内存中的距离(以数组元素的长度为单位，而不是以字节为单位)。即相差多少个元素就是多少。</p>
<p>如果两个指针所指向的不是同一个数组中的元素，那么它们之间相减的结果是未定义的。程序员无从知道两个数组在内存中的相对位置，如果不知道这一点， 两个指针之间的距离就毫无意义。</p>
<ul>
<li><strong>指针的关系运算</strong></li>
</ul>
<p>还可以进行&lt;、&lt;&#x3D;、&gt;、&gt; &#x3D;运算，不过前提是它们都指向同-个数组中的元素。根据你所使用的操作符，比较表达式将告诉你哪个指针指向数组中更前或更后的元素。</p>
<h4 id="指针数组与数组指针"><a href="#指针数组与数组指针" class="headerlink" title="指针数组与数组指针"></a>指针数组与数组指针</h4><ul>
<li><p><strong>指针数组</strong>：由指针作为元素组成的数组。定义：<code>int* a[10]</code></p>
</li>
<li><p><strong>数组指针</strong>：一个指向数组的指针。定义：<code>int (*p)[10]</code>为指向有10个元素的整形数组的指针，因为[]的优先级高于<em>，所以要有括号，用[10]表示*p指向的数组有10个元素。*<em>数组指针运算时以一整个数组大小为单位。</em></em></p>
</li>
</ul>
<p>对于二维数组<code>int w[3][4]</code>，定义一个与w等价的数组指针：<code>int (*pw)[4] = w; </code> </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-20220613143246893.png" alt="image-20220613143246893"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-20220613143516876.png" alt="image-20220613143516876"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a[]=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">a[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span>;  <span class="comment">// 变成xello</span></span><br><span class="line"><span class="type">char</span>* q=a;</span><br><span class="line">q[<span class="number">0</span>]=<span class="string">&#x27;b&#x27;</span>;    <span class="comment">// 变成bello</span></span><br><span class="line"><span class="type">char</span> *p=<span class="string">&quot;hello&quot;</span>;  <span class="comment">// 把存放该字符串的首地址装入指针变量</span></span><br><span class="line">p[<span class="number">0</span>]=<span class="string">&#x27;x&#x27;</span>;    <span class="comment">// 该语句错误</span></span><br></pre></td></tr></table></figure>

<p>最后一个语句错误。a是数组，内存分配在栈上，故可以通过数组名或指向数组的指针进行修改，而p指向的是位于<strong>文字常量区的字符串，是不允许被修改的</strong>，故通过指针修改错误。但使用p[0]访问相应元素是正确的，只是不能修改。</p>
<p>指针和数组密切相关。特别是在表达式中使用数组名时，该名字会自动转换为指向数组首元素(第0元素)的指针。<strong>但是注意数组的首地址是常量，不可以进行赋值操作。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[]=&#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line">ia += <span class="number">1</span>;   <span class="comment">// 编译错误，数组首地址ia为常量，不可变更；可以使用char* p=a; p+=2;实现</span></span><br><span class="line"><span class="type">int</span> *ip=ia;</span><br><span class="line"><span class="comment">// 修改第四个元素为9，可使用如下操作：</span></span><br><span class="line">ia[<span class="number">4</span>]=<span class="number">9</span>;</span><br><span class="line">*(ia+<span class="number">4</span>)=<span class="number">9</span>;</span><br><span class="line">ip[<span class="number">4</span>]=<span class="number">9</span>;</span><br><span class="line">*(ip+<span class="number">4</span>)=<span class="number">9</span>;</span><br></pre></td></tr></table></figure>

<p><strong><u>注意：</u><strong>对于<code>int a[10];</code>来说，</strong>&amp;a[0]等价于a，为指向数组<u>首元素的指针</u>，每加1就跳过4个字节（int类型）。而&amp;a为指向<u>数组的指针</u>，与a的类型不同（&amp;a的类型为int(*)[10]），但是指向的单元相同。</strong></p>
<blockquote>
<p>例题：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-20220614102002448.png" alt="image-20220614102002448"></p>
</blockquote>
<p><strong>在二维数组<code>int a[4][5]</code>中</strong>，同理，其可以看成由4个数组作为元素组成的数组。那么a的第一个元素为数组a[0]，然后是数组a[1]、a[2]、a[3]，<strong>a表示指向数组首元素a[0]的指针，即数组指针</strong>。而a[0]本身为包含5个元素的数组，所以<strong>a[0]表示指向数组a[0]首元素a[0][0]的指针</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-20220614110311876.png" alt="image-20220614110311876"></p>
<p>因此：</p>
<p><strong>&amp;a</strong>：类型为整个二维数组的数组指针，int(*)[4][5]。&amp;a[0]等价于a，&amp;a+1直接跳到二维数组末尾。</p>
<p><strong>a</strong>：类型为int(*)[5]，为a的第一个数组元素的数组指针。且a为常量，不可以进行赋值运算。a+i指向a[i]，a加1将直接跳过5个元素，即*(a+1)相当于a[i]。</p>
<p>***a或a[0]*<em>：类型为int</em>，指针，指向数组a[0]的首元素a[0][0]。</p>
<p>***(a+1)或a[1]**：指向数组a[1]首元素a[1][0]的指针。</p>
<p><strong>*(*(a+1)+2）</strong>：为数组a[1]的第二个元素a[1][2].</p>
<blockquote>
<p>例题：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-20220615094712862.png" alt="image-20220615094712862"></p>
</blockquote>
<hr>
<h3 id="1-4-数组的应用"><a href="#1-4-数组的应用" class="headerlink" title="1.4 数组的应用"></a>1.4 数组的应用</h3><ul>
<li><p>线性表的顺序存储</p>
<p>线性表是一种逻辑结构，线性表的顺序存储成为顺序表。</p>
</li>
</ul>
<p>**<u>注意</u>**：线性表中元素的位序是从1开始的，而数组元素下标是从0开始的。</p>
<p><strong><u>时间复杂度：</u></strong></p>
<p>存取访问：通过首地址和元素序号可以在O(1)内找到指定元素。</p>
<p>插入：表尾插入O(1)，表头插入O(n)。平均复杂度O(n)。</p>
<p>删除：表尾插入O(1)，表头插入O(n)。平均复杂度O(n)。</p>
<p>按值查找：目标就在表头O(1)，目标在表尾O(n)。平均复杂度O(n)。</p>
<hr>
<h2 id="2-字符串"><a href="#2-字符串" class="headerlink" title="2. 字符串"></a>2. 字符串</h2><h3 id="2-1-基础操作"><a href="#2-1-基础操作" class="headerlink" title="2.1 基础操作"></a>2.1 基础操作</h3><p><strong>子串</strong>：串种任意个连续字符组成的子序列。字符串本身以及空串也属于字符串的子串。</p>
<p><strong>子序列</strong>：不要求字符连续，但是顺序与其在主串中相一致。</p>
<p>以整数格式%d输出字符时，’\0’会输出0，其他字符会输出相应的ascii码的十进制。因此可以以<code>while(*str)</code>来判断是否到达字符串末尾。</p>
<table>
<thead>
<tr>
<th>strlen(s)</th>
<th>返回s的长度，以’\0’作为结束标志，但是不包括字符串结束符null</th>
</tr>
</thead>
<tbody><tr>
<td>strcmp(s1,s2)</td>
<td>比较两个字符串是否相同。两个字符串自左向右逐个字符比较（ASCII），直到出现不同的字符或遇到’\0’为止。<br>若相等，则返回0；若s1大于s2，则返回正数；若s1小于s2，则返回负数；<br>字符串比较不能用<code>if(s1==s2)</code>，该语句比较的是首地址，而不是内容。</td>
</tr>
<tr>
<td>strcat(s1,s2)</td>
<td>将字符串s2连接到s1之后，并返回s1。<br>覆盖s1末尾的’\0’，且s1处必须要有足够的空间存放新生成的字符串。</td>
</tr>
<tr>
<td>strcpy(s1,s2)</td>
<td>将s2复制给s1，并返回s1。复制的内容到’\0’结束，处理不好容易溢出。</td>
</tr>
<tr>
<td>strncat(s1,s2,n)</td>
<td>将s2的前n个字符连接到s1后面，并返回s1</td>
</tr>
<tr>
<td>strncpy(s1,s2,n)</td>
<td>将s2的前n个字符复制给s1，并返回s1</td>
</tr>
</tbody></table>
<p>**memcpy(void *dest, void *src, size_t n)**：从源src所指内存地址的起始位置拷贝n个字节到目标dest所指的内存地址的起始位置。必须指定拷贝长度n，且可用于各种数据类型，而strcpy仅用于字符串。</p>
<p>**memset(void *s,  int ch, size_t n)**：将s中前n个字节用ch替换并返回s，作用是在一段内存中填充某个给定的值，它是对较大的结构体或数组进行清零操作的一种最快方法。</p>
<h3 id="2-2-字符串包含问题"><a href="#2-2-字符串包含问题" class="headerlink" title="2.2 字符串包含问题"></a>2.2 字符串包含问题</h3><h4 id="串的模式匹配算法KMP"><a href="#串的模式匹配算法KMP" class="headerlink" title="串的模式匹配算法KMP"></a>串的模式匹配算法KMP</h4><ul>
<li><p><strong>Brute Force算法</strong></p>
<p><strong>时间复杂度O(mn)</strong></p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-20220616154236.png" alt="image-20220616153841511"></p>
<ul>
<li><p><strong>KMP算法</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1AY4y157yL?spm_id_from=333.337.search-card.all.click&amp;vd_source=854e3e80724343215a332be36ec7cf83">https://www.bilibili.com/video/BV1AY4y157yL?spm_id_from=333.337.search-card.all.click&amp;vd_source=854e3e80724343215a332be36ec7cf83</a></p>
<p><strong>时间复杂度O(mn)</strong></p>
<p>KMP算法每当一趟匹配过程中出现字符比较不等时，不需回溯主串（主串的指针一直向后移动，不回退），而是利用已经得到的“部分匹配”结果将模式串向右“滑动”尽可能远的一段距离后，继续进行比较，且此时并不一定是拿模式串的第一位继续比较。</p>
<p><strong>next数组的作用</strong>：当匹配失败时，查看最后一个匹配成功的字符所对应的next数值。下次匹配时，在模式串中跳过前next个字符继续比对</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">kmp_search</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* src, <span class="type">int</span> slen, <span class="type">const</span> <span class="type">char</span>* patn, <span class="type">int</span> plen, <span class="type">const</span> <span class="type">int</span>* nextval, <span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="comment">// nextval数组已知</span></span><br><span class="line">    <span class="type">int</span> i=pos;  <span class="comment">// 主串的指针</span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;    <span class="comment">// 子串的指针</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;slen &amp;&amp; j&lt;plen)&#123;  <span class="comment">// i永远递增</span></span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">-1</span> || src[i]==patn[j])&#123;++i;++j;&#125;   <span class="comment">// 该字符匹配，指针后移</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//匹配失败时直接使用patn[nextval[j]]与s[i]继续比较，即跳过模式串中的nextval[j]个字符</span></span><br><span class="line">            j=nextval[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;=plen) <span class="keyword">return</span> i-plen;  <span class="comment">//返回匹配成功的子串开头</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//匹配失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面给出计算<strong>nextval</strong>数组的函数：</p>
<p><strong>思想</strong>：在匹配成功的那段模式串中寻找最长的相同前后缀，这个长度就是nextval。那么对于匹配成功的那部分字符串，模式串的前缀就可以匹配到主串的后缀，所以可以跳过nextval个字符。</p>
<p>这个最长的相同前后缀不包括匹配成功的部分模式串本身。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_nextval</span><span class="params">(<span class="type">char</span> <span class="type">const</span>* ptrn, <span class="type">int</span> plen, <span class="type">int</span>* nextval)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>; nextval[<span class="number">0</span>]=<span class="number">-1</span>;   <span class="comment">// 第0位前面没有字符串，也无法找最长相同前后缀，所以初始化为-1</span></span><br><span class="line">    <span class="type">int</span> k=<span class="number">-1</span>;  <span class="comment">// K记录字符i之前的字符串中最长相同前后缀的位置，就是next[i]</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;plen<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 判断1：确定最长相同前后缀长度</span></span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">-1</span> || ptrn[i] == ptrn[k])&#123;  <span class="comment">// 相等时k加1，即在前一位字符的k上加1得到目前的字符的k</span></span><br><span class="line">            ++i;</span><br><span class="line">            ++k;</span><br><span class="line">            <span class="comment">// 判断2：如何给nextval[i]赋值</span></span><br><span class="line">            <span class="keyword">if</span>(ptrn[i] != ptrn[k])     <span class="comment">// i、k位置的字符是否相同，不相同，nextval[i]就等于k，下次与主串继续比较k处的字符，而不是从模式串开头开始</span></span><br><span class="line">                nextval[i]=k;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nextval[i]=nextval[k]; <span class="comment">// 相同的话，因为i和k处的字符相等，主串接着比较k处的字符依然是不相等的，所以改为继续比较nextval[k]处的字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            k=nextval[k]; <span class="comment">//不相等时k回退，直到找到k处的字符与i处相等或者k=-1</span></span><br><span class="line">        	<span class="comment">// 改为判断i、nextval[k]位置的字符是否相等，即查看相同前缀的前缀，继续判断（相同前缀的前缀等于相同后缀的后缀），直到k=-1（不存在任何相同的前后缀）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以模式串<code>char *ptrn = “ABABC&quot;</code>为例，nextval数组下标为0到4。</p>
<p>对于ptrn[0]来说，不存在更短的前后缀，所以nextval[0]直接为-1；</p>
<p>接着对于ptrn[1]之前的字符串”A“，此时k&#x3D;-1，所以进入判断1，k和i加1，k&#x3D;0，i&#x3D;1，由于ptrn[1] !&#x3D; ptrn[0]，所以nextval[1]为k，为0；<u>与ptrn[1]的’B’不匹配，而ptrn[0]与ptrn[1]不相等，所以可以右滑到与ptrn[0]的’A’继续匹配；</u></p>
<p>接着对于ptrn[2]之前的字符串”AB“，此时k&#x3D;0，ptrn[1] !&#x3D; ptrn[0]，所以进入判断1，k回退为nextval[0]，为-1，接着继续判断1，k和i加1，k&#x3D;0（最长相同前后缀的长度），i&#x3D;2，ptrn[2] &#x3D;&#x3D; ptrn[0]，所以nextval[2]为nextval[0]，为-1；<u>与ptrn[2]的’A’不匹配，那右滑到ptrn[0]的’A’也是仍然不匹配的，所以nextval[2]为-1；</u></p>
<p>对于ptrn[3]之前的字符串”ABA“，此时k&#x3D;0，ptrn[2] &#x3D;&#x3D; ptrn[0]，所以进入判断1，k和i加1，k&#x3D;1（最长相同前后缀的长度），i&#x3D;3，由于ptrn[3] &#x3D;&#x3D; ptrn[1]，nextval[3]为nextval[1]，为0；<u>与ptrn[3]的’B’不匹配，那右滑到ptrn[1]的’B’也是仍然不匹配的，所以nextval[3]为0；</u></p>
<p>对于ptrn[4]之前的字符串”ABAB“，此时k&#x3D;1，ptrn[3] &#x3D;&#x3D; ptrn[1]，所以进入判断1，k和i加1，k&#x3D;2（最长相同前后缀的长度），i&#x3D;4，ptrn[4] !&#x3D; ptrn[2]，所以nextval[3]为k，为2。<u>与ptrn[4]的’C’不匹配，那右滑到ptrn[2]的’A’继续匹配的；</u></p>
<h4 id="字符串移位包含问题"><a href="#字符串移位包含问题" class="headerlink" title="字符串移位包含问题"></a>字符串移位包含问题</h4><p>假设有一个函数 isSubstring, 其功能是判断一个字符串是不是另外一个字符串的子串。现在给你两个字符串s1与s2,请仅使用isSubstring函数判断s2是否能够被s1做循环移位得到的字符串包含。<br>解答思想是:<br>如果字符串s1的长度小于s2的长度，则返回0; .<br>否则，连接s1与其自身得到新字符串sls1,然后判断s2是否是sIsl的子串，若是返回1,若不是返回0。</p>
<hr>
<h3 id="2-3-字符串转数字"><a href="#2-3-字符串转数字" class="headerlink" title="2.3 字符串转数字"></a>2.3 字符串转数字</h3><p>将字符串的字符逐个转为数字（<code>*digit - &#39;0&#39;</code>），乘以10然后加上下一个字符表示的数字。</p>
<p>另外还需要考虑特殊字符，比如首字符是否为’+’或者’-‘，是否包含非法字符，最后要以’\0’结束。以及中间结果是否大于上限std: :numeric_ limits&lt;int&gt;: :max()。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220620111637041.png" alt="image-20220620111637041"></p>
<p>**<u>大数乘法</u>**：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220620142029124.png" alt="image-20220620142029124"></p>
<hr>
<h3 id="2-4-其他问题"><a href="#2-4-其他问题" class="headerlink" title="2.4 其他问题"></a>2.4 其他问题</h3><ul>
<li><p>字符串中的单词逆转：使用指针交换字符</p>
</li>
<li><p>在主串中删除模式串中出现的字符：</p>
<p>遍历；也可以给每个字母分配一个素数，从2开始，以此类推。这样a将会是2, b将会是3, c将会是5,等等，然后得出模式串的乘积multi, 现在遍历字符串s，把每个字母代表的素数除multi, 若能<br>整除，则将其删除。</p>
</li>
<li><p>删除字符串开头和末尾的空格，并将中间的连续空格转化为1个</p>
</li>
<li><p>在字符串中找到第一个只出现一次的字符：使用数组实现的hash表即可，下标存放ascii码值（char可以直接作为整数处理），元素存放出现次数。在第二次遍历时，取首个为1的元素即可。</p>
</li>
<li><p>判断字符串中所有字符都不相同：同样使用hash表即可，值统一为True。若出现一个字符在hash表中存在，则表明该字符重复。</p>
</li>
</ul>
<hr>
<h2 id="3-结构体、共用体和枚举"><a href="#3-结构体、共用体和枚举" class="headerlink" title="3. 结构体、共用体和枚举"></a>3. 结构体、共用体和枚举</h2><p><strong>与数组的不同</strong>：</p>
<p>结构体可以在一个结构中声明不同的数据类型；相同结构的结构体变量可以相互赋值。</p>
<p><strong>与class的不同</strong>：</p>
<p>class的成员访问权限默认为private，而struct成员的访问权限默认为public。</p>
<h3 id="3-1-结构体的定义"><a href="#3-1-结构体的定义" class="headerlink" title="3.1 结构体的定义"></a>3.1 结构体的定义</h3><p>不允许结构体本身的递归定义，但可以使用指针指向本类型。</p>
<p>结构体定义中可以包含另外的结构体，即可以嵌套。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Books</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span> title[<span class="number">50</span>];</span><br><span class="line">   <span class="type">char</span> author[<span class="number">50</span>];</span><br><span class="line">   <span class="type">char</span> subject[<span class="number">100</span>];</span><br><span class="line">   <span class="type">int</span> book_id;</span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">person</span> *per;  <span class="comment">// 指向本类型的指针</span></span><br><span class="line">&#125; book;  <span class="comment">// 同时声明一个结构体Books的变量book</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Books</span> book;   <span class="comment">// 声明一个结构体变量book</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span>&#123;</span><br><span class="line">	<span class="type">char</span> name [<span class="number">20</span>];</span><br><span class="line">	<span class="type">char</span> sex;</span><br><span class="line">    <span class="built_in">person</span>(<span class="type">char</span> a[<span class="number">20</span>], <span class="type">char</span> b) :<span class="built_in">name</span>(a), <span class="built_in">sex</span>(b)(a)&#123;&#125;   <span class="comment">// 构造函数</span></span><br><span class="line">&#125;boy1=&#123;<span class="string">&quot;zhangbing&quot;</span>,<span class="string">&#x27;M&#x27;</span>&#125;;   <span class="comment">// 结构体变量可以在定义时初始化赋值</span></span><br></pre></td></tr></table></figure>

<p>在对结构体变量初始化时，应将各成员所赋初值依照结构体类型说明中成员的顺序依次放在一对大括号中，不允许跳过前面的成员给后面的成员赋值，但<strong>可以只给前面若干成员赋初值</strong>，后面未赋初值的成员中，数值型和字符型的数据，系统自动赋值零。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//也可以用typedef创建新类型Simple</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">double</span> c; </span><br><span class="line">&#125; Simple;</span><br><span class="line"><span class="comment">//现在可以用Simple作为类型声明新的结构体变量</span></span><br><span class="line">Simple u1, u2[<span class="number">20</span>], *u3;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-2-结构体中的位字段"><a href="#3-2-结构体中的位字段" class="headerlink" title="3.2 结构体中的位字段"></a>3.2 结构体中的位字段</h3><p>C&#x2F;C++允许指定占用特定位数的数据成员，声明时，位字段的类型为整型或枚举，然后是冒号和指定位数的数字，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">reg</span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> a:<span class="number">1</span>;  <span class="comment">// 占1位</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> b:<span class="number">4</span>;  <span class="comment">// 占4位，4bits</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-3-共用体"><a href="#3-3-共用体" class="headerlink" title="3.3 共用体"></a>3.3 共用体</h3><p>结构体和共用体都是由多个不同的数据类型成员组成，但在任何同一时刻，<strong>共用体中只存放了一个被选中的成员</strong>，而结构体的所有成员都存在。<strong>对于共用体的不同成员赋值，将会对其他成员重写</strong>，原来成员的值就不存在了，而对于结构体的不同成员赋值是互不影响的。</p>
<p><strong>结构体占用内存，可能超过各成员内存量总和；共用体占用内存为各成员中占用最大者内存。</strong></p>
<p>共用体的用途之一是当数据项使用两种或更多种格式（但不会同时使用）时，可节省空间。</p>
<p>union成员<u><strong>从低地址开始存放</strong></u>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Intel X86上运行一下程序</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">short</span> s1:<span class="number">3</span>;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">short</span> s2:<span class="number">3</span>;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">short</span> s3:<span class="number">2</span>;</span><br><span class="line">        &#125;x;</span><br><span class="line">		<span class="type">char</span> C;</span><br><span class="line">	&#125;V;</span><br><span class="line">	v.c=<span class="number">103</span>;</span><br><span class="line">	cout&lt;&lt;v.x.s1&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于Intel X86是小端模式，103转为二进制为01100111，所以高地址到低地址的内存空间为01100111。而union成员都是从低地址开始存放，故分别分配给s1低地址的111，然后是s2的100，最后是s3的高地址的01。</p>
<hr>
<h3 id="3-4-大小端存储"><a href="#3-4-大小端存储" class="headerlink" title="3.4 大小端存储"></a>3.4 大小端存储</h3><h4 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h4><p><strong>大端存储格式</strong>：字数据的高字节存储在低地址中，而字数据的低字节则存放在高地址中；</p>
<p><strong>小端存储格式</strong>：低地址中存放的是字数据的低字节，高地址存放的是字数据的高字节。</p>
<p><em><strong><u>注意</u></strong></em>: </p>
<p>printf 函数是最右侧的元素先入栈。<strong>若入栈元素为char（占1个字节）、short（占2个字节） 等小于4个字节的类型，入栈时也占4个字节</strong>。这里的一个关键点是: char、 short 等类型入栈时由于入栈字节数为4，比它们实际占用的内存数要多，那么高位是补0还是补1呢?当数是<strong>无符号类型时（如unsigned short），高位总是补1</strong>，当数是<strong>有符号类型时（如short），高位补符号位</strong>。</p>
<p>例题：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220622110310042.png" alt="image-20220622110310042"></p>
<p>array数组后4个元素默认初始化为0x00。printf的输出从右到左先依次入栈，输出时依次出栈。首先pint为int类型的指针，所以运算时4个字节一个单位，*(pint+2)的值为0x00000000。pint64为long long类型指针，运算时8个字节一个单位，又系统为小端，低位在低地址字节，所以*pint64为0x0807060504030201。pshort为short类型指针，运算时2个字节一个单位，所以*(pshort+2)为0x0605，由于入栈时不足4个字节，所以高位补0，得到0x00000605。这些值依次入栈得到如下栈空间（高位先入栈）：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220622110332959.png" alt="image-20220622110332959"></p>
<h4 id="位序"><a href="#位序" class="headerlink" title="位序"></a>位序</h4><p>在字节内部也存在大小端问题（对于位字段&#x2F;位数据），相应的大小端定义为：</p>
<ul>
<li><p>第一步：将位字段组成的字节，低字节存放在低地址，高字节存放在高地址；</p>
</li>
<li><p>第二步：然后按照大小端格式的定义在每个字节中分配位地址：</p>
</li>
</ul>
<p><strong>大端存储格式</strong>：首先将位数据的高位存储在字节的高位中，之后低位数据存放在低位中。</p>
<p><strong>小端存储格式</strong>：首先将位数据的低位存储在字节的低位中，之后高位数据存放在高位中。</p>
<p><u><em><strong>注意</strong></em></u>：若位数据（如<code>short in a:9</code>）大于1个字节，则先在位数据组成的字节序中，先按字节序中的大小端的定义分配相应大小的位数据到相应的字节中（此过程位数据可能被拆分到不同字节中），然后再在每个字节中，按位序大小端的定义分配到相应的位地址。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> a:<span class="number">5</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> b:<span class="number">5</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> c:<span class="number">6</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>**)</span></span>&#123;</span><br><span class="line">    Test t;</span><br><span class="line">    t.a=<span class="number">16</span>;</span><br><span class="line">    t.b=<span class="number">4</span>;</span><br><span class="line">    t.c=<span class="number">0</span>;</span><br><span class="line">    <span class="type">short</span> i = *(<span class="type">short</span>*)&amp;t;</span><br><span class="line">    cout&lt;&lt;i;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，结构体表示的是由a，b，c三个位字段组成的两个字节，a是高位域员，c是低位域员。</p>
<p>在大端存储格式中，优先将位数据的高位存储在字节的高位中，所以5位的a（10000）和b的三位高位（001）分配到高位字节，剩下的2位b（00）和6位c（000000）分配到低位字节，因此高位字节的位序为[10000][001]，低位字节位序为[00][000000]；</p>
<p>在小端存储格式中，优先将位数据的低位存储在字节的低位中，所以5位a（10000）和b的三位低位（100）分配到高位字节，b的两位高位（00）和6位c（000000）分配到低位字节，因此高位字节的位序为[100][10000]，低位字节位序为[000000][00]；</p>
<p>因此，上述代码中t所在内存为：10010000 00000000，由于时小端存储，所以转换为十六进制为0x0090，所以输出应该为144。</p>
<hr>
<h3 id="3-5-枚举"><a href="#3-5-枚举" class="headerlink" title="3.5 枚举"></a>3.5 枚举</h3><p>C++的enum工具提供了另一种创建符号常量的方式，可以用于代替const。语句如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> 枚举类型名&#123;枚举常量<span class="number">1</span>[=整形常数], 枚举常量<span class="number">2</span>[=整形常数], …&#125;[变量名列表]</span><br></pre></td></tr></table></figure>

<p>花括号的内容称为枚举表，包含多个枚举常量，声明时可以为其赋初值。若不赋初值，编译器会为每一个枚举常量赋一个不同的整型值，第一个为0，第二个为1等。当枚举表中某个常量赋值后，其后的成员则按依次加1的规则确定其值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">enum</span>&#123;a, b=<span class="number">5</span>，c, d=<span class="number">4</span>, e&#125;;    <span class="comment">// a为0,c为6,e为5</span></span><br><span class="line">	<span class="keyword">enum</span>&#123;h, x, v=<span class="number">120</span>，w, r=<span class="number">99</span>, s&#125;;  <span class="comment">// h为0,x为1，w为121,s为100</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-6-sizeof运算符"><a href="#3-6-sizeof运算符" class="headerlink" title="3.6 sizeof运算符"></a>3.6 sizeof运算符</h3><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>sizeof属于运算符，而不是函数。以字节形式给出其操作数的存储大小。操作数可以是一个表达式或括在括号内的类型名。操作数是类型名时必须加括号，比如<code>sizeof(int)</code>。</p>
<p><strong>sizeof的计算发生在编译时刻</strong>，可以直接作为常量表达式使用，所以其操作数中的运算会被忽略，比如<code>sizeof(a++)</code>，其中的++并不执行。</p>
<p>实际上，sizeof 计算对象的大小也是转换成对对象类型的计算，也就是说，<strong>同种类型的不同对象其sizeof值都是一致的</strong>。这里，对象可以进一步延伸至表达式，即<strong>sizeof可以对一个表达式求值，编译器根据表达式的最终结果类型来确定大小，一般不会对表达式进行计算</strong>。比如<code>sizeof(2)</code>等价于<code>sizeof(int)</code>，<code>sizeof(2+3.14)</code>等价于<code>sizeof(double)</code>。</p>
<p>函数、位域成员不能被计算sizeof值。</p>
<h4 id="使用结果"><a href="#使用结果" class="headerlink" title="使用结果"></a>使用结果</h4><p>sizeof操作符的结果类型是size_ t，它被定义为unsigned int 类型。该类型保证能容纳实现所建立的最大对象的字节大小。</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>占据字节长度(16bit编译器)</th>
<th>占据字节长度(32bit编译器)</th>
<th>占据字节长度(64bit编译器)</th>
</tr>
</thead>
<tbody><tr>
<td>shortint</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>int</td>
<td>2</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>long</td>
<td>4</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>long long</td>
<td>8</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>char</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>bool</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>指针</td>
<td>-</td>
<td>4</td>
<td>8</td>
</tr>
<tr>
<td>引用</td>
<td>取决于被引用对象</td>
<td>取决于被引用对象</td>
<td>取决于被引用对象</td>
</tr>
</tbody></table>
<p>若有:<code>char ch3[]=&quot;Danie1&quot;;</code>则<code>sizeof(ch3) = sizeof(&quot;Daniel&quot;)=7</code>，而<code>strlen(&quot;Daniel&quot;)=6</code>。</p>
<p>可见<strong>sizeof计算数据（包括数组、变量、类型、结构体等）所占内存空间，用字节数表示，故将内容为’\0’的数组元素也会计算在内</strong>。而<strong>strlen()计算字符数组的字符数，以’\0’为结束标志，且不将’\0’计算在字符数内</strong>。</p>
<p><strong>注意：<code>sizeof(&quot;\0&quot;) = 2</code>。</strong></p>
<p>指针可视为变量类型的一种。在32位机器系统下，所有指针变量的sizeof操作结果均为4，若在64位机器系统下，所有指针变量的sizeof 操作结果为8。</p>
<p>数组可以使用sizeof计算其大小，等于元素个数*元素类型的sizeof。</p>
<h4 id="struct的空间计算"><a href="#struct的空间计算" class="headerlink" title="struct的空间计算"></a>struct的空间计算</h4><p>struct的空间计算总体遵循两个原则：</p>
<ul>
<li><p>**&#x3D;&#x3D;整体空间是占用空间最大的成员(的类型)所占字节数的整数倍&#x3D;&#x3D;**，但在32位Linux+gcc环境下，若最大成员类型所占字节数超过4，如double是8，则整体空间是4的倍数即可。</p>
</li>
<li><p>数据对齐原则：内存按结构体成员的先后顺序排列，&#x3D;&#x3D;<strong>当排到该成员变量时，其前面已摆放的空间大小必须是该成员类型大小的整数倍（当排到子结构体时，其前面已摆放的空间大小必须是该子结构体成员中最大类型大小的整数倍）</strong>&#x3D;&#x3D;，如果不够则补齐，依次向后类推，但在Linux+gcc环境下，若某成员类型所占字节数超过4,如double是8，则前面已摆放的空间大小是4的整数倍即可，不够则补齐。<br>对齐问题使结构体的sizeof变得比较复杂。</p>
<p><u><strong>&#x3D;&#x3D;<em>注意</em>&#x3D;&#x3D;</strong></u>：<strong>结构体中，数组时按照单个单个变量一个一个进行摆放，而不是视为整体。<u>空结构体的占用空间大小为1</u>。</strong></p>
</li>
</ul>
<h4 id="含位域的结构体的空间计算"><a href="#含位域的结构体的空间计算" class="headerlink" title="含位域的结构体的空间计算"></a>含位域的结构体的空间计算</h4><p>使用位域的主要目的是压缩存储，其大致规则为:</p>
<ul>
<li><strong>如果相邻位域字段的类型相同，且其位宽之和小于类型的sizeof大小</strong>，则后面的字段将紧邻前一个字段存储，直到不能容纳为止。<strong>所占字节数以其实际占用字节数为准</strong>，也就是进行压缩。</li>
<li><strong>如果相邻位域字段的类型相同，但其位宽之和大于类型的sizeof大小</strong>，则后面的字段将从新的存储单元开始，其<strong>偏移量为其类型大小的整数倍</strong>，不进行压缩。</li>
<li>如果相邻的位域字段的类型不同，则各编译器的具体实现有差异，VC6 采取不压缩方式，Dev-C++与linux+gcc采取压缩方式</li>
<li>如果位域字段之间穿插着非位域字段，则不进行压缩</li>
<li>整个结构体的总大小为<strong>最宽基本类型成员大小的整数倍</strong>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 环境为linux+gcc</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">a</span>&#123;</span><br><span class="line">	<span class="type">int</span> f1:<span class="number">3</span>;</span><br><span class="line">	<span class="type">char</span> b;</span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>比如，上述结构体中f1占3个bits，b非位域类型，所以f1占用1个字节，abc总共占用3个字节。最后由于整个结构体的总大小为最宽基本类型成员int大小的整数倍，所以总共要占用4个字节。</p>
<h4 id="union的空间计算"><a href="#union的空间计算" class="headerlink" title="union的空间计算"></a>union的空间计算</h4><p>结构体在内存组织上是顺序式的，而联合体union是重叠式的，各成员共享一段内存，所以整个联合体的sizeof也就是每个成员sizeof的最大值，且整体空间是占用空间最大的成员(的类型)所占字节数的整数倍。即取占用内存最多的成员的空间作为自己的空间，且需要考虑对齐。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span>&#123;</span><br><span class="line">	<span class="type">char</span> b[<span class="number">9</span>];</span><br><span class="line">    <span class="type">int</span> bh[<span class="number">2</span>];</span><br><span class="line">&#125;c;</span><br></pre></td></tr></table></figure>

<p>上述代码的union中，数组b占用9个字节，bh占用8个，考虑占用内存最大的成员，所以应该是占用9个字节；又需要考虑对齐，占用空间应该是4（int占用空间）的整数倍，所以补齐为12。</p>
<h4 id="枚举的空间计算"><a href="#枚举的空间计算" class="headerlink" title="枚举的空间计算"></a>枚举的空间计算</h4><p>enum仅定义一个常量集合，里面没有元素，而枚举类型均作为int类型存储，因此枚举类型的sizeof均为4。</p>
<hr>
<h2 id="4-运算符及其优先级"><a href="#4-运算符及其优先级" class="headerlink" title="4.  运算符及其优先级"></a>4.  运算符及其优先级</h2><h3 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h3><p>略</p>
<h3 id="自增与自减运算符"><a href="#自增与自减运算符" class="headerlink" title="自增与自减运算符"></a>自增与自减运算符</h3><p>以++操作为例，对于变量a, <code>++a</code>表示取a的地址，增加它的内容，然后把值放在寄存器中; <code>a++</code>表示取a的地址，把它的值装入寄存器，然后增加内存中a的值。<strong>前缀运算是“先变后用”，而后缀运算是“先用后变”。</strong></p>
<p><u><em>&#x3D;&#x3D;注意&#x3D;&#x3D;</em></u>：<code>a++</code>只能位于等号的右边，而<code>++a</code>可以位于等号的左边。</p>
<p>负号运算符与自增（减）运算符的优先级相同，结合方向是从右向左。比如<code>k=-i++</code>等价于<code>k=-(i++)</code>。</p>
<p>特别的，对于指针变量：</p>
<p><code>*p++</code>  实现了先输出p所指地址处的数据值，然后指针后移到下一指针处；</p>
<p><code>*++p</code>  实现了先将指针指向后移，再输出此时指针所指处的数据的值；</p>
<p><code>(*p)++</code> 实现的是将指针p所指向地址处的数据值（比如300）输出后再自增1（得到301）；</p>
<h3 id="关系与逻辑运算符"><a href="#关系与逻辑运算符" class="headerlink" title="关系与逻辑运算符"></a>关系与逻辑运算符</h3><p>关系操作符：&lt;、&lt;&#x3D;、&gt;、&gt;&#x3D;。具有<strong>左结合性质</strong>，先执行左边的部分。但是不建议将多个关系操作符串接使用。</p>
<p>在<code>if(i&lt;j&lt;k)</code>这种写法中，只要k大于1,上述表达式的值就为true。 这是因为第二个小于操作符的左操作<br>数是第一个小于操作符的结果: true 或false。 也就是，该条件将k与整数0或1做比较。为了实现我们想要的条件检验，应重写上述表达式如下：<code>if(i&lt;j &amp;&amp; j&lt;k)</code>。</p>
<p>逻辑与和逻辑或操作符总是先计算其左操作数，然后再计算其右操作数。<strong>只有在仅靠左操作数的值无法确定该逻辑表达式的结果时，才会求解其右操作数</strong>。我们常常称这种求值策略为“短路求值”。</p>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>位运算符使用整型操作数，将其视为二进制位的集合。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220623102913108.png" alt="image-20220623102913108"></p>
<p><strong><code>(n&amp;(n-1))==0</code>用于判断n的二进制表示是否仅有一位为1。</strong></p>
<p>异或运算满足交换律。两相同的数异或结果为0，可用于寻找数成对出现时缺失的某一个数。</p>
<p>例1：</p>
<blockquote>
<p>给你一个由n-1个整数组成的未排序的序列，其元素都是1到n中的不同的整数。请写出一个寻找序列中缺失整数的线性时间算法。</p>
<p>解答:</p>
<p>1)求这n-1个数的和sum,然后计算n(n+1)2-sum可得。此种解法当n很大时，加法运算有可能溢出。</p>
<p>2)用异或运算可以解决。首先求得从1到n共n个数的异或结果A，即A&#x3D;1^2^3..^n，然后用题目中的序列依次与A求异或，最后得到的数，就是丢失的整数。</p>
</blockquote>
<p>例2：</p>
<blockquote>
<p>不使用第三方变量，交换两个变量的值：</p>
<p>a&#x3D;a^b;<br>b&#x3D;a^b;<br>a&#x3D;a^b;</p>
</blockquote>
<p>&#x3D;&#x3D;<strong>~运算符的优先级 &gt; 移位运算符的优先级 &gt; 与、或、异或运算符的优先级。</strong>&#x3D;&#x3D;</p>
<h3 id="赋值转换"><a href="#赋值转换" class="headerlink" title="赋值转换"></a>赋值转换</h3><p>赋值转换指的是将一种类型的值赋给另一种类型的变量，这时，值将会转换为接收变量的类型。</p>
<p>比如<code>int val = 3.14;</code>得到的val为3，<code>int *p; p = 0;</code>中int型的0转换为int *类型的空指针。</p>
<p>当把一个超出其取值范围的值赋给一个指定类型的对象时，比如将一个 int 类型的数赋值为short类型的数，当前大多数的系统都是将int低字节赋值给short,而将高位舍去（相当于取余）。当把一个取值范围小的值赋给一个取值范围大的值，则进行符号位扩展。</p>
<h3 id="表达式转换"><a href="#表达式转换" class="headerlink" title="表达式转换"></a>表达式转换</h3><ul>
<li><p>整型提升<br>在表达式计算中，C++将bool、char、unsigned char、signed char、short 和signed short型值都会自<br>动转换成int型，对bool类型而言，true 转换为1, false 则转换为0。</p>
<p>&#x3D;&#x3D;<strong>同一类型的无符号类型与有符号类型所占内存空间相同，只不过无符号类型将符号位作为数值位而已。所以在C++中， 有符号数与无符号数转换时，内存中的内容并没改变，只是对内存中相同的数据解释不同而已。</strong>&#x3D;&#x3D;</p>
<blockquote>
<p>int和unsigned int混合运算时，int会被转换为unsigned int，内存的内容不变，但是符号位被当作数值，所表示的数值发生改变，且恒大于等于0。</p>
<p>比如int类型的-1的字节是100……001，共32位，第一位为符号位。由于在计算机中用补码表示数值（负数的补码为其符号位之外的位数求反然后加1），所以-1在内存中为其补码111……111。当其转为unsigned int时，所有位均表示数值，那么此数就是2^32-1。</p>
<p>所以unsigned int类型的变量一直减1，结果也不会小于0。</p>
</blockquote>
</li>
<li><p>运算时的转换</p>
<p>当运算涉及两种类型时，较小的类型将会被转换成较大的类型，换言之，表达力低的类型将会被转换成表达力高的类型。各类型表达能力从低到高排列为：</p>
<p><strong>int (等价于signed int)、unsigned int、long (等价与signed long) 、unsigned long、float、double、long double</strong></p>
</li>
</ul>
<p>&#x3D;&#x3D;<em>其余例题见P74例5</em>&#x3D;&#x3D;</p>
<h3 id="显示转换（强制类型转换）"><a href="#显示转换（强制类型转换）" class="headerlink" title="显示转换（强制类型转换）"></a>显示转换（强制类型转换）</h3><p>略</p>
<h3 id="运算符优先级表"><a href="#运算符优先级表" class="headerlink" title="运算符优先级表"></a>运算符优先级表</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220623211239436.png" alt="image-20220623211239436"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220623211447726.png" alt="image-20220623211447726"></p>
<p><strong>运算符优先级有几个简单的规则:</strong></p>
<ul>
<li>括号，下标，&gt;和.(成员)最高；</li>
<li>单目的比双目的高；算术双目的比其他双目的高；</li>
<li>移位运算高于关系运算；**关系运算高于按位运算(与，或，异或)**；按位运算高于逻辑运算；</li>
<li>三目的只有一个条件运算，低于逻辑运算；</li>
<li>赋值运算仅比”,“高，且所有的赋值运算符优先级相同，结合访问位从右向左。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220623212501031.png" alt="image-20220623212501031"></p>
<h2 id="5-C预处理器、作用域、static、const以及内存管理"><a href="#5-C预处理器、作用域、static、const以及内存管理" class="headerlink" title="5.  C预处理器、作用域、static、const以及内存管理"></a>5.  C预处理器、作用域、static、const以及内存管理</h2><h3 id="5-1-C预处理器"><a href="#5-1-C预处理器" class="headerlink" title="5.1 C预处理器"></a>5.1 C预处理器</h3><h4 id="宏定义与宏替换"><a href="#宏定义与宏替换" class="headerlink" title="宏定义与宏替换"></a>宏定义与宏替换</h4><p>宏定义不分配内存，变量定义才会分配内存。宏定义末尾不加分号。</p>
<p><code>#define</code>指示接受一个名字并定义该名字为预处理器变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 符号常量的宏定义及宏替换</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> 标识符 字符串</span></span><br><span class="line"><span class="comment">// 带有参数的宏定义及宏替换，如#define FUN(x) ((x)*(x)) 为避免宏替换时发生错误，参数最好加上括号</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> 标识符(参数列表) 字符串</span></span><br></pre></td></tr></table></figure>

<p><strong>宏替换的本质很简单——文本替换</strong>。关于宏定义与宏替换请注意以下几点：</p>
<ul>
<li>宏名一般用大写（避免名字冲突），宏名和参数的括号间不能有空格，宏定义末尾不加分号；</li>
<li><strong>宏替换只作替换，不做语法检查，不做计算，不做表达式求解</strong>；</li>
<li><strong>宏替换在编译前进行，不分配内存</strong>，函数调用在编译后程序运行时进行，并且分配内存；</li>
<li>函数只有一个返回值，利用宏则可以设法得到多个值；</li>
<li>宏替换使源程序变长，函数调用不会；</li>
<li>宏替换不占运行时间，只占编译时间，函数调用占运行时间（分配内存、保留现场、值传递、返回值）。</li>
</ul>
<p>&#x3D;&#x3D;注意&#x3D;&#x3D;：应尽量少用宏替换。在C++中，宏替换实现的符号常量功能由const、enum代替，带参数的宏替换可由模版内联函数代替。</p>
<h4 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标准头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;standard_header&gt;</span></span></span><br><span class="line"><span class="comment">// 非系统头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myfile.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h4><p>提供条件编译措施使同一源程序可以<strong>根据不同编译条件(参数)产生不同的目标代码</strong>，其作用在于便于调试和移植。条件编译控制语句有不同形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span>/<span class="keyword">ifdef</span>/<span class="keyword">ifndef</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><code>#ifndef</code>检测指定的预处理器变量是否未定义。如果预处理器变量未定义，那么跟在其后的所有语句都被处理，直到出现<code>#endif</code>。如果预处理器变量已定义，那么跟在其后直到出现<code>#endif</code>的所有语句都被忽略。</p>
<h3 id="5-2-全局变量与局部变量"><a href="#5-2-全局变量与局部变量" class="headerlink" title="5.2 全局变量与局部变量"></a>5.2 全局变量与局部变量</h3><ul>
<li><p><strong>全局变量</strong></p>
<p>在函数外部定义的变量，属于源程序文件，作用域为整个源程序。</p>
<p>在函数中使用全局变量时，需要说明使用的是全局变量。</p>
<p>在不同文件中引用一个已经定义过的全局变量：可以用引用头文件的方式，也可以用<strong>extern关键字</strong>。下面的代码给出了使用extern引用已经定义过的全局变量的例子。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file_ 1.cpp</span></span><br><span class="line"><span class="type">int</span> counter; <span class="comment">//定义counter</span></span><br><span class="line"><span class="comment">// file_ 2.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> counter;  <span class="comment">//使用file 1中的counter</span></span><br><span class="line">++counter; <span class="comment">// 使file_ 1中的counter自增1</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>局部变量</strong></p>
<p>在程序中，只在特定过程或函数中可以访问的变量。局部变量可以与全局变量同名且屏蔽全局变量。</p>
<p><strong>在语句的控制结构中定义的变量尽在定义它们的块语句结束前有效。这种变量的作用域限制在语句体内。</strong>比如比如while(int i &#x3D;get_num())中的i。</p>
<p><strong>在同一个文件中，当局部变量屏蔽了全局变量，而又想要使用全局变量时，有两种方法。一种是使用做用域操作符”::”，一种是使用”extern”。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">::counter++;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> count; </span><br><span class="line">counter++;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-3-static"><a href="#5-3-static" class="headerlink" title="5.3 static"></a>5.3 static</h3><h4 id="static的作用"><a href="#static的作用" class="headerlink" title="static的作用"></a>static的作用</h4><ul>
<li><p>**<u>隐藏：使变量不能被其他文件访问</u>**（对于函数和全局变量）</p>
<p>当编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性，其他的源文件也能访问。如果加了static前缀就会对其他源文件隐藏。利用这一特性可以在不同的文件中定义同名函数和同名变量，不必担心命名冲突。</p>
</li>
<li><p><u><strong>默认初始化为0</strong></u>（未初始化的全局静态变量和局部静态变量）</p>
<p>初始化的全局变量和静态变量存放在DATA段，<strong>未初始化的全局变量和静态变量存放在BSS段（未初始化数据段）</strong>。在BSS段中，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。<br>比如初始化一个稀疏矩阵，我们可以一个个地把所有元素都置0，然后把不是0的几个元素赋值。如果定义成静态的，就省去了一开始置0的操作。再比如要把一一个字符 数组当字符串来用，但又觉得每次在字符数组末尾加’\0’太麻烦。如果把字符串定义成静态的，就省去了这个麻烦，因为那里本来就是’\0’。</p>
<p><u>函数体外的内置数组，不管有没有static前缀，均会将各元素初始化为0；在函数体内定义的内置函数，若没有static前缀，各元素未初始化，其值不确定。</u></p>
</li>
<li><p><u><strong>保持局部变量内容的持久</strong></u></p>
<p>函数内的自动(局部)变量，当调用时就存在，退出函数时就消失，但静态局部变量虽然在函数内定义，但静态局部变量始终存在着，也就是说它的<strong>生存期为整个源程序</strong>，其特点是<strong>只进行一次初始化且具有“记忆性”</strong>。<br>静态局部变量的生存期虽然为整个源程序，但是<strong>其作用域仍与局部变量相同</strong>，即只能在定义该变量的函数内使用该变量。退出该函数后，尽管该变量还继续存在，但不能使用它。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count=<span class="number">3</span>;    <span class="comment">// 外部变量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i, sum, count=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>, sum=<span class="number">0</span>; i&lt;count; i+=<span class="number">2</span>, count++) &#123; </span><br><span class="line">    	<span class="type">static</span> <span class="type">int</span> count=<span class="number">4</span>; <span class="comment">//局部静态变量，只初始化一次</span></span><br><span class="line">        count++;</span><br><span class="line">    	<span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">    		<span class="keyword">extern</span> <span class="type">int</span> count;   <span class="comment">// 此处为外部变量，即第一行的count</span></span><br><span class="line">    		count++ ;</span><br><span class="line">    		sum += count; <span class="comment">//语句1，sum第一次循环+4，第二次循环+5</span></span><br><span class="line">    	&#125;</span><br><span class="line">    	sum +=count; <span class="comment">//语句2，此处count为局部静态变量，sum第一次循环+5，第二次循环+6</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d %d\n&quot;</span>, count, sum);   <span class="comment">// 此处为第三行的count，输出结果为4 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="类中static的作用"><a href="#类中static的作用" class="headerlink" title="类中static的作用"></a>类中static的作用</h4><p>用于表示<strong>属于一个类而不属于此类的任何特定对象</strong>的变量和函数（与java中此关键字的含义相同）。</p>
<ul>
<li><p>静态数据成员</p>
<p>在类内数据成员的声明前加上关键字static，<strong>静态数据成员独立于该类的任意对象而存在，即当某个类的实例修改了该静态成员变量，其修改值为该类的其他所有实例所见。</strong>静态数据成员和普通数据成员一样遵从public, protected, private访问规则。</p>
<p>由于静态数据成员定义时需要分配空间，所以不能在类声明中定义。**&#x3D;&#x3D;static数据成员必须在类定义体的外部定义&#x3D;&#x3D;**。一般而言，类的static 成员，像普通数据成员一 样，不能在类的定义体中初始化，static数据成员通常在类定义体的外部定义时才初始化。即在类定义体中对静态变量赋初值是错误的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">Account</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">public</span>:</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">void</span> applyint() &#123; amount += amount*interestRate; &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">static</span> <span class="type">double</span> rate() &#123; <span class="keyword">return</span> interestRate; &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">static</span> <span class="type">void</span> rate (<span class="type">double</span>); <span class="comment">// sets a new rate</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">private</span>:</span></span></span><br><span class="line"><span class="params"><span class="function">    std: :string Owner;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">double</span> amount ;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">static</span> <span class="type">double</span> interestRate;   <span class="comment">// 仅声明，需要在类外定义</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">static</span> <span class="type">double</span> interestRate=<span class="number">0.3</span>;  <span class="comment">// 错误，不可以在类定义体中对静态变量赋初值</span></span></span></span><br><span class="line"><span class="params"><span class="function">    </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">static</span> <span class="type">double</span> initRate() ;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">double</span> Account::interestRate = initRate();   <span class="comment">// 在类外定义</span></span></span></span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;例外：const static数据成员可以在类的定义体中进行初始化&#x3D;&#x3D;。基本整型const static数据成员在类的定义体中初始化时，该数据成员<strong>仍必须在类的定义体之外进行定义</strong>，只不过定义时，不再需要初始化。（相当于在类外定义，在类定义体中进行const static声明和初始化）</p>
<blockquote>
<p>例：C++中关于对象成员内存分布的描述正确的是（）。</p>
<p>A. 不管该类被产生多少个对象，静态成员变量永远只有一个实例，且在没有对象实例的情况下已经存在。<br>B, 费静态成员数据在类中的排列顺序将和其被声明的顺序相同，任何中间介入的静态成员都不会被放进对象的内存布局中。<br>C. 在同一访问段（也就是private，public，protected等区间段内），数据成员的排列符合“较晚出现的成员在对象中有较高的内存地址”。<br>D. 带有虚函数的类对象占用的内存大小跟虚函数的个数成正比。</p>
<p>解析：ABC。</p>
</blockquote>
<p><strong>类中数据成员的布局情况</strong>:</p>
<ol>
<li>非静态成员在类对象中的排列顺序和声明顺序一致， 任何在其中间声明的静态成员都不会被放进对象布局中。</li>
<li>静态数据成员存放在程序的全局(静态)存储中，和个别类对象无关。<br>C++标准规定，在同一个访问块即private、public、 protected 等区段中，成员的排列只需符合<strong>较晚出现的成员在类对象中有较高的地址</strong>即可。</li>
</ol>
</li>
<li><p>静态成员函数</p>
<p>​		静态成员函数同样属于类定义的一部分，为类服务，而不是某个具体对象。普通成员函数总是具体的属于某个类的具体对象，所以普通的成员函数一般都隐含了一个this指针，this指针指向类的对象本身。但是静态成员由于不与任何的对象相关联，因此<strong>不具有this指针</strong>。<strong>因而它无法访问类对象的非静态数据成员，也无法访问非静成员函数，它只能调用其余的静态成员函数与访问静态数据成员。</strong><br>  static成员函数不是任何对象的组成部分，因此<strong>static成员函数不能声明const</strong>。毕竟，将成员函数声明为const后就承诺不会修改函数所属的对象，而static成员函数不属于任何对象。<br>  <strong>static成员函数也不能被声明为虚函数、volatile</strong>。</p>
<p>关于静态成员函数，可以总结为以下几点:</p>
<ul>
<li><strong>静态成员之间可以相互访问</strong>，包括静态成员函数访问静态数据成员和访问静态成员函数。**<u>静态成员函数不能访问非静态成员函数和非静态数据成员，非静态成员函数可以任意地访问静态成员函数和静态数据成员</u>**（静态成员变量可被该类的所有方法访问）;</li>
<li>由于没有this指针的额外开销，因此静态成员函数与类的非静态成员函数相比速度上会有少许的增长。</li>
</ul>
</li>
</ul>
<h3 id="5-4-const"><a href="#5-4-const" class="headerlink" title="5.4 const"></a>5.4 const</h3><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>const限定符将一个对象转换为一个常量。常量在定义后就不能被修改，所以<strong>在定义时必须进行初始化</strong>。</p>
<p>在全局作用域里定义非const 变量时，它在整个程序中都可以访问。</p>
<p>但是除非特别说明，<strong>在全局作用域声明的const 变量是定义该对象的文件的局部变量</strong>。此变量只存在于那个<br>文件中，不能被其他文件访问。通过指定const 变更为extern，就可以在整个程序中访问const 对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file 1.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> counter=<span class="number">10</span>; <span class="comment">// 定义counter，extern使const常量可以被其他文件访问</span></span><br><span class="line"><span class="comment">// file 2.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> counter; <span class="comment">//使用file 1中的counter</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> index=<span class="number">0</span>; index != counter; ++index)</span><br><span class="line">..</span><br></pre></td></tr></table></figure>

<p><strong>在C语言中多使用#define进行常量声明</strong>。</p>
<p>如果在C中使用const，下面的语句在C语言中编译错误，因为在C中const意思是“一个不能被改变的普通变量”，即它被放在内存中，C编译器不知道它在编译时的值。但在C++中，下面的语句是可行的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> bufSize = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> buf[bufSize ];</span><br></pre></td></tr></table></figure>

<p><strong>const相比#define的优势：</strong></p>
<ul>
<li>const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对<br>后者只进行字符替换，没有类型安全检查；</li>
<li>使用常量可能比使用#define导致产生更小的目标代码，这是因为预处理器”盲目地将宏名称<br>BUFSIZE替换为其代替的值100”可能导致目标代码出现多份100的备份，但常量就不会出现这种情况。</li>
<li>const还可以执行常量折叠（常量折叠是在编译时间简单化常量表达的一个过程，简单来说就是将常量表达式计算求值，并用求得的值来替换表达式，放入常量表），也就是说，编译器在编译时可以通过必要的计算把一一个复杂的常量表达式缩减成简单的。</li>
</ul>
<p>综上，在C++中，我们应该用const取代#define。</p>
<h4 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h4><p>在指针的声明中，需要区分指向const对象的指针和const指针。</p>
<ul>
<li>指向const对象的指针</li>
</ul>
<p><strong>如果指针指向const对象</strong>，则不允许用指针来改变其所指的const值。为了保证这个特性，<strong>C++强制要求指向const对象的指针也必须具有const特性。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> *cptr = &amp;value;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="type">double</span> <span class="type">const</span> *cptr = &amp;value;</span><br></pre></td></tr></table></figure>

<p><strong>cptr是一个指向const double类型的指针，cptr 的值可以改变，但是不能通过ptr改变value的值；</strong></p>
<ul>
<li>const指针</li>
</ul>
<p><strong>使指针本身成为一个const指针</strong>，所指向的值可以改变，但是地址不变。声明时必须把const标明的部分放在*的右边，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> value=<span class="number">0.1</span>;</span><br><span class="line"><span class="type">double</span>* <span class="type">const</span> cptr = &amp;value;  <span class="comment">// 由于指针是const，所以编译时必须有初始化</span></span><br></pre></td></tr></table></figure>

<p><strong>cptr 的值不可以改变，但是可以通过ptr改变value的值。</strong></p>
<h4 id="const修饰函数参数与返回值"><a href="#const修饰函数参数与返回值" class="headerlink" title="const修饰函数参数与返回值"></a>const修饰函数参数与返回值</h4><ul>
<li><p>const修饰返回值</p>
<p>const 修饰返回值常用在处理用户定义的类型时。当处理用户定义的类型时，返回值不为常量有时会对用户造成困扰。</p>
<p>函数除了返回值类型外，还可以<strong>返回指针</strong>。函数不能返回指向局部栈变量的指针，这是因为在函数返回后它们是无效的，而且栈也被清理了（栈会自动分配和释放）。<strong>可返回的指针是指向堆中分配的存储空间的指针或指向静态存储区的指针</strong>，在函数返回后它仍然有效。</p>
<p>比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">GetMemory</span> <span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> p[]=<span class="string">&quot;he1lo world&quot;</span>;   <span class="comment">// 数组，内存分配在栈上</span></span><br><span class="line">    <span class="keyword">return</span> P:   <span class="comment">// 返回指向栈内存的指针，但是由于是局部变量，返回时原来的内容已被清除，p指向的新内容不可知</span></span><br><span class="line">&#125;</span><br><span class="line">           </span><br><span class="line"><span class="type">void</span> <span class="built_in">Test</span> (<span class="type">void</span>) &#123;</span><br><span class="line">    <span class="type">char</span> *str-<span class="literal">NULL</span>;</span><br><span class="line">    str=<span class="built_in">GetMemory</span>();</span><br><span class="line">    <span class="built_in">printf</span>(str);   <span class="comment">// 输出可能是乱码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Test</span>();</span><br></pre></td></tr></table></figure>

<p>可以改为如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1) </span><br><span class="line">char *GetMemory (void) &#123;</span><br><span class="line">    static char p[]=&quot;hello world&quot; ;  // 数组位于静态存储区,生存周期为整个源程序，可通过函数返回</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2) </span><br><span class="line">char *GetMemory (void) &#123;</span><br><span class="line">    char *p=&quot;hel1o world&quot;;  /* &quot;hel1o world&quot;位于文字常量区，所以p是指向全局(静态)存储区的指针，可通过函数返回*/</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3) </span><br><span class="line">char *GetMemory (void) &#123;</span><br><span class="line">    char *p = (char*)malloc(12);   /* p是指向堆中分配存储空间的指针，可通过函数返回，但需要以后调用delete []释放内存，否则会造成内存泄露*/</span><br><span class="line">    if(p == NULL)</span><br><span class="line">    	return NULL;</span><br><span class="line">    else</span><br><span class="line">    	P=&quot; hello world&quot;;</span><br><span class="line">    return P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>const修饰函数参数</p>
<p>使参数值在函数体内不会发生改变。主要是用来修饰地址，使地址不发生改变。</p>
<p><strong>若使用值或者函数返回值作为函数参数，那么传递给函数的均为临时变量，会被函数作为常量，编译器会为其分派临时存储单元，并产生一个地址和其引用捆绑在一起，存储的内容是常量，所以实参必须是const。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220627110937750.png" alt="image-20220627110937750"></p>
</li>
</ul>
<h4 id="cosnt在类中的应用"><a href="#cosnt在类中的应用" class="headerlink" title="cosnt在类中的应用"></a>cosnt在类中的应用</h4><p>const只能作用于成员函数，不能作用于全局函数。</p>
<ul>
<li><p>const成员函数</p>
<p>确保该成员函数可作用于const对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span>&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>func1默认会有对象的this指针作为形参。func2声明时末尾的const使得this所指向的对象也为const，这使得该函数可作用于const对象。因为<strong>const对象只能调用其const成员函数，无法调用其非const成员函数</strong>。</p>
<p>非const对象可以调用所有成员函数。</p>
</li>
<li><p>const数据成员</p>
<p>常量数据成员（常量成员变量）&#x3D;&#x3D;必须在构造函数的成员初始化列表中进行初始化&#x3D;&#x3D;，并且必须有构造函数。<strong>因为const 数据成员只在某个对象生存期内是常量，而对于整个类而言却是可变的</strong>。而类可以创建多个对象，不同的对象其const数据成员的值可以不同。所以不能在类的声明中初始化const数据成员，因为类的对象没被创建时，编译器不知道const数据成员的值是什么。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Thing</span>&#123;</span><br><span class="line">	<span class="built_in">Thing</span>():<span class="built_in">valueB</span>(<span class="number">1</span>)&#123;*&#125;)  <span class="comment">// 使用构造函数初始化列表对const数据成员valueB进行初始化</span></span><br><span class="line">	<span class="type">int</span> valueA;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> valueB;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;例外：当const整型数据成员同时被声明为static时，可以使用外部初始化。&#x3D;&#x3D;因为static使得该数据成员为类所有，而不是对象，只能在类外进行定义。</p>
<p>如果想要建立在整个类中都恒定的常量，除了使用上面的const static外，还可以使用枚举常量实现，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Test</span>():<span class="built_in">a</span>(<span class="number">0</span>) &#123;&#125;    <span class="comment">// 在构造函数初始化列表中对const数据成员a进行初始化</span></span><br><span class="line">	<span class="keyword">enum</span> &#123;size1<span class="number">-100</span>, size2=<span class="number">200</span>&#125;;</span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> a;   <span class="comment">//只能在构造函数初始化列表中初始化</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> b;  <span class="comment">//在类的实现文件中（即类定义体的外部）定义并初始化</span></span><br><span class="line">    <span class="type">const</span> <span class="type">static</span> <span class="type">int</span> c;  <span class="comment">/*与static const int c; 相同，c为整型，故也可在此处初始化，但仍需在类定义体外进行定义，注意c为非整型时，不能在此处初始化，整型包括char、short、int、long*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Test::b=<span class="number">0</span>;         <span class="comment">/* static成员变量不能在构造函数初始化列表中初始化，因为它不属于某个对象*/</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Test::c=<span class="number">0</span>;   <span class="comment">/*注意:给const static成员变量赋值时，不需要加static修饰符，但要加const*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-5-内存管理与释放"><a href="#5-5-内存管理与释放" class="headerlink" title="5.5 内存管理与释放"></a>5.5 内存管理与释放</h3><p>一个C&#x2F;C+ +的程序，用户使用的内存主要分为以下几个部分：</p>
<ol>
<li><p>堆</p>
<p><strong>手动分配和释放</strong>，与数据结构中的堆不是同一个概念，分配方式类似链表。一般速度较慢，容易产生内存碎片，不过用起来方便。C中由malloc、free操作，C++中由new、delete操作。若不手动释放，则在程序结束后由系统释放。malloc与free是C&#x2F;C++语言的<strong>标准库函数</strong>，new&#x2F;delete 是C++的<strong>运算符</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* p1 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);  <span class="comment">// 申请10个字节空间，由free释放</span></span><br><span class="line"><span class="type">char</span>* p2 = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">10</span>];        <span class="comment">// 由delete[]释放</span></span><br></pre></td></tr></table></figure>

<p>但是注意指针p1、p2 本身是在栈中的，它们指向在堆上分配的内存。**回收用new[]分配的一组对象的内存空间时用delete[]**。</p>
</li>
<li><p>栈区(stack)</p>
<p>由编译器<strong>自动分配和释放</strong>，存放函数的参数值、局部变量的值等。操作方式类似数据结构中的栈，速度较快。</p>
</li>
<li><p>全局（静态）存储区</p>
<p><strong>存放全局变量和静态变量</strong>。初始化的全局变量和静态变量存放在<strong>DATA段</strong>，未初始化的存放在<strong>BSS段</strong>。程序结束后由系统释放，</p>
<p>BSS段的特点是在程序执行之前BSS段会自动清0。所以<strong>未初始化的全局变量和静态变量在程序执行前已经为0</strong>。</p>
</li>
<li><p>文字常量区：存储常量字符串。程序结束后由系统释放。</p>
</li>
<li><p>程序代码区：存放函数体的二进制代码。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-20220609144830856.png" alt="image-20220609144830856"></p>
</li>
</ol>
<h4 id="C语言内存操作函数"><a href="#C语言内存操作函数" class="headerlink" title="C语言内存操作函数"></a>C语言内存操作函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetMemory</span><span class="params">(<span class="type">char</span> *p)</span></span>&#123;</span><br><span class="line">	p=(<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">11</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">char</span> *str=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	<span class="built_in">GetMemory</span>(str);</span><br><span class="line">	<span class="built_in">strcpy</span>(str, <span class="string">&quot;hello word&quot;</span>);  <span class="comment">// 运行错误</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序会运行错误。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220627144556450.png" alt="image-20220627144556450"></p>
<p>开始时，str是指向文字常量区的指针，GetMemory函数并不会为str新分配空间。如上图所示，函数调用传参时，str和形参的p虽然指向相同，但它们自身的地址不同，是两个不同的变量。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220627144623164.png" alt="image-20220627144623164"></p>
<p>如上图所示，p在执行malloc之后就指向不同的位置了，随后因为p是局部变量而被释放，malloc的空间没有free，成为无法引用的空间了。</p>
<p>str一直指向的是”hello”的文字常量区，而文字常量是不允许修改的，故调用strcpy时会出错。</p>
<h4 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++内存管理"></a>C++内存管理</h4><p>动态创建对象如果不是显示初始化（如string()），那么对于类类型的对象，用该类默认构造函数初始化；而内置类型的对象则无法初始化，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string *ps=<span class="keyword">new</span> string;	    <span class="comment">//调用默认构造函数初始化</span></span><br><span class="line">string *ps=<span class="keyword">new</span> <span class="built_in">string</span>();	<span class="comment">//调用默认构造函数初始化</span></span><br><span class="line"><span class="type">int</span> *pi=<span class="keyword">new</span> <span class="type">int</span>;	<span class="comment">// pi指向的内容未初始化</span></span><br><span class="line"><span class="type">int</span> *pi=<span class="keyword">new</span> <span class="built_in">int</span>();  <span class="comment">// 显式初始化，pi指向一个初始化为0的int值</span></span><br></pre></td></tr></table></figure>

<p>可见对于提供了默认构造函数的类类型(如string)，没有必要对其对象进行显式初始化。因为无论程序是明确地不初始化还是要求进行初始化，都会自动调用其默认构造函数初始化该对象。</p>
<p>而对于内置类型或没有定义默认构造函数的类型，采用不同初始化方式则有显著的差别。内置类型对象或未提供默认构造函数的类类型对象必须显式初始化。</p>
<p><strong>new的执行过程是</strong>：首先，调用名为operator new的标准库函数，<u>分配足够大的原始未类型化的内存</u>，以保存指定类型的一个对象；接下来，<u>运行该类型的一个构造函数</u>，用指定初始化式构造对象；最后，<u>返回指向新分配并构造的对象的指针</u>。</p>
<p><strong>delete的执行过程是</strong>：首先，对sp指向的对象<u>运行适当的析构函数</u>；然后，通过调用名为operator delete的标准库函数<u>释放该对象所用内存</u>。</p>
<p><strong>malloc&#x2F;free与new&#x2F;delete的区别</strong>：</p>
<ul>
<li>malloc&#x2F;free是C&#x2F;C++语言的标准库函数，new&#x2F;delete是C++运算符</li>
<li>new自动计算需要分配的空间，而malloc需要手工计算字节数</li>
<li>new是类型安全的，而malloc则不是</li>
<li><strong><u>new调用operator new分配足够的空间，并调用相关对象的构造函数，而malloc只负责分配空间，不能调用构造函数；delete将调用实例的析构函数，然后调用operator delete，以释放该实例占用的控件，而free只负责释放空间，不能调用析构函数</u></strong></li>
<li>malloc&#x2F;free需要库文件支持，new&#x2F;delete不需要</li>
</ul>
<h2 id="6-函数"><a href="#6-函数" class="headerlink" title="6. 函数"></a>6. 函数</h2><p>一般的来说，函数是可以返回局部变量的。 局部变量的作用域只在函数内部，在函数返回后，局部变量的内存已经释放了。因此，<strong>如果函数返回的是局部变量的值，不涉及地址，程序不会出错。但是如果返回的是局部变量的地址(指针)的话，程序运行后会出错。</strong>因为函数只是把指针复制后返回了，但是指针指向的内容已经被释放了，这样指针指向的内容就是不可预料的内容，调用就会出错。<strong>准确的来说，函数不能通过返回指向栈内存的指针(注意这里指的是栈，返回指向堆内存的指针是可以的。</strong></p>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>形参和实参用作数据传送。形参出现在函数定义中，仅在函数体中可以使用。实参出现在主调函数中，进入被调函数后，实参变量也不能使用。<strong>主调函数只是把实参的值传送给被调函数的形参，只有引用才会改变实参</strong>。</p>
<p>C语言的函数参数传递可以分为传递值和传递地址（指针）。C++中可以分为传递值、传递指针、传递引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">viod <span class="title">f1</span><span class="params">(<span class="type">int</span>* m, <span class="type">long</span>&amp; n)</span> </span>;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">long</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">f1</span>(&amp;a, b);   <span class="comment">// m为指针传递，n为引用传递</span></span><br></pre></td></tr></table></figure>

<p>给函数传递实参遵循变量初始化的规则。非引用类型的形参以相应实参的副本(值)初始化，若是对象还会调用拷贝构造函数。<strong>对(非引用)形参的任何修改仅作用于局部副本，并不影响实参本身</strong>。为了避免传递副本的开销，可将形参指定为引用类型，这时内存中不会产生实参的副本。<strong>对引用形参的任何修改会直接影响实参本身</strong>。应将不需要修改相应实参的引用形参定义为const引用。</p>
<p>要使引用pr代表变量<code>char *p</code>， 则pr的初始化语句为<code>char* &amp;pr=p;</code>。</p>
<p>使用指针和解引用来交换变量的值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> *p1,<span class="type">int</span> *p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 交换指针所指向地址的内容</span></span><br><span class="line">	<span class="type">int</span> t=*p1;</span><br><span class="line">	*p1=*p2;</span><br><span class="line">	*p2=t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b=<span class="number">20</span>;</span><br><span class="line"><span class="built_in">swap</span>(&amp;a,&amp;b);</span><br></pre></td></tr></table></figure>

<h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>通常编译时，调用内联函数的地方，将不进行函数调用，而是<strong>使用函数体替换调用处的函数名</strong>，形式类似宏替换，这种替换称为内联扩展。</p>
<p>内联扩展可以消除函数调用时的时间开销。将函数指定为inline函数，通常就是将它在程序中每个调用点上“内联地”展开。</p>
<p>一般来说，内联机制适用于优化小的、只有几行的而且经常被调用的函数。大多数的编译器都不支持递归函数的内联。</p>
<ul>
<li><p>成员函数成为内联函数<br>在类中定义的成员函数全部默认为内联函数，可以显式加上inline标识符，或者不加。在类中声明的成员函数，如果加了inline, 则其为内联函数；如果没加inline，而在类外定义该成员函数时加了inline，该成员函数也为内联函数。</p>
</li>
<li><p>普通函数成为内联函数<br>在普通函数声明或定义前加inline使其成为内联函数。</p>
</li>
</ul>
<p><strong>注意：宏定义与内联函数的区别</strong></p>
<p>首先，宏定义是在预处理阶段进行代码替换，而内联函数是在编译阶段插入代码；</p>
<p>其次， 宏定义没有类型检查，而内联函数有类型检查。</p>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><ul>
<li>默认参数只可以在函数声明中设定一次，只有在无函数声明时，才可以在函数定义中设定。</li>
<li>默认参数定义的顺序为自右到左。即如果一个参数设定了默认值，其右边的参数都要有默认值。</li>
<li>默认值可以是全局变量、全局常量，甚至一个函数，但不可以是局部变量。因为默认参数是在编译时确定的，而局部变量位置与默认值在编译时无法确定。</li>
</ul>
<p>接受可变参数的函数实现多个数的相加：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num, ...)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>* p=(<span class="type">int</span>*)&amp;num+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;index&lt;num;++index)&#123;</span><br><span class="line">        sum += *p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>, j=<span class="number">2</span>, k=<span class="number">3</span>;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">add</span>(<span class="number">3</span>,i,j,k);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>进行函数重载时，要求同名函数在参数个数上不同，或者参数类型上不同。</p>
<p>操作符重载，本质上也是函数重载，它大大丰富了已有操作符的含义，方便使用，如+可用于连接字符串等。</p>
<h3 id="函数模板与泛型"><a href="#函数模板与泛型" class="headerlink" title="函数模板与泛型"></a>函数模板与泛型</h3><p>在泛型编程中，我们所编写的类和函数能够多态地用于跨越编译时不相关的类型。一个类或一个函数可以用来操纵多种类型的对象。标准库中的容器、迭代器和算法是很好的泛型编程的例子。标准库用独立于类型的方式定义每个容器、迭代器和算法，因此几乎可以在任意类型上使用标准库的类和函数。</p>
<h4 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h4><p>在C++中，模板是泛型编程的基础。模板是创建类或函数的蓝图或公式。</p>
<p>模板定义以关键字template开始，后接模板形参表，模板形参表是用尖括号括住的一个或多个模板形参的列表，形参之间以<strong>逗号</strong>分隔。模板形参表不能为空。同样，模板形参表示可以在类或函数的定义中使用的类型或值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  <span class="comment">// 关键字使用class或者typename</span></span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T x, T y)</span></span>&#123;       <span class="comment">// T表示哪个实际类型由编译器根据所用的函数参数而确定</span></span><br><span class="line">	<span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220627211022576.png" alt="image-20220627211022576"></p>
<h4 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        <span class="built_in">Queue</span>();        <span class="comment">// default constructor</span></span><br><span class="line">        <span class="function">Type &amp;<span class="title">front</span> <span class="params">()</span></span>; <span class="comment">// return element from head of Queue</span></span><br><span class="line">        <span class="function"><span class="type">const</span> Type &amp;<span class="title">front</span> <span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">push</span> <span class="params">(<span class="type">const</span> Type &amp;)</span></span>; <span class="comment">// add element to back of Queue</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">// remove element from head of Queue</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>; / <span class="literal">true</span> <span class="keyword">if</span> no elements in the Queue</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="comment">// ……</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用类模板时，必须为模板形参显式指定实参<code>Queue&lt;int&gt; qi;</code>编译器使用实参来实例化这个类的特定类型版本，即编译器用用户提供的实际特定类型（比如int）代替Type，重新编写Queue。</p>
<h3 id="函数的递归"><a href="#函数的递归" class="headerlink" title="函数的递归"></a>函数的递归</h3><p>必须注意递归模型不能是循环定义的，其必须满足下面的两个条件：</p>
<ul>
<li>递归表达式(递归体)</li>
<li>边界条件(递归出口)</li>
</ul>
<p>递归的精髓在于能否将原始问题转换为属性相同但规模较小的问题。</p>
<p>在递归调用的过程中，系统为每一层的返回点、 局部变量、传入实参等开辟了递归工作栈来进行数据存储，递归次数过多容易造成栈溢出等。而其效率不高的原因是递归调用过程中包含很多重复的计算。</p>
<h2 id="7-指针与引用"><a href="#7-指针与引用" class="headerlink" title="7. 指针与引用"></a>7. 指针与引用</h2><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><h4 id="指针的声明"><a href="#指针的声明" class="headerlink" title="指针的声明"></a>指针的声明</h4><p>一个有效的指针必然是以下三种状态之一：</p>
<p>保存一个特定对象的地址；指向某个对象后面的另一对象；或者是0值。若指针保存0值，表明它不指向任何对象。未初始化的指针是无效的，直到给该指针赋值后，才可使用它。</p>
<p>特别的，对于指针变量：</p>
<p><code>*p++</code>  实现了先输出p所指地址处的数据值，然后指针后移到下一指针处；</p>
<p><code>*++p</code>  实现了先将指针指向后移，再输出此时指针所指处的数据的值；</p>
<p><code>(*p)++</code> 实现的是将指针p所指向地址处的数据值（比如300）输出后再自增1（得到301）；</p>
<h4 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h4><p>C语言允许用typedef说明一种新类型名，来代替已有类型名，形式为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> 类型名 标识符;</span><br></pre></td></tr></table></figure>

<p>typedef并未产生新的数据类型，它的作用仅仅是<strong>给已存在的类型名起一个“别名”</strong>，且原有类型名依然有效。</p>
<p>例1: <code>typedef char* String_t;</code>和<code>#define string_d char \*</code>这两句在使用上有什么区别?(2012●腾讯)</p>
<p>解答：前者声明一个类型的别名，在编译时处理，有类型检查；后者是-一个简单的替换，在预编译时处理，无类型检查。从使用上来说，<code>String_t a, b;</code>“中a和b都是char*类型的，但<code>String _d a, b;</code>中只有a是char*类型的，b是char型的。</p>
<h4 id="void-指针"><a href="#void-指针" class="headerlink" title="void* 指针"></a>void* 指针</h4><p>void* 指针是一种特殊类型的指针，其可以保存任何类型对象的地址。</p>
<p>void*表明该指针与一地址有关，但是不清楚此地址上的对象的类型，故仅支持几种有限的操作：</p>
<ul>
<li>与另一个指针进行比较</li>
<li>向函数传递void*指针或从函数返回void* 指针</li>
<li>给另一个void*指针赋值。</li>
</ul>
<p>不允许使用void*指针操纵它所指向的对象。</p>
<h4 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h4><p>指针本身也是占用内存空间的存放其值的，所以也可用指针指向。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival=<span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> *pi=&amp;ival;</span><br><span class="line"><span class="type">int</span> **ppi=&amp;pi;  <span class="comment">// 指向指针的指针</span></span><br></pre></td></tr></table></figure>

<p>32位系统下，有如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span>* (*a)[<span class="number">3</span>][<span class="number">6</span>];    <span class="comment">// (*a)[3][6]表示数组指针，a指向一个二维数组，而数组的元素是double*类型</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">sizeof</span>(a)&lt;&lt;endl; <span class="comment">// 4，指针占用4个字节</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">sizeof</span>(*a)&lt;&lt;endl;  <span class="comment">// 72，二维数组有18个元素，每个元素（元素类型为指针）占4个字节</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">sizeof</span>(**a)&lt;&lt;endl; <span class="comment">// 24，*a为二维数组，*a[0]就是**a，即第一个元素，内容为一维数组，6*4得24</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">sizeof</span>(***a)&lt;&lt;endl;  <span class="comment">// 4，**a为一个一维数组，**a[0]就是***a，类型为double*</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">sizeof</span>(****a)&lt;&lt;end1; <span class="comment">// 8，***a为double*类型，所以****a为取double*指针指向地址的内容，存储大小为double的大小，即8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><p>函数指针指向某个特定的函数类型，函数类型由其返回类型以及形参决定。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数指针变量的声明，类型为bool (*)(const string &amp;, const string &amp;)</span></span><br><span class="line"><span class="built_in">bool</span> (*pf)(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;);</span><br></pre></td></tr></table></figure>

<p>这个语句将pf声明为指向函数的指针，它所指向的函数带有两个const string&amp; 类型的形参和bool类型的返回值。</p>
<p>&#x3D;&#x3D;注意：*pf两侧的圆括号是必须的。且形参只需写类型名&#x3D;&#x3D;</p>
<p>由于函数指针类型冗长，所以可以使用typedef简化函数指针的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*cmpFcn)</span><span class="params">(<span class="type">const</span> string &amp;，<span class="type">const</span> string &amp;)</span></span>;</span><br><span class="line">cmpFcn pf1=<span class="number">0</span>;  <span class="comment">// 定义一个空的函数指针，使用前一行typedef定义的cmpFcn函数指针类型</span></span><br></pre></td></tr></table></figure>

<p>在要使用这种函数指针类型时，只需直接使用cmpFcn即可，不必每次都把整个类型声明全部写出来。</p>
<p>在引用函数名但又没有调用该函数时，函数名将被自动解释为指向函数的指针，等效于在函数名上应用取地址符。可使用函数名对函数指针做初始化或赋值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lengthCompare</span><span class="params">(<span class="type">const</span> string &amp;，<span class="type">const</span> string &amp;)</span></span>;   <span class="comment">// 有一同返回类型以及形参的函数声明</span></span><br><span class="line">cmpFcn pf2=lengthCompare;   <span class="comment">// 使用该函数名初始化函数指针</span></span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;注意：函数指针只能通过同类型的函数或函数指针或0值常量表达式进行初始化或赋值。&#x3D;&#x3D;指向不同函数类型的指针之间不存在转换。将函数指针初始化为0，表示该指针不指向任何函数。</p>
<ul>
<li><p><strong>函数指针的使用</strong></p>
<p>指向函数的指针可用于调用它所指向的函数。可以不需要使用解引用操作符，直接通过指针调用函数，若有：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*cmpFcn)</span><span class="params">(<span class="type">const</span> string &amp;，<span class="type">const</span> string &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lengthCompare</span><span class="params">(<span class="type">const</span> string &amp;，<span class="type">const</span> string &amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<p>则：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cmpFcn pf=lengthCompare;</span><br><span class="line"><span class="built_in">lengthCompare</span>(<span class="string">&quot;hi&quot;</span>,<span class="string">&quot;bye&quot;</span>);  <span class="comment">// 使用函数名</span></span><br><span class="line"><span class="built_in">pf</span>(<span class="string">&quot;hi&quot;</span>,<span class="string">&quot;bye&quot;</span>);             <span class="comment">// 使用函数指针，未使用*</span></span><br><span class="line">(*pf)(<span class="string">&quot;hi&quot;</span>,<span class="string">&quot;bye&quot;</span>);          <span class="comment">// 使用函数指针，使用*</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>函数指针形参</strong><br>函数的形参可以是指向函数的指针。这种形参可以用以下两种形式编写:<br><code>void useBigger (const string &amp;，const string &amp;, bool (const string &amp;，const string &amp;));</code><br>上述定义等价于:<br><code>void useBigger (const string &amp; const string &amp;, bool (*) (const string &amp;, const string&amp;));</code></p>
</li>
<li><p><strong>返回指向函数的指针</strong></p>
<p>函数可以返回指向函数的指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*<span class="built_in">ff</span>(<span class="type">int</span>))(<span class="type">int</span>*, <span class="type">int</span>);   <span class="comment">// 声明返回类型为函数指针的函数</span></span><br></pre></td></tr></table></figure>

<p>这个语句中，函数为<code>ff(int)</code>，其返回值类型为<code>int (*)(int*, int)</code>的函数指针。这样子比较难理解，使用typedef更简明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*PF)</span><span class="params">(<span class="type">int</span>*, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function">PF <span class="title">ff</span><span class="params">(<span class="type">int</span>)</span></span>;   <span class="comment">// 返回类型为函数指针</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>例1：</p>
<p>用变量a给出下面的定义，一个有10个指针的数组，每个指针指向-一个函数，该函数有一个整型参数并返回一个整型( )。</p>
<p>解答：</p>
<p> <code>int (*a[10]) (int)</code>。</p>
</blockquote>
<blockquote>
<p>例2：</p>
<p>定义一个函数指针，指向的函数有两个int形参并且返回-一个函数指针，返回的指针指向一个有一个int形参且返回int的函数。</p>
<p>解答：</p>
<p><code>int (*(*p)[10])(int *)</code>。变量为*p，类型为<code>int (*[10])(int *)</code>。</p>
</blockquote>
</li>
</ul>
<h4 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h4><p>野指针是<strong>指向不可用内存</strong>的指针，任何指针变量在创建时，不会自动成为NULL指针（空指针），其默认值是随机的，此时的指针就是野指针。</p>
<p>当指针调用free或者delete<strong>释放后，未能将其设置为NULL</strong>，也会导致该指针便成为野指针，此时虽然free或delete把指针所指的内存释放掉了，但它们并没有把指针本身释放掉。</p>
<p>第三个造成野指针的原因是<strong>指针操作超越了变量的作用范围</strong>。</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>C++中规定一旦定义了引用，就必须把它跟一个变量绑定起来，并且不能修改这个绑定。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">3</span>,j =<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> &amp;ref=i;     <span class="comment">// 定义i的引用ref</span></span><br><span class="line">cout&lt;&lt;ref;      <span class="comment">//输出3</span></span><br><span class="line">ref=j;          <span class="comment">//注意这里是将i修改为1,而不是修改ref使其绑定到j上</span></span><br><span class="line">cout&lt;&lt;ref;      <span class="comment">//输出1</span></span><br><span class="line">cout&lt;&lt;i;        <span class="comment">//输出1</span></span><br></pre></td></tr></table></figure>

<p>虽然使用引用和指针都可以间接访问另一个值，但它们之间有几个重要区别：</p>
<ul>
<li>引用不能为空，当引用被创建时，必须被初始化。而指针可以为空值，可以在任何时候被初始化；</li>
<li>一旦一个引用被初始化为指向一个对象，他就不能被改变为对另外一个对象的引用。指针则可以在任何时候指向另一个对象。</li>
<li>不可能有NULL引用。必须保证引用是一块合法的存储单元关联；</li>
<li>“sizeof(引用)”所得到的的是指向的变量（对象）的大小，而“sizeof(指针)”得到的是指针本身的大小，通常为4；</li>
<li>给引用赋值修改的是该引用所关联的对象的值，而并不是使用引用于另一个对象关联；</li>
<li>引用使用时不需要解引用，而指针需要解引用，引用和指针的自增（++）操作运算符意义不一样；</li>
<li>如果返回动态分派的对象或内存，必须使用指针，引用可能引起内存泄漏；</li>
<li>当使用&amp;运算符去一个引用的地址时，其值为所引用变量的地址；而对指针使用&amp;运算符，取的是指针变量的地址。</li>
</ul>
<h4 id="const引用（常引用）"><a href="#const引用（常引用）" class="headerlink" title="const引用（常引用）"></a>const引用（常引用）</h4><p>const引用是指const对象的引用，<strong>当引用的对象是const对象时，引用也必须是const</strong>，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ival=<span class="number">1024</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ref1=ival;	<span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> &amp;ref2=ival;		<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<p>如果既要利用引用提高程序的效率，又要保护传递给函数的数据不再函数中被改变，就应该使用常引用。常引用主要用于定义一个普通变量的<strong>只读属性的别名</strong>，作为函数的传入形参，避免实参在调用函数中被意外改变。</p>
<h4 id="引用做类的数据成员"><a href="#引用做类的数据成员" class="headerlink" title="引用做类的数据成员"></a>引用做类的数据成员</h4><p>引用是可以作为类的数据成员的。引用类型数据成员的初始化有以下特点：</p>
<ul>
<li>不能直接在构造函数里初始化，<strong>必须用到初始化列表</strong>；</li>
<li>凡是有引用类型的数据成员的类，<strong>必须定义构造函数</strong>。</li>
</ul>
<p>如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConstRef</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//ci与ri必须在成员初始化列表中初始化，因此必须自定义构造函数，书写成员初始化列表</span></span><br><span class="line">    <span class="built_in">ConstRef</span>(<span class="type">int</span> ii):<span class="built_in">i</span>(ii), <span class="built_in">ci</span>(i), <span class="built_in">ri</span>(ii)&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> ci;</span><br><span class="line">	<span class="type">int</span> &amp;ri;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="8-类"><a href="#8-类" class="headerlink" title="8. 类"></a>8. 类</h2><p>在C++中，模板是泛型编程的基础。模板是创建类或函数的蓝图或公式。</p>
<h3 id="8-1-访问标号"><a href="#8-1-访问标号" class="headerlink" title="8.1 访问标号"></a>8.1 访问标号</h3><p>访问标号public、 private、 protected 可以多次出现在类定义中。给定的访问标号应用到下一个访问标号出现时为止。</p>
<p>对于在第一个访问标号之前定义的成员，其访问级别依赖于类是如何定义的。<u><strong>如果类是用struct 关键字定义的，则在第一个访问标号<br>之前的成员是公有的；如果类是用class关键字定义的，则这些成员是私有的</strong></u>。类对其成员的访问形式主要有以下两种:</p>
<ul>
<li>内部访问：由类中的成员函数对类的成员的访问。</li>
<li>对象访问：在类外部，通过类的对象对类的成员的访问。</li>
</ul>
<p>类的成员可以有public、protected、 private 三种访问属性，<u><strong>类的成员函数( 内部访问）以及友元函数可以访问类中所有成员</strong>，但是<strong>在类外通过类的对象（对象访问）就只能访问该类的公有成员</strong>。</u>上述权限说明并未考虑有继承的情况，有继承的情况将在下章详细说明。</p>
<h3 id="8-2-类成员简介"><a href="#8-2-类成员简介" class="headerlink" title="8.2 类成员简介"></a>8.2 类成员简介</h3><p>空类<strong>默认产生</strong><u>默认构造函数、复制构造函数、析构函数、赋值运算符重载函数、取址运算符重载函数、const 取址运算符重载函数</u>等。</p>
<h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h4><p>在类内部，声明成员函数是必需的，而定义成员函数则是可选的。<strong>在类内部定义的函数默认为inline（内联函数）</strong>。</p>
<p>调用成员函数时，实际上是<strong>使用对象来调用</strong>的。每个成员函数（<strong>除了static 成员函数</strong>外）都有一个<strong>额外的、隐含的形参this</strong>。在调用成员函数时，形参this初始化为调用函数的对象的地址。</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>特殊的成员函数，与类同名，没有返回类型。主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。一个类可以有多个构造函数（<strong>构造函数可以重载</strong>），每个构造函数必须有与其他构造函数不同的数目或类型的形参。</p>
<p>若没有定义显式的构造函数，编译器将自动为这个类生成默认构造函数（不带参数，或者所有的形参都有默认实参）。</p>
<p>若使用编译器自动生成的默认构造函数（或自己定义一个未进行任何操作的默认构造函数），则类中每个成员，使用与初始化变量相同的规则来进行初始化。</p>
<ul>
<li>类成员：运行该类型的默认构造函数来初始化。</li>
<li>内置或复合类型的成员的初始值依赖于对象的作用域：<strong>在局部作用域中这些成员不被初始化</strong>，而<strong>在全局作用域中它们被初始化为0</strong>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Student</span>()&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> number;</span><br><span class="line">	<span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line">Student a;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Student b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，a与b的name都调用string类的默认构造函数初始化（运行该类型的默认构造函数来初始化）。a中number和score初始化为0，而b是局部对象，故b中number和score不被初始化，为垃圾值。</p>
<h5 id="成员初始化列表"><a href="#成员初始化列表" class="headerlink" title="成员初始化列表"></a>成员初始化列表</h5><p>构造函数的成员初始化列表为类的一个或多个数据成员指定初值。</p>
<p><strong>在C++中，成员变量的初始化顺序与变量在类型中的声明顺序相同，而于它们在构造函数的初始化列表中的顺序无关。</strong>构造函数的初始化列表仅仅指定用于初始化成员的值,并不指定这些初始化执行的次序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>():<span class="built_in">j</span>(<span class="number">0</span>), <span class="built_in">i</span>(j+<span class="number">2</span>)&#123;&#125;    <span class="comment">// 按照声明顺序初始化，先初始化i（此时j还未初始化，所以i是个垃圾值），后初始化j为0。</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;j&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	a.<span class="built_in">print</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>省略初始化列表在构造函数的函数体内对数据成员赋值是合法的。从概念上讲，可以认为构造函数分两个阶段执行:</p>
<ul>
<li>初始化阶段（成员初始化列表）</li>
<li>普通的计算阶段。计算阶段由构造函数函数体中的所有语句组成。</li>
</ul>
<p>类类型的数据成员总是在初始化阶段初始化（使用其构造函数），内置和复合类型的尘谷氨只对定义在全局作用域中的对象才初始化（初始化为0），定义在局部作用域中的对象包含包含的内置（int等类型）和复合类型（数组、指针等）的成员没有初始化。</p>
<p><strong>没有默认构造函数的类类型的成员，以及const类型的成员变量和引用类型的成员变量，都必须在构造函数初始化列表中进行初始化。</strong></p>
<blockquote>
<p>假定有一个NoDefault类，它没有定义自己的默认构造函数，却有一个接受一个 string实参的构造函数。因为该类定义了一个构造函数，因此编译器将不合成默认构造函数。编译器将不会为具有NoDefault类型成员的类合成默认构造函数。<strong>如果这样的类希望提供默认构造函数，就必须显式地定义，并且默认构造函数必须显式地初始化其NoDefault成员</strong>（在成员初始化列表中通过传递一个初始的string值给NoDefault构造函数）。</p>
</blockquote>
<h5 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h5><p>拷贝构造函数、赋值操作符和析构函数总称为复制控制。<strong>编译器自动实现这些操作，但类也可以定义自己的版本。</strong></p>
<p>如果类需要析构函数，则它也需要赋值操作符和拷贝构造函数，这是一个有用的经验法则。这个规则常称为三法则，指的是如果需要析构函数，则需要所有这三个复制控制成员。有一种特别常见的情况需要类定义自己的复制控制成员的：类具有指针成员。</p>
<p><strong>概念：只有单个形参，而且该形参是<u>对本类类型对象的引用</u>(常用const 修饰)，这样的构造函数称为拷贝构造函数(或复制构造函数)。</strong>如果拷贝构造函数的形参不是引用，那么就相当于采用了传值的方式(pass-by-value)，而传值的方式会调用该类的拷贝构造函数，从而造成无穷递归地调用拷贝构造函数。因此<strong>拷贝构造函数的参数必须是一个引用</strong>。</p>
<p>与默认构造函数一样，拷贝构造函数可由编译器隐式调用。拷贝构造函数可用于：</p>
<ul>
<li><p>根据另一个同类型的对象初始化一个对象</p>
<p>C++支持两种初始化形式：直接初始化和复制初始化。复制初始化使用&#x3D;符号，而直接初始化将初始化式放在圆括号中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">null_book1</span><span class="params">(<span class="string">&quot;9-999-99999-9&quot;</span>)</span></span>;    <span class="comment">//直接初始化</span></span><br><span class="line">string null_book2 = null_book1; <span class="comment">//复制初始化</span></span><br><span class="line"><span class="function">string <span class="title">null_book2</span><span class="params">(null_book1)</span></span>; <span class="comment">//复制初始化</span></span><br><span class="line">string null_book3 = <span class="string">&quot;9-999-99999-9&quot;</span>;   <span class="comment">//复制初始化，等号右侧相当于一个C风格字符串作为形参创建的string临时对象，会产生新的对象</span></span><br><span class="line">string null_book4;</span><br><span class="line">null_book4 = null_book3；	<span class="comment">//不是调用复制构造函数，而是利用赋值运算符将null_book3赋值给null_book4，因为之前已经创建了空字符串对象null_book4（属于赋值运算符重载，没有产生新的对象）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>复制一个对象，将它作为实参传给一个函数或从函数返回时复制一个对象</p>
<p>当函数的形参或返回值为类类型时，将由拷贝构造函数进行复制。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Myclass</span>(<span class="type">int</span> n)&#123;number = n;&#125;</span><br><span class="line">	<span class="built_in">Myclass</span>(<span class="type">const</span> Myclass &amp;other)&#123;</span><br><span class="line">		number=other.number;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;a &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> number;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(Myclass p)</span></span>&#123;   <span class="comment">// 函数的形参为类类型时，将由复制构造函数进行复制</span></span><br><span class="line">	<span class="function">Myclass <span class="title">temp</span><span class="params">(p)</span></span>;   <span class="comment">// 使用复制构造函数来初始化对象temp</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="function">Myclass  <span class="title">obj1</span><span class="params">(<span class="number">10</span>)</span>, <span class="title">obj2</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="function">Myclass <span class="title">obj3</span><span class="params">(obj1)</span></span>;     <span class="comment">// 复制构造函数进行初始化</span></span><br><span class="line">	<span class="built_in">fun</span>(obj3);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的输出为a a a 。调用了三次拷贝构造函数，第一次是main中<code>Myclass obj3(obj1);</code> ，第二次是实参obj3到fun形参p，第三次是函数fun中的<code>Myclass temp(p);</code>语句。</p>
</li>
<li><p>初始化顺序容器中的元素</p>
<p>拷贝构造函数可用于初始化顺序容器中的元素。例如，可以用表示容量的单个形参来初始化容器。容器的这种构造方式使用默认构造函数和拷贝构造函数：<code>vector&lt;string&gt; svec(5);</code>编译器首先使用string 默认构造函数创建一个临时值来初始化 svec，然后使用拷贝构造函数将临时值复制到svec的每个元素。</p>
</li>
<li><p>根据元素初始化列表初始化数组元素</p>
<p>如果用常规的花括号括住的数组初始化列表来提供显式元素初始化式，则使用复制初始化来初始化每个元素。根据指定值创建适当类型的元素，然后用复制构造函数将该值复制到相应元素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sales_ item primer_ eds[] = &#123;<span class="built_in">string</span> (<span class="string">&quot;0-201-16487-6&quot;</span>), <span class="built_in">string</span> (<span class="string">&quot;0-201-54848-8&quot;</span>), <span class="built_in">string</span> (<span class="string">&quot;0-201-82470-1&quot;</span>)&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="x3D-x3D-浅复制与深复制-x3D-x3D"><a href="#x3D-x3D-浅复制与深复制-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;浅复制与深复制&#x3D;&#x3D;"></a>&#x3D;&#x3D;浅复制与深复制&#x3D;&#x3D;</h5><ul>
<li><p>浅复制</p>
<p>被复制对象的所有变量都含有与原来的对象相同的值，而变量中所有的对其他对象的引用仍然指向原来的对象。换言之，浅复制仅仅复制所考虑的对象，而不复制它所引用的对象。</p>
</li>
<li><p>深复制</p>
<p>被复制对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，也就是把引用变量所引用的对象也复制一遍。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="type">char</span> *ptr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shallow_copy</span><span class="params">(Test &amp; src, Test &amp; dest)</span> </span>&#123;</span><br><span class="line">	dest.ptr=src.ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deep_copy</span><span class="params">(Test &amp; srC, Test &amp; dest)</span> </span>&#123;</span><br><span class="line">	dest.ptr=<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(src.ptr) +<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>(dest.ptr, src.ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>浅复制可能会导致运行时错误，特别是在对象的创建与删除过程中。</p>
<h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><p>析构函数进行资源的回收，作为类构造函数的补充。<strong>当对象超出作用域或动态分配的对象被删除时，将自动应用析构函数</strong>。析构函数<strong>可用于释放对象构造时或在对象的生命期中所获取的资源</strong>。不管类是否定义了自己的析构函数，编译器都<strong>自动执行</strong>类中非static数据成员的析构函数。</p>
<p>虽然构造函数不能被定义成虚函数，但析构函数可以定义为虚函数，一般来说，如果类中定义了虛函数，析构函数也应被定义为虚析构函数,尤其是类内有申请的动态内存，需要清理和释放的时候。</p>
<p>与复制构造函数和赋值操作符不同，<strong>无论类是否定义了自己的析构函数，都会创建和运行合成析构函数</strong>。如果类定义了析构函数，则在类定义的析构函数结束之后运行合成析构函数。合成析构函数**<u>按对象创建时的逆序撤销每个非static 成员，因此，它按成员在类中声明次序的逆序撤销成员</u>**。对于类类型的每个成员，合成析构函数调用该成员的析构函数来撤销对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;A&quot;</span>;&#125;;    </span><br><span class="line">    ~<span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;~A&quot;</span>;&#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(A &amp;a):_a(a)&#123;  <span class="comment">// _a(a)调用了拷贝构造函数，用对象a初始化对象_a，拷贝构造函数自动生成，无输出</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;B&quot;</span>;</span><br><span class="line">    &#125;;    </span><br><span class="line">    ~<span class="built_in">B</span>()&#123;cout&lt;&lt;<span class="string">&quot;~B&quot;</span>;&#125; </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    A _a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="function">B <span class="title">b</span><span class="params">(a)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为AB~B~A~A。构造过程：A A B，那么析构过程为：B A A。注意之所以构造了两个A，是因为“a _(a)”调用了拷贝构造函数对B类对象中A初始化，而拷贝构造函数采用的是系统自动生成的版本，没有输出。</p>
<h4 id="构造函数与析构函数调用顺序"><a href="#构造函数与析构函数调用顺序" class="headerlink" title="构造函数与析构函数调用顺序"></a>构造函数与析构函数调用顺序</h4><ul>
<li><p>单继承</p>
<p>派生时，构造函数和析构函数是不能继承的，为了对基类成员进行初始化，必须<strong>对派生类重新定义构造函数和析构函数，并在构造函数的初始化列表中调用基类的构造函数</strong>。由于派生类对象通过继承而包含了基类数据成员，因此，创建派生类对象时，系统&#x3D;&#x3D;<u><strong>首先通过派生类的构造函数来调用基类的构造函数，完成基类成员的初始化，而后对派生类中新增的成员进行初始化</strong></u>&#x3D;&#x3D;。</p>
<p>**必须将基类的构造函数放在派生类的初始化列表中，以调用基类构造函数完成基类数据成员的初始化(若无，则调用基类的默认构造函数)**，派生类构造函数实现的功能，或者说调用顺序为：</p>
<ol>
<li><p>完成对象所占整块内存的开辟，由系统在调用构造函数时自动完成。</p>
</li>
<li><p>调用基类的构造函数完成基类成员的初始化。</p>
</li>
<li><p>若派生类中含对象成员、const 成员或引用成员，则必须在初始化表中完成其初始化。</p>
</li>
<li><p>派生类构造函数体执行。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;A&quot;</span>;&#125;;    </span><br><span class="line">    ~<span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;~A&quot;</span>;&#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;    <span class="comment">// 类B继承自类A</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(A &amp;a):_a(a)&#123;  <span class="comment">// _a(a)调用了拷贝构造函数，用对象a初始化对象_a，拷贝构造函数自动生成，无输出</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;B&quot;</span>;</span><br><span class="line">    &#125;;    </span><br><span class="line">    ~<span class="built_in">B</span>()&#123;cout&lt;&lt;<span class="string">&quot;~B&quot;</span>;&#125; </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    A _a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    A a;    <span class="comment">// 语句1</span></span><br><span class="line">    <span class="function">B <span class="title">b</span><span class="params">(a)</span></span>; <span class="comment">// 语句2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出为AAB~B~A~A~A。构造过程：A A A B，那么析构过程为：B A A A。</p>
<p>首先语句1构造一个A的对象，输出A；</p>
<p>然后语句2中，由于B有父类A，所以先调用父类A的构造函数，输出A。</p>
<p>然后B的构造函数初始化列表“a _(a)”调用了拷贝构造函数构造一个A的对象，而拷贝构造函数采用的是系统自动生成的版本，没有输出。但是析构的时候会输出。</p>
<p>最后执行B的构造函数，输出B。析构时与构造顺序相反。</p>
</blockquote>
</li>
<li><p>多继承</p>
<p>多继承时，派生类的构造函数初始化列表需要调用各个基类的构造函数。</p>
<p><strong>注意：</strong>此时构造函数初始化列表只能控制用于初始化基类的值，不能控制基类的构造次序。<strong>基类构造函数按照基类构造函数在类派生列表中的出现次序调用</strong>。</p>
</li>
<li><p>虚继承</p>
<p>首先调用虚基类的构造函数，虚基类如果有多个，则虚基类构造函数的调用顺序是此虚基类在当前类派生表中出现的顺序而不是它们在成员初始化表中的顺序。</p>
</li>
</ul>
<h4 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h4><p>操作符重载函数的名字为operator 后跟着所定义的操作符的符号。像任何其他函数一样，<strong>操作符重载函数有一个返回值和一个形参表</strong>。<strong>形参表必须具有与该操作符数目相同的形参</strong>（如果操作符是一个类成员，则包括隐式this形参）。</p>
<p>大多数操作符可以定义为成员函数或非成员函数。<strong>当操作符为成员函数时，它的第一个操作数隐式绑定到this 指针。</strong>有些操作符(包括赋值操作符)必须是类的成员函数。<u>比如赋值就必须是类的成员，所以this绑定到指向左操作数的指针。因此，赋值操作符接受单个形参，且该形参是同一类类型的对象。右操作数一般作为const引用传递。</u></p>
<p>并非所有操作符都是可重载的，下表给出可重载和不可重载的操作符。<strong>带“点”的都不能重载。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220629152653268.png" alt="image-20220629152653268"></p>
<h5 id="赋值操作符重载"><a href="#赋值操作符重载" class="headerlink" title="赋值操作符重载"></a>赋值操作符重载</h5><p><strong>在写赋值操作符重载函数时需要注意：</strong></p>
<ul>
<li>返回值类型为引用（允许连续赋值），形参为常量引用（避免调用拷贝构造函数，产生无谓的消耗）</li>
<li>记得判断传入实例和当前实例*this是否为同一实例</li>
<li>释放实例自身已有的内存，否则可能引起内存泄露</li>
</ul>
<p>例子如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CMyString</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CMyString</span>(<span class="type">const</span> <span class="type">char</span>* pData_NULL);   <span class="comment">// 自定义构造函数</span></span><br><span class="line">    <span class="built_in">CMyString</span> (<span class="type">const</span> CMyString&amp; other);  <span class="comment">// 自定义拷贝构造函数</span></span><br><span class="line">    ~<span class="built_in">CMyString</span>();    <span class="comment">// 自定义析构函数</span></span><br><span class="line">    CMyString&amp; CMyString::<span class="keyword">operator</span>=(<span class="type">const</span> CMyString &amp;str);   <span class="comment">// 赋值运算符的重载，函数名为operator=，形参为const CMyString &amp;str，返回类型为CMyString&amp;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span>* m pData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">String::<span class="built_in">String</span> (<span class="type">const</span> <span class="type">char</span> *pData) &#123; </span><br><span class="line">    <span class="keyword">if</span> (pData == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        m_pData=<span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>] ;</span><br><span class="line">        *m_pData=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> length-<span class="built_in">strlen</span> (pData);</span><br><span class="line">        m pData=<span class="keyword">new</span> <span class="type">char</span> [length+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_pData, pData) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义构造函数</span></span><br><span class="line">CMyString::<span class="built_in">CMyString</span> (<span class="type">const</span> CMyString &amp;other)&#123;</span><br><span class="line">    <span class="type">int</span> iLen=<span class="built_in">strlen</span> (other .m pData) ;</span><br><span class="line">    m pData=<span class="keyword">new</span> <span class="type">char</span>[iLen+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span> (m_pData, other.m_pData) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义拷贝构造函数</span></span><br><span class="line">CMyString::~<span class="built_in">CMyString</span>()&#123;</span><br><span class="line">	<span class="keyword">delete</span> []m_pData;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 赋值运算符重载函数</span></span><br><span class="line">CMyString&amp; CMyString::<span class="keyword">operator</span>=(<span class="type">const</span> CMyString &amp;str)&#123;   <span class="comment">// 注意返回值类型为引用，形参为常量引用</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>== &amp;str)   <span class="comment">// 记得判断传入实例str和当前实例*this是否为同一实例</span></span><br><span class="line">    	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span> []m_ pData;   <span class="comment">// 记得释放实例自身已有的内存，否则可能引起内存泄露</span></span><br><span class="line">    m_pData_NULL;</span><br><span class="line">    m_pData=<span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str.m_pData)+<span class="number">1</span>]; </span><br><span class="line">    <span class="built_in">strcpy</span>(m_pData, str.m_pData) ;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并不是出现“&#x3D;”就是调用赋值构造函数，<strong>赋值运算符重载的情况没有新对象产生，而拷贝构造函数是生成新的对象</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">null_book1</span><span class="params">(<span class="string">&quot;9-999-99999-9&quot;</span>)</span></span>;    <span class="comment">//直接初始化</span></span><br><span class="line">string null_book2 = null_book1;        <span class="comment">//复制初始化</span></span><br><span class="line"><span class="function">string <span class="title">null_book2</span><span class="params">(null_book1)</span></span>;         <span class="comment">//复制初始化</span></span><br><span class="line">string null_book3 = <span class="string">&quot;9-999-99999-9&quot;</span>;   <span class="comment">//复制初始化，等号右侧相当于一个C风格字符串作为形参创建的string临时对象（产生新的对象）</span></span><br><span class="line">string null_book4;</span><br><span class="line">null_book4 = null_book3；	<span class="comment">//不是调用复制构造函数，而是利用赋值运算符将null_book3赋值给null_book4，因为之前已经创建了空字符串对象null_book4（属于赋值运算符重载，没有产生新的对象）</span></span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;**<u>复制构造函数与赋值运算符的区别：</u>**是否有新对象产生&#x3D;&#x3D;</p>
<p>首先要说明的是，若用户没有定义, C++隐式声明一个拷贝构造函数和一个赋值运算符。</p>
<ul>
<li>拷贝构造函数<strong>涉及对象实例化</strong>，只在对象实例化时才会被调用，也就是说，在复制构造函数调用期间，这个对象处于一个未决状态(直到复制构造函数被成功调用)。而赋值运算符<strong>对现存对象</strong>进行赋值操作。</li>
<li>拷贝构造函数<strong>不返回任何值</strong>，void 都没有。而赋值运算符则在一个现存的对象被赋予新的值时被调用，并且它<strong>有返回值</strong>。</li>
</ul>
<h5 id="operator-new和operator-delete的重载"><a href="#operator-new和operator-delete的重载" class="headerlink" title="operator new和operator delete的重载"></a>operator new和operator delete的重载</h5><p><strong>new的执行过程是</strong>：首先，调用名为operator new的标准库函数，<u>分配足够大的原始未类型化的内存</u>，以保存指定类型的一个对象；接下来，<u>运行该类型的一个构造函数</u>，用指定初始化式构造对象；最后，<u>返回指向新分配并构造的对象的指针</u>。</p>
<p><strong>delete的执行过程是</strong>：首先，对sp指向的对象<u>运行适当的析构函数</u>；然后，通过调用名为operator delete的标准库函数<u>释放该对象所用内存</u>。</p>
<p>new和delete运算符的重载，实际上是对标准库函数operator new和operator delete的重载：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">X</span>() &#123;cout&lt;&lt;<span class="string">&quot;constructor&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line">    <span class="comment">// 重载操作符operate new，第一个参数为分配的空间大小（字节），类型为size_t，返回类型必须为void*</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(size_ t size)</span> </span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;new&quot;</span>&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);    <span class="comment">// 只分配所要求的空间，不调用相关对象的构造函数</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span> <span class="params">(<span class="type">void</span>* pointee)</span> </span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;delete&quot;</span>&lt;&lt;endl ;</span><br><span class="line">		::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pointee)</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">X</span>() &#123;cout&lt;&lt;<span class="string">&quot;destructor&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    X* px=<span class="keyword">new</span> <span class="built_in">X</span>();  <span class="comment">// 调用operator new分配空间，然后再调用构造函数</span></span><br><span class="line">    <span class="keyword">delete</span> px;      <span class="comment">// 先调用析构函数，再调用operator delete释放空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何禁止产生堆对象：禁用new，也就是使operator new为private。同时为了对称，最好将operator delete也重载为private。</p>
<p>如何禁止产生栈对象：将构造函数或析构函数设为private。</p>
<h3 id="8-3-成员函数的重载、覆盖与隐藏"><a href="#8-3-成员函数的重载、覆盖与隐藏" class="headerlink" title="8.3 成员函数的重载、覆盖与隐藏"></a>8.3 成员函数的重载、覆盖与隐藏</h3><h4 id="成员函数的重载"><a href="#成员函数的重载" class="headerlink" title="成员函数的重载"></a>成员函数的重载</h4><p><strong>在同一类中</strong>定义的<strong>同名函数</strong>。重载函数的<strong>形参类型和数目有所不同</strong>。重载和成员函数<strong>是否为虚函数无关</strong>。</p>
<h4 id="成员函数的覆盖"><a href="#成员函数的覆盖" class="headerlink" title="成员函数的覆盖"></a>成员函数的覆盖</h4><p><strong>在派生类中</strong><u>覆盖</u>基类中的<strong>同名函数</strong>，<strong>要求基类函数必须是虚函数</strong>，且：</p>
<p>1）与基类的虚函数有<strong>相同的参数个数</strong></p>
<p>2）与基类的虚函数有<strong>相同的参数类型</strong></p>
<p>3）与基类的虚函数有<strong>相同的返回类型</strong>；或者都返回指针(或引用)，并且派生类虚函数所返回的指针(或引用)类型是基类中被替换的虚函数所返回的指针(或引用)类型的子类型(派生类型)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun1</span><span class="params">(<span class="type">int</span> ,<span class="type">int</span>)</span></span>&#123;&#125;   <span class="comment">// 虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	 <span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">(<span class="type">int</span> ,<span class="type">int</span>)</span></span>&#123;&#125;   <span class="comment">// 具有相同的函数名、参数个数、参数类型、返回类型，覆盖了A中的fun1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>覆盖的特征如下：</p>
<ul>
<li>不同的范围（分别位于派生类与基类）；</li>
<li>相同的函数名字；</li>
<li>相同的参数；</li>
<li>基类函数必须有vitural关键字。</li>
</ul>
<p>重载与覆盖的区别如下：</p>
<ul>
<li>覆盖是子类和父类之间的关系，是垂直关系；重载是同一个类中不同方法之间的关系，是水平关系。</li>
<li>覆盖要求参数列表相同，重载要求参数列表不同；覆盖要求返回类型相同，重载则不要求；</li>
<li>覆盖关系中，调用方法体是根据对象的类型来决定的，重载关系是根据调用时的实参表与形参表来选择方法体的。</li>
</ul>
<h4 id="成员函数的隐藏"><a href="#成员函数的隐藏" class="headerlink" title="成员函数的隐藏"></a>成员函数的隐藏</h4><p>隐藏指的是在某些情况下，<strong>派生类中的函数屏蔽了基类中的同名函数</strong>，这些情况包括:</p>
<ul>
<li><p>两个函数参数相同，但基类函数不是虚函数。和覆盖的区别在于基类函数是否是虚函数。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> xp)</span></span>&#123;	<span class="comment">//成员函数fun，非虚函数</span></span><br><span class="line">		cout &lt;&lt; xp &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A&#123;	    <span class="comment">//类B由类A派生而来</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> xp)</span></span>&#123;&#125;	<span class="comment">// 参数相同，但是基类函数不是虚函数，所以隐藏父类的fun函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B b;</span><br><span class="line">b.<span class="built_in">fun</span>(<span class="number">2</span>);      <span class="comment">// 调用B中的函数fun</span></span><br><span class="line">b.A::<span class="built_in">fun</span>(<span class="number">2</span>);   <span class="comment">// 调用A中的函数fun</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>两个函数参数不同，无论基类函数是否是虚函数，基类函数都会被屏蔽。和重载的区别在于两个函数不在同一类中。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> xp)</span></span>&#123;	<span class="comment">//非虚成员函数fun，参数为int型</span></span><br><span class="line">		cout &lt;&lt; xp &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A&#123;	    <span class="comment">//类B由类A派生而来</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(cahr* xp)</span></span>&#123;&#125;	<span class="comment">// 参数不同，隐藏父类的fun函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B b;</span><br><span class="line">b.<span class="built_in">fun</span>(<span class="number">2</span>);     <span class="comment">// 错误，参数类型错误</span></span><br><span class="line">b.A::<span class="built_in">fun</span>(<span class="number">2</span>);  <span class="comment">// 通过，调用A中的函数fun</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="9-面向对象编程"><a href="#9-面向对象编程" class="headerlink" title="9. 面向对象编程"></a>9. 面向对象编程</h2><h3 id="9-1-继承"><a href="#9-1-继承" class="headerlink" title="9.1 继承"></a>9.1 继承</h3><p><strong>基类的构造函数(包括拷贝构造函数)、析构函数、赋值操作符重载函数，都不能被派生类继承。.</strong></p>
<p>一个派生类可以从一个或多个基类派生（单继承、多继承）。</p>
<p>多继承的定义格式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> &lt;派生类&gt;:&lt;继承方式<span class="number">1</span>&gt; &lt;基类名<span class="number">1</span>&gt;,&lt;继承方式<span class="number">2</span>&gt; &lt;基类名<span class="number">2</span>&gt;, ...&#123;</span><br><span class="line">	&lt;派生类新定义成员&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>派生类对象由多个部分组成：派生类本身定义的(非static)成员加上由基类(非static)成员组成的子对象。</p>
<p>如果一个类有多个直接基类，而这些直接基类又有一个共同的基类，则在最低层的派生类中会保留这个间接的共同基类数据成员的多份同名成员。为了解决这个问题，提出了<strong>虚继承</strong>的概念。虚继承时，公共基类在对象模型中只有一份拷贝。</p>
<h4 id="基类成员在派生类中的访问属性"><a href="#基类成员在派生类中的访问属性" class="headerlink" title="基类成员在派生类中的访问属性"></a>基类成员在派生类中的访问属性</h4><p>派生类<strong>可以继承基类中除了构造函数与析构函数(赋值运算符重载函数也不能被继承)之外的成员</strong>，但是这些成员的访问属性在派生过程中是可以调整的。从基类继承来的成员在派生类中的访问属性是由继承方式控制的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220629211927705.png" alt="image-20220629211927705"></p>
<ul>
<li><p>公有继承</p>
<p>父类的public成员成为子类的public成员，可以被该子类中的函数(内部访问)及其友元函数访问，除此之外，也可以<strong>由该子类的对象(属于外部访问)访问</strong>。</p>
<p>父类的private成员仍旧是父类的private成员，子类成员不可以访问这些成员，包括子类中的函数及其友元函数、子类对象。</p>
<p>父类的protected成员成为子类的protected成员，可以被该<strong>子类中的函数及其友元函数访问</strong>，除此之外，<strong>不可以由该子类的对象访问（不允许外部访问）</strong>。</p>
</li>
<li><p>私有继承</p>
<p>私有继承的特点是基类的公有成员和保护成员都作为派生类的私有成员，并且不能被这个派生类的子类所访问。在私有继承时，基类的成员只能由直接派生类访问，而无法再往下继承。</p>
</li>
<li><p>保护继承</p>
<p>保护继承的特点是基类的所有公有成员和保护成员都成为派生类的保护成员，并且<strong>只能被它的派生类成员函数或友元访问</strong>，基类的私有成员仍然是私有的。</p>
</li>
</ul>
<h4 id="继承时导致的二义性"><a href="#继承时导致的二义性" class="headerlink" title="继承时导致的二义性"></a>继承时导致的二义性</h4><h5 id="类间的转换"><a href="#类间的转换" class="headerlink" title="类间的转换"></a>类间的转换</h5><p>1） 在公有继承方式（私有、保护继承时，不能隐式转换）下，<strong>派生类的对象&#x2F;对象指针&#x2F;对象引用可以赋值给基类的对象&#x2F;对象指针&#x2F;对象引用（发生隐式转换）（上行转换）</strong>，基类的对象&#x2F;对象指针&#x2F;对象引用<strong>不能赋值</strong>给派生类的对象&#x2F;对象指针&#x2F;对象引用。<u>因为派生类包含了基类的所有信息，而基类缺乏派生类中的信息。</u>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A&#123;&#125;；</span><br><span class="line">A a;</span><br><span class="line">B b;</span><br><span class="line"></span><br><span class="line">a=b;	<span class="comment">//合法，派生类向基类隐式转换（向上转换）</span></span><br><span class="line">b=a;	<span class="comment">//错误，基类向派生类转换，语句1</span></span><br><span class="line">A* pa=&amp;b;	<span class="comment">//合法，隐式转换，派生类指针转换为基类指针</span></span><br><span class="line">B* pb=&amp;a;	<span class="comment">//错误，语句2</span></span><br><span class="line">A&amp; ra=b;	<span class="comment">//合法，隐式转换</span></span><br><span class="line">B&amp; rb=a;	<span class="comment">//错误，语句3</span></span><br></pre></td></tr></table></figure>

<p>2）C++允许<strong>把基类对象指针&#x2F;引用<u>强制转换</u>（显式）成派生类的对象指针&#x2F;引用（下行转换）</strong>，如1）中代码，语句2可以改为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B* pb=(B*)&amp;a;</span><br></pre></td></tr></table></figure>

<p>语句3可以改为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B&amp; rb=(B&amp;)a;</span><br></pre></td></tr></table></figure>

<p>但是语句1不能通过强制转换完成。</p>
<p>3）<strong>一个指向基类的指针可以用来指向该基类公有派生类的任何对象，这是C++实现程序运行时的多态性的关键。</strong></p>
<p>若存在<strong>多重继承</strong>，由于对象在往上转换期间（派生类转换为基类）出现多个类，因而<strong>对象会存在多个this指针</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base1</span>&#123;</span><br><span class="line">    <span class="type">char</span> c[<span class="number">16</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printthis1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;base1 this=&quot;</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;endl;  <span class="comment">// this为本类对象的地址</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">base2</span>&#123;</span><br><span class="line">    <span class="type">char</span> c[<span class="number">16</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printthis2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;base2 this=&quot;</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">member1</span>&#123;</span><br><span class="line">    <span class="type">char</span> c[<span class="number">16</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printthism1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;member1 this=&quot;</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">member2</span>&#123;</span><br><span class="line">    <span class="type">char</span> c[<span class="number">16</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printthism2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;member2 this=&quot;</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mi</span>:<span class="keyword">public</span> base1, <span class="keyword">public</span> base2&#123;</span><br><span class="line">    member1 m1;</span><br><span class="line">    member2 m2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printthis</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;m1 this=&quot;</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">printthis1</span>();   <span class="comment">//调用继承自base1的printthis1函数</span></span><br><span class="line">        <span class="built_in">printthis2</span>();   <span class="comment">//调用继承自base2的printthis2函数</span></span><br><span class="line">        m1.<span class="built_in">printthism1</span>();</span><br><span class="line">        m2.<span class="built_in">printthism2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mi MI;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(mi)=&quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(mi)&lt;&lt;endl;</span><br><span class="line">    MI.<span class="built_in">printthis</span>();</span><br><span class="line">    base1* b1=&amp;MI;  <span class="comment">// 派生对象的指针赋值给基类指针（发生隐式转换）</span></span><br><span class="line">    base2* b2=&amp;MI;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;base 1 pointer=&quot;</span>&lt;&lt;b1&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;base 2 pointer=&quot;</span>&lt;&lt;b2&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sizeof(mi)=64</span><br><span class="line">m1 this=0031FCB0</span><br><span class="line">base1 this=0031FCB0</span><br><span class="line">base2 this=0031FCC0</span><br><span class="line">member1 this=0031FCD0</span><br><span class="line">member2 this=0031FCE0</span><br><span class="line">base 1 pointer=0031FCB0</span><br><span class="line">base 2 pointer=0031FCC0</span><br></pre></td></tr></table></figure>

<p>每一个类都有打印一个this指针函数，这些类通过多重继承和组合被装配成类mi，它打印自己和其他所有子对象的地址，有主程序调用这些打印功能。可以清楚地看到，<strong>能在一个相同的对象中获得两个不同的this指针</strong>。<br>  派生对象MI的起始地址和它的基类列表中的第一个类（base1）的地址是一致的，第二个类base2的地址随后，接着根据声明的次序安排成员对象(member1、member2的地址)。当向base1和base2进行上行转换时（语句<code>base1* b1=&amp;MI;</code>和语句<code>base2* b2=&amp;MI;</code>），产生的指针<strong>表面上是指向同一个对象MI，而实际上有不同的this指针，b1指向base1类的子对象，b2指向base2类的子对象。</strong></p>
<p>派生对象MI的地址空间：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220630111042948.png" alt="image-20220630111042948"></p>
<p>在上述代码中加入如下语句：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mi *b3= &amp;MI;</span><br><span class="line"><span class="keyword">if</span>(b1 == b3) cout&lt;&lt;<span class="string">&quot;b1==b3&quot;</span>&lt;&lt;endl ;</span><br><span class="line"><span class="keyword">if</span>(b2 == b3) cout&lt;&lt;<span class="string">&quot;b2==b3&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>实际上，b1 与b3的比较过程中，由于两者类型不同，会发生隐式类型转换，b3 (mi*类型）会被隐式转换为basel* (派生类被隐式转换为基类，这是b1能与b3比较的基础，反过来转换不成立)，然后与b1进行比较；同理，b2与b3的比较过程中，b3会被转换为base2*，然后与b2进行比较，故实际输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b1==b3</span><br><span class="line">b2==b3</span><br></pre></td></tr></table></figure>

<h5 id="多基继承"><a href="#多基继承" class="headerlink" title="多基继承"></a>多基继承</h5><p>一般来说， 在派生类中对基类成员的访问应当具有唯一性， 但在多基继承时，如果多个基类中存在同名成员的情况，造成编译器无从判断具体要访问哪个基类中的成员，则称为对基类成员访问的：二义性问题。</p>
<p>若两个基类中具有同名的数据成员或成员函数，应<strong>使用成员名限定来消除二义性</strong>。比如<code>A::print()</code>。或者实现对基类同名成员函数的隐藏（见8.3节）。</p>
<h5 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;  <span class="comment">//公共基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;this is x inA:”&lt;&lt; endl;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">class B: public A&#123;&#125;;  //类B由类A派生而来</span></span><br><span class="line"><span class="string">class C: public A&#123;&#125;;  //类C由类A派生而来</span></span><br><span class="line"><span class="string">class D : public B, public C&#123;&#125;; //类 D由类B和类C派生而来</span></span><br><span class="line"><span class="string">void main() &#123;</span></span><br><span class="line"><span class="string">	D d;              //声明一个D类对象d，其含有2个基类对象A，一个基类对象B，一个基类对象C</span></span><br><span class="line"><span class="string">	A* pa=(A*) &amp;d;    //上行转换产生二义性，语句1</span></span><br><span class="line"><span class="string">	d.print();        //print()具有二义性，系统不知道是调用B类的还是C类的print()函数，语句2</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>上述代码的语句2<code>d.print();</code>编译错误，可改为以下的其中一种：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d.B.<span class="built_in">print</span>();</span><br><span class="line">d.C.<span class="built_in">print</span>();</span><br></pre></td></tr></table></figure>

<p>但是不能改为<code>d.A.print();</code>，因为d对象中有2个A类对象，故编译会报“基类A不明确”。</p>
<p>而语句2<code>A* pa=(A*) &amp;d;</code>产生的二义性也是因为d对象中有2个A类对象，转换时不知道让pa指向哪个子对象，可以改为以下的一种：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A* pa=(A*) (B*)&amp;d;</span><br><span class="line">A* pa=(A*) (C*)&amp;d;</span><br></pre></td></tr></table></figure>

<p><u>事实上，<strong>使用关键字virtual将共同基类A声明为虚基类</strong>，可有效解决上述二义性的问题。</u></p>
<h4 id="转换构造函数"><a href="#转换构造函数" class="headerlink" title="转换构造函数"></a>转换构造函数</h4><p>转换构造函数可以用单个实参来调用，其<strong>定义从形参类型到该类类型的一个隐式转换</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Integral</span> &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="built_in">Integral</span>(<span class="type">int</span>=<span class="number">0</span>);<span class="comment">//转换构造函数</span></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">	<span class="type">int</span> real;</span><br><span class="line">&#125;;</span><br><span class="line">Integral integ=<span class="number">1</span>; <span class="comment">//调用转换构造函数将1转换为Integral类的对象</span></span><br></pre></td></tr></table></figure>

<p>转换构造函数<strong>需满足以下条件之一</strong>:</p>
<ul>
<li>Integral类的定义和实现中给出了<strong>仅包括只有一个int类型参数的构造函数</strong>；</li>
<li>Integral 类的定义和实现中给出了包含<strong>一个int类型参数，且其他参数都有缺省值的构造函数</strong>；</li>
<li>Integral 类的定义和实现中虽然不包含int 类型参数，但包含一个非 int类型参数如float类型，此外没有其他参数或者其他参数都有缺省值，且int类型参数可隐式转换为float类型参数。</li>
</ul>
<p>可以通过将构造函数声明为explicit, 来禁止隐式转换。</p>
<h4 id="类型转换函数"><a href="#类型转换函数" class="headerlink" title="类型转换函数"></a>类型转换函数</h4><p>类型转换函数的作用是<strong>将一个类的对象转换成另一类型的数据</strong>，与转换构造函数作用相反。在类中，定义类型转换函数的一般格式为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Integral</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Integral</span>(<span class="type">int</span>=<span class="number">0</span>);  <span class="comment">//转换构造函数</span></span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span></span>&#123;   <span class="comment">//类型转换函数，函数名为operator int，指明转换的目标类型为int</span></span><br><span class="line">        <span class="keyword">return</span> real;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> real;</span><br><span class="line">Integral integ=<span class="number">1</span>;   <span class="comment">//调用转换构造函数将int型的1转换为Integral类的对象</span></span><br><span class="line"><span class="type">int</span> i=integ;        <span class="comment">//调用类型转换函数将integ转换为int类型</span></span><br></pre></td></tr></table></figure>

<p>定义类型转换函数，需要注意以下几点:</p>
<ul>
<li>转换函数必须是成员函数，不能是友元形式;</li>
<li>转换函数不能指定返回类型，但在函数体内必须用return语句以传值方式返回一个目标类型的变量</li>
<li>转换函数不能有参数。</li>
</ul>
<p>非C++内建型别A和B，<strong>在以下几种情况下B能隐式转化为A</strong>。</p>
<ul>
<li><p>B公有继承自A，可以是间接继承的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class B:public A&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此时若有<code>A a; B b;</code>， 则<code>a=b;</code>合法。</p>
</li>
<li><p>B中有类型转换函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">A</span><span class="params">()</span></span>;   <span class="comment">// 类型转换函数，将B类对象强制转换为A类类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此时若有<code>A a; B b;</code>， 则<code>a=b;</code>合法。</p>
</li>
<li><p>A实现了非explicit的参数为B (可以有其他带默认值的参数)的构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">const</span> B&amp;);    <span class="comment">// 转换构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此时若有<code>A a; B b;</code>， 则<code>a=b;</code>合法。</p>
</li>
</ul>
<h3 id="9-2-虚函数多态"><a href="#9-2-虚函数多态" class="headerlink" title="9.2 虚函数多态"></a>9.2 虚函数多态</h3><p>通俗地说，多态性是指<strong>同一个操作作用于不同的对象就会产生不同的响应</strong>；</p>
<p>多态性分为<strong>静态多态性</strong>和<strong>动态多态性</strong>：</p>
<ul>
<li>静态多态性：函数重载和运算符重载</li>
<li>动态多态性：虛函数</li>
</ul>
<h4 id="静态联编与动态联编"><a href="#静态联编与动态联编" class="headerlink" title="静态联编与动态联编"></a>静态联编与动态联编</h4><p>以函数重载为例，C++编译器根据传递给函数的参数和函数名决定具体要使用哪一个函数，称为<strong>联编</strong>或绑定(binding)。</p>
<p>编译器可以在编译过程中完成这种联编，<strong>在编译过程中进行的联编叫静态联编</strong>(static binding)或早期联编(early binding)。<br>在一些场合下，编译器无法在编译过程中完成联编，必须<strong>在程序运行时</strong>完成选择，因此编译器必须提供一套称为“动态联编”(dynamic binding)的机制，也叫晚期联编(late binding)，<strong>C++通过虚函数来实现动态联编</strong>。</p>
<p>如果一个基类的成员函数定义为虚函数，那么，它在所有派生类中也保持为虚函数；即使在派生类中省略了virtual 关键字，也仍然是虚函数。</p>
<p>派生类中可根据需要对虚函数进行重定义，重定义的格式有一定的要求：</p>
<ul>
<li>与基类的虚函数有相同的参数个数</li>
<li>与基类的虚函数有相同的参数类型</li>
<li>与基类的虚函数有相同的返回类型；或者都返回指针(或引用)，并且派生类虚函数所返回的指针(或引用)类型是基类中被替换的虚函数所返回的指针(或引用)类型的子类型(派生类型)。</li>
</ul>
<h5 id="虚函数的访问"><a href="#虚函数的访问" class="headerlink" title="虚函数的访问"></a>虚函数的访问</h5><p>虚函数可以通过对象名来调用，此时编译器采用的是静态联编。通过对象名访问虚函数时，调用哪个类的函数取决于定义对象名的类型。</p>
<ul>
<li>&#x3D;&#x3D;使用指针访问<strong>非虚函数</strong>时，编译器根据<strong>指针本身的类型决定</strong>要调用哪个函数&#x3D;&#x3D;，而不是根据指针指向的对象类型；</li>
<li>&#x3D;&#x3D;使用指针访问<strong>虚函数</strong>时，编译器根据<strong>指针所指对象的类型决定</strong>要调用哪个函数<strong>（动态联编）</strong>&#x3D;&#x3D;，而与指针本身的类型无关。</li>
</ul>
<p>因此这里<strong>虚函数的作用</strong>就是使得指向基类的指针在操作它的多态类对象时，是根据不同的类对象来调用相应的函数，而不是调用基类的函数。</p>
<p>使用引用访问虚函数，与使用指针访问虚函数类似，不同的是，引用一经声明后，引用变量本身无论如何改变，其调用的函数就不会再改变，始终指向其开始定义时的函数。因此在使用上有一定限制，但这在一定程度上提高了代码的安全性。</p>
<p>总结如下，C++中的函数调用默认不使用动态绑定。要触发动态绑定，需满足两个条件：</p>
<p>第一，只有指定为虚函数的成员函数才能进行动态绑定，成员函数默认为非虚函数，非虚函数不进行动态绑定；</p>
<p>第二，必须通过基类类型的引用或指针进行函数调用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">disp</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;hel1o, base1&quot;</span>&lt;&lt; endl; &#125;   <span class="comment">// 虚函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">disp2</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;hello, base2&quot;</span> &lt;&lt; endl; &#125;         <span class="comment">// 默认为非虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">childl</span> :<span class="keyword">public</span> base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">disp</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;hello, child1&quot;</span> &lt;&lt; endl; &#125;    <span class="comment">// 覆盖基类的虚函数disp</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">disp2</span> <span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;hello, child2&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">base * base=<span class="literal">NULL</span>;</span><br><span class="line">childl obj_child1;</span><br><span class="line">base = &amp;obj_childl;  <span class="comment">// 派生类地址给基类指针赋值，发生隐式转换</span></span><br><span class="line">base-&gt;<span class="built_in">disp</span>();        <span class="comment">// 通过指针访问虚函数，根据指针所指对象的类型决定调用的函数，base指向childl类类型</span></span><br><span class="line">base-&gt;<span class="built_in">disp2</span>() ;      <span class="comment">// 通过指针访问非虚函数，根据指针本身的类型决定调用的函数，base为base类类型</span></span><br></pre></td></tr></table></figure>

<p>上述代码的输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello, child1</span><br><span class="line">hello, base2</span><br></pre></td></tr></table></figure>

<p><u><strong>常见的不能声明为虚函数的有</strong></u>：</p>
<p>普通函数(非成员函数)、静态成员函数、构造函数、友元函数，而<strong>内联成员函数、赋值操作符重载函数即使声明为虚函数也无意义</strong>。</p>
<p>析构函数可以被声明为虚函数，因为销毁对象时需要识别对象类型。</p>
<ul>
<li><p><strong>构造函数</strong>不能为虚函数：</p>
<p>若基类的构造函数为虚函数，那么派生类的构造函数会覆盖基类的构造函数，使得基类无法构造。且虚函数旨在在不同类型的对象上产生不同动作，而构造函数运行时对象还未产生。</p>
</li>
<li><p><strong>普通函数</strong>不能为虚函数：</p>
<p>普通函数只能被重载，不能被覆盖，声明为虚函数没有意义。</p>
</li>
<li><p><strong>静态函数</strong>不能为虚函数：</p>
<p>静态函数属于类，而不是对象，所以没有动态绑定的需要。</p>
</li>
<li><p><strong>友元函数</strong>不能为虚函数：</p>
<p>C++不支持友元函数的继承</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Fun</span> <span class="params">(<span class="type">int</span> number=<span class="number">10</span>)</span> </span>&#123;</span><br><span class="line">	std: :cout &lt;&lt; <span class="string">&quot;A::Fun with number”&lt;&lt; number&lt;&lt;endl;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">class B: public A&#123;</span></span><br><span class="line"><span class="string">public:</span></span><br><span class="line"><span class="string">	virtual void Fun (int number=20) &#123;</span></span><br><span class="line"><span class="string">	std::cout &lt;&lt; &quot;</span>B::Fun with number ”&lt;&lt; number&lt;&lt;endl ;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    A &amp;a=b;</span><br><span class="line">    a.<span class="built_in">Fun</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述代码输出为<code>B::Fun with number 10</code> 。由于A中的Fun函数为虚函数，所以<code>a.Fun()</code>会动态联编到a所引用的对象b的Fun函数上，因此输出<code>B::Fun with number 10</code>。之所以number变量为10，是因为缺省实参是编译时确定的，在动态联编之前。</p>
</blockquote>
<h5 id="构造函数和析构函数中的虚函数"><a href="#构造函数和析构函数中的虚函数" class="headerlink" title="构造函数和析构函数中的虚函数"></a>构造函数和析构函数中的虚函数</h5><p>构造派生类对象时，<strong>首先</strong>运行基类构造函数初始化对象的基类部分。在执行基类构造函数时，对象的派生类部分是未初始化的。实际上，此时对象还不是一个派生类对象。</p>
<p>撤销派生类对象时，<strong>首先</strong>撤销它的派生类部分，然后按照与构造顺序的逆序撤销它的基类部分。</p>
<p><em>在这两种情况下，运行构造函数或析构函数时，对象都是不完整的。为了适应这种不完整，编译器将对象的类型视为在构造或析构期间发生了变化。在基类构造函数或析构函数中，将派生类对象当作基类类型对象对待。</em></p>
<p><strong>如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本（静态联编）。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220701105151776.png" alt="image-20220701105151776"></p>
<blockquote>
<p>解析：构造函数不需要是虚函数，也不允许是虚函数，因为创建一个对象时我们总是要明确指定对象的类型，尽管我们可能通过实验室的基类的指针或引用去访问它但析构却不一定，我们往往通过基类的指针来销毁对象。这时候如果析构函数不是虚函数，就不能正确识别对象类型从而不能正确调用析构函数。</p>
</blockquote>
<h4 id="虚函数表指针（vptr）及虚基类表指针（bptr）"><a href="#虚函数表指针（vptr）及虚基类表指针（bptr）" class="headerlink" title="虚函数表指针（vptr）及虚基类表指针（bptr）"></a>虚函数表指针（vptr）及虚基类表指针（bptr）</h4><p>C+ +在布局以及存取时间上主要的额外负担是由virtual引起的，包括:</p>
<p>virtual function 机制：用以支持-一个有效率的“执行期绑定”;</p>
<p>virtual base class：用以实现多次出现在继承体系中的基类，有一个单一而被共享的实体。</p>
<h5 id="虚函数表指针"><a href="#虚函数表指针" class="headerlink" title="虚函数表指针"></a>虚函数表指针</h5><p>C++中数据成员可以分为静态和非静态，以及三种类成员函数：静态、非静态和虚函数。</p>
<p>其中，非static数据成员被配置于每一个对象之内，static 数据成员则被存放在所有的对象之外，通常被放置在程序的全局(静态)存储区内，故不会影响个别的对象大小。static 和非static函数也被放在所有的对象之外。virtual 函数则以两个步骤支持之：</p>
<ol>
<li><p><strong>每一个类产生出一堆指向virtual functions的指针，放在表格之中，这个表格被称为virtual table(vtbl)；</strong> </p>
</li>
<li><p><strong>每一个<u>对象</u>被添加了一个指针，指向相关的vitual table。</strong>通常这个指针被称为**vptr (虚函数表指针)**。vptr 的设定和重置都由每一个类的构造函数、析构函数和复制构造函数自动完成。（每个虚函数的存在会为类的内存空间增加一个虚函数表指针）</p>
</li>
</ol>
<h5 id="含静态变量、虚函数的类的空间计算"><a href="#含静态变量、虚函数的类的空间计算" class="headerlink" title="含静态变量、虚函数的类的空间计算"></a>含静态变量、虚函数的类的空间计算</h5><p>sizeof应用在类和结构的处理情况是相同的。但需要注意结构或者类中的<strong>静态成员不对结构或者类的大小产生影响</strong>，因为静态变量的存储位置与单个对象的地址无关。</p>
<p><strong>空类的大小为1个字节</strong>。<strong>含有虚函数的类会多出虚函数表指针的空间占用</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;;    <span class="comment">// 空类占1个字节</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;      <span class="comment">// 有一个虚函数，因此B中有指针vptr，占4个字节</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>() ;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">B</span>() ;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;      <span class="comment">// 大小为4、4（2对其为4）、4、64、4、4的和，为84</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(4)   <span class="comment">// 设置编译器按照4个字节对齐</span></span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">short</span> j;</span><br><span class="line">    <span class="type">float</span> k;</span><br><span class="line">    <span class="type">char</span> <span class="number">1</span>[<span class="number">64</span>] ;</span><br><span class="line">    <span class="type">long</span> m;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack()</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>&#123;      <span class="comment">// 大小为4、2、4、64、4、4的和，为82</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(1)   <span class="comment">// 设置编译器按照1个字节对齐</span></span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">short</span> j;</span><br><span class="line">    <span class="type">float</span> k;</span><br><span class="line">    <span class="type">char</span> <span class="number">1</span> [<span class="number">64</span>]; </span><br><span class="line">    <span class="type">long</span> m;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack()</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述代码中，各类的sizeof结果为1、4、84、82。</p>
<h5 id="虚函数表的实现"><a href="#虚函数表的实现" class="headerlink" title="虚函数表的实现"></a>虚函数表的实现</h5><p>使用指针访问<strong>虚函数</strong>时，编译器根据<strong>指针所指对象的类型决定</strong>要调用哪个函数（动态联编）。比如有基类A及其派生类B，基类A中有一个虚函数fun()，派生类也有一个函数fun()进行覆盖。若有一B类对象b，对于语句<code>A* a=&amp;b; a-&gt;fun();</code>，其运行时会发生动态联编，调用的fun()为指针所指的B类对象b的函数，而不是A类。</p>
<p>但是此过程中，父类指针a是如何根据虚函数表找到子类B的虚函数的?</p>
<p><strong>首先父类指针a所指空间为对象b，其中存在虚函数表指针vptr，通过其可以找到对象b的虚函数表，进而找到类B的函数fun()。</strong></p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;a() in A&quot;</span>&lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;b() in A&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">c</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;c() in A&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">d</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;d() in A&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;a() in B&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;cout&lt;&lt; <span class="string">&quot;b() in B&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;a() in C&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;b() in C&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;a() in D&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">d</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;d() in D&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述代码中，类A的对象的虚函数表如下，每个各自记录一个函数的<strong>地址</strong>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220701150726541.png" alt="image-20220701150726541"></p>
<p>由于B、C继承自A，所以其定义的a()、b()也为虚函数。类B、C的对象的虚函数表如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220701150850252.png" alt="image-20220701150850252"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220701150927278.png" alt="image-20220701150927278"></p>
<p>可见单基继承时，仅有一个vptr。派生类的函数覆盖了基类的同名函数，虚函数表中相应位置也替换为了新函数的地址。通过对象的虚函数表指针vptr就可以找到所属类的函数了。</p>
<p>类D的对象的虚函数表如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220701151349316.png" alt="image-20220701151349316"></p>
<p>可见，多基继承时，有几个基类就有几个vptr。D类中的函数a与d覆盖了B类中的同名函数，故虚函数表中对应位置替换为新函数的地址。D类中的函数a与d覆盖了C类中的同名函数，故虚函数表中对应位置替换为新函数的地址。</p>
<h5 id="虚基类表指针"><a href="#虚基类表指针" class="headerlink" title="虚基类表指针"></a>虚基类表指针</h5><p>继承也可以指定为虚拟（virtual）。在虚拟继承的情况下，基类不管在继承串链中被派生多少次，永远只会存在一个实体。</p>
<p>在虚拟继承基类的子类中，子类会增加某种形式的指针，或者指向虚基类子对象，或者指向一个相关的表格；表格中存放的不是虚基类子对象的地址，就是其偏移量。<strong>此指针被称为bptr</strong>，如下图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220701204518663.png" alt="image-20220701204518663"></p>
<p><strong>注意：在同时存在vptr与bptr时，某些编译器会将其进行优化，合并为一个指针。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>&#123;&#125;;                    <span class="comment">// 空类，占1个字节</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Y</span>:<span class="keyword">public</span> <span class="keyword">virtual</span> X&#123;&#125;;   <span class="comment">// 虚拟继承，需要虚基表指针bptr的空间，4个字节，继承自X的1字节被优化为0</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Z</span>:<span class="keyword">public</span> <span class="keyword">virtual</span> X&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:<span class="keyword">public</span> Y, <span class="keyword">public</span> Z&#123;&#125;; <span class="comment">// 继承Y，占4个字节；继承Z，占4个字节；总共占8个字节</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof(X) : &quot;</span>&lt;&lt; <span class="built_in">sizeof</span>(X) &lt;&lt; endl;</span><br><span class="line">    cout.&lt;&lt; <span class="string">&quot;sizeof(Y) : &quot;</span>&lt;&lt; <span class="built_in">sizeof</span>(Y) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof(Z) : &quot;</span>&lt;&lt; <span class="built_in">sizeof</span>(Z) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof(A) : &quot;</span>&lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="虚拟继承时构造函数的书写"><a href="#虚拟继承时构造函数的书写" class="headerlink" title="虚拟继承时构造函数的书写"></a>虚拟继承时构造函数的书写</h4><p>对普通的多层继承而言，构造函数的调用是嵌套的，如由C1类派生C2类，C2 类又派生C3类时，则各个构造函数有如下形式:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">C2</span> (总参数表) :<span class="built_in">C1</span> (参数表)</span><br><span class="line"><span class="built_in">C3</span> (总参数表) :<span class="built_in">C2</span> (参数表)</span><br></pre></td></tr></table></figure>

<p>而对虚基派生来说，如果按照上述规则，若A类虚拟派生B类、C类，D类继承B类、C类，则各个构造函数有如下形式:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">B</span>(总参数表) :<span class="built_in">A</span>(参数表)</span><br><span class="line"><span class="built_in">C</span>(总参数表) :<span class="built_in">A</span>(参数表)</span><br><span class="line"><span class="built_in">D</span>(总参数表) :<span class="built_in">B</span>(参数表)，<span class="built_in">C</span>(参数表)，<span class="built_in">A</span>(参数表)</span><br></pre></td></tr></table></figure>

<p>​		根据虚基派生的性质，类D中只有一份虚基类A的拷贝，因此A类的构造函数在D类中只能被调用一次。所以，从A类直接虚拟派生(B和C)和间接派生(D)的类中，其<strong>构造函数的初始化列表中都要列出对虚基类A构造函数的调用</strong>。这种机制保证了<strong>不管有多少层继承，虚基类的构造函数必须且只能被调用一次</strong>。</p>
<p><strong>若在初始化列表中没有显式调用虚基类的构造函数，则将调用虚基类的默认构造函数，若虚基类没有定义默认构造函数，则编译出错。</strong></p>
<h4 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h4><p>纯虚函数是一一种特殊的虚函数，它的一般格式如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> &lt;类名&gt;&#123;</span><br><span class="line"><span class="keyword">virtual</span> &lt;类型&gt; &lt;函数名&gt; (&lt;参数表&gt;)=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在许多情况下，<strong>在基类中不对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做</strong>。这就是纯虚函数的作用。纯虚函数可以让类先具有一个操作名称，而没有操作内容，让派生类在继承时再去具体地给出定义。**<u>凡是含有纯虚函数的类称为抽象类</u>**。这种类不能声明对象，只是作为基类为派生类服务。除非在派生类中完全实现基类中所有的纯虚函数，否则，派生类也是抽象类，不能实例化对象。</p>
<p><strong>只定义了protected 型构造函数的类也是抽象类。</strong>对一个类来说，如果只定义了protected 型的构造函数而没有提供public构造函数，无论是在外部还是在派生类中都不能创建该类的对象，但可以由其派生出新的类，这种能派生新类，却不能创建自己对象的类是另一种形式的抽象类。</p>
<p><strong>抽象类不能声明对象，但是可以作为指针或者引用类型使用。</strong></p>
<h3 id="9-3-动态运行时类型识别与显式转换"><a href="#9-3-动态运行时类型识别与显式转换" class="headerlink" title="9.3 动态运行时类型识别与显式转换"></a>9.3 动态运行时类型识别与显式转换</h3><h4 id="typeid"><a href="#typeid" class="headerlink" title="typeid"></a>typeid</h4><p>通过运行时类型识别(RTTI)，程序能够使用基类的指针或引用来检索这些指针或引用所指对象的实际类型。</p>
<p>C++通过下面两个操作符提供RTTI：</p>
<ul>
<li><p><strong>typeid 操作符，返回<u>指针或引用所指对象的实际类型</u>。</strong>操作对象为指针所指对象。</p>
</li>
<li><p><strong>dynamic_ cast 操作符，将基类类型的指针或引用安全地转换为派生类型的指针或引用。</strong></p>
</li>
</ul>
<p>typeid 操作符使程序能够询问一个表达式的类型。</p>
<p>typeid表达式形如: <code>typeid(e)</code>。 这里e是任意表达式或者是类型名。用法如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Base *bp;</span><br><span class="line">Derived *dp;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">typeid</span>(*bp) == <span class="built_in">typeid</span>(*dp)) &#123;…&#125;       <span class="comment">// 比较bp所指对象与dp所指对象的实际类型</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">typeid</span>(*bp) == <span class="built_in">typeid</span>(Derived))  &#123;…&#125;  <span class="comment">// 判断bp所指对象是否为Derived</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">typeid</span>(bp) == <span class="built_in">typeid</span>(Derived))  &#123;…&#125;   <span class="comment">// 比较Base *类型和Derived类型，两类型不相等，测试失败</span></span><br></pre></td></tr></table></figure>

<p>只有当typeid的操作数是带虚函数的类类型的对象的时，才返回动态类型信息。测试指针(相对于指针指向的对象)返回指针的静态的、编译时类型。</p>
<h4 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h4><p>也叫强制类型转换，包括以下强制类型转换操作符：static_cast、dynamic_cast、const_cast、reinterpret_cast。</p>
<p>命名的强制类型转换符号的一-般形式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cast-<span class="built_in">name</span>&lt;type&gt; (expression) ;</span><br></pre></td></tr></table></figure>


<p>其中，cast-name 为static_ cast、 dynamic_ cast、 const_ cast 和reinterpret cast 之一， type 为转换的目标类型，而expression则是被强制转换的表达式。强制转换的类型指定了在expression上执行某种特定类型的转换。</p>
<h5 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h5><p>在引入命名的强制类型转换操作符之前，显式强制转换用圆括号将类型括起来实现:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ip;</span><br><span class="line"><span class="type">char</span> *pc = (<span class="type">char</span>*) ip;</span><br></pre></td></tr></table></figure>

<p>效果与使用reinterpret cast符号相同。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ip;</span><br><span class="line"><span class="type">char</span> *pc = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(ip) ;</span><br></pre></td></tr></table></figure>

<h5 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h5><p>将转换掉表达式的const性质。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *ip;</span><br><span class="line"><span class="type">char</span> *pc = <span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(ip);</span><br></pre></td></tr></table></figure>

<p><strong>只有使用const_ cast 才能将const性质转换掉</strong>。在这种情况下，试图使用其他三种形式的强制转换都会导致编译时的错误。类似地，除了添加或删除const特性，用const _cast 符来执行其他任何类型转换，都会引起编译错误。</p>
<h5 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h5><p>编译器<strong>隐式</strong>执行的任何类型转换都可以由static_ cast显式完成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> d=<span class="number">97.0</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="type">static</span> <span class="built_in">cast</span>&lt;<span class="type">int</span>&gt;(d) ;</span><br><span class="line"><span class="comment">// 等价于:</span></span><br><span class="line"><span class="type">double</span> d=<span class="number">97.0</span>;</span><br><span class="line"><span class="type">int</span> i=d;</span><br></pre></td></tr></table></figure>

<p><strong>仅当类型之间可隐式转换时（除类层次间的下行转换以外），static cast 的转换才是合法的</strong>，否则将出错。<br>类层次间的下行转换属于强制转换，是不能通过隐式转换完成的，请看下例。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">child</span>:<span class="keyword">public</span> base&#123;&#125;;</span><br><span class="line">base* b;</span><br><span class="line">child* c;</span><br><span class="line">c = <span class="type">static</span> <span class="built_in">cast</span>&lt;child*&gt;(b);<span class="comment">// 下行转换，错误</span></span><br><span class="line">c = b;           <span class="comment">// 基类对象不能给派生类赋值，编译不正确</span></span><br></pre></td></tr></table></figure>

<h5 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h5><p>​		该运算符把expression转换成type类型的对象。<strong>type 必须是类的指针、类的引用或者void</strong>*。如果type是指针类型，那么expression也必须是一个指针， 如果type是一个引用，那么expression也必须是一个引用。<br>​		与其他强制类型转换不同，dynamic_ cast <strong>涉及运行时类型检查</strong>。dynamic_ cast 运行时的类型检查需要运行时的类型信息，而这个<strong>类型信息存储在类的虚函数表中</strong>，只有定义了虚函数的类才有虚函数表，没有定义虚函数的类是没有虚函数表的，<strong>对没有虚函数表的类使用会导致dynamic_ cast 编译错误</strong>。<br>​		如果绑定到引用或指针的对象的类型不是目标类型，则dynamic_cast 失败。如果转换到指针类型的dynamic_cast 失败，则dynamic_cast 的结果是0值；如果转换到引用类型的dynamic_cast失败，则抛出一个bad_cast 类型的异常。<br>​		因此，dynamic_cast 操作符一次执行两个操作。 它<strong>首先验证被请求的转换是否有效</strong>，只有转换有效，<strong>然后操作符才实际进行转换</strong>。一般而言，引用或指针所绑定的对象的类型在编译时是未知的，基类的指针可以赋值为指向派生类对象,同样，基类的引用也可以用派生类对象初始化，因此，dynamic_cast操作符执行的验证必须在运行时进行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">A *pb=<span class="keyword">new</span> <span class="built_in">B</span>();   <span class="comment">// 定义A*类型的指针，指向B类类型的对象</span></span><br><span class="line">B b;</span><br></pre></td></tr></table></figure>

<p>针对上述代码，下列语句的执行情况如何：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A *pa = <span class="built_in">dynamic_cast</span>&lt;A *&gt;(pb); <span class="comment">// 通过。pb本来就是A*类型，实际上不需要转换类型</span></span><br><span class="line">A *pa = <span class="built_in">dynamic_cast</span>&lt;B *&gt;(pb); <span class="comment">// 编译错误。运行时dynamic cast的操作数必须包含多态类类型，而B类没有虚函数</span></span><br><span class="line">A *pa = static_ <span class="built_in">cast</span>&lt;A *&gt;(pb); <span class="comment">// 通过。pb本来就是A*类型，实际上不需要转换类型</span></span><br><span class="line">A a = static_ <span class="built_in">cast</span>&lt;A &gt;(b);     <span class="comment">// 通过。派生类对象赋值给基类对象，发生隐式转换</span></span><br><span class="line">A a = dynamic <span class="built_in">cast</span>&lt;A &gt;(b);     <span class="comment">// 编译错误。用dynamic_cast进行转换时，待转换的类型只能是指针或引用</span></span><br></pre></td></tr></table></figure>

<p><strong>dynamic_cast 主要用于类层次间的上行转换和下行转换。</strong>dynamic_cast 运算符可以在执行期决定真正的类型。如果下行转换是安全的(也就说，如果基类指针或者引用确实指向一个派生类对象)，这个运算符会传回转型过的指针。如果downcast不安全，这个运算符会传回空指针(也就是说，基类指针或者引用没有指向一个派生类对象)。</p>
<p>在类层次间进行上行转换时，dynamic <em>cast 和static</em> cast 的效果是一样的；在进行下行转换时，dynamic_ cast 具有类型检查的功能，比static_ cast 更安全。</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">ccb</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://frankcao3.github.io/posts/50843">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://frankcao3.github.io/posts/50843')">C/C++ 基础知识</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://frankcao3.github.io/posts/50843"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=C/C++ 基础知识&amp;url=https://frankcao3.github.io/posts/50843&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>计算机基础<span class="tagsPageCount">5</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/28758"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">计算机网络</div></div></a></div><div class="next-post pull-right"><a href="/posts/9423"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">STL</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/posts/9423" title="STL"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2021-08-15</div><div class="title">STL</div></div></a></div><div><a href="/posts/28758" title="计算机网络"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2021-08-15</div><div class="title">计算机网络</div></div></a></div><div><a href="/posts/1106" title="数据结构"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2021-08-15</div><div class="title">数据结构</div></div></a></div><div><a href="/posts/1079" title="操作系统"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2021-08-15</div><div class="title">操作系统</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-x2F-C"><span class="toc-number">1.</span> <span class="toc-text">C&#x2F;C++</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%95%B0%E7%BB%84"><span class="toc-number">1.1.</span> <span class="toc-text">1. 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 一维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C%E9%A3%8E%E6%A0%BC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">C风格字符串</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 二维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-1"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">初始化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E6%8C%87%E9%92%88"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3 指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">指针运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E4%B8%8E%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">指针数组与数组指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.4 数组的应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.2.</span> <span class="toc-text">2. 字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 基础操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%85%E5%90%AB%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 字符串包含问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95KMP"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">串的模式匹配算法KMP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%A7%BB%E4%BD%8D%E5%8C%85%E5%90%AB%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">字符串移位包含问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B0%E5%AD%97"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 字符串转数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.4 其他问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%BB%93%E6%9E%84%E4%BD%93%E3%80%81%E5%85%B1%E7%94%A8%E4%BD%93%E5%92%8C%E6%9E%9A%E4%B8%BE"><span class="toc-number">1.3.</span> <span class="toc-text">3. 结构体、共用体和枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1 结构体的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E7%9A%84%E4%BD%8D%E5%AD%97%E6%AE%B5"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2 结构体中的位字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%85%B1%E7%94%A8%E4%BD%93"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3 共用体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%A4%A7%E5%B0%8F%E7%AB%AF%E5%AD%98%E5%82%A8"><span class="toc-number">1.3.4.</span> <span class="toc-text">3.4 大小端存储</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">字节序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E5%BA%8F"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">位序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E6%9E%9A%E4%B8%BE"><span class="toc-number">1.3.5.</span> <span class="toc-text">3.5 枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-sizeof%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.3.6.</span> <span class="toc-text">3.6 sizeof运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.6.1.</span> <span class="toc-text">使用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%9C"><span class="toc-number">1.3.6.2.</span> <span class="toc-text">使用结果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#struct%E7%9A%84%E7%A9%BA%E9%97%B4%E8%AE%A1%E7%AE%97"><span class="toc-number">1.3.6.3.</span> <span class="toc-text">struct的空间计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AB%E4%BD%8D%E5%9F%9F%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E7%A9%BA%E9%97%B4%E8%AE%A1%E7%AE%97"><span class="toc-number">1.3.6.4.</span> <span class="toc-text">含位域的结构体的空间计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#union%E7%9A%84%E7%A9%BA%E9%97%B4%E8%AE%A1%E7%AE%97"><span class="toc-number">1.3.6.5.</span> <span class="toc-text">union的空间计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%9A%84%E7%A9%BA%E9%97%B4%E8%AE%A1%E7%AE%97"><span class="toc-number">1.3.6.6.</span> <span class="toc-text">枚举的空间计算</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%8A%E5%85%B6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.4.</span> <span class="toc-text">4.  运算符及其优先级</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.4.1.</span> <span class="toc-text">赋值语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%A2%9E%E4%B8%8E%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.4.2.</span> <span class="toc-text">自增与自减运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E4%B8%8E%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.4.3.</span> <span class="toc-text">关系与逻辑运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.4.4.</span> <span class="toc-text">位运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.4.5.</span> <span class="toc-text">赋值转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.4.6.</span> <span class="toc-text">表达式转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E8%BD%AC%E6%8D%A2%EF%BC%88%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%89"><span class="toc-number">1.4.7.</span> <span class="toc-text">显示转换（强制类型转换）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E8%A1%A8"><span class="toc-number">1.4.8.</span> <span class="toc-text">运算符优先级表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-C%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81static%E3%80%81const%E4%BB%A5%E5%8F%8A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.5.</span> <span class="toc-text">5.  C预处理器、作用域、static、const以及内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-C%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">1.5.1.</span> <span class="toc-text">5.1 C预处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8F%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%AE%8F%E6%9B%BF%E6%8D%A2"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">宏定义与宏替换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">文件包含</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">条件编译</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">1.5.2.</span> <span class="toc-text">5.2 全局变量与局部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-static"><span class="toc-number">1.5.3.</span> <span class="toc-text">5.3 static</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#static%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">static的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E4%B8%ADstatic%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">类中static的作用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-const"><span class="toc-number">1.5.4.</span> <span class="toc-text">5.4 const</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%92%8Cconst"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">指针和const</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const%E4%BF%AE%E9%A5%B0%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.5.4.3.</span> <span class="toc-text">const修饰函数参数与返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cosnt%E5%9C%A8%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.5.4.4.</span> <span class="toc-text">cosnt在类中的应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E9%87%8A%E6%94%BE"><span class="toc-number">1.5.5.</span> <span class="toc-text">5.5 内存管理与释放</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.5.1.</span> <span class="toc-text">C语言内存操作函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.5.5.2.</span> <span class="toc-text">C++内存管理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.</span> <span class="toc-text">6. 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">1.6.1.</span> <span class="toc-text">参数传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.2.</span> <span class="toc-text">内联函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="toc-number">1.6.3.</span> <span class="toc-text">默认参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">1.6.4.</span> <span class="toc-text">函数重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.6.5.</span> <span class="toc-text">函数模板与泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.6.5.1.</span> <span class="toc-text">函数模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.6.5.2.</span> <span class="toc-text">类模板</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%92%E5%BD%92"><span class="toc-number">1.6.6.</span> <span class="toc-text">函数的递归</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8"><span class="toc-number">1.7.</span> <span class="toc-text">7. 指针与引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">1.7.1.</span> <span class="toc-text">指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">指针的声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#typedef"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">typedef</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#void-%E6%8C%87%E9%92%88"><span class="toc-number">1.7.1.3.</span> <span class="toc-text">void* 指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">1.7.1.4.</span> <span class="toc-text">指向指针的指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">1.7.1.5.</span> <span class="toc-text">函数指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8E%E6%8C%87%E9%92%88"><span class="toc-number">1.7.1.6.</span> <span class="toc-text">野指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">1.7.2.</span> <span class="toc-text">引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#const%E5%BC%95%E7%94%A8%EF%BC%88%E5%B8%B8%E5%BC%95%E7%94%A8%EF%BC%89"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">const引用（常引用）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%81%9A%E7%B1%BB%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">引用做类的数据成员</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E7%B1%BB"><span class="toc-number">1.8.</span> <span class="toc-text">8. 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E8%AE%BF%E9%97%AE%E6%A0%87%E5%8F%B7"><span class="toc-number">1.8.1.</span> <span class="toc-text">8.1 访问标号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E7%B1%BB%E6%88%90%E5%91%98%E7%AE%80%E4%BB%8B"><span class="toc-number">1.8.2.</span> <span class="toc-text">8.2 类成员简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.8.2.2.</span> <span class="toc-text">构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-number">1.8.2.2.1.</span> <span class="toc-text">成员初始化列表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.8.2.2.2.</span> <span class="toc-text">拷贝构造函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#x3D-x3D-%E6%B5%85%E5%A4%8D%E5%88%B6%E4%B8%8E%E6%B7%B1%E5%A4%8D%E5%88%B6-x3D-x3D"><span class="toc-number">1.8.2.2.3.</span> <span class="toc-text">&#x3D;&#x3D;浅复制与深复制&#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.8.2.3.</span> <span class="toc-text">析构函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.8.2.4.</span> <span class="toc-text">构造函数与析构函数调用顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">1.8.2.5.</span> <span class="toc-text">操作符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">1.8.2.5.1.</span> <span class="toc-text">赋值操作符重载</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#operator-new%E5%92%8Coperator-delete%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">1.8.2.5.2.</span> <span class="toc-text">operator new和operator delete的重载</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E8%BD%BD%E3%80%81%E8%A6%86%E7%9B%96%E4%B8%8E%E9%9A%90%E8%97%8F"><span class="toc-number">1.8.3.</span> <span class="toc-text">8.3 成员函数的重载、覆盖与隐藏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">1.8.3.1.</span> <span class="toc-text">成员函数的重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E8%A6%86%E7%9B%96"><span class="toc-number">1.8.3.2.</span> <span class="toc-text">成员函数的覆盖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E9%9A%90%E8%97%8F"><span class="toc-number">1.8.3.3.</span> <span class="toc-text">成员函数的隐藏</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B"><span class="toc-number">1.9.</span> <span class="toc-text">9. 面向对象编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E7%BB%A7%E6%89%BF"><span class="toc-number">1.9.1.</span> <span class="toc-text">9.1 继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%B1%BB%E6%88%90%E5%91%98%E5%9C%A8%E6%B4%BE%E7%94%9F%E7%B1%BB%E4%B8%AD%E7%9A%84%E8%AE%BF%E9%97%AE%E5%B1%9E%E6%80%A7"><span class="toc-number">1.9.1.1.</span> <span class="toc-text">基类成员在派生类中的访问属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%97%B6%E5%AF%BC%E8%87%B4%E7%9A%84%E4%BA%8C%E4%B9%89%E6%80%A7"><span class="toc-number">1.9.1.2.</span> <span class="toc-text">继承时导致的二义性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.9.1.2.1.</span> <span class="toc-text">类间的转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E5%9F%BA%E7%BB%A7%E6%89%BF"><span class="toc-number">1.9.1.2.2.</span> <span class="toc-text">多基继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF"><span class="toc-number">1.9.1.2.3.</span> <span class="toc-text">菱形继承</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.9.1.3.</span> <span class="toc-text">转换构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="toc-number">1.9.1.4.</span> <span class="toc-text">类型转换函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E8%99%9A%E5%87%BD%E6%95%B0%E5%A4%9A%E6%80%81"><span class="toc-number">1.9.2.</span> <span class="toc-text">9.2 虚函数多态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E8%81%94%E7%BC%96%E4%B8%8E%E5%8A%A8%E6%80%81%E8%81%94%E7%BC%96"><span class="toc-number">1.9.2.1.</span> <span class="toc-text">静态联编与动态联编</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-number">1.9.2.1.1.</span> <span class="toc-text">虚函数的访问</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">1.9.2.1.2.</span> <span class="toc-text">构造函数和析构函数中的虚函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E6%8C%87%E9%92%88%EF%BC%88vptr%EF%BC%89%E5%8F%8A%E8%99%9A%E5%9F%BA%E7%B1%BB%E8%A1%A8%E6%8C%87%E9%92%88%EF%BC%88bptr%EF%BC%89"><span class="toc-number">1.9.2.2.</span> <span class="toc-text">虚函数表指针（vptr）及虚基类表指针（bptr）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E6%8C%87%E9%92%88"><span class="toc-number">1.9.2.2.1.</span> <span class="toc-text">虚函数表指针</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%AB%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E7%9A%84%E7%A9%BA%E9%97%B4%E8%AE%A1%E7%AE%97"><span class="toc-number">1.9.2.2.2.</span> <span class="toc-text">含静态变量、虚函数的类的空间计算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.9.2.2.3.</span> <span class="toc-text">虚函数表的实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E5%9F%BA%E7%B1%BB%E8%A1%A8%E6%8C%87%E9%92%88"><span class="toc-number">1.9.2.2.4.</span> <span class="toc-text">虚基类表指针</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF%E6%97%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E4%B9%A6%E5%86%99"><span class="toc-number">1.9.2.3.</span> <span class="toc-text">虚拟继承时构造函数的书写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">1.9.2.4.</span> <span class="toc-text">纯虚函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-%E5%8A%A8%E6%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E8%AF%86%E5%88%AB%E4%B8%8E%E6%98%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.9.3.</span> <span class="toc-text">9.3 动态运行时类型识别与显式转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#typeid"><span class="toc-number">1.9.3.1.</span> <span class="toc-text">typeid</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.9.3.2.</span> <span class="toc-text">显示转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#reinterpret-cast"><span class="toc-number">1.9.3.2.1.</span> <span class="toc-text">reinterpret_cast</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#const-cast"><span class="toc-number">1.9.3.2.2.</span> <span class="toc-text">const_cast</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#static-cast"><span class="toc-number">1.9.3.2.3.</span> <span class="toc-text">static_cast</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#dynamic-cast"><span class="toc-number">1.9.3.2.4.</span> <span class="toc-text">dynamic_cast</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/16107" title="Hello World">Hello World</a><time datetime="2023-10-05T11:40:46.695Z" title="Created 2023-10-05 19:40:46">2023-10-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/34953" title="渗透测试全流程">渗透测试全流程</a><time datetime="2022-08-04T16:00:00.000Z" title="Created 2022-08-05 00:00:00">2022-08-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/39395" title="基础概念与信息收集">基础概念与信息收集</a><time datetime="2022-08-04T16:00:00.000Z" title="Created 2022-08-05 00:00:00">2022-08-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/58219" title="反序列化漏洞">反序列化漏洞</a><time datetime="2022-08-04T16:00:00.000Z" title="Created 2022-08-05 00:00:00">2022-08-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/57467" title="XXE">XXE</a><time datetime="2022-08-04T16:00:00.000Z" title="Created 2022-08-05 00:00:00">2022-08-05</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2023 By <a class="footer-bar-link" href="/" title="ccb" target="_blank">ccb</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">Articles</div><div class="length-num">40</div></a><a href="/tags/" title="tag"><div class="headline">Tags</div><div class="length-num">6</div></a><a href="/categories/" title="category"><div class="headline">Categories</div><div class="length-num">0</div></a></div><span class="sidebar-menu-item-title">Function</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="Display Mode"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>Display Mode</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/DVWA%E9%9D%B6%E5%9C%BA/" style="font-size: 0.88rem;">DVWA靶场<sup>10</sup></a><a href="/tags/%E5%AE%9E%E8%AE%AD-%E7%BD%91%E7%BB%9C%E5%BB%BA%E8%AE%BE%E9%83%A8%E5%88%86/" style="font-size: 0.88rem;">实训-网络建设部分<sup>7</sup></a><a href="/tags/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/" style="font-size: 0.88rem;">搭建博客<sup>1</sup></a><a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 0.88rem;">机器学习<sup>1</sup></a><a href="/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/" style="font-size: 0.88rem;">渗透测试<sup>15</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" style="font-size: 0.88rem;">计算机基础<sup>5</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.8",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 ccb 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "visitor@anheyu.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>