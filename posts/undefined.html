<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>数据结构 | CCB</title><meta name="keywords" content="计算机基础"><meta name="author" content="ccb"><meta name="copyright" content="ccb"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="数据结构"><meta name="application-name" content="数据结构"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="数据结构"><meta property="og:url" content="https://frankcao3.github.io/posts/undefined.html"><meta property="og:site_name" content="CCB"><meta property="og:description" content="数据结构线性表：具有相同特性的数据元素的一个有限序列。 具有有穷性、一致性（所有元素的性质相同）、序列性（所有元素的相对位置是线性的，即存在唯一的开始元素和终端元素，除此之外每个元素只有唯一的前驱元素和后继元素）。 线性表的顺序存储结构：顺序表，借助数组实现（数组存放线性表元素、另外一个int型的值"><meta property="og:locale" content="en"><meta property="og:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta property="article:author" content="ccb"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta name="description" content="数据结构线性表：具有相同特性的数据元素的一个有限序列。 具有有穷性、一致性（所有元素的性质相同）、序列性（所有元素的相对位置是线性的，即存在唯一的开始元素和终端元素，除此之外每个元素只有唯一的前驱元素和后继元素）。 线性表的顺序存储结构：顺序表，借助数组实现（数组存放线性表元素、另外一个int型的值"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://frankcao3.github.io/posts/undefined"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"Author: ccb","link":"Link: ","source":"Source: CCB","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.","copySuccess":"Copy success, copy and reprint please mark the address of this article"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'CCB',
  title: '数据结构',
  postAI: '',
  pageFillDescription: '数据结构, 1 链表, 1.1 单链表, 1.2 快慢指针, 1.3 双链表, 2 栈与队列, 2.1 栈（堆栈）, 栈的顺序存储结构, 栈的链式存储结构——链栈, 2.2 栈的应用, 中缀表达式和后缀表达式, 后缀表达式的求值, 2.3 Catalan数, 进出栈序列, 括号序列, 二叉树, 2.4 队列, 队列的顺序存储结构, 环形队列, 队列的链式存储结构——链队, 3 树, 3.1 树的基本概念和性质, 基本概念, 性质, 树的存储结构, 3.2 二叉树, 满二叉树, 完全二叉树, 二叉树的性质, 二叉树的存储结构, x3Dx3D二叉树的遍历x3Dx3D, 3.3 二叉树的应用, 3.4 树的应用, 二叉排序树 BST, 平衡二叉树 AVL, B树和B+树, 红黑树, 哈夫曼树及哈夫曼编码, 3.5 并查集, 4 图, 4.1 图的基本概念, 4.2 图的存储及基本操作, 邻接矩阵法, 邻接表法, 4.3 图的遍历, x3Dx3D深度优先搜索DFSx3Dx3D, x3Dx3D广度优先搜索 BFSx3Dx3D, 4.4 图遍历算法的应用, 4.5 图的基本应用, 最小生成树, 最短路径, x3Dx3DDijkstra算法x3Dx3D（BFS+贪心）求单源最短的径问题, x3Dx3DFloyd算法x3Dx3D（动态规划）, 拓扑排序, 5 排序, 5.1 插入排序, 直接插入排序, 希尔排序, 5.2 交换排序, 冒泡排序, x3Dx3D快速排序x3Dx3D（常考）, 快排一次排序的应用, 5.3 选择排序, 简单选择排序, 堆排序, 堆排序的应用, 5.4 归并排序, 二路归并排序, 多路归并排序, 5.5 计数排序, x3Dx3D5.5 桶排序x3Dx3D（重要）, 5.5 基数排序（重要）, 5.6 不同排序算法的比较, 6 查找, 6.1 基本概念, 6.2 折半查找, 6.3 键树, 键树的定义与Trie树, 键树的两种实现的对比, 6.4 后缀树与后缀数组, 后缀树, 后缀数组, 6.5 哈希表(重点), 基本概念, hash函数, 处理冲突（碰撞）的方法, 6.6 一致性哈希, 普通集群, hash集群, 一致性哈希, 6.7 海量数据处理, 分治——hash映射, Bit-map, Bloom Filter, 倒排索引法数据结构线性表具有相同特性的数据元素的一个有限序列具有有穷性一致性所有元素的性质相同序列性所有元素的相对位置是线性的即存在唯一的开始元素和终端元素除此之外每个元素只有唯一的前驱元素和后继元素线性表的顺序存储结构顺序表借助数组实现数组存放线性表元素另外一个型的值存放线性表长度顺序表求线性表长度按索引取元素的时间复杂度为按值查找元素的时间复杂度为插入删除元素的平均时间复杂度为链表线性表的链式存储结构链表可分为单链表双链表循环链表链表可用来表示线性表也可以用来表示各种非线性的数据结构单链表单链表结点类型描述如下单链表的建立头插法常用在将一个已存在的链表逆序头插法使用头插法将链表逆序遍历结点头插法更新指针尾插法需要增加一个尾指针始终指向当前链表的尾结点初始化尾指针尾插法单链表的插入删除取元素的时间复杂度均为求线性表长度的时间复杂度为求线性表中某个元素的值按值查找元素以及插入删除元素的时间复杂度均为顺序表和链表的比较存取方式顺序表可以顺序存取也可以随机存取链表只能从表头顺序存取元素查找插入和删除操作对于按值查找当顺序表在无序的情况下两者的时间复杂度均为而当顺序表有序时可采用折半查找此时时间复杂度为对于按序号查找顺序表支持随机访问时间复杂度仅为而链表的平均时间复杂度为顺序表的插入删除操作平均需要移动半个表长的元素因此平均时间复杂度为链表的插入删除操作时只需要修改相关结点的指针域即可时间复杂度均为空间分配链式存储的结点空间在需要的时候申请分配操作灵活高效快慢指针快慢指针中的快慢指的是移动的步长即每次向前移动速度的快慢例如可以让快指针每次沿链表向前移动慢指针每次向前移动次用途判断单链表是否存在环如果链表存在环就好似操场的跑道是一个环形此时让快慢指针都从链表头开始遍历快指针每次向前移动两个位置慢指针每次向前移动一个位置如果快指针到达说明链表以为结尾没有环如果快指针追上慢指针则表示有环寻找循环链表的入口假设链表存在环那么怎么寻找环的入口呢假设链表长为起始点到环入口长度为环长度为则如图所示在快指针进入环到慢指针进入环前的这段时间若环的长度较短也许快指针已经走了好几圈了然后慢指针进入环设慢指针和快指针在环内相遇时慢指针在环内走了步走的总步数包括环内与环外为步显然那么快指针走了多少步呢快指针在环内已经走了圈加步即步其中最少为而走的总步数为步由于快指针走的总步数为慢指针的倍故由上式得即因此和相差的整数倍也就是说若令快慢指针的步长均为慢指针从链表头开始走快指针从相遇点也继续往前走两者走的距离为时两者相遇此时就是环入口的位置寻找相遇点有环没有相遇因而没有环确定环入口将从开始移动从相遇点处移动现在指向的就是环入口在有序链表中寻找中位数利用快慢指针可不借助计数器变量实现寻找中位数的功能原理是快指针的移动速度是慢指针移动速度的倍因此当快指针到达链表尾时慢指针到达中点程序还要考虑链表结点个数的奇偶数因素当快指针移动次每次步后到达表尾说明链表有奇数个结点直接返回慢指针指向的数据即可如果快指针是倒数第二个结点说明链表结点个数是偶数这时可以根据规则返回上中位数或下中位数或上中位数下中位数的一半事实上像快慢指针这种用两个指针分别前进来查找某个结点还有其他的形式例寻找倒数第个结点我们可以定义两个指针第一个指针从链表的头指针开始遍历向前走步第二个指针保持不动从第步开始第二个指针也开始从链表的头指针开始遍历由于两个指针的距离保持在当第一个指针到达链表的尾结点时第二个指针正好是倒数第个结点当链表的长度小于的时候返回例确定两个单向链表是否相交若相交找出第一个公共结点解答首先利用快慢指针判断链表是否有环如果都不存在环则如果两个单向链表有公共的结点也就是说两个链表从某一结点开始它们的后继结点指针都指向同一个结点但由于是单向链表的结点每个结点只有一个指针因此从第一个公共结点开始之后它们所有结点都是重合的如下图所示如何寻找相较的第一个结点首先两个链表各遍历一次求出两个链表的长度然后可得出两个链表的长度差然后先在长的链表上遍历个结点之后再同步遍历于是在遍历中第一个相同的结点就是第一个公共的结点此时如果第一个链表的长度为第二个链表的长度为该方法的时间复杂度为如果一个存在环另一个不存在环则这两个链表是不可能相交的如果利用快慢指针发现两个链表都存在环则判断任意一个链表上快慢指针相遇的那个结点在不在另一条链表上共环末尾结点存在环中如果在则相交如果不在则不相交若相交两个链表的入口点可能并不是环上同一个结点则再利用本节的方法各自找出两个链表环的入口点可以定义任一入口点为相交的第一个结点双链表使得查找某个结点的前驱结点的时间复杂度从变为了双链表的插入操作在双链表中所指结点之后插入结点将结点插入结点之后最后修改双链表的删除操作删除双链表中结点的后继结点栈与队列栈与队列同样是线性表具有和线性表相同的逻辑结构但是操作受限栈堆栈栈也叫堆栈其限制是仅允许在表的一端进行插入和删除人们把此端称为栈顶栈顶的第一个元素被称为栈顶元素相对地把另一端称为栈底向一个栈插入新元素又称为进栈或入栈它是把该元素放到栈顶元素的上面使之成为新的栈顶元素从一个栈删除元素又称为出栈或退栈它是把栈顶元素删除掉使其下面的相邻元素成为新的栈顶元素由于堆栈数据结构只允许在一端进行操作因而按照后进先出的原理运作栈的顺序存储结构存放栈中的数据元素下标范围为栈顶指针存放栈顶元素在数组中的下标栈空的条件栈满的条件进栈栈已满入栈栈顶指针加出栈注意为引用栈已空取栈顶元素出栈栈顶指针减取栈顶元素注意为引用栈已空取栈顶元素销毁栈栈的链式存储结构链栈存放栈中的数据元素指针域栈空的条件栈满的条件不考虑进栈插入头节点之后入栈插入头结点之后作为新的首结点出栈注意为引用栈已空指向首结点提取首结点值删除首结点取栈顶元素注意为引用栈已空取栈顶元素栈的应用中缀表达式和后缀表达式中缀表达式运算符在数之间如需要考虑运算符的出现顺序优先级以及括号的使用后缀表达式逆波兰式把运算符放在两个运算对象之后不存在括号也不存在优先级的差别计算过程按照运算符出现的先后次序进行比如对应的后缀表达式为中缀表达式转换为后缀表达式方法一使用两个栈实现要使用到个栈栈用来存放运算符栈用来存放最后的后缀表达式转换原则是从左向右扫描中缀表达式若读到的是操作数则直接存入栈若读到的是运算符该运算符为则直接存入栈该运算符为则将栈中第一个前的所有运算符依次出栈并依次存入栈但是和都不存入栈若该运算符为非括号则将该运算符和栈顶运算符进行比较若高于栈顶运算符则直接存入栈否则将栈顶运算符出栈存入栈然后继续与新的栈顶元素比较直到该运算符能存入使得中优先级高的运算符在前或者说接近栈底当扫描完后栈中还有运算符时则将所有的运算符出栈存入栈转换为后缀表达式的过程如下方法二使用语法树实现方法三加括号法先按照运算符的优先级对中缀表达式加括号变成将运算符移到括号的后面变成去掉括号得到后缀表达式的求值通过后缀表示计算表达式值的过程为顺序扫描表达式的每一项然后根据它的类型做如下相应操作如果该项是操作数则将其压入栈中如果该项是操作符则连续从栈中退出两个操作数和形成运算指令并将计算结果重新压入栈中当表达式的所有项都扫描并处理完后栈顶存放的就是最后的计算结果数卡特兰数是组合数学中一个常出现在各种计数问题中的数列数列的前几项为相关的经典问题进出栈序列个元素进栈序列为则有多少种出栈序列将进栈表示为出栈表示为根据栈本身的特点每次出栈的时候必定之前有元素入栈即对于每个前面都有一个相对应因此出栈序列的所有前缀和必然大于等于并且的数量等于的数量当出现某一前缀和小于时即出现前缀和等于的情况的数量比多一个该出栈序列就是非法的假设和的数量均为将该前缀取反之后就会变成的数量比多一个即存在个个取反后的序列与之前的序列是一一对应的因此非法序列的数量有因此合法的出栈序列的数量为此时我们就得到了卡特兰数的通项括号序列对括号则有多少种括号匹配的括号序列左括号看成右括号看成那么就和上题的进出栈一样每次有右括号的时候必定之前有左括号匹配且序列的所有前缀和必然大于等于并且的数量等于的数量因此共有种序列二叉树个叶子节点能够构成多少种形状不同的国际满二叉树结点要么是叶子结点要么它有两个子结点且叶子节点均在最后一层使用深度优先搜索这个满二叉树向左扩展时标记为向右扩展时标记为由于每个非叶子节点都有两个左右子节点所有它必然会先向左扩展再向右扩展总体下来左右扩展将会形成匹配即变成进出栈的题型个叶子结点会有次扩展构成种形状不同的满二叉树基本上所有的卡特兰数问题经过一定的转换都可以还原成进出栈问题其中都会存在一种匹配关系如进出栈匹配括号匹配等一旦计数问题中存在这种关系那我们就需要去考虑这是否是卡特兰数问题此外我们还可以记住序列前四项这些将有利于我们联想到卡特兰数例如以下问题的题解均为卡特兰数有个人排成一行进入剧场入场费元其中只有个人有一张元钞票另外人只有元钞票剧院无其他钞票问有多少种方法使得只要有元的人买票售票处就有元的钞票找零种一位大城市的律师在她住所以北个街区和以东个街区处工作每天她走个街区去上班如果她从不穿越但可以碰到从家到办公室的对角线那么有多少条可能的道路种在圆上选择个点将这些点成对连接起来使得所得到的条线段不相交的方法数种矩阵连乘依据乘法结合律不改变其顺序只用括号表示成对的乘积试问有几种括号化的方案种队列一种操作受限的线性表仅允许在表的一端队尾进行插入操作入队而在表的另一端队首进行删除操作出队因此队列也叫做先进先出表队列的顺序存储结构队列中的元素队头指针和队尾指针初始值队空的条件队满的条件进队增然后将元素插入到该位置队满队尾增队尾插入元素出队增然后将该位置的元素赋给队空队列的元素个数进队时增出队时增这样整个队列会在数组中慢慢向右移动容易出现假溢出的情况环形队列按照的队满条件判断时可能存在假溢出的情况另一端仍然存在空位置解决的办法是把数组的前后端连接在一起形成环形队列循环队列用数组实现队列的话循环队列一般是必需的环形队列的队空条件环形队列的队满条件环形队列的进队增然后将元素插入到该位置队满队尾增注意环形队列的指针是循环增也就是还要对取余队尾插入元素环形队列的出队增然后将该位置的元素赋给队空队头增注意环形队列的指针是循环增也就是还要对取余环形队列的元素个数队列的链式存储结构链队链队中的数据结点类型的声明如下存放元素下一个结点指针链队头结点类型的声明如下指向队首结点指向队尾结点队空的条件或者队满的条件不考虑进队新建结点存放元素由指向它将结点插入作为尾结点要注意原来队列为空的情况队列为空和将都指向新增的结点队尾插入元素更新队尾指针出队取出队首结点的值并将其删除要注意原来的队列仅有一个数据结点的情况用于暂存队首结点队空取队首结点原来的队列仅有一个数据结点树树的基本概念和性质基本概念树是个结点的有限集当时树为空树时有且仅有一个结点作为树的根节点树中一个结点的子结点个数称为该结点的度树中结点的最大度数称为树的度通常将度为的树成为次树度不为的结点称为分支结点度为的结点称为叶子结点结点的层次从树根开始定义根结点为第层它的子结点为第层以此类推结点的深度是从根结点开始自顶向下逐层累加的结点的高度是从叶结点开始自底向上逐层累加的树中结点的最大层数称为树的高度或深度有序树和无序树将子结点视为有顺序的树称为有序树反之则称为无序树有序树中一个结点其子结点按从左到右顺序出现是有关联的森林是棵互不相交的树的集合森林的概念与树的概念十分相近因为只要把树的根结点删去就成了森林反之只要给棵独立的树加上一个结点并把这棵树作为该结点的子树则森林就变成了树性质树具有如下最基本的性质树中的结点数等于所有结点的度数加度为的树中第层上至多有个结点高度为的叉树至多有个结点的等比数列求和具有个结点的叉树的最小高度为根据计算得到树的存储结构双亲存储结构树的一种顺序存储结构用一组连续空间存储树的所有结点每个结点中设有一个伪指针指示其双亲结点的位置固定根结点的双亲结点位置为存放结点的值存放双亲结点位置特点容易查找某个结点的双亲结点但是在求某个结点的孩子结点时需要遍历整个树孩子链存储结构每个结点的存储空间不仅包括结点值还有指向其所有孩子结点的指针需要按照树的度来设计结点的孩子结点指针的指针域个数存放结点的值指向孩子结点为最多的孩子结点个数即该树的度特点查找孩子结点方便但是查找双亲结点费时并且当树的度较大时存在较多的空指针域孩子兄弟链存储结构每个结点设计了个域包括数据元素域一个指向该结点的左边第一个孩子的指针域一个指向该结点的下一个兄弟结点的指针域这样每个结点就固定只有个指针域且这两个指针域是有序的类似二叉树的存储结构存放结点的值指向兄弟结点指向孩子结点二叉树二叉树是另一种树形结构是个结点的有限集合其特点是每个结点至多只有两棵子树即二叉树中不存在度大于的结点并且二叉树的子树有左右之分其次序不能任意颠倒二叉树是有序树若将其左右子树颠倒就成为另一棵不同的二叉树即使树中结点只有一棵子树也要区分它是左子树还是右子树注意二叉树与度为的有序树的区别度为的树至少有个结点而二叉树可以为空度为的有序树的孩子结点的左右次序是相对于另一孩子结点而言的如果某个结点只有一个孩子结点这个孩子结点就无须区分其左右次序而二叉树无论其孩子数是否为均需确定其左右次序下面介绍几种特殊的二叉树满二叉树叶子结点都集中在二叉树的最下一层并且除叶子结点之外的每个结点度数均为的二叉树称为满二叉树即树中的每一层都含有最多的结点如图所示或者也可以说一棵高度为且含有个结点的树为满二叉树可以对满二叉树按层序编号约定编号从根结点根结点编号为起自上而下自左向右这样每个结点对应一一个编号对于编号为的结点如果有双亲其双亲为如果有左孩子则左孩子为如果有右孩子则右孩子为完全二叉树设一个高度为有个结点的二叉树当且仅当其每一个结点都与高度为的满二叉树中编号为的结点一一对应时称为完全二叉树如图所示这种树的特点如下若则结点为分支结点否则为叶子结点层次遍历前一半的结点均为分支结点后一半均为叶子结点叶子结点只可能在层次最大的两层上出现最大层次中的叶子结点都依次排列在该层最左边的位置上如果有度为的结点只可能有一个且该结点只有左孩子而无右孩子按层序编号后一旦出现某结点其编号为为叶子结点或只有左孩子则编号大于的结点均为叶子结点若为奇数则每个分支结点都有左孩子和右孩子若为偶数则编号最大的分支结点编号为只有左子女没有右子女其余分支结点左右子女都有注意性质中表明完全二叉树中度为的结点数要么为要么为当总结点数为偶数时度为的结点数为当总结点数为奇数时度为的结点数为叶子结点数为总结点数二叉树的性质二叉树的性质非空二叉树上叶子结点度为数等于度为的结点数加即证明设度为和的结点个数分别为和结点总数再看二叉树中的分支数除根结点外其余结点都有一个分支进入设为分支总数则由于这些分支是由度为或的结点射出的所以又有于是得非空二叉树上第层上至多有个结点高度为的二叉树至多有个结点对完全二叉树按从上到下从左到右的顺序依次编号则有以下关系当时结点的双亲结点编号为即当为偶数时其双亲结点的编号为它是双亲结点的左孩子当为奇数时其双亲结点的编号为它是双亲结点的右孩子当时结点的左孩子编号为否则无左孩子当时结点的右孩子编号为否则无右孩子结点所在层次深度为具有个结点的完全二叉树的高度为或者例题二叉树的存储结构二叉树的顺序存储结构顺序存储就是用一组地址连续的存储单元依次自上而下自左而右存储完全二叉树的结点元素即将完全二叉树编号为的结点元素存储在某个数组下标为的分量中对于一般二叉树则应将其每个结点与完全二叉树上的结点相对照存储在一维数组的相应分量中为方便运算一般下标为的位置空着空结点用表示然而在最坏的情况下一个高度为且只有个结点的单支树却需要占据接近个存储单元因此顺序存储结构一般仅适用在完全二叉树中二叉树的链式存储结构每个结点由三个域组成包括数据域指向该结点左孩子结点的指针域指向该结点右孩子结点的指针域容易验证在有个结点的二叉树中每个结点有个指针域因此一共存在个链域其中除根结点外其余结点均有指针指向因此有个有效链域个空链域二叉树的遍历很多问题的求解是借助二叉树的遍历完成的重点为二叉树遍历的非递归算法先序遍历递归非递归使用顺序栈实现辅助栈根节点先进栈直到栈中没有节点每次栈顶就是访问的元素如果有右孩子则右孩子进栈如果有左孩子则左孩子进栈中序遍历递归非递归使用顺序栈实现辅助栈当树结点不为空或栈中有结点时每次先找到最左结点路径上的结点均入栈弹出栈顶左孩子为空进入右孩子结点后序遍历递归非递归使用顺序栈实现返回结果辅助栈指针和栈均为空时结束循环每次先找到最左边的结点路径上的结点均入栈弹出栈顶如果该结点没有右孩子或是右孩子已经访问过访问该结点自身且记录为访问过了有右孩子则该结点入栈先去访问右孩子层序遍历借助队列实现使用队列实现取队首结点左右孩子入队二叉树的应用判断两颗二叉树是否相同运用递归的方法按照先序遍历对比即可树为空的情况根结点相等继续对比左孩子和右孩子进一步的比较两棵可以旋转的二叉树是否相等二叉树的左右子结点可以旋转是指可以把二叉树的左结点旋转成为右结点右结点旋转成为左结点百度若左右子结点可以旋转的话需要将递归的代码改为如下内容求二叉树的深度从根结点到叶结点依次经过的结点含根叶结点形成树的一条路径最长路径的长度为树的深度相当于做后序遍历求二叉树中结点的最大距离如果我们把二叉树视为一个图父子结点之间的连线视为双向的我们姑且定义距离为两结点之间边的个数写一个程序求一棵二叉树中相距最远的两个结点之间的距离分析计算一个二叉树的最大距离有两个情况情况路径经过左子树的最深结点通过根结点再到右子树的最深结点情况路径不穿过根结点而是左子树或右子树的最大距离路径取其大者只需要计算这两个情况的路径距离并取其大者就是该二叉树的最大距离定义返回结果最大距离最大深度最大深度初始化为是因为调用者要对其加然后变为使得无子树的最大深度为树的最大深度情况情况一棵二叉树每个结点包含一个整数请设计一个算法输出所有满足条件的路径此路径上的所有结点之和等于给定值注意此类路径不要求必须从根结点开始满足条件的路径不唯一该题可利用先序遍历输出结果默认当前结点加入减去中已有元素找到路径深度加大小加继续遍历左孩子结点回溯到当前结点然后继续遍历右孩子结点由遍历序列构造二叉树重建二叉树在先序遍历序列中第一个结点一定是二叉树的根结点而在中序遍历中根结点必然将中序序列分割成两个子序列前一个子序列就是根结点的左子树的中序序列后一个子序列是根结点的右子树的中序序列根据这两个子序列可以在先序序列中找到对应的左子序列和右子序列在先序序列中左子序列的第一个结点是左子树的根结点右子序列的第一个结点是右子树的根结点如此递归地进行下去便能唯一地确定这棵二叉树即先序序列和中序序列可以唯一地确定一棵二叉树同理由二叉树的后序序列和中序序列也可以唯一地确定一棵二叉树因为后序序列的最后一个结点就如同先序序列的第一个结点可以将中序序列分割成两个子序列然后采用类似的方法递归地进行划分就可以得到一棵二叉树由二叉树的层序序列和中序序列也可以唯一地确定一棵二叉树需要注意的是如果只知道二叉树的先序序列和后序序列是无法唯一确定一棵二叉树的例求先序序列和中序序列所确定的二叉树由先序序列确定根结点再由中序序列确定该根结点的左子树右子树再依次递归下去例输入某二叉树的前序遍历和中序遍历的结果请重建出该二叉树假设输入的前序遍历和中序遍历的结果中都不含重复的数字例如输入前序遍历序列和中序遍历序列则重建二叉树并输出它的后序遍历序列剑指例题存放先序序列存放中序序列为二叉树的结点个数返回构造的二叉树的根结点指针根结点在中序序列中寻找根结点确定根结点在中序序列中的位置也是左子树的序列长度递归构造左子树和均指向左子树序列的开头递归构造右子树和均指向右子树列的开头树的应用二叉排序树二叉排序树也称为二叉查找树二叉搜索树或二叉排序树或者是一棵空树或者是一棵具有下列特性的非空二叉树若左子树非空则左子树上所有结点关键字值均小于根结点的关键字值若右子树非空则右子树上所有结点关键字值均大于根结点的关键字值左右子树本身也分别是一棵二叉排序树由此定义可知二叉排序树是一个递归的数据结构根据二叉排序树的定义有左子树结点值根结点值右子树结点值所以对二叉排序树进行中序遍历可以得到一个递增的有序序列二叉排序树的查找操作的时间复杂度是比较次数与树的深度有关例如图的二叉排序树的中序遍历序列为判断一个二叉树是否为二叉排序树使用中序遍历二叉树判断是否为递增序列复杂度定义为最小的整数中序遍历左子树不是二叉排序树或者根结点值不大于更新为根结点的值即右子树的所有结点值均要大于平衡二叉树为了避免树的高度增长过快降低二叉排序树的性能我们规定在插入和删除二叉树结点时要保证任意结点的左右子树高度差的绝对值不超过并将这样的二叉排序树称为平衡二叉树简称平衡树树定义结点左子树与右子树的高度差为该结点的平衡因子则平衡二叉树结点的平衡因子的值只可能是或因此平衡二叉树可定义为它或者是一棵空树或者是具有下列性质的二叉树它的左子树和右子树都是平衡二叉树且左子树和右子树的高度差的绝对值不超过平衡二叉树的操作效率查询插入删除效率较高时间复杂度是即树的深度图所示是不平衡的二叉树结点中的值为该结点的平衡因子判断一棵二叉树是不是平衡二叉树解法一递归的思路遍历树的每个结点求出其左右子树的深度计算深度差解法二解法一虽然简洁但是每个结点会被遍历多次效率较低如果我们用后序遍历的方式遍历二叉树的每一个结点在遍历到一个结点之前我们已经遍历了它的左右子树只要在遍历每个结点的时候记录它的高度我们就可以一边遍历一边判断每个结点是不是平衡的下面是这种思路的参考代码取左右子树中深度的最大值解法三除此之外下面的方法也是可行的且形式更加简洁求出根结点的最大深度与最小深度则最大深度与最小深度之差就是树中任一子树深度差最大值所以只要小于等于此树就是平衡二叉树代码如下求树的最大深度求树的最小深度计算根结点的最大深度与最小深度之差小于等于就说明是平衡二叉树树和树参考树和树都是多路查找树为了解决数据量大树的高度大增二叉树而产生的一种数据结构树树又称为多路平衡查找树是二叉排序树的扩展满足平衡的性质所有结点的平衡因子均等于结点又拥有多个子树对于组织和维护外存文件系统非常有效数据库把树中结点所拥有的最大的子树数目称为树的阶通常记为一颗阶树或为空树或为满足如下特性的叉树树中每个结点至多有个孩子结点同时至多含有个关键字每两颗子树指针夹着一个关键字若根结点不是叶子结点则至少有两个孩子结点至少一个关键字除根结点外的所有非叶子结点至少有棵子树即至少含有个关键字所有的外部结点出现在同一个层次上不带信息但是计算树的高度时需要考虑外部结点就像是折半查找判断树中查找失败的结点每一个结点中的关键字按递增的顺序排列关键字两边为指向孩子结点的指针树中的非叶子结点对应数据库查找时的关键字叶子结点对应要查找的详细记录而外部结点对应查找失败指向它的指针为不含有任何信息一颗含有个关键字的树有个外部结点树的插入向树插入结点时只能向叶子结点插入当叶子结点的关键字个数小于时直接在该结点增加关键字即可注意保持递增当叶子结点的关键字个数等于时无法继续增加关键字这时采用分裂法比如一棵阶树结点的关键字个数最多为有一关键字为的结点需要插入定位到在叶子节点中插入时发现关键字已满此时对该叶子结点进行分裂选取的中位数作为双亲结点提升到上一层中其余关键字作为孩子结点留在本层若关键字提升到双亲结点后造成双亲结点的关键字数量超过那么双亲结点也进行同样的分裂树的删除删除关键字时同样也要考虑结点内原本关键词的数量保证结点始终拥有至少个关键字当结点内关键字数量大于这时删除这个关键字不会破坏树的定义要求所以直接删除即可比如删除关键字当结点内关键字数量等于并且其左右兄弟结点中存在关键字数量大于的结点则删除后去兄弟结点中借关键字比如删除关键字而每个结点应至少有个关键字所以结构调整子树结构为根结点为为左孩子为右孩子当结点内关键字数量等于并且其左右兄弟结点中不存在关键字数量大于的结点则需要进行结点合并比如删除关键字后无法向兄弟结点借关键字所以调整子树结构为如下如果删除的关键字不在终端结点上最底层非叶子结点需要先转换成在终端结点上找相邻关键字替换再按照在终端结点上的情况来分别考虑对应的方法树树是树的一些变形是常用于数据库和操作系统的文件系统中的一种用于查找的数据结构包括等主流数据库树的性质阶树的每个分支结点至多有个子树不用来保存数据而是保存数据的索引除根结点外的所有非叶子结点至少有棵子树根结点要么没有子树要么至少有个子树有棵子树的结点恰好有个关键字所有的叶子结点中包含了全部关键字的信息及指向含这些关键字记录的指针且叶子结点本身依关键字的大小自小而大顺序链接非叶子结点的元素在叶子结点上有冗余非叶子结点的数据只是作为索引来帮助查找叶子结点元素所有的非终端结点可以看成是索引部分结点中仅含其子树中的大或小关键字树中数据对象的插入和删除仅在叶节点上进行树有个头指针一个是树的根节点用于随机查找一个是小关键码的叶节点指针用于顺序查找范围查找且叶子结点之间有指针索引使用的是树因为索引非叶子结点是用来加快查询的同时而树通过对数据进行排序所以是可以提高查询速度的并且一个结点中可以存储多个元素从而可以使得树的高度不会太高在中一个页就是一个树结点一个页默认存储本结点关键字所以一般情况下一棵两层的树可以存万行左右的数据树一般不会超过层然后通过利用树叶子结点存储了所有数据并且进行了排序并且叶子结点之间有指针可以很好的支持全表扫描范围查找等语句树和树的区别在树中具有个关键字的结点只含有棵子树即每个关键字对应一颗子树而在树中具有个关键字的结点含有棵子树在树中每个结点非根内部结点关键字个数的范围是根结点在树中每个结点非根内部结点关键字个数的范围是根结点在树中叶结点包含信息所有非叶结点仅起到索引的作用非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针不含有该关键字对应的存储地址在树中叶结点包含了全部关键字即在非叶结点中出现的关键字也会出现在叶结点中而在树中叶结点包含的关键字和其他结点包含的关键字是不重复的在树中有一个指针指向关键字最小的叶子结点所有叶子结点连接成一个单链表红黑树参考背景若插入和删除操作总在平衡二叉树的某一子树进行那么大多数的结点都会在根结点的右侧或左侧此时二叉搜索树就接近于一个链表它的操作效率就降低了为了不断维持平衡二叉树的平衡状态就需要对进行旋转处理红黑树的出现是为了解决维持平衡二叉树而导致的成本高的问题比如下面进行平衡二叉树的插入时就需要进行旋转重新维持平衡概念自平衡二叉查找树以前也叫平衡二叉树红黑树具有良好的效率它可在时间内完成查找增加删除等操作红黑树为具备了某些特性的二叉搜索树能解决非平衡树问题是一种接近平衡的二叉树说它是接近平衡因为它并没有像树的平衡因子的概念它只是靠着满足红黑节点的条性质来维持一种接近平衡的结构进而提升整体的性能并没有严格的卡定某个平衡因子来维持绝对平衡红黑树同时具有平衡和排序的特点既接近平衡二叉树又是二叉搜索树性质首先红黑树是一个二叉搜索树它在每个结点增加了一个存储位记录节点的颜色可以是也可以是通过任意一条从根到叶子简单路径上颜色的约束红黑树保证最长路径不超过最短路径的二倍因而近似平衡最短路径就是全黑节点最长路径就是一个红结点一个黑结点当从根结点到叶子结点的所有路径上黑色结点数目相同时最长路径刚好是最短路径的两倍它同时满足以下特性结点是红色或黑色根是黑色叶子结点外部结点空结点都是黑色红色结点的子结点都是黑色红色结点的父结点都是黑色从根结点到叶子结点的所有路径上不能有个连续的红色结点从任一结点到叶子结点空结点的所有路径都包含相同数目的黑色结点哈夫曼树及哈夫曼编码概念结点的权值给树的结点赋予的有某种意义的数值结点的带权路径长度从根结点到该结点之间的路径长度与该结点的权值的乘积树的带权路径长度树中所有叶子结点的带权路径长度之和记为式中是第个叶结点所带的权值是该叶结点到根结点的路径长度哈夫曼树在个带权叶子节点构成的所有二叉树中带权路径长度最小的二叉树称为哈夫曼树原则权值越大的叶子结点越靠近根结点权值越小的叶子结点越远离根结点哈夫曼树的构造给定个权值分别为的结点构造哈夫曼树的算法描述如下将这个结点分别作为棵仅含一个结点的二叉树构成森林从中选取两棵根结点权值最小的树作为左右子树来构造一个新二叉树并且将新二叉树根结点的权值置为左右子树上根的权值之和从中用新得到的树代替刚才选出的两棵树重复步骤和直至中只剩下一棵树为止哈夫曼编码固定长度编码每个字符使用相同长度的二进制位来表示可变长度编码允许对每个字符使用不同长度的二进制位来表示可变长度编码比固定长度编码好得多其特点是对频率高的字符赋予短编码而对频率较低的字符则赋予较长一些的编码从而可以使平均编码长度减短起到压缩数据的效果哈夫曼编码是一种被广泛应用而且非常有效的数据压缩编码它是可变长度编码前缀编码没有一个编码是另一个编码的前缀前缀编码的解码操作相对简单无需考虑重复前缀哈夫曼编码属于前缀编码构造哈夫曼编码首先要构造一棵哈夫曼树首先将每个出现的字符当作一个独立的结点其权值为它出现的频度或次数然后构造出对应的哈夫曼树显然所有字符结点都出现在叶结点中我们可以将字符的编码解释为从根至该字符的路径上边标记的序列其中边标记为表示转向左孩子标记为表示转向右孩子图所示为一个由哈夫曼树构造哈夫曼编码的示例矩形方块表示字符及其出现的次数这棵哈夫曼树的为此处的可以视为最终编码得到二进制编码的长度共位如果采用位固定长度编码则得到的二进制编码长度为位可见哈夫曼编码共压缩了约的数据利用哈夫曼树可以设计出总长度最短的二进制前缀编码并查集并查集是一种树形的数据结构用于处理一些不相交集合的合并及查询问题常常在使用中以森林来表示进行快速规整并查集保持一组不相交的动态集合每个集合通过一个代表来识别代表即集合中的某个成员在某些应用中哪一个成员被选作代表是无所谓的在一些应用中如何选择代表可能存在着预先说明的规则例如选择集合中的最小元素集合中的每一个元素是由一个对象表示的设表示一个对象则并查集应支持以下操作建立一个新的集合其唯一成员就是此时即是代表因为各集合是不相交的故要求没有在其他集合中出现过如果分属不同集合则将包含和的动态集合合并为一个新的集合返回一个指针指向包含所在的集合的代表单链表实现要实现并查集数据结构一种简单的方法是每一个集合都用一个链表来表示每个链表的第一个对象作为它所在集合的代表链表中的每一个对象都包含一个集合成员一个指向包含下一个集合成员的对象的指针以及指向代表的指针每个链表都含指针指向链表的代表以及指针指向链表中最后的对象并查集森林并查集的另一种更快的实现是用有根树来表示集合每棵树表示一个集合树中的结点对应一个成员在下图所示的并查集森林中每个成员仅指向其父结点父结点为其代表每棵树的根为整个集合的代表并且是它自己的父结点图中左侧是两棵表示两个集合的树左边的树表示集合其中为代表右边的树表示集合其中为代表右侧为的结果创建一棵仅包含一个结点的树在执行操作时要沿着父结点指针一直找下去直至找到树根为止操作使得一棵树的根指向另一棵树的根两种并查集森林的改进策略第一种是按秩合并其思想是操作使包含较少结点的树的根指向包含较多结点的树的根这种方法并不显式记录以每个结点为根的子树的大小而是采用了一种能够简化分析的方法对每个结点用秩表示结点高度的一个上界在按秩合并中具有较小秩的根在操作中要指向具有较大秩的根第二种是路径压缩这种方法简单有效它使一棵树的每个结点都直接指向根结点如图所示假如已知有个人和对好友关系存于数字如果两个人是直接或间接的好友好友的好友的好友则认为他们属于同一个朋友圈请写程序求出这个人里一共有多少个朋友圈假如表示有个人和是好友和是好友和是好友则属于一个朋友圈属于另一个朋友圈结果为个朋友圈最后请分析所写代码的时间空间复杂度评分会参考代码的正确性和效率存储每个元素的代表带路径优化的并查集查找算法查找集合的代表并使用路径压缩让所有结点指向该代表寻找此集合的代表只有根结点满足因此当时表示找到了该集合的代表即根结点使得代表的集合中所有结点直接指向即路径压缩继续更新原来的代表优化的并查集归并算法找到的代表找到的代表合并两个集合令的代表指向的代表或者反过来个结点个关系初始化并查集分支数为各点为孤立点各结点代表就是自身所以读入和为有关系的结点统计代表是自己的结点个数也即朋友圈参考图图的基本概念图由顶点集和边集组成记为其中表示图中顶点的有限非空集表示图中顶点之间的关系边集合若用表示图中顶点的个数也称为图的阶用表示图中边的条数注意线性表可以是空表树可以是空树但图不可以是空图就是说图中不能一个顶点也没有图的顶点集一定非空但边集可以为空此时图中只有顶点而没有边有向图若是有向边也称为弧的有限集合时则图为有向图无向图若是无向边简称边的有限集合时则图为无向图在无向图中如果任意两个顶点之间都存在边则称该图为无向完全图含有个顶点的无向完全图有条边在有向图中如果任意两个顶点之间都存在方向相反的两条弧则称该图为有向完全图含有个顶点的有向完全图有条有向边设有两个图和若是的子集且是的子集则称是的子图若有满足的子图则为的生成子图在无向图中若从顶点到顶点有路径存在则称和是连通的若图中任意两个顶点都是连通的则称图为连通图否则称为非连通图无向图中的极大连通子图称为连通分量如果一个图有个顶点并且有小于条边则此图必是非连通图如图所示图有个连通分量在有向图中若从顶点到顶点和从顶点到顶点之间都有路径则称这两个顶点是强连通的若图中任何一对顶点都是强连通的则称此图为强连通图有向图中的极大强连通子图称为有向图的强连通分量图的强连通分量如图所示图中每个顶点的度定义为以该顶点为一个端点的边的数目对于无向图顶点的度是指依附于该项点的边的条数记为在无向图中无向图的全部顶点的度之和等于边数的两倍这是因为每条边和两个顶点相关联对于有向图顶点的度分为入度和出度入度是以顶点为终点的有向边的数目而出度是以顶点为起点的有向边的数目顶点的度等于其入度和出度之和在有向图中有向图的全部顶点的入度之和与出度之和相等并且等于边数这是因为每条有向边都有一个起点和终点图的存储及基本操作邻接矩阵法所谓邻接矩阵存储就是用一个二维数组存储图中边的信息即各顶点之间的邻接关系存储顶点之间邻接关系的二维数组称为邻接矩阵结点数为的图的邻接矩阵是的将的顶点编号为若则否则若或是中的边若或不是中的边对于带权图而言若顶点和之间有边相连则邻接矩阵中对应项存放着该边对应的权值若顶点和不相连则用来代表这两个顶点之间不存在边若或是中的边或若或不是中的边最大顶点数字节型数值的最大数为顶点类型邻接矩阵顶点数边数存放顶点信息图的邻接矩阵存储表示法具有以下特点无向图的邻接矩阵一定是一个对称矩阵并且唯一对于无向图邻接矩阵的第行或第列非零元素或非元素的个数正好是第个顶点的度对于有向图邻接矩阵的第行或第列非零元素或非元素的个数正好是第个顶点的出度或入度用邻接矩阵方法存储图很容易确定图中任意两个顶点之间是否有边相连但是要确定图中有多少条边则必须按行按列对每个元素进行检测所花费的时间代价很大稠密图适合使用邻接矩阵的存储表示邻接表法所谓邻接表就是对图中的每个顶点建立一个单链表第个单链表中的结点表示关联于顶点的边对于有向图则是以顶点的起点的边这个单链表就称为顶点的的边表对于有向图则称为出边表边表的头指针和顶点的数据信息采用顺序存储称为顶点表所以在邻接表中存在两种结点顶点表结点和边表结点如图所示顶点表中存储顶点的名称或其他信息指向顶点的单链表中的首结点边表的表示与顶点邻接的顶点编号指向下一个边结点另外还可以有一个数值域存放边的权值等信息顶点表头结点顶点的其他信息指向第一个边结点边表边结点该边的邻接点编号指向下一条边的指针该边的相关信息比如权值邻接表的头结点数组图的顶点数边数图的邻接表存储方法具有以下特点如果为无向图则所需的存储空间为如果为有向图则所需的存储空间为前者的倍数是由于无向图中每条边在邻接表中出现了两次对于稀疏图采用邻接表表示将极大地节省存储空间在邻接表中给定一顶点能很容易地找出它的所有邻边因为只需要读取它的邻接表就可以在邻接矩阵中相同的操作则需要扫描一行花费的时间为但是如果要确定给定的两个顶点间是否存在边则在邻接矩阵里可以立刻查到在邻接表中则需要在相应结点对应的边表中查找另一结点效率较低图的遍历深度优先搜索深度优先搜索类似于树的先序遍历它的基本思想如下首先访问图中某一起始顶点然后由出发访问与邻接且未被访问的任一顶点再访问与邻接且未被访问的任一顶点重复上述过程当不能再继续向下访问时依次退回到最近被访问的顶点若它还有邻接顶点未被访问过则从该点开始继续上述搜索过程直到图中所有顶点均被访问过为止以邻接表为存储结构的深度优先遍历算法全局数组标记顶点是否已被访问边结点访问该结点置访问标记为指向顶点的第一个邻接点若编号为的结点未被访问则递归访问它继续遍历它的邻接点一轮深度优先遍历结束后回退到出发点继续遍历剩余邻接结点指向顶点的下一个邻接点广度优先搜索广度优先搜索类似于二叉树的层序遍历算法它的基本思想是首先访问起始项点接着由出发依次访问的各个未访问过的邻接顶点然后再依次访问的所有未被访问过的邻接顶点再从这些访问过的顶点出发再访问它们所有未被访问过的邻接顶点以此类推直到图中所有顶点都被访问过为止类似的思想还将应用于单源最短路径算法和最小生成树算法广度优先搜索是一种分层的查找过程每向前走一步可能访问一批顶点不像深度优先搜索那样有往回退的情况因此它不是一个递归的算法为了实现逐层的访问算法必须借助一个辅助队列以记忆正在访问的顶点的下一层顶点用于存储下一次广度搜索时要访问的结点标记顶点是否已被访问置已访问标记队列不为空时出队顶点编号存入指向的第一个邻接结点访问所有的邻接结点并将其入队以进行下一次广度搜索访问该邻接结点并置访问标记为若访问过则继续遍历其余邻接结点图遍历算法的应用判断图的连通性图的遍历算法可以用来判断图的连通性对于无向图来说如果无向图是连通的则从任一结点出发仅需一次遍历就能够访问图中所有顶点如果无向图是非连通的则从某一个顶点出发一次遍历只能访问到该顶点所在连通分量的所有顶点而对于图中其他连通分量的顶点则无法通过这次遍历访问对于有向图来说若从初始点到图中的每个顶点都有路径则能够访问到图中的所有顶点否则不能访问到所有顶点遍历解答树在问题求解时对所有可能的问题解构成一棵树而最优解或者符合要求的解就是该树的一条路径或者一个结点这种树称为解答树例比如的排列一共有个生成它们至少需要的时间图是生成的全排列的解答树通过深度优先遍历就可以输出的全排列的最大值记录解记录某个值是否被遍历过没遍历过为遍历过后为到达叶子结点第一层选择未被访问的数置访问标记为递归遍历下一层回退标记数未被访问初始化数组将中前个字节置按照相同的原理输出数组的全排列表示遍历解答树的深度表示数组下标最大值继续递归遍历解答树的下一层回溯例有分分分分四种硬币每种硬币数量无限给定分钱求有多少种组合可以组合成分钱依然是解答树的深度优先遍历问题回溯法参考统计有多少种组合记录硬币的面值解向量满足条件输出结果无解币种为种也就是解空间树结点有个分支继续深度优先遍历回溯需输入大于的整数背包问题使用深度优先遍历的思想解决背包问题除了用动态规划解决以外是不是也可以利用深度优先遍历解决呢下图为有若干件物品的背包问题解答树我们利用深度优先遍历遍历至每个叶子结点求出小于背包容量的最大值即可代码如下物品最大件数保存解物品件数背包载重量或者体积容量物品的重量或者体积物品的价值解向量到达叶子结点更新最优解超过背包容量该路径不是问题的解保存当前路径解深度优先搜索要或不要两种选择而已不放入放入图的基本应用最小生成树连通图的生成树是包含图中全部顶点的一个极小连通子图若图中顶点数为则它的生成树含有条边对于生成树而言若砍去它的一条边则会变成非连通图若加上一条边则会形成一个回路在非连通图中连通分量的生成树构成了非连通图的生成森林注意区分极大连通子图和极小连通子图极大连通子图是无向图的连通分量极大即要求该连通子图包含其所有的边极小连通子图是连通无向图的生成树极小既要保持图连通又要使得边数最少只有生成树满足条件砍去生成树的任一条边图将不再连通构造最小生成树有多种算法但大多数算法都利用了最小生成树的下列性质假设是一个带权连通无向图是顶点集的一个非空子集若是一条具有最小权值的边其中则必存在一棵包含边的最小生成树基于该性质的最小生成树算法主要有算法和算法它们都基于贪心算法的策略算法运用算法的步骤如下初始化向空树中添加图的任一顶点使循环重复下列操作至从图中选择满足且具有最小权值的边并置算法的时间复杂度为不依赖于因此它适用于求解边稠密的图的最小生成树虽然采用其他方法可以改进算法的时间复杂度但增加了实现的复杂性算法与算法从顶点开始扩展最小生成树不同算法是一种按权值的递增次序选择合适的边来构造最小生成树的方法假设是连通网对应的最小生成树算法的步骤如下初始化使即每个顶点构成一棵独立的树此时是一个仅含个顶点的森林循环重复下列操作至是一棵树按的边的权值递增顺序依次从中选择一条边如果这条边加入后不构成回路则将其加入否则舍弃直到中含有条边通常在算法中采用堆来存放边的集合则每次选择最小权值的边只需的时间又生成树中所有边可以视为一个等价类每次添加新的边的过程类似于求解等价类的过程由此可以采用并查集的数据结构来描述从而构造的时间复杂度为因此算法适合于边稀疏而顶点较多的图最短路径求解最短路径的算法通常都依赖于一种性质也就是两点之间的最短路径也包含了路径上其他顶点间的最短路径这种最优子结构性质是动态规划和贪心算法是否适用的一个标记带权有向图的最短路径问题一般可分为两类一是单源最短路径即求图中某一顶点到其他各顶点的最短路径可通过经典的算法求解此算法也是基于贪心算法的策略二是求每一对顶点间的最短路径可通过算法来求解此算法是基于动态规划的思想算法贪心求单源最短的径问题参考求带权有向图中某个源点到其余各顶点的最短路径最常用的是算法该算法设置一个集合记录已求得的最短路径的顶点初始时把源点的放入中此外在构造过程中还设置了两个辅助数组记录了从源点到其他各顶点当前的最短路径长度初值为表示从源点到顶点之间的最短路径的前驱结点在算法结束时可根据其值追溯得到源点到顶点的最短路径假设从顶点出发即集合最初只包含顶点邻接矩阵表示带权有向图表示有向边的权值若不存在有向边则为算法的步骤如下不考虑对的操作初始化集合初始为的初始值从未入选的顶点集合中选出距离出发点最近即最小的结点也就是满足就是当前求得的一条从出发的最短路径的终点将其收录进即令修改从出发到集合上的可达的最短路径长度为的邻近顶点如果经过结点到达的距离小于已知的到达的距离即则更新令重复操作共次直到所有的顶点都包含在中算法计算过程举例例如表所示为应用算法对图中的图从顶点出发求其到其余顶点的最短路径第一趟与结点直接相连的有结点距离分别为而其余结点不能直达所以距离为无限这样每个结点都有一个初始化的距离更新结点的距离并将距离最短的结点加入第二趟上一趟在中加入了结点因此对于与结点直连且未选入的结点计算其距离与出发点的距离计算时判断经过结点的路径和已知路径哪个更短对于结点经过结点的路径长度为不经过则为已知的因此更新其最短路径长度为数组中可以更新结点的值为表示到达结点的最短路径中终点的前驱结点为同理对于结点其最短路径长度更新为对于结点其最短路径长度更新为接着选择中有路径长度最短的结点加入第三趟重复第二趟中的过程更新结点的邻近结点未加入的最短路径长度因此更新为然后选择中路径最短的结点加入第四趟继续重复更新结点的邻近结点未加入的最短路径长度因此更新为然后选择中路径最短的结点加入这样所有结点均加入计算完毕特点显然算法是基于贪心策略的若使用邻接矩阵表示它的时间复杂度为若使用带权的邻接表表示虽然修改的时间可以减少但由于在中选择最小分量的时间不变其时间复杂度仍为注意如果边的权值为负则算法不适用算法动态规划参考基本思想算法的基本思想是递推产生一个阶方阵序列其中表示从顶点到顶点的最短路径长度表示绕行第个顶点的运算步骤初始时对于任意两个顶点和若它们之间存在边则以此边上的权值作为它们之间的最短路径长度若它们之间不存在有向边则以作为它们之间的最短路径长度逐步尝试在原路径中加入顶点作为中间顶点如果增加中间顶点后得到的路径比原来的路径长度减少了则以此新路径代替原路径算法的描述如下定义一个阶方阵序列其中也就是不经过任何顶点的路径路径长度就直接等于邻接矩阵的值经过和不经过顶点的路径长度取最小值得到考虑个顶点的情况下的最短路径算法是一个迭代的过程每迭代一次在从到的最短路径上就多考虑了一个顶点经过次迭代后所得到的考虑了路径上可能遇到的所有结点所以就得到了从到的最短路径长度即方阵中就保存了任意一对顶点之间的最短路径长度算法计算过程举例如图所示为带权有向图及其邻接矩阵下面通过实例来说明算法的过程见表第一个矩阵记录所有顶点之间的初始的路径长度直连的两顶点的值就是其边权值否则为第二个矩阵将顶点纳入路径的考虑中将已知的顶点和顶点之间的路径长度与经过顶点的路径长度相比较取其最小值作为的值比如初始为而考虑经过顶点时路径长度为因此此处可以有一个二维数组用于存储顶点之间的最短路径所经过的顶点默认值为比如这里可以令表示顶点到顶点的最短路径要经过顶点查找路径时再继续查找和即可这样就可以查找到完整路径同理第三个矩阵将顶点纳入路径的考虑中对于顶点和顶点之间的路径对比经过和不经过的情况取路径长度的最小值得到继续循环下去直到得到矩阵考虑了所有的个顶点代码为顶点个数初始化数组和数组迭代数组考虑路径上可能的个结点所有的顶点对经过和不经过顶点哪个路径更短更新矩阵经过顶点则将数组也更新根据数组输出路径直接输出特点算法的时间复杂度为不过由于其代码很紧凑而且并不包含其他复杂的数据结构因此隐含的常数系数是很小的即使对于中等规模的输入来说它仍然是相当有效的算法允许图中有带负权值的边但不允许有包含带负权值的边组成的回路算法同样也适用于带权无向图因为带权无向图可以视为有往返二重边的有向图也可以用单源最短路径算法来解决每对顶点之间最短路径问题每一次运行时轮流将一个顶点作为源点并且若所有边权值均为非负时可以采用上面提到的算法其时间复杂度为拓扑排序有向无环图一个有向图中不存在环则称为有向无环图简称图网如果用图表示一个工程其顶点表示活动用有向边表示活动必须先于活动进行的这样一种关系则将这种有向图称为顶点表示活动的网络记为网在网中活动是活动的直接前驱活动是活动的直接后继这种前驱和后继关系具有传递性且任何活动不能以它自己作为自己的前驱或后继拓扑排序在图论中由一个有向无环图的顶点组成的序列当且仅当满足下列条件时称为该图的一个拓扑排序每个顶点出现且只出现一次若项点在序列中排在顶点的前面则在图中不存在从顶点到顶点的路径或者定义为拓扑排序是对有向无环图的顶点的一种排序它使得如果存在一条从顶点到顶点的路径那么在排序中顶点出现在顶点的后面每个图都有一个或多个拓扑排序序列对一个图进行拓扑排序的算法有很多下面介绍比较常用的一种方法的步骤从图中选择一个没有前驱的顶点并输出从图中删除该顶点和所有以它为起点的有向边重复和直到当前的图为空或当前图中不存在无前驱的顶点为止而后一种情况即当前图中不存在无前驱的顶点则说明有向图中必然存在环排序参考算法的稳定性如果待排序表中有两个元素其对应的关键字且在排序前在前面如果使用某排序算法排序后仍然在的前面则称这个排序算法是稳定的否则称排序算法是不稳定的注意对于不稳定的排序算法只需举出一组关键字的实例说明它的不稳定性即可在排序的过程中根据数据元素是否完全在内存中可将排序算法分为两类内部排序是指在排序期间元素全部存放在内存中的排序外部排序是指在排序期间元素无法全部同时存放在内存中必须在排序的过程中根据要求不断地在内外存之间移动的排序待排序的顺序表中数据元素的类型声明如下定义关键字类型关键字项其他数据项插入排序基本思想在于每次将一个待排序的记录按其关键字大小插入到前面已经排好序的子序列中直到全部记录插入完成直接插入排序为数组长度依次将插入到前面已排序序列若的关键码小于其前驱即非递增需将插入有序表暂存向后挪位从后往前查找待插入位置大于时继续往前复制到插入位置复杂度直接插入排序的时间复杂度为空间复杂度为在最好情况下表中元素已经有序此时每插入一个元素都只需比较一次而不用移动元素因而时间复杂度为稳定性由于每次插入元素时总是从后向前先比较再移动所以不会出现相同元素相对位置发生变化的情况即直接插入排序是一个稳定的排序方法缺点寻找插入位置耗时需要从后往前一个个扫描移动元素需要将插入位置的元素全部后移优化对于寻找插入位置的优化可以使用二分查找法由此引出折半插入排序折半插入排序在有序区查找插入位置时将从后往前的逐个比较优化为折半查找方法找到插入位置后再集中将后面的元素后移最后插入折半插入排序其实仅减少了元素的比较次数对移动元素的性能并没有改善其平均时间复杂度依然为空间复杂度为是一种稳定的排序方法携带多个元素进行插入每次可以移动更多位数减少移动次数将数组改为链表结构无需移动元素希尔排序希尔排序基本思想先将待排序表分割成若干形如的特殊子表分别进行直接插入排序当整个表中元素已呈基本有序时再对全体记录进行一次直接插入排序希尔排序的排序过程如下先取一个小于的步长把表中全部记录分成个组所有距离为的倍数的记录放在同一个组中在各组中进行直接插入排序然后取第二个步长重复上述过程直到所取到的即所有记录已放在同一组中再进行直接插入排序由于此时已经具有较好的局部有序性故可以很快得到最终结果到目前为止尚未求得一个最好的增量序列希尔提出的方法是并且最后一个增量等于每一步的步长逐渐减小先让序列大致有序然后随着减小调整分组方式组序列越来越长整体序列也逐渐趋向有序比如如下图片中透明方块一行代表待排序序列总共个元素所以步长为序列会被划分为个组第二行中同色方块代表同组元素种颜色第三行代表在每组中进行直接插入排序后的序列接着步长为所有元素被划分为个组图中第二行有三种颜色第三行代表在每组中进行直接插入排序后的序列最后步长为所有元素被划分为个组也就是对序列整体进行一次直接插入排序所以图中第二行只有一种颜色第三行代表直接插入排序后的序列这样就得到了最终排序好的序列希尔排序的核心思想是化远为近将相隔较远的元素放在一组组成短序列进行直接插入排序逐渐使序列整体趋近有序减少了查找次数和元素移动的次数为数组长度增量置初值直到增量为结束因为最后一个增量必定为对步长为的所有分组采用直接插入排序首先定位到所有分组的第二个元素即结束后继续往后定位到第三个元素直到序列末尾对进行直接插入排序暂存要插入的元素前一个元素组内元素后移继续比较前一个元素减小增量复杂度希尔排序的时间复杂度依赖于增量序列的函数这涉及数学上尚未解决的难题难以分析一般认为其平均时间复杂度为最坏情况下为希尔排序空间复杂度为稳定性当相同关键字的元素被划分到不同的分组时可能会改变它们之间的相对次序因此希尔排序是一一个不稳定的排序方法交换排序冒泡排序基本思想假设待排序表长为从后往前或从前往后两两比较相邻元素的值若为逆序即则交换它们直到序列比较完我们称它为一趟冒泡结果将最小的元素交换到待排序列的第一个位置下一趟冒泡时前一趟确定的最小元素不再参与比较待排序列减少一个元素每趟冒泡的结果把序列中的最小元素放到了序列的最终位置这样最多做趟冒泡就能把所有元素排好序从前往后比较将无序区最大值移到末尾最多比较轮第轮比较到位置为止后面的部分是有序的本轮没有发生交换已经完全有序复杂度最坏情况下时间复杂度为最好情况下表中元素基本有序时间复杂度为其平均时间复杂度为空间复杂度为稳定性冒泡排序是一个稳定的排序方法注意冒泡排序中所产生的有序子序列一定是全局有序的不同于直接插入排序也就是说有序子序列中的所有元素的关键字一定小于或大于无序子序列中所有元素的关键字这样每一趟排序都会将一个元素放置到其最终的位置上快速排序常考基本思想基于分治法首先从待排序序列中取一个元素作为基准数然后扫描序列将比基准数小的元素全部放到它的左边大于或等于基准数的元素全部放到它的右边得到左右两个区间接着再对左右区间重复第二步直到各区间少于两个元素代码实现中采用了挖坑填数的方法首先取出基准数的位置挖坑从右往左扫描出小于基准数的元素填坑得到新坑再从左往右扫描出大于等于基准数的元素填新坑这样循环下去直到两指针重合将基准数填入即可一趟划分第一个数做为基准数指针未重合时定位到右区间中小于基准数的元素填坑定位到左区间中大于基准数的元素填坑快排函数时间复杂度快速排序的运行时间与划分是否对称有关而后者又与具体使用的划分算法有关快速排序的最坏情况发生在两个区域分别包含个元素和个元素时这种最大程度的不对称性若发生在每一层递归上即对应于初始排序表基本有序或基本逆序时就得到最坏情况下的时间复杂度为最好情况下每次划分都能对称即基准数就是区间的中值那么最好情况下时间复杂度为空间复杂度由于快速排序是递归的需要借助一个递归工作栈来保存每一层递归调用的必要信息其容量应与递归调用的最大深度一致最好情况下所取基准数就是区间的中值每次能划分出长度相等的左右区间所以递归树高度为最坏情况下因为要进行次递归调用所以栈的深度为平均情况下栈的深度为因而空间复杂度在最坏情况下为平均情况下为稳定性在划分算法中若右端区间存在两个关键字相同且均小于基准值的元素则在交换到左端区间后它们的相对位置会发生变化即快速排序是一个不稳定的排序方法注意在快速排序算法中并不产生有序子序列但每一趟排序后会将一个元素基准元素放到其最终的位置上优化当递归过程中划分得到的子序列的规模较小时不要再继续递归调用快速排序可以采用直接插入排序算法进行后续的排序工作尽量选取一个可以将数据中分的基准数如从序列的头尾以及中间选取三个元素再取这三个元素的中间值作为最终的基准数或者随机从当前序列中选取基准数这样做使得最坏情况在实际排序中几乎不会发生在最理想的状态下即可能做到最平衡的划分得到的两个子问题的大小都不可能大于在这种情况下快速排序的运行速度将大大提升此时时间复杂度为好在快速排序平均情况下运行时间与其最佳情况下的运行时间很接近而不是接近其最坏情况下的运行时间快速排序是所有内部排序算法中平均性能最优的排序算法快排一次排序的应用例一个数组中存储有且仅有大写和小写字母编写一个函数对数组内的字母重新排列让小写字母在所有大写字母之前中兴腾讯该题直接使用快排的一次区间划分即可左右指针索引从两端向中间扫描挖坑填数代码略例给定含有个元素的整型数组其中包括元素和非元素对数组进行排序要求人民搜索排序后所有元素在前所有非零元素在后且非零元素排序前后相对位置不变不能使用额外存储空间该题需要使用快排的一次空间划分相当于基准数为注意由于需要保持非零元素排序前后相对位置不变所以不能使用左右指针索引从两端向中间扫描的办法这里使用的是将相对位置在左的非元素依次与在右的元素交换的方法这样不会破坏排序前元素的相对位置代码如下从后往前遍历遇到非元素就后移即将其与位置的元素互换两种情况与自身互换与元素互换或者从前往后遍历从前往后遍历遇到元素就前移即将其与位置的元素互换两种情况与自身互换与元素互换例进阶荷兰国旗问题将乱序的红白蓝三色小球排列成同颜色在一起的小球组按照红白蓝排序这个问题称为荷兰国旗问题这是因为我们可以将红白蓝三色小球想象成条状物有序排列后正好组成荷兰国旗序列中表示红球表示白球表示蓝球这个问题类似于快排的区间划分问题但是这里需要使用个指针索引而不是个使用指针指向元素应该在的位置用于跳过元素用以指向元素应该在的位置和都初始化指向数组首部初始化指向数组尾部代码如下元素前移与交换元素不动元素后移与交换例最小的个数输入个整数输出其中最小的个网易例如输入这个数字则最小的个数字为最简单的思路莫过于把输入的个整数排序这样排在最前面的个数就是最小的个数只是这种思路的时间复杂度为这里同样可以使用快排区间划分的方法我们设最小的个数中最大的数为在快速排序算法中我们先在数组中随机选择一个数字然后调整数组中数字的顺序使得比选中的数字小的数字都排在它的左边比选中的数字大的数字都排在它的右边即快排一次排序如果快排一次划分后这个选中的数字的下标刚好是下标从开始那么这个数字就是加上左侧的个数字就是最小的个数如果它的下标大于那么位于它的左边我们可以接着在它的左边部分的数组中查找如果它的下标小于那么应该位于它的右边我们可以接着在它的右边部分的数组中查找可见这是一个递归问题但是注意我们找到的个数不一定是有序的可以用如下代码实现是输入的数组元素个数为是用来保存最小个数的数组一次划分函数见前面左区间已包含超过个数直到为止注意上述方法平均时间复杂度为选择排序简单选择排序从头至尾扫描序列找出最小的一个元素和第一个元素交换接着从剩下的元素中继续这种选择和交换方式最终得到一个有序序列定位无序区最小元素无序区第一个元素和无序区最小元素交换复杂度简单选择排序过程中元素移动的操作次数很少不会超过次一次需要次元素移动最好的情况是移动次此时对应的表已经有序但元素间比较的次数与序列的初始状态无关始终是次所以时间复杂度始终是空间复杂度稳定性不稳定选择排序中每一趟选择最小元素前移后该元素都是处于其最终的位置上堆排序是指利用堆这种数据结构所设计的一种排序算法堆积具有以下特点完全二叉树子结点的键值或索引总是小于等于或者大于等于它的父节点在大根堆中最大元素存放在根结点中且对其任一非根结点它的值小于等于其双亲结点值小根堆的定义刚好相反根结点是最小元素对于关键字序列构建的完全二叉树结点的左孩子为右孩子为由于一般待排序的数组从开始编号所以改为结点的左孩子为右孩子为算法思想将初始待排序关键字序列构建成大顶堆此堆为初始的无序区将堆顶元素与最后一个元素交换此时得到新的无序区和新的有序区且满足由于交换后新的堆顶可能违反堆的性质因此需要对当前无序区调调整为新堆然后再次将与无序区最后一个元素交换得到新的无序区和新的有序区不断重复此过程直到有序区的元素个数为则整个排序过程完成下面的代码已经调整为从开始存储元素所以左右孩子结点分别为调整堆后根结点为调整根索引为最大结点索引不超过的完全二叉树为大根堆或者说从中筛选出最大值作为根结点定义为的左孩子如果孩子结点的索引未超出范围继续向下调整循环继续比较两个孩子的关键字选择最大的若根结点的关键字大于孩子结点表示调整完成直接跳出函数若根结点的关键字小于孩子结点孩子结点和根结点互换孩子结点作为下一循环的根结点继续向下调整大根堆的初始化分支结点一共有个所以调用算法次从下往上到将所有以分支节点作为根的子树调整为大根堆以作为根结点向下调整为大根堆将根结点最大元素与最右边叶子结点互换然后不考虑换下的最大元素继续调整堆为大根堆循环次取出根结点目前的最大元素与叶子结点互换根结点被交换需要调整新堆为大根堆且不考虑结点已经有序大根堆的初始化如下图对应上述代码中的复杂度大根堆的调整中即调用函数向下调整的时间与树高有关为即建堆过程中每次向下调整时大部分结点的高度都较小因此可以证明在元素个数为的序列上建堆的时间复杂度为这说明可以在线性时间内将一个无序数组建成一个大顶堆在最好最坏和平均情况下堆排序的时间复杂度为空间复杂度为稳定性不稳定上述代码中的函数是向下调整大根堆适用于根结点被交换删除使堆的性质被破环的情况比如删除堆顶元素后应该使用最后一个元素替换堆顶然后比较堆顶和其左右孩子交换然后继续向下调整而如果是作为叶子结点向堆中插入元素那么就需要向上调整堆代码如下为所插入的结点索引也为新堆的结点个数结点索引从开始编号将暂存到根结点始终指向的父节点父节点下调更新父节点为继续向上比较堆排序的应用最小的个数输入个整数输出其中最小的个例如输入和这个数字则最小的个数字为和网易在讲快排的时候已经提出了利用快排的一次划分来解此题时间复杂度为但此种方法也有其限制首先我们需要一次性读入所有数据其次需要修改输入的数组其实此题也可以利用堆排序来解决此种方法特别适合于处理海量数据首先我们读入个数创建一个大小为的大根堆然后我们依次读入剩余数据如果当前数据比大根堆的堆顶小则用这个数替换当前堆顶并调整堆使其保持大根堆的性质如果当前数据比堆顶大那么这个数不可能是最小的个整数之一故可以抛弃此数此种方法总的时间复杂度是数组中存储输入的个数从中依次读入个数到第一个数存在中依此类推初始化为大根堆以作为根结点向下调整为大根堆依次读入剩余数据大于堆顶跳过替换堆顶调整大根堆当需要求最大的个数时只需将大根堆改为小根堆即可原理相同归并排序归并的含义是将两个或两个以上的有序表组合成一个新的有序表二路归并排序参考假定待排序表含有个元素首先可以视为个有序的子表每个子表长度为然后两两归并得到个长度为或的有序表再两两归并如此重复直到合并成一个长度为的有序表为止这种排序方法称为二路归并排序如图所示为二路归并排序的例子将有序的和归并到辅助数组在前一段有序表扫描在另一段有序表扫描依次比较将更小的数存入存入后指针索引后移有一个有序表的指针索引到达末尾将另一有序表的剩余元素全部存入即可两个只会有一个执行递归写法分治法非递归写法为待排序表的长度所归并的序列长度更新为原来的倍因为是两两合并要合并的两个序列末尾索引不超过对等长的两个子表合并定位到下一组要合并的序列最后一组不等长的两个子表合并一轮归并结束所有元素转移到所以要交换以保证下一趟归并时仍从归并到复杂度最坏情况下合并两个大小为的已排序数组所需要的比较次数为所以每一趟归并的时间复杂度为共需进行趟归并所以算法的时间复杂度为操作中由于辅助空间刚好要占用个单元但每一趟归并后这些空间就被释放了所以归并排序的空间复杂度为稳定性由于操作不会改变相同元素的相对次序所以二路归并排序算法是一个稳定的排序方法原地归并排序多路归并排序外部排序指的是大文件的排序即待排序的记录存储在外部存储器上待排序的文件无法一次装入内存需要在内存和外部存储器之间进行多次数据交换以达到排序整个文件的目的外部排序最常用的算法是多路归并排序即将原文件分解成多个能够一次性装入内存的部分分别把每一部分调入内存完成排序然后对已经排序的子文件进行归并排序从二路到多路路增大可以减少外存信息读写时间但个归并段中选取最小的记录需要比较次为了降低选出每个记录需要的比较次数引出了败者树的概念败者树是对树形选择排序的一种变形可以视为一棵完全二叉树每个叶结点存放各归并段在归并过程中当前参加比较的记录内部结点用来记忆左右子树中的失败者而让胜者往上继续进行比较一直到根结点如果比较两个数大的为失败者小的为胜利者则根结点指向的数为最小数计数排序计数排序统计小于等于该元素值的元素的个数于是该元素就放在目标数组的索引位计数排序基于一个假设待排序数列的所有数均为整数且出现在的区间之内如果待排数组的最大值过大则会引起较大的空间复杂度不适合数范围大的情况一般是用来排序到之间的数字的最好的算法比如考试分数排名但是它不适合按字母顺序排序人名计数排序不是比较排序排序的速度快于任何比较排序算法计数排序是稳定的排序算法算法思想找出待排序的数组中最大元素统计数组中每个值为的元素出现的次数存入数组的第项向填充目标数组将每个元素填充进新数组填充次数为若待排序容器为空使用的最大值作为计数容器的大小用于查询容器中最大值第一次出现的位置用于记录所有元素的出现次数统计每个键值出现的次数后面的键值出现的位置为前面所有键值出现的次数之和将键值放到目标位置此处逆序是为了保持相同键值的稳定性稳定性稳定缺点空间浪费其需要长度为最大值的计数空间但是其间的很多数值可能并未出现优化使用长度为最大值最小值的计数空间桶排序重要桶排序是计数排序的升级版它利用了函数的映射关系高效与否的关键就在于这个映射函数的确定参考工作原理假设输入数据服从均匀分布将数据分到有限数量的桶里每个桶再分别排序有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序设置一个定量的数组当作空桶子寻访序列并且把项目一个一个放到对应的桶子去比如一位数放到一个桶两位数放到一个桶三位数放到一个桶对每个不是空的桶子进行排序递归或者使用其他排序算法从不是空的桶子里把项目再放回原来的序列中合并对进行拷贝不改变参数内容利用映射函数将数据分配到各个桶中对每个桶进行排序这里使用了插入排序自动扩容并保存数据由于桶中将要存放多少元素是不确定的因此最好将桶定义为链表数据结构复杂度桶排序的时间复杂度取决与对各个桶之间数据进行排序的时间复杂度因为其它部分的时间复杂度都为很显然桶划分的越小各个桶之间的数据越少排序所用的时间也会越少但相应的空间消耗就会增大基数排序重要基数排序是桶排序的扩展是按照低位先排序然后收集再按照高位排序然后再收集依次类推直到最高位有时候有些属性是有优先级顺序的先按低优先级排序再按高优先级排序最后的次序就是高优先级高的在前高优先级相同的低优先级高的在前算法描述取得数组中的最大数并取得位数为原始数组从最低位开始取每个位组成数组对进行计数排序利用计数排序适用于小范围数的特点按个位数分配桶然后依次从桶中收集元素同一桶中的元素先进桶的在前此序列的个位数是有序的接着按照第一次收集的序列顺序再依次入桶这次按十位数分配桶然后依次从桶中收集元素同一桶中的元素先进桶的在前此序列的十位个位组成的数是有序的接着按照第二次收集的序列顺序再依次入桶这次按百位数分配桶然后依次从桶中收集元素同一桶中的元素先进桶的在前此序列的个十百位组成的数都是有序的找出列表中最大的位数求出每一个元素的个十百位的值稳定性稳定不同排序算法的比较稳定性所有简单排序时间复杂度为都是稳定排序选择排序除外所有时间复杂度为的排序都是不稳定排序归并排序基数排序除外希尔排序是不稳定排序基数排序是稳定排序时间复杂度比较次数比较次数与初始排列无关的是选择排序简单选择排序堆排序在初始序列基本有序的情况下最优的是插入排序此时插入排序时间复杂度为其次是冒泡排序时间复杂度也为快速排序在此时性能最差时间复杂度为同时快速排序在初始序列逆序的时候性能也最差此时时间复杂度也为堆排序对初始数据集的排列顺序不敏感在最好最坏和平均情况下堆排序的时间复杂度均为空间复杂度基于比较的排序算法中插入排序交换排序选择排序归并排序归并排序的空间复杂度最高为其次为快速排序为其余的为查找基本概念查找结构查找表用于查找的数据集合称为查找结构查找表它可以是一个链表也可以是一个数组或其他数据类型对于查找表经常进行的操作一般有四种查询某个特定的数据元素是否在查找表中检索满足条件的某个特定的数据元素的各种属性在查找表中插入一个数据元素从查找表中删除某个数据元素如果一个查找表的操作只涉及和的操作则无须动态地修改查找表此类查找表称为静态查找表与此对应需要动态地修改的查找表则称为动态查找表适合静态查找表的查找方法有顺序查找折半查找散列查找等适合动态查找表的查找方法有二叉排序树的查找散列查找等平均查找长度在查找的过程中一次查找的长度是指需要比较的关键码次数而平均查找长度则是所有查找过程中进行的关键码比较次数的平均值其定义如下式中为查找第个元素的概率一般认为每个元素的查找概率相等为找到第个元素所需的比较次数平均查找次数是衡量查找算法效率的最主要指标例查找一个整数数组中第二大的数迅雷型最小值原来的最大值变成第二大原来的第二大值被换下折半查找折半查找又称为二分查找仅适用于事先已经排好序的顺序表基本思路首先将给定值与表中中间位置元素的关键字比较若相等则查找成功返回该元素的存储位置若不等则所需查找的元素只能在中间数据以外的前半部分或后半部分中然后在缩小的范围中继续进行同样的查找如此重复直到找到为止算法如下在有序表中查找关键字为的元素若存在则返回其位置不存在则返回有序表存在元素时循环取中间位置查找成功返回其逻辑序号在前半部分继续查找在后半部分继续查找因为折半查找需要方便地定位查找区域所以适合折半查找的存储结构必须具有随机存取的特性因此二分查找法仅适合于线性表的顺序存储结构不适合链式存储结构且要求元素按关键字有序排列例有一个循环有序数组如不知道其最小值的位置那么如何从这样的数组中寻找一个特定的元素呢百度人民搜索解答可以将这个循环有序数组看作两个有序子数组前一个子数组的元素均大于后一个数组在二分查找的过程中增加一个判断确定中间元素位于哪一个子数组为数组首元素下标为数组最后的元素下标但由于是循环有序所以并不是最大值为要查找的值查找成功返回其逻辑序号到是有序的到跨了两个子数组大于在和之间比和均要小所查找元素在之后到跨了两个子数组到是有序的在和之间在和之间比和均要大所查找元素在之前上述算法对数组元素重复的时候不支持比如此时只能依次遍历判定树折半查找的过程可用图所示的二叉树来描述称为判定树树中每个圆形结点表示一个记录结点中的值为该记录的关键字值树中最下面的叶结点都是方形的它表示查找不成功的情况从判定树可以看出查找成功时的查找长度为从根结点到目的结点的路径上的结点数而查找不成功时的查找长度为从根结点到对应失败结点的父结点路径上的结点数每个结点值均大于其左子结点值且均小于其右子结点值若有序序列有个元素则对应的判定树有个圆形的非叶结点和个方形的叶结点图中个圆形结点代表有序序列有个元素构成的树的深度与个结点的完全二叉树的深度高度相等均为或者折半查找的时间复杂度为最坏的情况下查找次数也不会超过为不管有没有查找成功比顺序查找的效率高在图所示的判定树中在等概率的情况下查找成功的每个结点的深度为其查找长度深度为的结点有个深度为的结点有个深度为的结点有个深度为的结点有个查找不成功的由上述的分析可知用折半查找法查找到给定值或查找失败的比较次数最多不会超过树的高度如在图中查找成功与查找不成功最坏的情况下都需要比较次即树高例有一类数组例如前半部分是一个递增数组后半部分还是递增数组但整个数组不是递增数组怎么最快地找出其中一个数有大量查询待进行百度解答开始时找出两个数组的分界线有两个一个是前一个数组的最末元素另一个是后一个数组的最初元素分别设为和然后处理每个查询查询过程为分析要查找的数若此数刚好等于或则返回相应位置否则若此数小于则在前一个数组二分查找若此数大于则也在后一个数组二分查找若此数大于且小于则不存在键树键树的定义与树键树又称为数字查找树键树其结构受启发于一部大型字典的书边标目字典中标出首字母是的单词所在页再对各部分标出第二字母为的单词所在的页等它是一棵度大于等于的树树中的每个结点中不是包含一个或几个关键字而是只含有组成关键字的符号例如若关键字是数值则结点中只包含一个数位若关键字是单词则结点中只包含一个字母字符假设有如下个关键字的集合可对此集合作如下的逐层分割首先按首字母分成不同子集然后再在子集中按第二个字符进行分割直到每个小子集中只包含一个关键字为止如图所示从根到叶子结点路径中结点的字符组成的字符串表示一个关键字叶子结点中的特殊符号表示字符串的结束键树的存储通常有两种方式用树的孩子兄弟链表来表示键树称为双链树每个有三个域域存储关键字的一个字符域存储指向第一棵子树的根的指针域存储指向右兄弟的指针这时的键树又称为双链树图所示键树的双链树如图所示查找过程是从根结点出发顺着查找如果相等继续下一个否则沿着查找直到到了空指针为止此时若仍未完成的匹配查找不成功在双链树中插入或删除一个关键字相当于在树中某个结点上插入或删除一棵子树用多重链表表示又称为树字典树如果以树的多重链表表示键树则树的每个结点中应包含个为关键字符的基如字符集由英文大写字母构成时则指针域此时的键树又称为树树的思想是利用字符串的公共前缀来降低时空开销由组成的树如下树的典型应用是用于统计和排序大量的字符串但不仅限于字符串比较适合的是查找前缀匹配的字符串所以经常被搜索引擎系统用于文本词频统计树的优点是最大限度地减少无谓的字符串比较树的缺点是如果存在大量字符串且这些字符串基本没有公共前缀则相应的树将非常消耗内存构建树时间复杂度是是树中所有元素的个数即单词的个数单词的平均长度查询树时间复杂度是表示要查找的字符串的长度即单词的平均长度例已知个由小写字母构成的平均长度为的单词判断其中是否存在某个串为另一个串的前缀子串解答使用树假设要查询的单词是显然以等不是以开头的字符串就不用查找了首先建立一棵树然后将每个单词插入树时间复杂度为其中为单词的平均长度然后依次查询每个单词每个单词查询的时间复杂度为单词的长度查询时看是否存在有单词与已有单词结点重合即可例给定一个单词如果通过交换单词中字母的顺序可以得到另外的单词那么定义是的兄弟单词例如单词和互为兄弟单词现在给定一个字典用户输入一个单词如何根据字典找出这个单词有哪些兄弟单词要求时间和空间效率尽可能高百度解法一使用和链表首先使兄弟单词具有相同的比如和具有相同的为相当于对单词的字母进行排序然后使用生成到链表的映射链表用来存储所对应所有兄弟单词开始时先遍历字典将每个单词按照其加入对应的链表中去当需要查找某一单词的兄弟单词时只需计算其然后根据找到所对应的链表这样就可以确定其兄弟单词其中创建的时间复杂度为查找兄弟单词的时间复杂度为解法二也是使用和链表此方法无需对单词的字母进行排序来生成将每个字母对应一个质数这样单词就可以对应为其字母的质数之积将得到的值进行这样兄弟单词就具有相同的值将值与其对应的所有兄弟单词组成的链表进行映射单词的乘积为链表起始地址当需要查找某一单词的兄弟单词时只需计算其单词乘积然后查找遍历链表就能得到所有兄弟单词其中创建的时间复杂度为查找兄弟单词的时间复杂度为解法三利用树单词插入树之前先按照字母排序如与排完序都是然后将插入树在树的结点中增加一个记录所有的兄弟单词这样查询的时候只需先将查询词排序然后把排序后的单词拿去查询当所有字母都遍历后读出对应结点的里面存储的即是此单词的所有兄弟单词键树的两种实现的对比双链树和树是键树的两种不同表示方法它们有各自的特点从其不同的存储结构特性可见若键树中结点的度较大则采用树结构较双链树更为合适综上键树的查找过程都是从根结点出发走了一条从根到叶子或非终端结点的路径其查找时间依赖于单词的长度后缀树与后缀数组后缀树键树只适合前缀匹配和全字匹配而后缀树适合后缀和子串匹配它与键树的最大不同在于后缀树的单词集合是由指定字符串的后缀子串构成的比如字符串的后缀子串分别如下然后对这些子串的集合建立一棵键树即为的后缀树若字符串为则其建立的后缀树如图所示含有所有的后缀子串后缀树常用于在串中查询子串是否存在查询效率为为单词长度后缀树还可以用来找出字符串的最长重复子串找出字符串和的最长公共子串找出字符串的最长回文子串等后缀数组后缀树实现较为复杂通常可以用其变形后缀数组代替使用数组来存储所有的后缀子串比如若输入字符串为该数组将表示这些后缀可见由于数组中的指针分别指向字符串中的每个后缀所以将数组命名为后缀数组找出字符串的最长重复子串比如的最长重复子串是的最长重复子串是最长重复子串可以重叠解法一直接遍历时间复杂度为返回数组的最大公共长度逐个遍历所有的子串解法二使用后缀数组生成后缀数组然后对后缀数组进行快速排序将后缀相近的子串集中在一一起比如输入字符串为则排序后的后缀数组如下然后通过比较邻接元素找出最长的重复字符串最长处理个字符存储字符串为指针数组存储的所有后缀子串返回起始地址为的数组的最大公共长度应用于库函数快排的比较函数将数组中的最后一个元素设为空字符以终止所有字符串时间复杂度分析处理过程为先对一个字符串生成相应的后缀数组然后再排序排完序依次检测相邻的两个字符串的开头公共部分其中生成后缀数组时间复杂度为排序时间复杂度为依次检测相邻的两个字符串时间复杂度为故总的时间复杂度是优于第一种方法的哈希表重点基本概念哈希表也叫散列表它是基于快速存取的角度设计的是一种典型的空间换时间的做法哈希表是普通数组的一种推广因为数组可以直接寻址故可在时间内访问数组的任意元素哈希表是根据关键字而直接进行访问的数据结构它将关键字通过某种规则映射到数组中某个位置以加快查找的速度这个映射规则称为哈希函数散列函数存放记录的数组称为哈希表哈希表建立了关键字和存储地址之间的一种直接映射关系若多个不同的关键字通过哈希函数计算得到相同的数组下标称其发生了冲突碰撞这些发生冲突的不同关键字称为同义词一方面设计好的函数应尽量减少这样的冲突另一方面由于这样的冲突总是不可避免的所以还要设计好处理冲突的方法函数如果两个散列值是不相同的根据同一函数那么这两个散列值的原始输入也是不相同的这个特性使散列函数具有确定性的结果具有这种性质的散列函数称为单向散列函数典型的散列函数都有无限定义域比如任意长度的字节字符串和有限的值域比如固定长度的比特串典型的哈希算法包括和和安全哈希算法可以说是目前应用最广泛的算法而它们都是以为基础设计的是的缩写的摘要长度为位比特可以用来表示位的十六进制数字适用于位字长的处理器是一种面向工业标准的方案摘要长度为位比特比要复杂所以速度也更慢一些但是更安全在抗分析和抗差分方面表现更好是由美国国家安全局设计美国国家标准与技术研究院发布的密码散列函数会从一个最大位元的信息中产生一串位元的摘要设计时基于和相同原理并且模仿了该算法函数的应用包括文件校验数字签名鉴权协议函数不能用来加密处理冲突碰撞的方法任何哈希函数都不可能绝对地避免冲突为此必须考虑冲突发生时应如何进行处理即为产生冲突的关键字寻找下一个空的地址于是提出了处理冲突的各种方法链地址法值对应一个链表存放多个记录链地址法是指把所有的冲突关键字同义词存储在一个线性链表中这个链表由其散列地址唯一标识开放定址法在冲突值基础上增量开放定址法是指可存放新表项的空闲地址既向它的同义词表项开放又向它的非同义词表项开放一个地址往后的空间按照增量大小依次存放多个值其数学递推公式为表示冲突发生后第次探测的散列地址式中为散列表表长为增量序列通常有以下几种取法当时称为线性探测法其特点是冲突发生时顺序查看表中下一个单元直到找出一个空单元或查遍全表当时其中又为二次探测法当伪随机数序列时称为伪随机探测法在开放定址的情形下不能随便删除表中已有元素因为若删除元素将会截断其他具有相同散列地址的元素的查找地址所以若想删除一个元素时给它做一个删除标记进行逻辑删除但这样做的副作用是在执行多次删除后表面上看起来散列表很满实际上只是逻辑删除物理上有许多位置没有利用因此需要定期维护散列表要把做删除标记的元素物理删除再散列法当发生冲突时利用另一个哈希函数再次计算一个地址直到冲突不再发生这种方法称为再哈希法建立一个公共溢出区一旦由哈希函数得到的地址冲突就都填入溢出表进行表的查找时计算查找成功的平均查找长度时平均的概念是对表中当前非空元素而言的并非是整个表长计算查找失败的平均查找长度时平均的概念是针对表长一致性哈希如何快速定位数据在集群中的存储位置关系到集群的性能普通集群普通集群把固定的映射到固定的结点上结点只存放各自的数据如图所示此种方法将和结点的关系作为一张单独的表格进行维护当其中一个结点宕机结点上的数据需要迁移此表格也要重新维护此种方法的问题是当需要查找某个值对应的数据时必须遍历所有表格直到寻找到存放此值的结点然后再去对应结点读取数据可见查找速度慢集群为了不想维护上节所述的表格降低复杂性和其他开销容易想到对数据的假设为整型如果不是整型可通过一个哈希函数映射为一个整型进行哈希对结点数取模比如我们原本有四个结点如图所示图中等为服务器结点等为数据的可见寻找数据时只需将值对结点数取模然后再去访问对应结点即可此种方法的不足是假如某个时候其中一个结点宕机了那这个结点的数据就完全不可用了如要进行数据迁移的话因为这时候结点少了变为对重新模的话只能整个集群的数据都重新映射一遍才能达到效果一致性哈希一致性哈希是一种哈希算法在移除或添加一个结点时它能够尽可能小地改变已存在的映射关系一致性哈希将整个哈希值空间组织成一个虚拟的圆环现假设某哈希函数的值空间为即哈希值是一一个位无符号整型那么整个哈希空间环如图所示基本思想使用相同的哈希算法即假设的哈希函数将数据和结点都映射到上图的环形哈希空间中把数据映射到空间假设有个数据那么通过哈希函数计算出的哈希值在环上的分布如图所示把结点映射到哈希空间具体可以选择结点服务器的或主机名作为关键字进行哈希这样每台机器就能确定其在哈希环上的位置假设当前有和共台服务器结点那么其映射结果将如图所示它们在哈希空间中以对应的哈希值排列把数据映射到结点现在结点和数据都已经通过同一个哈希算法映射到哈希数值空间中了接下来要考虑的就是如何将数据映射到结点上确定了映射关系也就确定了存储关系在这个环形空间中如果沿着顺时针方向当然也可以约定为逆时针从数据的值出发直到遇见一个结点机器那么就将该数据存储在这个结点上因为数据和结点的哈希值是固定的因此这个结点必然是唯一和确定的这样就确定了一种数据和结点的一对一映射方法如图所示移除结点考虑假如出现问题根据上面讲到的映射方法这时受影响的将仅是那些沿逆时针遍历直到下一个本例为之间的数据即本来映射到上的那些数据因此这里仅需要变动数据将其重新映射到上即可如图所示添加结点考虑已有的情况下再添加一台新的的情况假设在这个环形哈希空间中被映射在数据和之间这时受影响的将仅是那些沿逆时针遍历直到下一个本例是之间的数据它们本来是映射到将这些数据重新映射到上即可因此这里仅需要变动数据将其重新映射到上如图所示虚拟结点在上面的例子中假设仅部署和那么在个数据中仅存储了而则存储了和可见分布是很不平衡的为了解决这种情况一致性哈希引入了虚拟结点的概念虚拟结点是实际结点在哈希空间的复制品一个实际结点对应了若干虚拟结点这个对应个数也称为复制个数虚拟结点在哈希空间中以哈希值排列仍以仅部署和的情况为例现在我们引入虚拟结点并设置复制个数为这就意味着一共会存在个虚拟结点代表了代表了假设一种比较理想的情况参见图此时数据和被映射到了上而和映射到了上平衡性有了很大提高海量数据处理所谓海量数据处理就是基于海量数据的查找统计运算等操作所谓海量数据就是数据量太大所以导致要么是无法在较短时间内迅速解决要么是数据太大导致无法一次性装入内存从而导致传统的操作无法实现分治映射所有散列函数都有抗碰撞性如果两个散列值是不相同的根据同一函数那么这两个散列值的原始输入也是不相同的这个特性使散列函数具有确定性的结果在对大文件进行处理时若文件过大无法一次性读入内存可以考虑采取映射的方法将文件中的元素映射到不同小文件中然后再依次处理各个小文件最后合并处理结果这样就降低了问题规模问题在大规模数据处理中经常会遇到的一类问题如何寻找出最大的前个数或最小的个数若这些数据能一次性读入内存快排一次排序是时间复杂度为的解决办法但当面对着海量数据时快排的一次划分就不能再使用但依然可以使用堆求最大个数采用小根堆求最小个数采用大根堆时间复杂度为空间复杂度为故堆也是海量数据处理经常采用的工具对单词后取余按余数将文件内的单词分散到多个文件每个文件大小不超过内存限制然后按照分治法的思想在每个小文件内对单词进行频率统计树或者然后对每个文件的频率前的单词进行归并排序的原理就是使用位数组来表示某些元素是否存在一个元素对应一位由于采用了为单位来存储数据因此在存储空间方面可以大大节省故适用于海量数据的快速查找判重删除等假设我们要对值区间为的个元素排序这里假设这些元素没有重复那么我们就可以采用的方法来达到排序的目的要表示个数我们就只需要个首先我们开辟的空间位依次编号为将这些空间的所有位都置为得到然后遍历待排序表将元素值所对应的位置得到最后依次输出该位为的编号即可位图排序的时间复杂度是它是以空间换时间需要一个位的串在程序设计中经常需要判断集合中是否存在重复的问题当数据量比较大时位图法比较适合例已知某个文件内包含一些电话号码每个号码为位数字统计不同号码的个数解答位数字表示的最大数为可以理解为从的数字一共的次方个数字用解决则每个数字对应一个位所以只需要约约等于的次方这样就用了只有左右的内存表示了所有的位数的电话依次读入每个电话号码然后将相应位置为最后统计中为的位数即为不同号码的个数位图法还可用来快速判断集合中某个数据是否存在例给亿个不重复的的整数没排过序的然后再给一个数如何快速判断这个数是否在亿个数当中解答最多有个数用的方法申请的内存一个位代表个值读入亿个数设置相应的位读入要查询的数查看相应位是否为为表示存在为表示不存在本题若限制进一步节省内存但可以允许一定的错误率那么可以采用下节将要介绍的例在亿个整数中找出只出现一次的整数内存不足以容纳这亿个整数方案采用每个数分配表示不存在表示出现一次表示多次无意义进行共需内存内存其中是因为整数最多有个然后依次扫描这亿个整数查看中对应位如果是变变保持不变扫描结束后查看把对应位是的整数输出即可方案也可采用映射的方法划分成多个小文件然后在小文件中利用找出不重复的整数布隆过滤器可以视为对的扩展的作法是申请一个位为集合中最大整数的数组然后每一位对应一个特定整数的基本原理是位数组与函数联合使用使用多个函数将元素映射到位数组的多个位上多个置的位共同表示该元素存在具体而言是一个包含了位的位数组数组的每一位都初始化为然后定义个不同的函数每个函数都可以将集合中的元素映射到位数组中的某一位当向集合中插入一个元素时根据个函数可以得到位数组中的个位将这些位全部设置为如果一个位置多次被置为那么只有第一次会起作用后面几次将没有任何效果当要查询某个元素是否属于集合时就使用个哈希函数得到此元素对应的个位如果所有点都是那么元素在集合内其实是可能在这个集合因为有可能某个为的位是被别的元素置的所以存在出错的可能如果有元素则不在集合内的位数通常要比集合中的最大元素小得多可见是一种空间效率和时间效率很高的随机数据结构但这种高效是有一定代价的在判断一个元素是否属于某个集合时有可能会把不属于这个集合的元素误认为属于这个集合因此不适合那些零错误应用场合而在能容忍低错误率的应用场合下通过极少的错误换取了存储空间的极大节省倒排索引法正向索引是用来存储每个文档所包含的单词的列表在正向索引中文档占据了中心的位置每个文档指向了一个它所包含的索引项的序列倒排索引则相反其存储包含某个单词的文档列表倒排索引也常被称为反向索引置入档案或反向档案是一种索引方法被用来存储在全文检索下某个单词在一个文档或者一组文档中的存储位置的映射它是文档检索系统中最常用的数据结构适用范围搜索引擎的关键字查询以英文为例下面是要被索引的文本我们就能得到下面的反向文件索引代表上述个文本集合代表出现了该单词的文本那么当用户检索的条件为和则将分别查询这三个关键词对应的文本集合即然后求对应集合的交集得到这样就能确定包含关键字的文本可见倒排索引在处理复杂的多关键字查询时可在倒排表中先完成查询的并交等逻辑运算得到结果后再对记录进行存取',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-05 19:40:46',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="CCB" type="application/atom+xml">
</head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">CCB</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> Newest Comments</span></div><div class="aside-list"><span>loading...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/DVWA%E9%9D%B6%E5%9C%BA/" style="font-size: 1.05rem;">DVWA靶场<sup>10</sup></a><a href="/tags/%E5%AE%9E%E8%AE%AD-%E7%BD%91%E7%BB%9C%E5%BB%BA%E8%AE%BE%E9%83%A8%E5%88%86/" style="font-size: 1.05rem;">实训-网络建设部分<sup>7</sup></a><a href="/tags/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/" style="font-size: 1.05rem;">搭建博客<sup>1</sup></a><a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 1.05rem;">机器学习<sup>1</sup></a><a href="/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/" style="font-size: 1.05rem;">渗透测试<sup>15</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" style="font-size: 1.05rem;">计算机基础<sup>5</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>Archives</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">October 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/08/"><span class="card-archive-list-date">August 2022</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">15</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/07/"><span class="card-archive-list-date">July 2022</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/08/"><span class="card-archive-list-date">August 2021</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2020/08/"><span class="card-archive-list-date">August 2020</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">18</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>计算机基础</span></a></span></div></div><h1 class="post-title" itemprop="name headline">数据结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2021-08-14T16:00:00.000Z" title="Created 2021-08-15 00:00:00">2021-08-15</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-10-05T11:40:46.709Z" title="Updated 2023-10-05 19:40:46">2023-10-05</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为长沙"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>长沙</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://frankcao3.github.io/posts/undefined"><header><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" tabindex="-1" itemprop="url">计算机基础</a><h1 id="CrawlerTitle" itemprop="name headline">数据结构</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">ccb</span><time itemprop="dateCreated datePublished" datetime="2021-08-14T16:00:00.000Z" title="Created 2021-08-15 00:00:00">2021-08-15</time><time itemprop="dateCreated datePublished" datetime="2023-10-05T11:40:46.709Z" title="Updated 2023-10-05 19:40:46">2023-10-05</time></header><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p><u><strong>线性表</strong></u>：具有相同特性的数据元素的一个有限序列。</p>
<p>具有<strong>有穷性</strong>、<strong>一致性</strong>（所有元素的性质相同）、<strong>序列性</strong>（所有元素的相对位置是线性的，即存在唯一的开始元素和终端元素，除此之外每个元素只有唯一的前驱元素和后继元素）。</p>
<p>线性表的<strong>顺序存储结构</strong>：顺序表，借助数组实现（数组存放线性表元素、另外一个int型的值存放线性表长度）。</p>
<p>顺序表求线性表长度、按索引取元素的时间复杂度为O(1)，按值查找元素的时间复杂度为O(n)，插入、删除元素的平均时间复杂度为O(n)。</p>
<h2 id="1-链表"><a href="#1-链表" class="headerlink" title="1 链表"></a>1 链表</h2><p>线性表的<strong>链式存储结构</strong>：链表。</p>
<p>可分为单链表、双链表、循环链表。</p>
<p>链表可用来表示线性表，也可以用来表示各种非线性的数据结构。</p>
<h3 id="1-1-单链表"><a href="#1-1-单链表" class="headerlink" title="1.1 单链表"></a>1.1 单链表</h3><p>单链表<strong>结点类型</strong>描述如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span> &#123;</span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LNode</span> * next;</span><br><span class="line">&#125;LinkNode;</span><br></pre></td></tr></table></figure>

<p>单链表的建立：</p>
<ul>
<li><p><strong>头插法</strong></p>
<p>常用在将一个已存在的链表逆序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ListNode * L = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">	ListNode * s = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    s-&gt;data = a[i];</span><br><span class="line">    s-&gt;next = L-&gt;next;   <span class="comment">// 头插法</span></span><br><span class="line">    L-&gt;next = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**<u>&#x3D;&#x3D;使用头插法将链表x逆序&#x3D;&#x3D;</u>**：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">item</span>&#123;</span><br><span class="line">    <span class="type">char</span> C;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">item</span> next:</span><br><span class="line">&#125;Item;</span><br><span class="line"><span class="function">Item *<span class="title">Routinel</span> <span class="params">(Item *x)</span> </span>&#123;</span><br><span class="line">    Item *prev=<span class="literal">NULL</span>, *curr=x;</span><br><span class="line">    <span class="keyword">while</span>(curr) &#123;               <span class="comment">// 遍历结点</span></span><br><span class="line">        Item next=curr-&gt;next;</span><br><span class="line">        curr-&gt;next=prev;        <span class="comment">// 头插法</span></span><br><span class="line">        prev=curr;              <span class="comment">// 更新指针</span></span><br><span class="line">        curr=next;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>尾插法</strong></p>
<p>需要增加一个尾指针，始终指向当前链表的尾结点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ListNode * L = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">ListNode * r;</span><br><span class="line">r = L;   <span class="comment">// 初始化尾指针r</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">	ListNode * s = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    s-&gt;data = a[i];</span><br><span class="line">    r-&gt;next = s;   <span class="comment">// 尾插法</span></span><br><span class="line">    r = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单链表的插入、删除、取元素的时间复杂度均为O(n)；求线性表长度的时间复杂度为O(n)；求线性表中某个元素的值、按值查找元素、以及插入、删除元素的时间复杂度均为O(n)。</p>
</li>
</ul>
<p><strong>顺序表和链表的比较</strong>：</p>
<ol>
<li>存取方式</li>
</ol>
<p><strong>顺序表可以顺序存取，也可以随机存取</strong>，链表只能从表头顺序存取元素。</p>
<ol start="2">
<li>查找、插入和删除操作</li>
</ol>
<p>对于按值查找，当顺序表在无序的情况下，两者的时间复杂度均为O(n)；而当顺序表有序时，可采用折半查找，此时时间复杂度为O(log2n)。 对于按序号查找，顺序表支持随机访问，时间复杂度仅为O(1)，而链表的平均时间复杂度为O(n)。 顺序表的插入、删除操作，平均需要移动半个表长的元素，因此平均时间复杂度为O(n)。链表的插入、删除操作时，只需要修改相关结点的指针域即可，时间复杂度均为O(n)。</p>
<p>3)空间分配</p>
<p>链式存储的结点空间在需要的时候申请分配，操作灵活、高效。</p>
<h3 id="1-2-快慢指针"><a href="#1-2-快慢指针" class="headerlink" title="1.2 快慢指针"></a>1.2 快慢指针</h3><p>快慢指针中的快慢指的是<strong>移动的步长</strong>，即每次向前移动速度的快慢。例如可以让快指针每次沿链表向前移动2，慢指针每次向前移动1次。</p>
<p>用途：</p>
<ul>
<li><p>&#x3D;&#x3D;<strong>判断单链表是否存在环</strong>&#x3D;&#x3D;</p>
<p>如果链表存在环，就好似操场的跑道是一个环形。此时让快、慢指针都从链表头开始遍历，快指针每次向前移动两个位置，慢指针每次向前移动一个位置；<u>如果快指针到达NULL，说明链表以NULL为结尾，没有环</u>。<u>如果快指针追上慢指针，则表示有环</u>。</p>
</li>
<li><p><strong>&#x3D;&#x3D;寻找循环链表的入口&#x3D;&#x3D;</strong></p>
<p>假设链表存在环，那么怎么寻找环的入口呢?</p>
<p>假设链表长为L，起始点到环入口长度为a，环长度为r，则L&#x3D;atr， 如图11-3所示。</p>
<p>​	<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220711211307378.png" alt="image-20220711211307378"></p>
<p>在快指针进入环到慢指针进入环前的这段时间，若环的长度较短，也许快指针已经走了好几圈了，然后慢指针进入环。</p>
<p>设慢指针和快指针在环内相遇时，慢指针在环内走了X步，走的总步数（包括环内与环外）为S步（显然<code>S=X+a</code>），那么快指针走了多少步呢？<br>快指针在环内已经走了n圈加X步，即<code>nr+X</code>步，其中n最少为1，而走的总步数为<code>nr+X+a</code>步。由于快指针走的总步数为慢指针的2倍，故<code>nr+X+a=(X+a)*2</code>。由上式得<code>a+X = nr</code>，即<code>a = nr-X = (n-1)r+r-X</code>；</p>
<p>因此a和r-x相差r的整数倍，也就是说，<u>若令快慢指针的步长均为1，慢指针从链表头开始走，快指针从相遇点也继续往前走，两者走的距离为<code>a = (n-1)r+r-X</code>时，两者相遇，此时就是环入口的位置。</u></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">FindBeginning</span> <span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* n1=head;</span><br><span class="line">    ListNode* n2=head;</span><br><span class="line">    <span class="keyword">while</span> (n2-&gt;next != <span class="literal">NULL</span>) &#123;<span class="comment">//寻找相遇点</span></span><br><span class="line">        n1=n1-&gt;next;</span><br><span class="line">        n2=n2-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(n1==n2)&#123;  <span class="comment">// 有环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//没有相遇，因而没有环</span></span><br><span class="line">    <span class="keyword">if</span> (n2-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/*确定环入口，将n1从head开始移动，n2从相遇点处移动*/</span></span><br><span class="line">	n1=head;</span><br><span class="line">	<span class="keyword">while</span> (n1 != n2) &#123;</span><br><span class="line">		n1=n1-&gt;next;</span><br><span class="line">		n2=n2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 现在n2指向的就是环入口</span></span><br><span class="line">    <span class="keyword">return</span> n2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在有序链表中寻找中位数</strong></p>
<p>利用快慢指针可不借助计数器变量实现寻找中位数的功能。</p>
<p>原理是：快指针的移动速度是慢指针移动速度的2倍，因此<u>当快指针到达链表尾时，慢指针到达中点</u>。程序还要考虑链表结点个数的奇偶数因素，当快指针移动x次(每次2步)后到达表尾，说明链表有奇数个结点，直接返回慢指针指向的数据即可。如果快指针是倒数第二个结点，说明链表结点个数是偶数，这时可以根据“规则”返回上中位数或下中位数或(上中位数+下中位数)的一半。</p>
</li>
<li><p>事实上，像快慢指针这种用两个指针分别前进来<strong>查找某个结点</strong>，还有其他的形式。</p>
<blockquote>
<p>例1：&#x3D;&#x3D;<u>寻找倒数第K个结点</u>&#x3D;&#x3D;。</p>
<p>我们可以定义两个指针，第一个指针从链表的头指针开始遍历向前走k-1步，第二个指针保持不动；从第k步开始，第二个指针也开始从链表的头指针开始遍历。由于两个指针的距离保持在k-1，当第一个指针到达链表的尾结点时，第二个指针正好是倒数第k个结点。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">findKthtoTail</span> <span class="params">(ListNode* P, <span class="type">unsigned</span> <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">assert</span>(p != <span class="literal">NULL</span> &amp;&amp; k &gt;= <span class="number">1</span>);</span><br><span class="line">	ListNode* pa=p, *pb=p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; k<span class="number">-1</span>; ++i) &#123;</span><br><span class="line">        pa-pa-&gt;pNext;</span><br><span class="line">        <span class="keyword">if</span>(pa == <span class="literal">NULL</span>)</span><br><span class="line">   			<span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">// 当链表p的长度小于k的时候，返回NULL;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (pa-&gt;pNext != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    	pa=pa-&gt;pNext;</span><br><span class="line">    	pb=pb-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>例2：&#x3D;&#x3D;<u>确定两个单向链表是否相交，若相交找出第一个公共结点</u>。&#x3D;&#x3D;</p>
<p>解答：首先利用快慢指针判断链表是否有环。</p>
<ol>
<li>如果都不存在环，则如果两个单向链表有公共的结点，也就是说两个链表<u>从某一结点开始，它们的后继结点指针都指向同一个结点。</u>但由于是单向链表的结点，每个结点只有一个next指针，因此从第一个公共结点开始，之后它们所有结点都是重合的，如下图所示。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220712095846069.png" alt="image-20220712095846069"></p>
<p>如何寻找相较的第一个结点：</p>
<p>首先两个链表各遍历一次，求出两个链表的长度L1、 L2, 然后可得出两个链表的长度差L。然后先在长的链表上遍历L个结点，之后再同步遍历，于是在遍历中，第一个相同的结点就是第一个公共的结点。此时，如果第一个链表的长度为m,第二个链表的长度为n，该方法的时间复杂度为O(m+n)。</p>
<ol start="2">
<li><p>如果一个存在环，另一个不存在环，则这两个链表是不可能相交的；</p>
</li>
<li><p>如果利用快慢指针发现两个链表都存在环，则判断任意一个链表上快慢指针相遇的那个结点在不在另一条链表上（共环，末尾结点存在环中）。如果在，则相交，如果不在，则不相交。若相交，两个链表的入口点可能并不是环上同一个结点，则再利用本节的方法各自找出两个链表环的入口点，可以定义任一入口点为相交的第一个结点。</p>
</li>
</ol>
</blockquote>
</li>
</ul>
<h3 id="1-3-双链表"><a href="#1-3-双链表" class="headerlink" title="1.3 双链表"></a>1.3 双链表</h3><p>使得查找某个结点的前驱结点的时间复杂度从O(n)变为了O(1)。</p>
<ul>
<li><p><strong>双链表的插入操作</strong></p>
<p>在双链表中p所指结点之后插入结点s</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s-&gt;next = p-&gt;next;    <span class="comment">// 将s结点插入p结点之后</span></span><br><span class="line">p-&gt;next-&gt;prior = s;</span><br><span class="line">s-&gt;prior = p;</span><br><span class="line">p-&gt;next = s;   <span class="comment">// 最后修改p-&gt;next</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220712103056289.png" alt="image-20220712103056289"></p>
</li>
<li><p><strong>双链表的删除操作</strong></p>
<p>删除双链表中结点p的后继结点q</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;next = q-&gt;next;</span><br><span class="line">q-&gt;next-&gt;prior = p;</span><br><span class="line">free(q);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-栈与队列"><a href="#2-栈与队列" class="headerlink" title="2 栈与队列"></a>2 栈与队列</h2><p>栈与队列同样是线性表，具有和线性表相同的逻辑结构，但是操作受限。</p>
<h3 id="2-1-栈（堆栈）"><a href="#2-1-栈（堆栈）" class="headerlink" title="2.1 栈（堆栈）"></a>2.1 栈（堆栈）</h3><p>栈，也叫堆栈，其限制是仅允许在表的一端进行插入和删除。人们把此端称为栈顶，栈顶的第一个元素被称为栈顶元素，相对地，把另一端称为栈底。向一个栈插入新元素又称为进栈或入栈（push），它是把该元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称为出栈或退栈（pop），它是把栈顶元素删除掉，使其下面的相邻元素成为新的栈顶元素。</p>
<p>由于堆栈数据结构只允许在一端进行操作，因而按照<strong>后进先出</strong>（LIFO, Last In First Out）的原理运作。</p>
<h4 id="栈的顺序存储结构"><a href="#栈的顺序存储结构" class="headerlink" title="栈的顺序存储结构"></a>栈的顺序存储结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data[MaxSize];  <span class="comment">// 存放栈中的数据元素，下标范围为0 ~ MaxSize-1</span></span><br><span class="line">    <span class="type">int</span> top;                 <span class="comment">// 栈顶指针，存放栈顶元素在data数组中的下标</span></span><br><span class="line">&#125;SqStack；</span><br></pre></td></tr></table></figure>

<p><strong>栈空的条件</strong>：<code>s-&gt;top == -1</code>。</p>
<p><strong>栈满的条件</strong>：<code>s-&gt;top == MaxSize-1</code>。</p>
<p><strong>进栈</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(SqStack * &amp;s, ElemType e)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s-&gt;top == MaxSize<span class="number">-1</span>)  <span class="comment">// 栈已满</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;top++;   <span class="comment">// 入栈，栈顶指针加1</span></span><br><span class="line">    s-&gt;data[s-&gt;top] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>出栈</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(SqStack * &amp;s, ElemType &amp;e)</span></span>&#123;  <span class="comment">// 注意e为引用</span></span><br><span class="line">	<span class="keyword">if</span>(s-&gt;top == <span class="number">-1</span>)  <span class="comment">// 栈已空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e = s-&gt;data[s-&gt;top];  <span class="comment">// 取栈顶元素</span></span><br><span class="line">    s-&gt;top--;             <span class="comment">// 出栈，栈顶指针减1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>取栈顶元素</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetTop</span><span class="params">(SqStack * &amp;s, ElemType &amp;e)</span></span>&#123;  <span class="comment">// 注意e为引用</span></span><br><span class="line">	<span class="keyword">if</span>(s-&gt;top == <span class="number">-1</span>)  <span class="comment">// 栈已空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e = s-&gt;data[s-&gt;top];  <span class="comment">// 取栈顶元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>销毁栈</strong>：free(s)。</p>
<hr>
<h4 id="栈的链式存储结构——链栈"><a href="#栈的链式存储结构——链栈" class="headerlink" title="栈的链式存储结构——链栈"></a>栈的链式存储结构——链栈</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">linknode</span>&#123;</span><br><span class="line">    ElemType data;             <span class="comment">// 存放栈中的数据元素</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">linknode</span> *next;     <span class="comment">// 指针域</span></span><br><span class="line">&#125;LinkStNode；</span><br></pre></td></tr></table></figure>

<p><strong>栈空的条件</strong>：<code>s-&gt;next == NULL</code>。</p>
<p><strong>栈满的条件</strong>：不考虑。</p>
<p><strong>进栈</strong>：插入<u>头节点</u>之后</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(LinkStNode * &amp;s, ElemType e)</span></span>&#123;</span><br><span class="line">	LinkStNode *p = <span class="keyword">new</span> <span class="built_in">LinkStNode</span>();</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    p-&gt;next = s-&gt;next;   <span class="comment">// 入栈,插入头结点s之后，作为新的首结点</span></span><br><span class="line">    s-&gt;next = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>出栈</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(LinkStNode * &amp;s, ElemType &amp;e)</span></span>&#123;  <span class="comment">// 注意e为引用</span></span><br><span class="line">    LinkStNode *p;</span><br><span class="line">	<span class="keyword">if</span>(s-&gt;next == <span class="literal">NULL</span>)   <span class="comment">// 栈已空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    p = s-&gt;next;          <span class="comment">// p指向首结点</span></span><br><span class="line">    e = p-&gt;data;          <span class="comment">// 提取首结点值</span></span><br><span class="line">    s-&gt;next = p-&gt;next;    <span class="comment">// 删除首结点</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>取栈顶元素</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetTop</span><span class="params">(LinkStNode * &amp;s, ElemType &amp;e)</span></span>&#123;  <span class="comment">// 注意e为引用</span></span><br><span class="line">	<span class="keyword">if</span>(s-&gt;next == <span class="literal">NULL</span>)   <span class="comment">// 栈已空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e = s-&gt;next-&gt;data;  <span class="comment">// 取栈顶元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-栈的应用"><a href="#2-2-栈的应用" class="headerlink" title="2.2 栈的应用"></a>2.2 栈的应用</h3><h4 id="中缀表达式和后缀表达式"><a href="#中缀表达式和后缀表达式" class="headerlink" title="中缀表达式和后缀表达式"></a>中缀表达式和后缀表达式</h4><p><strong>中缀表达式</strong>：运算符在数之间，如<code>A+B*(C-D)-E/F</code>，需要考虑运算符的出现顺序、优先级，以及括号的使用。</p>
<p><strong>后缀表达式</strong>（逆波兰式）：把运算符放在两个运算对象之后。不存在括号，也不存在优先级的差别，计算过程按照运算符出现的先后次序进行。比如<code>A+B*(C-D)-E/F</code>对应的后缀表达式为<code>ABCD-*+EF/-</code>。</p>
<p>&#x3D;&#x3D;中缀表达式转换为后缀表达式：&#x3D;&#x3D;</p>
<p><u><strong>方法一：使用两个栈实现</strong></u></p>
<p>要使用到2个栈，stack栈用来存放运算符，post栈用来存放最后的后缀表达式。</p>
<p>转换原则是：从左向右扫描中缀表达式，<u>若读到的是操作数，则直接存入post栈</u>；若读到的是运算符：</p>
<ol>
<li><p>该运算符为”(“，则直接存入stack栈；</p>
</li>
<li><p>该运算符为”)”，则将stack栈中第一个”(“前的所有运算符依次出栈，并依次存入post栈，但是”(“和”)”都不存入post栈；</p>
</li>
<li><p>若该运算符为非括号，则<u>将该运算符和stack栈顶运算符进行比较，若<strong>高于</strong>栈顶运算符，则直接存入stack栈，否则将栈顶运算符出栈，存入post栈</u>，然后继续与新的栈顶元素比较，直到该运算符能存入stack。（使得post中优先级高的运算符在前，或者说接近栈底）当扫描完后，stack栈中还有运算符时，则将所有的运算符出栈，存入post栈。</p>
</li>
</ol>
<p><code>A+B*(C-D)-E/F</code>转换为后缀表达式的过程如下：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220713095114567.png" alt="image-20220713095114567" style="zoom:20%;" />

<p><strong><u>方法二：使用语法树实现</u></strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220713095408275.png" alt="image-20220713095408275"></p>
<p><strong><u>方法三：加括号法</u></strong></p>
<ol>
<li>先按照运算符的优先级对中缀表达式加括号，变成<code>((a+(b*c))+(((d*e)+f)*g))</code></li>
<li>将运算符移到括号的后面，变成<code>((a(bc)*)+(((de)*f)+g)*)+</code></li>
<li>去掉括号，得到<code>abc*+de*f+g*+</code></li>
</ol>
<h4 id="后缀表达式的求值"><a href="#后缀表达式的求值" class="headerlink" title="后缀表达式的求值"></a>后缀表达式的求值</h4><p>通过后缀表示计算表达式值的过程为：<br>顺序扫描表达式的每一项，然后根据它的类型做如下相应操作：如果该项是操作数，则将其压入栈中；<u>如果该项是操作符&lt;op&gt;，则连续从栈中退出两个操作数Y和X，形成运算指令X&lt;op&gt;Y，并将计算结果重新压入栈中</u>。当表达式的所有项都扫描并处理完后，栈顶存放的就是最后的计算结果。</p>
<h3 id="2-3-Catalan数"><a href="#2-3-Catalan数" class="headerlink" title="2.3 Catalan数"></a>2.3 Catalan数</h3><p>卡特兰数（Catalan number）是<strong>组合数学</strong>中一个常出现在各种<strong>计数问题</strong>中的<strong>数列</strong>。</p>
<p>数列的前几项为：1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, …</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220713150425813.png" alt="image-20220713150425813"></p>
<p><strong>相关的经典问题：</strong></p>
<h4 id="进出栈序列"><a href="#进出栈序列" class="headerlink" title="进出栈序列"></a>进出栈序列</h4><blockquote>
<p>n个元素进栈序列为：1，2，3，4，…，n，则有多少种出栈序列？</p>
</blockquote>
<p>将进栈表示为 +1，出栈表示为 -1，根据栈本身的特点，每次出栈的时候，必定之前有元素入栈，即对于每个 -1 前面都有一个 +1 相对应。因此，出栈序列的 <strong>所有前缀和</strong> 必然大于等于 0，并且 +1 的数量 <strong>等于</strong> -1 的数量。</p>
<p>当出现某一前缀和小于0时（即出现前缀和等于-1的情况，-1的数量比+1多一个），该出栈序列就是非法的。假设+1和-1的数量均为n，将该前缀取反之后，就会变成+1的数量比-1多一个，即存在n+1个+1，n-1个-1。取反后的序列与之前的序列是一一对应的。因此，非法序列的数量有$C^{n+1}<em>{2n}$。因此，合法的出栈序列的数量为$\LARGE C^{n}</em>{2n}-C^{n+1}<em>{2n}&#x3D;\frac{C^{n}</em>{2n}}{n+1}$。此时我们就得到了卡特兰数的通项$\LARGE \frac{C^{n}_{2n}}{n+1}$。</p>
<h4 id="括号序列"><a href="#括号序列" class="headerlink" title="括号序列"></a>括号序列</h4><blockquote>
<p>n 对括号，则有多少种 “括号匹配” 的括号序列</p>
</blockquote>
<p>左括号看成 +1，右括号看成 -1，那么就和上题的进出栈一样，每次有右括号的时候，必定之前有左括号匹配，且序列的 <strong>所有前缀和</strong> 必然大于等于 0，并且 +1 的数量 <strong>等于</strong> -1 的数量。因此共有$\LARGE \frac{C^{n}_{2n}}{n+1}$种序列。</p>
<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><blockquote>
<p><code>n + 1</code> 个叶子节点能够构成多少种形状不同的（国际）满二叉树（结点要么是叶子结点，要么它有两个子结点，且叶子节点均在最后一层）</p>
</blockquote>
<p>使用深度优先搜索这个满二叉树，向左扩展时标记为 +1，向右扩展时标记为 -1。</p>
<p>由于每个非叶子节点都有两个左右子节点，所有它必然会先向左扩展，再向右扩展。总体下来，左右扩展将会形成匹配，即变成进出栈的题型。<code>n + 1</code>个叶子结点会有 2n 次扩展，构成$\LARGE \frac{C^{n}_{2n}}{n+1}$种形状不同的满二叉树。</p>
<p><strong>基本上所有的卡特兰数问题经过一定的转换都可以还原成进出栈问题，其中都会存在一种匹配关系，如进出栈匹配，括号匹配等。</strong>一旦计数问题中存在这种关系，那我们就需要去考虑这是否是卡特兰数问题。此外，我们还可以记住序列前四项：<code>1, 1, 2, 5</code>，这些将有利于我们联想到卡特兰数。</p>
<p>例如，以下问题的题解均为卡特兰数：</p>
<p>有2n个人排成一行进入剧场。 入场费5元。其中只有n个人有一张5元钞票，另外n人只有10元钞票，剧院无其他钞票，问有多少种方法使得只要有10元的人买票，售票处就有5元的钞票找零? $\LARGE \frac{C^{n}<em>{2n}}{n+1}$种。<br>一位大城市的律师在她住所以北n个街区和以东n个街区处工作。每天她走2n个街区去上班。如果她从不穿越(但可以碰到)从家到办公室的对角线，那么有多少条可能的道路? $\LARGE \frac{C^{n}</em>{2n}}{n+1}$种。<br>在圆上选择2n个点，将这些点成对连接起来使得所得到的n条线段不相交的方法数? $\LARGE \frac{C^{n}<em>{2n}}{n+1}$种。<br>矩阵连乘：p&#x3D;$a_1$x$a_2$x…x$a_n$，依据乘法结合律，不改变其顺序，只用括号表示成对的乘积，试问有几种括号化的方案? $\LARGE \frac{C^{n}</em>{2n}}{n+1}$种。</p>
<h3 id="2-4-队列"><a href="#2-4-队列" class="headerlink" title="2.4 队列"></a>2.4 队列</h3><p>一种操作受限的线性表，<strong>仅允许在表的一端（队尾）进行插入操作（入队），而在表的另一端（队首）进行删除操作（出队）</strong>。因此，队列也叫做<strong>先进先出表</strong>。</p>
<h4 id="队列的顺序存储结构"><a href="#队列的顺序存储结构" class="headerlink" title="队列的顺序存储结构"></a>队列的顺序存储结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	ElemType data[MaxSize];   <span class="comment">// 队列中的元素</span></span><br><span class="line">    <span class="type">int</span> front, rear;          <span class="comment">// 队头指针和队尾指针，front、rear初始值-1</span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure>

<p><strong>队空的条件</strong>：<code>q-&gt;front == q-&gt;rear</code>。</p>
<p><strong>队满的条件</strong>：<code>q-&gt;rear == MaxSize-1</code>。</p>
<p><strong>进队</strong>：<u>rear增1</u>，然后将元素e插入到该位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">enQueue</span><span class="params">(SqQueue *&amp;q, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;rear == MaxSize<span class="number">-1</span>)   <span class="comment">// 队满</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    q-&gt;rear++;           <span class="comment">// 队尾增1</span></span><br><span class="line">    q-&gt;data[q-&gt;rear] = e;   <span class="comment">// 队尾插入元素e</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>出队</strong>：<u>front增1</u>，然后将该位置的元素赋给e。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">deQueue</span><span class="params">(SqQueue *&amp;q, ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;front == q-&gt;rear)   <span class="comment">// 队空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    q-&gt;front++;</span><br><span class="line">    e = q-&gt;data[q-&gt;front];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>队列的元素个数：<code>rear-front</code>。</p>
<p>进队时rear增1，出队时front增1，这样整个队列会在数组中慢慢向右移动，容易出现假溢出的情况。</p>
<hr>
<h4 id="环形队列"><a href="#环形队列" class="headerlink" title="环形队列"></a>环形队列</h4><p>按照<code>q-&gt;rear == MaxSize-1</code>的队满条件判断时，可能存在假溢出的情况，另一端仍然存在空位置。解决的办法是把data数组的前后端连接在一起，形成环形队列（循环队列）。<strong>用数组实现队列的话，循环队列一般是必需的。</strong></p>
<p>环形队列的队空条件：<code>q-&gt;front == q-&gt;rear</code>。</p>
<p>环形队列的队满条件：<code>(q-&gt;rear+1) % MaxSize == q-&gt;front</code>。</p>
<p><strong>环形队列的进队</strong>：rear增1，然后将元素e插入到该位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">enQueue</span><span class="params">(SqQueue *&amp;q, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((q-&gt;rear+<span class="number">1</span>) % MaxSize == q-&gt;front)   <span class="comment">// 队满</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    q-&gt;rear = (q-&gt;rear+<span class="number">1</span>) % MaxSize; <span class="comment">// 队尾增1，注意：环形队列的rear指针是循环增1，也就是还要对MaxSize取余</span></span><br><span class="line">    q-&gt;data[q-&gt;rear] = e;            <span class="comment">// 队尾插入元素e</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>环形队列的出队</strong>：front增1，然后将该位置的元素赋给e。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">deQueue</span><span class="params">(SqQueue *&amp;q, ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;front == q-&gt;rear)   <span class="comment">// 队空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    q-&gt;front = (q-&gt;front+<span class="number">1</span>) % MaxSize; <span class="comment">// 队头增1，注意：环形队列的front指针是循环增1，也就是还要对MaxSize取余</span></span><br><span class="line">    e = q-&gt;data[q-&gt;front];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>环形队列的元素个数</strong>：<code>(rear-front+MaxSize) % MaxSize</code>。</p>
<hr>
<h4 id="队列的链式存储结构——链队"><a href="#队列的链式存储结构——链队" class="headerlink" title="队列的链式存储结构——链队"></a>队列的链式存储结构——链队</h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220713162757790.png" alt="image-20220713162757790" style="zoom:20%;" />

<p>链队中的<u>数据结点类型</u>DataNode的声明如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">qnode</span>&#123;</span><br><span class="line">	ElemType data;            <span class="comment">// 存放元素</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qnode</span> *next;       <span class="comment">// 下一个结点指针</span></span><br><span class="line">&#125;DataNode;</span><br></pre></td></tr></table></figure>

<p>链队<u>头结点类型</u>LinkQuNode的声明如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">	DataNode *front;      // 指向队首结点</span><br><span class="line">    DataNode *rear;       // 指向队尾结点</span><br><span class="line">&#125;LinkQuNode;</span><br></pre></td></tr></table></figure>

<p><strong>队空的条件</strong>：<code>q-&gt;front == NULL</code>或者<code>q-&gt;rear == NULL</code>。</p>
<p><strong>队满的条件</strong>：不考虑。</p>
<p><strong>进队</strong>：新建结点存放元素e（由p指向它），将结点p插入作为尾结点。要注意原来队列为空的情况。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">enQueue</span><span class="params">(LinkQuNode *&amp;q, ElemType e)</span></span>&#123;</span><br><span class="line">    DataNode *p = <span class="keyword">new</span> <span class="built_in">DataNode</span>();</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;rear==<span class="literal">NULL</span>)  <span class="comment">// 队列为空，front和rear将都指向新增的结点p</span></span><br><span class="line">        q-&gt;front=q-&gt;rear=q;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        q-&gt;rear-&gt;next = p   <span class="comment">// 队尾插入元素e</span></span><br><span class="line">        q-&gt;rear = p;        <span class="comment">// 更新队尾指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>出队</strong>：取出队首结点的data值并将其删除。要注意原来的队列仅有一个数据结点的情况。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">deQueue</span><span class="params">(LinkQuNode *&amp;q, ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    DataNode *t;          <span class="comment">// 用于暂存队首结点</span></span><br><span class="line">    <span class="keyword">if</span>(q-&gt;rear == <span class="literal">NULL</span>)   <span class="comment">// 队空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    t = q-&gt;front;         <span class="comment">// 取队首结点</span></span><br><span class="line">    <span class="keyword">if</span>(q-&gt;front == q-&gt;rear)   <span class="comment">// 原来的队列仅有一个数据结点</span></span><br><span class="line">        q-&gt;front=q-&gt;rear=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        q-&gt;front = q-&gt;front-&gt;next;</span><br><span class="line">    e = t-&gt;data;</span><br><span class="line">    <span class="built_in">free</span>(t);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-树"><a href="#3-树" class="headerlink" title="3 树"></a>3 树</h2><h3 id="3-1-树的基本概念和性质"><a href="#3-1-树的基本概念和性质" class="headerlink" title="3.1 树的基本概念和性质"></a>3.1 树的基本概念和性质</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>树是N (N&gt;&#x3D;0)个结点的有限集。当N&#x3D;0时， 树为空树。N&gt;0时，有且仅有一个结点作为树的 <strong>根节点</strong>。</p>
<p>树中一个结点的子结点个数称为该 <strong>结点的度</strong> ，树中结点的最大度数称为 <strong>树的度</strong>。通常将度为m的树成为 <strong>m次树</strong>。</p>
<p>度不为0的结点称为 <strong>分支结点</strong>，度为0的结点称为 <strong>叶子结点</strong>。</p>
<p>结点的层次从树根开始定义，根结点为第1层，它的子结点为第2层，以此类推。结点的<strong>深度</strong>是<u>从根结点</u>开始自顶向下逐层累加的；结点的<strong>高度</strong>是<u>从叶结点</u>开始自底向上逐层累加的。树中结点的最大层数称为<strong>树的高度或深度</strong>。</p>
<p>有序树和无序树：将子结点视为有顺序的树称为有序树，反之则称为无序树。有序树中，一个结点其子结点按从左到右顺序出现是有关联的。</p>
<p><strong>森林</strong>是m (m≥0)棵互不相交的树的集合。森林的概念与树的概念十分相近，因为只要把树的根结点删去就成了森林。反之，只要给n棵独立的树加上一个结点，并把这n棵树作为该结点的子树，则森林就变成了树。</p>
<h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p><strong>树具有如下最基本的性质:</strong></p>
<ol>
<li>树中的结点数等于所有结点的度数加1。</li>
<li><strong>度为m的树中第i层上至多有$m^{i-1}$个结点（i≥1）</strong>。</li>
<li>高度为h的m叉树至多有$(m^h-1)&#x2F;(m- 1)$个结点。（1、$m$、$m^2$、…、$m^{h-1}$的等比数列求和）</li>
<li>具有n个结点的m叉树的最小高度为$[log_{m}(n(m -1)+1)]$。 （根据$n&#x3D;(m^h-1)&#x2F;(m- 1)$计算得到）</li>
</ol>
<h4 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h4><ul>
<li><p><strong>双亲存储结构</strong></p>
<p>树的一种顺序存储结构，用一组连续空间存储树的所有结点，每个结点中设有一个伪指针指示其双亲结点的位置。固定根结点的双亲结点位置为-1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	ElemType data; <span class="comment">// 存放结点的值</span></span><br><span class="line">    <span class="type">int</span> parent;    <span class="comment">// 存放双亲结点位置</span></span><br><span class="line">&#125;PTree[MAxSize];</span><br></pre></td></tr></table></figure>

<p>特点：容易查找某个结点的双亲结点，但是在求某个结点的孩子结点时需要遍历整个树。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220713200419420.png" alt="image-20220713200419420" style="zoom:20%;" />
</li>
<li><p><strong>孩子链存储结构</strong></p>
<p>每个结点的存储空间不仅包括结点值，还有指向其所有孩子结点的指针。需要按照树的度来设计结点的孩子结点指针的指针域个数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct node&#123;</span><br><span class="line">	ElemType data;                 // 存放结点的值</span><br><span class="line">    struct node *sons[MaxSons];    // 指向孩子结点，MaxSons为最多的孩子结点个数，即该树的度</span><br><span class="line">&#125;PTree[MAxSize];</span><br></pre></td></tr></table></figure>

<p>特点：查找孩子结点方便，但是查找双亲结点费时，并且当树的度较大时存在较多的空指针域。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220713201928679.png" alt="image-20220713201928679" style="zoom:20%;" />
</li>
<li><p><strong>孩子兄弟链存储结构</strong></p>
<p>每个结点设计了3个域，包括<u>数据元素域</u>、一个指向该结点的<u>左边第一个孩子</u>的指针域、一个指向该结点的<u>下一个兄弟</u>结点的指针域。这样每个结点就固定只有2个指针域，且这两个指针域是有序的（类似二叉树的存储结构）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tnode</span>&#123;</span><br><span class="line">	ElemType data;       <span class="comment">// 存放结点的值</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tnode</span> *hp;    <span class="comment">// 指向兄弟结点</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tnode</span> *vp;    <span class="comment">// 指向孩子结点</span></span><br><span class="line">&#125;TSBNode;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-2-二叉树"><a href="#3-2-二叉树" class="headerlink" title="3.2 二叉树"></a>3.2 二叉树</h3><p>二叉树是另一种树形结构(是n (n≥0)个结点的有限集合)，其特点是每个结点至多只有两棵子树(即二叉树中不存在度大于2的结点)，并且，二叉树的<u>子树有左右之分，其次序不能任意颠倒</u>。</p>
<p>二叉树是有序树，若将其左、右子树颠倒，就成为另一棵不同的二叉树。即使树中结点只有一棵子树，也要区分它是左子树还是右子树。</p>
<p>**<u>注意：</u>**二叉树与度为2的有序树的区别：度为2的树至少有3个结点，而二叉树可以为空；度为2的有序树的孩子结点的左右次序是相对于另一孩子结点而言的，如果某个结点只有一个孩子结点，这个孩子结点就无须区分其左右次序，而二叉树无论其孩子数是否为2，均需确定其左右次序。</p>
<p>下面介绍几种特殊的二叉树。</p>
<h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a><strong>满二叉树</strong></h4><p><u>叶子结点都集中在二叉树的最下一层</u>， 并且<u>除叶子结点之外的每个结点度数均为2</u>的二叉树称为满二叉树，即树中的每一层都含有最多的结点，如图13-1(a)所示。或者也可以说一棵高度为h且含有$2^h-1$ 个结点的树为满二叉树。</p>
<p>可以对满二叉树按层序编号：约定编号从根结点(根结点编号为1) 起，自上而下，自左向右。这样每个结点对应一一个编号， 对于编号为i的结点，如果有双亲，其<u>双亲</u>为⌊i&#x2F;2⌋，如果有左孩子，则<u>左孩子</u>为2i；如果有右孩子，则<u>右孩子</u>为2i+1。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220713205538873.png" alt="image-20220713205538873"></p>
<h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a><strong>完全二叉树</strong></h4><p>设一个高度为h，有n个结点的二叉树，当且仅当其每一个结点都与高度为h的满二叉树中编号为1~n的结点一一对应时，称为完全二叉树，如图13- 1(b)所示。这种树的特点如下:</p>
<p>① 若$i≤\lfloor n&#x2F;2 \rfloor$，则结点i为分支结点，否则为叶子结点。（层次遍历，前一半的结点均为分支结点，后一半均为叶子结点）</p>
<p>② **<u>叶子结点只可能在层次最大的两层上出现</u><strong>。</strong><u>最大层次中的叶子结点都依次排列在该层最左边的位置上</u>**。</p>
<p>③ 如果有度为1的结点，只可能有一个，且该结点<u>只有左孩子</u>而无右孩子。</p>
<p>④ 按层序编号后，一旦出现某结点(其编号为i)为叶子结点或只有左孩子，则编号大于i的结点均为叶子结点。</p>
<p>⑤ 若n为奇数，则每个分支结点都有左孩子和右孩子；<u>若n为偶数，则编号最大的分支结点(编号为n&#x2F;2)只有左子女，没有右子女</u>，其余分支结点左、右子女都有。</p>
<p><u>注意</u>：性质3中表明完全二叉树中，<u><strong>度为1的结点数</strong> 要么为0，要么为1</u>。<strong>当总结点数为偶数时，度为1的结点数为1；当总结点数为奇数时，度为1的结点数为0。</strong><u><strong>叶子结点数</strong> 为：总结点数&#x2F;2</u>。</p>
<h4 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h4><p>二叉树的性质</p>
<ol>
<li><strong>非空二叉树上<u>叶子结点（度为0）数等于度为2的结点数加1</u>，即$\large N_0&#x3D;N_2+1$。</strong></li>
</ol>
<p><strong>证明</strong>：设度为0、1和2的结点个数分别为$N_0$、$N_1$和$N_2$，结点总数$N$&#x3D;$N_0$+$N_1$+$N_2$。再看二叉树中的分支数，除根结点外，其余结点都有一个分支进入，设B为分支总数，则$N&#x3D;B+1$。由于这些分支是由度为1或2的结点射出的，所以又有$B$ &#x3D;$N_1$+$2N_2$。于是得$\large N_0&#x3D;N_2+1$.</p>
<ol start="2">
<li><p>非空二叉树上第K层上至多有$2^{k-1}$个结点(K≥1)。</p>
</li>
<li><p>**高度为H的二叉树至多有$2^H-1$个结点(H≥1)**。</p>
</li>
<li><p>对完全二叉树按从上到下、从左到右的顺序<u>依次编号1, 2, …, N，则有以下关系</u>：</p>
</li>
</ol>
<p>a) 当i&gt;1时，结点i的双亲结点编号为⌊i&#x2F;2⌋，即当i为偶数时，其双亲结点的编号为i&#x2F;2，它是双亲结点的左孩子；当i为奇数时，其双亲结点的编号为(i -1)&#x2F;2，它是双亲结点的右孩子。</p>
<p>b) 当2i≤N时，结点i的<strong>左孩子编号为2i</strong>,否则无左孩子。</p>
<p>c) 当2i+1≤N时，结点i的<strong>右孩子编号为2i+1</strong>, 否则无右孩子。</p>
<p>d) 结点i所在层次(深度)为$⌊log_2i⌋+1$。</p>
<ol start="5">
<li>具有N个(N&gt;0)结点的 <strong>完全二叉树的高度</strong> 为$\lfloor log_2N \rfloor +1$ 或者 $\lceil log_2(N+1) \rceil \space$。</li>
</ol>
<blockquote>
<p>例题：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220714092056003.png" alt="image-20220714092056003"></p>
</blockquote>
<h4 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h4><ul>
<li><p>二叉树的顺序存储结构</p>
<p>顺序存储就是用一组地址连续的存储单元依次自上而下、自左而右存储完全二叉树的结点元素，即<u>将完全二叉树编号为i的结点元素存储在某个数组下标为i-1的分量中</u>。对于一般二叉树，则应将其每个结点与完全二叉树上的结点相对照，存储在一维数组的相应分量中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> ElemType SqBinTree[MaxSize];   # 为方便运算，一般下标为<span class="number">0</span>的位置空着，空结点用<span class="string">&quot;#&quot;</span>表示</span><br></pre></td></tr></table></figure>

<p>然而，在最坏的情况下，一个高度为H且只有H个结点的单支树却需要占据接近$2^H-1$个存储单元。因此，顺序存储结构<u>一般仅适用在完全二叉树中</u>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220714093138887.png" alt="image-20220714093138887"></p>
</li>
<li><p>二叉树的链式存储结构</p>
<p>每个结点由三个域组成，包括数据域、指向该结点左孩子结点的指针域、指向该结点右孩子结点的指针域。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">  	ElemType data;</span><br><span class="line">      <span class="keyword">struct</span> <span class="title class_">node</span> *lchild;</span><br><span class="line">      <span class="keyword">struct</span> <span class="title class_">node</span> *rchild;</span><br><span class="line">  &#125;BTNode;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220714093353067.png" alt="image-20220714093353067"></p>
<p>容易验证，在有n个结点的二叉树中，每个结点有2个指针域，因此一共存在2n个链域。其中，除根结点外，其余结点均有指针指向，因此，有n-1个有效链域，n+1个空链域。</p>
</li>
</ul>
<h4 id="x3D-x3D-二叉树的遍历-x3D-x3D"><a href="#x3D-x3D-二叉树的遍历-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;二叉树的遍历&#x3D;&#x3D;"></a>&#x3D;&#x3D;二叉树的遍历&#x3D;&#x3D;</h4><p>很多问题的求解是借助二叉树的遍历完成的。重点为<u><strong>二叉树遍历的非递归算法</strong></u>。</p>
<ul>
<li><strong>&#x3D;&#x3D;先序遍历&#x3D;&#x3D;</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-------------递归-------------*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(BTNode *b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(b != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%c&quot;</span>, b-&gt;data);</span><br><span class="line">        <span class="built_in">PreOrder</span>(b-&gt;lchild);</span><br><span class="line">        <span class="built_in">PreOrder</span>(b-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-------------非递归（使用顺序栈实现）-------------*/</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(BTNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    stack&lt;BTNode*&gt; s;  <span class="comment">//辅助栈</span></span><br><span class="line">    <span class="comment">//根节点先进栈</span></span><br><span class="line">    s.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="comment">//直到栈中没有节点</span></span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="comment">//每次栈顶就是访问的元素</span></span><br><span class="line">        BTNode* node = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        <span class="comment">//如果有右孩子，则右孩子进栈</span></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;right)</span><br><span class="line">            s.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        <span class="comment">//如果有左孩子，则左孩子进栈</span></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left)</span><br><span class="line">            s.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>&#x3D;&#x3D;中序遍历&#x3D;&#x3D;</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-------------递归-------------*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(BTNode *b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(b != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">InOrder</span>(b-&gt;lchild);</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%c&quot;</span>, b-&gt;data);</span><br><span class="line">        <span class="built_in">InOrder</span>(b-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-------------非递归（使用顺序栈实现）-------------*/</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(BTNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    stack&lt;BTNode*&gt; s;  <span class="comment">//辅助栈</span></span><br><span class="line">    <span class="comment">//当树结点不为空或栈中有结点时</span></span><br><span class="line">    <span class="keyword">while</span>(root != <span class="literal">NULL</span> || !s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="comment">//每次先找到最左结点，路径上的结点均入栈</span></span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            s.<span class="built_in">push</span>(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//弹出栈顶</span></span><br><span class="line">        BTNode* node = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        <span class="comment">//左孩子为空，进入右孩子结点</span></span><br><span class="line">        root = node-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>&#x3D;&#x3D;后序遍历&#x3D;&#x3D;</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-------------递归-------------*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">(BTNode *b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(b != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">PostOrder</span>(b-&gt;lchild);</span><br><span class="line">        <span class="built_in">PostOrder</span>(b-&gt;rchild);</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%c&quot;</span>, b-&gt;data);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-------------非递归（使用顺序栈实现）-------------*/</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(BTNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;   <span class="comment">// 返回结果</span></span><br><span class="line">    stack&lt;BTNode*&gt; s;  <span class="comment">//辅助栈</span></span><br><span class="line">    BTNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(root != <span class="literal">NULL</span> || !s.<span class="built_in">empty</span>())&#123;    <span class="comment">// 指针root和栈均为空时结束循环</span></span><br><span class="line">        <span class="comment">//每次先找到最左边的结点，路径上的结点均入栈</span></span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            s.<span class="built_in">push</span>(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//弹出栈顶</span></span><br><span class="line">        BTNode* node = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">//如果该结点没有右孩子或是右孩子已经访问过</span></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;right == <span class="literal">NULL</span> || node-&gt;right == pre)&#123;</span><br><span class="line">            <span class="comment">//访问该结点自身</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="comment">//且记录为访问过了</span></span><br><span class="line">            pre = node;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//有右孩子，则该结点入栈，先去访问右孩子</span></span><br><span class="line">            s.<span class="built_in">push</span>(node);</span><br><span class="line">            root = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>层序遍历</strong>（借助队列实现）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-------------使用队列实现-------------*/</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">levelOrder</span>(BTNode* root) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; res;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> res;</span><br><span class="line">    queue&lt;BTNode *&gt; qu;</span><br><span class="line">    qu.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!qu.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> size = qu.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">        <span class="keyword">while</span> (size--) &#123;</span><br><span class="line">            <span class="comment">// 取队首结点</span></span><br><span class="line">            BTNode *node = qu.<span class="built_in">front</span>();</span><br><span class="line">            qu.<span class="built_in">pop</span>();</span><br><span class="line">            vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="comment">// 左右孩子入队</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) qu.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) qu.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (vec.<span class="built_in">size</span>() &gt; <span class="number">0</span>) res.<span class="built_in">push_back</span>(vec);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-3-二叉树的应用"><a href="#3-3-二叉树的应用" class="headerlink" title="3.3 二叉树的应用"></a>3.3 二叉树的应用</h3><blockquote>
<ol>
<li><em><strong>判断两颗二叉树是否相同。</strong></em></li>
</ol>
</blockquote>
<p>运用递归的方法，按照先序遍历对比即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">node</span> *left;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">node</span> *right;</span><br><span class="line">&#125;BTNode;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEqual</span> <span class="params">(BTNode* node1, BTNode* node2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//树为空的情况</span></span><br><span class="line">    <span class="keyword">if</span> (nodel == <span class="literal">NULL</span> &amp;&amp; node2 = <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>;	</span><br><span class="line">    <span class="keyword">if</span> (!nodel || !node2) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//根结点相等，继续对比左孩子和右孩子</span></span><br><span class="line">    <span class="keyword">if</span> (nodel-&gt;val == node2-&gt;val)</span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">isEqual</span> (node1-&gt;left, node2-&gt;left) &amp;&amp; <span class="built_in">isEqual</span> (node1-&gt;right, node2-&gt;right);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进一步的，比较两棵可以旋转的二叉树是否相等。二叉树的左右子结点可以旋转是指可以把二叉树的左结点旋转成为右结点，右结点旋转成为左结点。(2012. 百度)</p>
<p>若左右子结点可以旋转的话，需要将递归的return代码改为如下内容：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (<span class="built_in">isEqual</span> (node1-&gt;left, node2-&gt;left) &amp;&amp; <span class="built_in">isEqual</span> (node1-&gt;right, node2-&gt;right)) || </span><br><span class="line">	(<span class="built_in">isEqual</span> (node1-&gt;left, node2-&gt;right) &amp;&amp; <span class="built_in">isEqual</span> (node1-&gt;right, node2-&gt;left));</span><br></pre></td></tr></table></figure>

<blockquote>
<ol start="2">
<li><em><strong>求二叉树的深度</strong></em></li>
</ol>
</blockquote>
<p>从根结点到叶结点依次经过的结点(含根、叶结点)形成树的一条路径，最长路径的长度为树的深度。（相当于做后序遍历）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">node</span> *left;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">node</span> *right;</span><br><span class="line">&#125;BTNode;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BTHeight</span><span class="params">(BTNode *root)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> lefth, righth;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        lefth = <span class="built_in">BTHeight</span>(root-&gt;left);</span><br><span class="line">        righth = <span class="built_in">BTHeight</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> (lefth &gt; righth)? (lefth+<span class="number">1</span>):(righth+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol start="3">
<li><em><strong>求二叉树中结点的最大距离</strong></em></li>
</ol>
</blockquote>
<p>如果我们把二叉树视为一个图，父子结点之间的连线视为双向的，我们姑且定义“距离”为两结点之间边的个数。写一个程序求一棵二叉树中相距最远的两个结点之间的距离。</p>
<p>分析：计算-一个二叉树的最大距离有两个情况：</p>
<p>情况A：路径经过左子树的最深结点，通过根结点，再到右子树的最深结点。<br>情况B：路径不穿过根结点，而是左子树或右子树的最大距离路径，取其大者。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220715091403774.png" alt="image-20220715091403774"></p>
<p>只需要计算这两个情况的路径距离，并取其大者，就是该二叉树的最大距离。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">node</span> *left;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">node</span> *right;</span><br><span class="line">&#125;BTNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RESULT</span>&#123;<span class="comment">//定义返回结果</span></span><br><span class="line">	<span class="type">int</span> MaxDistance; <span class="comment">//最大距离</span></span><br><span class="line">	<span class="type">int</span> MaxDepth;<span class="comment">//最大深度</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">RESULT <span class="title">GetMaxDistance</span> <span class="params">(BTNode* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!root) &#123;</span><br><span class="line">		RESULT empty = &#123; <span class="number">0</span>, <span class="number">-1</span> &#125;; <span class="comment">/*最大深度初始化为-1是因为调用者要对其加1，然后变为0，使得无子树的最大深度为0*/</span></span><br><span class="line">		<span class="keyword">return</span> empty;</span><br><span class="line">    &#125;</span><br><span class="line">	RESULT lhs = <span class="built_in">GetMaxDistance</span> (root-&gt;left);</span><br><span class="line">	RESULT rhs = <span class="built_in">GetMaxDistance</span> (root-&gt;right);</span><br><span class="line">	RESULT result;</span><br><span class="line">	result.MaxDepth = <span class="built_in">max</span> (lhs.MaxDepth+<span class="number">1</span>, rhs.MaxDepth+<span class="number">1</span>);   <span class="comment">// 树的最大深度</span></span><br><span class="line">	result.MaxDistance = <span class="built_in">max</span> (<span class="built_in">max</span>(lhs.MaxDistance, rhs.MaxDistance),   <span class="comment">// 情况B</span></span><br><span class="line">                              lhs.MaxDepth+rhs.MaxDepth+<span class="number">2</span>);    <span class="comment">// 情况A</span></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><em>一棵二叉树每个结点包含一个整数，请设计一个算法输出所有满足条件的路径：此路径上的所有结点之和等于给定值。注意此类路径不要求必须从根结点开始，满足条件的路径不唯一。</em></p>
</blockquote>
<p>该题可利用先序遍历：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printbuffer</span> <span class="params">(vector&lt;<span class="type">int</span>&gt; buffer, <span class="type">int</span> level, <span class="type">int</span> i2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=level; i &lt;= i2; i++) &#123;</span><br><span class="line">		cout&lt;&lt;buffer[i] &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">findSum</span> <span class="params">(BTNode* head, <span class="type">int</span> sum, vector&lt;<span class="type">int</span>&gt; buffer, <span class="type">int</span> level)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">    	<span class="keyword">return</span>;  <span class="comment">//默认void</span></span><br><span class="line">    <span class="type">int</span> tmp = sum;</span><br><span class="line">    buffer.<span class="function">push_ <span class="title">back</span><span class="params">(head-&gt;val)</span></span>;      <span class="comment">// 当前结点加入buffer</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=level; i &gt; <span class="number">-1</span>; i--) &#123;   <span class="comment">// 减去buffer中已有元素</span></span><br><span class="line">    	tmp -= buffer[i];</span><br><span class="line">    	<span class="keyword">if</span>(tmp == <span class="number">0</span>)   <span class="comment">// 找到路径</span></span><br><span class="line">    		<span class="built_in">printbuffer</span>(buffer, i, level);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">findSum</span>(head-&gt;left, sum, buffer, leve1+<span class="number">1</span>);   <span class="comment">// 深度level加1（buffer大小加1），继续遍历左孩子结点</span></span><br><span class="line">    <span class="comment">// 回溯到当前结点，然后继续遍历右孩子结点</span></span><br><span class="line">    buffer.<span class="built_in">pop_back</span>();</span><br><span class="line">    level -= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">findSum</span> (head-&gt;right, sum, buffer, level+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol start="4">
<li><em><strong>由遍历序列构造二叉树（重建二叉树）</strong></em></li>
</ol>
</blockquote>
<p><u>在先序遍历序列中，第一个结点一定是二叉树的根结点</u>，而<u>在中序遍历中，根结点必然将中序序列分割成两个子序列</u>，前一个子序列就是根结点的左子树的中序序列，后一个子序列是根结点的右子树的中序序列。<u>根据这两个子序列，可以在先序序列中找到对应的左子序列和右子序列。</u>在先序序列中，左子序列的第一个结点是左子树的根结点，右子序列的第一个结点是右子树的根结点。如此递归地进行下去，便能唯一地确定这棵二叉树。即<strong>先序序列和中序序列可以唯一地确定一棵二叉树。</strong></p>
<p>同理，由二叉树的<strong>后序序列和中序序列也可以唯一地确定一棵二叉树</strong>，因为后序序列的最后一个结点就如同先序序列的第一个结点， 可以将中序序列分割成两个子序列，然后采用类似的方法递归地进行划分，就可以得到一棵二叉树。</p>
<p>由二叉树的<strong>层序序列和中序序列也可以唯一地确定一棵二叉树</strong>。需要注意的是，<strong>如果只知道二叉树的先序序列和后序序列，是无法唯一确定一棵二叉树的。</strong></p>
<blockquote>
<p>例1：求先序序列（ABCDEFGHI）和中序序列（BCAEDGHFI）所确定的二叉树。</p>
</blockquote>
<p>由先序序列确定根结点，再由中序序列确定该根结点的左子树、右子树。再依次递归下去。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220715101328300.png" alt="image-20220715101328300"></p>
<blockquote>
<p>例2：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1, 2, 4, 7, 3, 5, 6, 8}和中序遍历序列{4, 7, 2, 1, 5, 3, 8, 6}，则重建二叉树并输出它的后序遍历序列。(剑指Offer例题)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">node</span> *left;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">node</span> *right;</span><br><span class="line">&#125;BTNode;</span><br><span class="line"></span><br><span class="line"><span class="function">BTNode *<span class="title">CreatBT1</span><span class="params">(<span class="type">char</span> *pre, <span class="type">char</span> *in, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">// pre存放先序序列，in存放中序序列，n为二叉树的结点个数，返回构造的二叉树的根结点指针b</span></span><br><span class="line">    BTNode *b;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    b = <span class="keyword">new</span> <span class="built_in">BTNode</span>();</span><br><span class="line">    b-&gt;val = *pre;   <span class="comment">// 根结点</span></span><br><span class="line">    <span class="keyword">for</span>(p=in;p&lt;in+n;p++)&#123;   <span class="comment">// 在中序序列中寻找根结点pre</span></span><br><span class="line">        <span class="keyword">if</span>(*p == *pre)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    k = p-in;    <span class="comment">// 确定根结点在中序序列in中的位置k，也是左子树的序列长度</span></span><br><span class="line">    b-&gt;left = <span class="built_in">CreatBT1</span>(pre+<span class="number">1</span>, in, k);    <span class="comment">// 递归构造左子树，pre+1和in均指向左子树序列的开头</span></span><br><span class="line">    b-&gt;right = <span class="built_in">CreatBT1</span>(pre+k+<span class="number">1</span>, p+<span class="number">1</span>, n-k<span class="number">-1</span>);  <span class="comment">// 递归构造右子树，pre+k+1和p+1均指向右子树列的开头</span></span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-树的应用"><a href="#3-4-树的应用" class="headerlink" title="3.4 树的应用"></a>3.4 树的应用</h3><h4 id="二叉排序树-BST"><a href="#二叉排序树-BST" class="headerlink" title="二叉排序树 BST"></a>二叉排序树 BST</h4><p>二叉排序树，也称为二叉查找树，二叉搜索树，或BST。二叉排序树或者是一棵<u>空树</u>，或者是一棵具有下列特性的非空二 叉树：</p>
<ol>
<li><p>若左子树非空，则左子树上所有结点关键字值均<u>小于</u>根结点的关键字值。</p>
</li>
<li><p>若右子树非空，则右子树上所有结点关键字值均<u>大于</u>根结点的关键字值。</p>
</li>
<li><p><u>左、右子树本身也分别是一棵二叉排序树</u>。</p>
</li>
</ol>
<p>由此定义可知，二叉排序树是一个递归的数据结构。</p>
<p>根据二叉排序树的定义，有**左子树结点值 &lt; 根结点值 &lt; 右子树结点值**。所以对二叉排序树<u>进行中序遍历，可以得到一个递增的有序序列</u>。</p>
<p>二叉排序树的查找操作的时间复杂度是$O(log_2N)$，比较次数与树的深度有关。</p>
<p>例如，图13-5的二叉排序树的中序遍历序列为123468。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220715150035730.png" alt="image-20220715150035730"></p>
<blockquote>
<p>判断一个二叉树是否为二叉排序树</p>
</blockquote>
<p>使用中序遍历二叉树，判断是否为递增序列，复杂度O(n)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> prev1 = INT_ MIN; <span class="comment">//定义为最小的整数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">node</span> *lchild, *rchild;</span><br><span class="line">&#125;BTNode;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">JudgeBST</span> <span class="params">(BTNode *bt)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> b1, b2;</span><br><span class="line">	<span class="keyword">if</span>(bt == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 中序遍历</span></span><br><span class="line">		b1 = <span class="built_in">JudgeBST</span> (bt-&gt;lchi1d);</span><br><span class="line">		<span class="keyword">if</span>(b1 == <span class="number">0</span> || bt-&gt;val &lt;= prev1) <span class="comment">// 左子树不是二叉排序树，或者根结点值不大于prev1</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		prev1 = bt-&gt;val;   <span class="comment">// 更新prev1为根结点的值，即右子树的所有结点值均要大于prev1</span></span><br><span class="line">		b2 = <span class="built_in">JudgeBST</span> (bt-&gt;rchild);</span><br><span class="line">		<span class="keyword">return</span> b2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="平衡二叉树-AVL"><a href="#平衡二叉树-AVL" class="headerlink" title="平衡二叉树 AVL"></a>平衡二叉树 AVL</h4><p>为了避免树的高度增长过快，降低二叉排序树的性能，我们规定在插入和删除二叉树结点时，要<u>保证任意结点的左、右子树高度差的绝对值不超过1</u>，并将这样的<u>二叉排序树</u>称为<strong>平衡二叉树</strong>，简称平衡树(AVL树)。<u>定义结点左子树与右子树的高度差为该结点的<strong>平衡因子</strong></u>，则平衡二叉树结点的平衡因子的值只可能是-1、0或1。</p>
<p>因此，平衡二叉树可定义为它或者是一棵<u>空树</u>，或者是具有下列性质的二叉树：它的左子树和右子树都是平衡二叉树，且 <strong>左子树和右子树的高度差的绝对值不超过1</strong>。</p>
<p>平衡二叉树的操作效率（查询，插入，删除）效率较高，时间复杂度是$O(log_2N)$，即树的深度。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220715150213734.png" alt="image-20220715150213734"></p>
<p>图13-6(b)所示是不平衡的二叉树。结点中的值为该结点的平衡因子。</p>
<blockquote>
<p>判断一棵二叉树是不是平衡二叉树。</p>
</blockquote>
<p><strong>解法一</strong>：递归的思路，遍历树的每个结点，求出其左右子树的深度，计算深度差。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsBalanced</span> <span class="params">(BTNode* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">    <span class="type">int</span> left_Depth = <span class="built_in">BTHeight</span> (root-&gt;left) ;</span><br><span class="line">    <span class="type">int</span> right_Depth = <span class="built_in">BTHeight</span> (root-&gt;right) ;</span><br><span class="line">    <span class="type">int</span> diff = left_Depth - right_Depth;</span><br><span class="line">	<span class="keyword">if</span>(diff &gt; <span class="number">1</span> || diff &lt; <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">IsBalanced</span> (root-&gt;left) &amp;&amp; <span class="built_in">IsBalanced</span> (root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解法二</strong>：解法一虽然简洁但是每个结点会被遍历多次，效率较低。如果我们用后序遍历的方式遍历二叉树的每一个结点， 在遍历到一个结点之前我们已经遍历了它的左右子树。只要在遍历每个结点的时候记录它的高度，我们就可以一边遍历一边判断每个结点是不是平衡的。下面是这种思路的参考代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsBalanced</span> <span class="params">(BTNode* root, <span class="type">int</span>* Depth)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		*Depth=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="type">int</span> left_Depth, right_Depth;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IsBalanced</span> (root-&gt;left, &amp;left_Depth) &amp;&amp; <span class="built_in">IsBalanced</span> (root-&gt;right, &amp;right_Depth)) &#123;</span><br><span class="line">		<span class="type">int</span> diff=left_Depth - right_Depth;</span><br><span class="line">		<span class="keyword">if</span>(diff &lt;= <span class="number">1</span> &amp;&amp; diff&gt;= <span class="number">-1</span>)&#123;</span><br><span class="line">			*Depth = <span class="number">1</span> + (left_Depth &gt; right_Depth ? left_Depth : right_Depth);  <span class="comment">// 取左右子树中深度的最大值</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解法三</strong>：除此之外，下面的方法也是可行的，且形式更加简洁。<u>求出根结点的最大深度与最小深度</u>，则最大深度与最小深度之差dis就是树中任一子树深度差最大值，所以<u>只要dis小于等于1，此树就是平衡二叉树</u>，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求树的最大深度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxDepth</span> <span class="params">(BTNode* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span> (<span class="built_in">maxDepth</span>(root-&gt;left), <span class="built_in">maxDepth</span>(root-&gt;right));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 求树的最小深度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minDepth</span> <span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">min</span> (<span class="built_in">minDepth</span>(root-&gt;left), <span class="built_in">minDepth</span>(root-&gt;right)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算根结点的最大深度与最小深度之差，小于等于1就说明是平衡二叉树</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isBalanced</span> <span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">maxDepth</span>(root) - <span class="built_in">minDepth</span>(root) &lt;= <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a>B树和B+树</h4><p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaofengshan/p/15443140.html">https://www.cnblogs.com/xiaofengshan/p/15443140.html</a></p>
<p>B树和B+树都是多路查找树，为了解决数据量大，树的高度大增（二叉树）而产生的一种数据结构。</p>
<p><strong>B树</strong></p>
<p>B树又称为<strong>多路平衡查找树</strong>，是二叉排序树的扩展，满足平衡的性质，<u>所有结点的平衡因子均等于0</u>，结点又拥有多个子树，对于组织和维护外存文件系统非常有效（数据库）。</p>
<p>把树中结点所拥有的最大的子树数目称为 <strong>B树的阶</strong>。通常记为m。一颗m阶B树或为空树，或为满足如下特性的m叉树：</p>
<ul>
<li>树中<u>每个结点至多有m个孩子结点</u>。（同时<u>至多含有m-1个关键字</u>，每两颗子树指针夹着一个关键字)；</li>
<li><u>若根结点不是叶子结点，则至少有两个孩子结点</u>。(至少一个关键字)；</li>
<li><u>除根结点外的所有非叶子结点至少有$\lceil m&#x2F;2 \rceil$棵子树</u>。（即至少含有$\lceil m&#x2F;2 \rceil -1$个关键字）；</li>
<li><u>所有的外部结点出现在同一个层次上</u>，不带信息，但是计算B树的高度时需要考虑外部结点。(就像是折半查找判断树中查找失败的结点）。</li>
<li>**<u>每一个结点中的关键字按递增的顺序排列</u>**，关键字两边为指向孩子结点的指针。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220722103219609.png" alt="image-20220722103219609"></p>
<p>B树中的非叶子结点对应数据库查找时的关键字，叶子结点对应要查找的详细记录，而外部结点对应查找失败，指向它的指针为NULL，不含有任何信息。一颗含有n个关键字的B树有n+1个外部结点。</p>
<ul>
<li><p><strong>B树的插入</strong></p>
<p>向B树插入结点时，只能向叶子结点插入。</p>
<p>当叶子结点的关键字个数小于m-1时，直接在该结点增加关键字即可，注意保持递增。</p>
<p>当叶子结点的关键字个数等于m-1时，无法继续增加关键字。这时采用 <strong>分裂法</strong>，比如一棵3阶B树，结点的关键字个数最多为2。有一关键字为50的结点需要插入，定位到在叶子节点{20、30}中插入时，发现关键字已满。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1878829-20211023171456763-1075232344.png" alt="image"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1878829-20211023171704347-889107402.png" alt="image"></p>
<p>此时对该叶子结点进行分裂，选取{20、30、50}的中位数30作为双亲结点提升到上一层中，其余关键字作为孩子结点留在本层。若关键字30提升到双亲结点后，造成双亲结点的关键字数量超过m-1，那么双亲结点也进行同样的分裂。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1878829-20211023172041053-21577706.png" alt="image"></p>
</li>
<li><p><strong>B树的删除</strong></p>
<p>删除关键字时，同样也要考虑结点内原本关键词的数量，<strong>保证结点始终拥有至少$\lceil m&#x2F;2 \rceil$-1个关键字</strong>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1878829-20211023175004402-1855562437.png" alt="image"></p>
<ul>
<li><p>当结点内关键字数量大于$\lceil m&#x2F;2 \rceil$-1，这时删除这个关键字不会破坏B树的定义要求，所以直接删除即可。</p>
<p>比如删除关键字9；</p>
</li>
<li><p>当结点内关键字数量等于$\lceil m&#x2F;2 \rceil$-1，并且其左右兄弟结点中存在关键字数量大于$\lceil m&#x2F;2 \rceil$-1的结点，则删除后 <strong>去兄弟结点中借关键字</strong>；</p>
<p>比如删除关键字2，而每个结点应至少有1个关键字，所以结构调整子树结构为根结点为5，7为左孩子，9为右孩子。</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1878829-20211023175630640-1755597084.png" alt="image"></p>
<ul>
<li><p>当结点内关键字数量等于$\lceil m&#x2F;2 \rceil$-1，并且其左右兄弟结点中不存在关键字数量大于$\lceil m&#x2F;2 \rceil$-1的结点，则需要 <strong>进行结点合并</strong>；</p>
<p>比如删除关键字16后，无法向兄弟结点借关键字，所以调整子树结构为如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1878829-20211023180238546-719277151.png" alt="image"></p>
</li>
</ul>
<p>如果删除的关键字不在终端结点上（最底层非叶子结点）：需要先转换成在终端结点上（找相邻关键字替换），再按照在终端结点上的情况来分别考虑对应的方法。</p>
</li>
</ul>
<p><strong>B+树</strong></p>
<p>B+树是B树的一些变形，是常用于数据库和操作系统的文件系统中的一种用于查找的数据结构，包括oracle、Mysql等主流数据库。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220722152447901.png" alt="image-20220722152447901"></p>
<p><strong>B+树的性质：</strong></p>
<ul>
<li><u>m阶B+树的每个分支结点至多有m个子树</u>，不用来保存数据而是保存数据的索引。</li>
<li><u>除根结点外的所有非叶子结点至少有$\lceil m&#x2F;2 \rceil$棵子树</u>。根结点要么没有子树，要么至少有2个子树。</li>
<li><u><strong>有n棵子树的结点恰好有n个关键字。</strong></u></li>
<li>**<u>所有的叶子结点中包含了全部关键字的信息</u>**，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。非叶子结点的元素在叶子结点上有冗余，<u>非叶子结点的数据只是作为索引来帮助查找叶子结点元素</u>。</li>
<li>所有的非终端结点可以看成是索引部分，结点中仅含其子树中的大（或小）关键字。</li>
<li>B+树中，数据对象的插入和删除仅在叶节点上进行。</li>
<li>B+树**<u>有2个头指针</u><strong>，一个是树的根节点root（用于随机查找），一个是小关键码的叶节点指针sqt（用于顺序查找&#x2F;范围查找）。且</strong><u>叶子结点之间有指针</u>**。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220722165630558.png" alt="image-20220722165630558"></p>
<p>Mysql索引使用的是B+树，因为索引（非叶子结点）是用来加快查询的。同时而B+树通过对数据进行排序，所以是可以提高查询速度的，并且一个结点中可以存储多个元素，从而可以使得B+树的高度不会太高。</p>
<p>在Mysql中一个Innodb页就是一个B+树结点，一个Innodb页默认16kb（存储本结点关键字），所以一般情况下一棵两层的B+树可以存2000万行左右的数据（B+树一般不会超过3层），然后通过利用B+树叶子结点存储了所有数据并且进行了排序，并且叶子结点之间有指针，可以很好的支持全表扫描，范围查找等SQL语句。</p>
<p><strong>B树和B+树的区别：</strong></p>
<p>① 在B+树中，具有n个关键字的结点只含有n棵子树，即每个关键字对应一颗子树；而在B树中，具有n个关键字的结点含有(n+1)棵子树。<br>② 在B+树中，每个结点(非根内部结点)关键字个数n的范围是[m&#x2F;2]&lt;&#x3D;n&lt;&#x3D;m(根结点1&lt;&#x3D;n&lt;&#x3D;m),在B树中，每个结点(非根内部结点)关键字个数n的范围是[m&#x2F;2]-1&lt;&#x3D;n&lt;&#x3D;m-1(根结点:1&lt;&#x3D;n&lt;&#x3D;m-1)。<br>③ 在B+树中，叶结点包含信息，所有非叶结点仅起到索引的作用，非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应的存储地址。<br>④ 在B+树中，叶结点包含了全部关键字，即在非叶结点中出现的关键字也会出现在叶结点中；而在B树中，叶结点包含的关键字和其他结点包含的关键字是不重复的。<br>⑤ 在B+树中，有一个指针指向关键字最小的叶子结点，所有叶子结点连接成一个单链表。</p>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/cy973071263/article/details/122543826">https://blog.csdn.net/cy973071263/article/details/122543826</a></p>
<ul>
<li><p><strong>背景</strong></p>
<p>若插入和删除操作总在平衡二叉树（AVL）的某一子树进行，那么大多数的结点都会在根结点的右侧或左侧，此时，二叉搜索树就接近于一个链表，它的操作效率就降低了。为了不断维持平衡二叉树的平衡状态，就需要对AVL进行旋转处理。红黑树的出现是为了解决维持平衡二叉树AVL而导致的成本高的问题。</p>
<p>比如下面进行平衡二叉树的插入时，就需要进行旋转，重新维持平衡。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220715162620468.png" alt="image-20220715162620468"></p>
</li>
<li><p><strong>概念</strong></p>
<p>自平衡二叉查找树，以前也叫平衡二叉B树。红黑树具有良好的效率，它可在 O(logN) 时间内完成查找、增加、删除等操作。</p>
<p>红黑树为具备了某些特性的<u><strong>二叉搜索树</strong></u>，能解决非平衡树问题，是一种**<u>接近平衡</u>**的二叉树（说它是接近平衡因为它并没有像AVL树的平衡因子的概念，它只是靠着满足红黑节点的5条性质来维持一种接近平衡的结构，进而提升整体的性能，并没有严格的卡定某个平衡因子来维持绝对平衡）。红黑树同时具有平衡和排序的特点，既接近平衡二叉树，又是二叉搜索树BST。</p>
</li>
<li><p><strong>性质</strong></p>
<p><u>首先，红黑树是一个二叉搜索树</u>，它在每个结点增加了一个存储位记录节点的颜色，可以是RED，也可以是BLACK；<u>通过任意一条从根到叶子简单路径上颜色的约束，红黑树保证最长路径不超过最短路径的二倍，因而近似平衡</u>（最短路径就是全黑节点，最长路径就是一个红结点一个黑结点，当从根结点到叶子结点的所有路径上黑色结点数目相同时，最长路径刚好是最短路径的两倍）。它同时满足以下特性：</p>
<ul>
<li>结点是红色或黑色</li>
<li>根是黑色</li>
<li>叶子结点（外部结点，空结点）都是黑色</li>
<li>红色结点的子结点都是黑色，红色结点的父结点都是黑色，从根结点到叶子结点的所有路径上不能有 2 个连续的红色结点</li>
<li>从任一结点到叶子结点（空结点）的所有路径都包含相同数目的黑色结点</li>
</ul>
</li>
</ul>
<h4 id="哈夫曼树及哈夫曼编码"><a href="#哈夫曼树及哈夫曼编码" class="headerlink" title="哈夫曼树及哈夫曼编码"></a>哈夫曼树及哈夫曼编码</h4><ul>
<li><p>概念</p>
<p><strong>结点的权值</strong>：给树的结点赋予的有某种意义的数值；</p>
<p><strong>结点的带权路径长度WPL</strong>：从根结点到该结点之间的路径长度与该结点的权值的乘积；</p>
<p><strong>树的带权路径长度WPL</strong>：树中所有叶子结点的带权路径长度之和，记为$WPL&#x3D;\sum_{i&#x3D;1}^n{w_i*l_i}$。式中，$w_i$是第i个叶结点所带的权值，$l_i$是该叶结点到根结点的路径长度。</p>
<p><strong>哈夫曼树</strong>：在$n_0$个带权叶子节点构成的所有二叉树中，带权路径长度WPL最小的二叉树称为哈夫曼树。（原则：权值越大的叶子结点越靠近根结点，权值越小的叶子结点越远离根结点）</p>
</li>
<li><p>哈夫曼树的构造</p>
<p>给定n个权值分别为$w_1$，$w_2$，…，$w_n$的结点。构造哈夫曼树的算法描述如下:</p>
<ol>
<li>将这n个结点分别作为n棵仅含一个结点的二叉树，构成森林F。</li>
<li>从F中选取两棵根结点权值最小的树作为左、右子树来构造一个新二叉树，并且将新二叉树根结点的权值置为左、右子树上根的权值之和。</li>
<li>从F中，用新得到的树代替刚才选出的两棵树。</li>
<li>重复步骤2)和3)，直至F中只剩下一棵树为止。</li>
</ol>
</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:/Users/cbcao/AppData/Roaming/Typora/typora-user-images/image-20220715165325637.png" alt="image-20220715165325637" style="zoom:15%;" />

<ul>
<li><p>哈夫曼编码</p>
<p><strong>固定长度编码</strong>：每个字符使用相同长度的二进制位来表示；</p>
<p><strong>可变长度编码</strong>：允许对每个字符使用不同长度的二进制位来表示；</p>
<p>可变长度编码比固定长度编码好得多，其特点是<u>对频率高的字符赋予短编码，而对频率较低的字符则赋予较长一些的编码</u>，从而可以使平均编码长度减短，起到压缩数据的效果。哈夫曼编码是一种被广泛应用而且非常有效的数据压缩编码，它是可变长度编码。</p>
<p><strong>前缀编码</strong>：没有一个编码是另一个编码的前缀。前缀编码的解码操作相对简单，无需考虑重复前缀。哈夫曼编码属于前缀编码。</p>
<p><strong>构造哈夫曼编码</strong>首先要构造一棵哈夫曼树。 首先，将每个出现的字符当作一个独立的结点， 其权值为它出现的频度(或次数)，然后构造出对应的哈夫曼树。显然，所有字符结点都出现在叶结点中。我们可以<u>将字符的编码解释为从根至该字符的路径上边标记的序列</u>，其中边标记为0表示“转向左孩子”，标记为1表示“转向右孩子”。图13-7所示为-一个由哈夫曼树构造哈夫曼编码的示例，矩形方块<br>表示字符及其出现的次数。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220715165926663.png" alt="image-20220715165926663"></p>
<p>这棵哈夫曼树的WPL为：WPL&#x3D;1*45+3*(13+12+16)+4*(5+9)&#x3D;224</p>
<p>此处的WPL可以视为最终编码得到二进制编码的长度，共224位。如果采用3位固定长度编码，则得到的二进制编码长度为300位。可见哈夫曼编码共压缩了约25%的数据。利用哈夫曼树可以设计出总长度最短的二进制前缀编码。</p>
</li>
</ul>
<h3 id="3-5-并查集"><a href="#3-5-并查集" class="headerlink" title="3.5 并查集"></a>3.5 并查集</h3><p>并查集是一种树形的数据结构，用于处理一些不相交集合(Disjoint Sets)的合并及查询问题。常常在使用中以森林来表示，进行快速规整。</p>
<p>并查集保持一组不相交的动态集合 S&#x3D;{S1, S2, ….., Sk }。**<u>每个集合通过一个代表来识别</u>**， 代表即集合中的某个成员。在某些应用中，哪一个成员被选作代表是无所谓的。在一些应用中，如何选择代表可能存在着预先说明的规则，例如选择集合中的最小元素。</p>
<p>集合中的每一个元素是由一个对象表示的，设x表示一个对象，则并查集应支持以下操作：</p>
<p>make_set(x)：建立一个新的集合，其唯一成员就是 x (x此时即是代表)。因为各集合是不相交的，故要求x没有在其他集合中出现过。</p>
<p>union_set(x, y)：如果x、y分属不同集合，则将包含x和y的动态集合<u>合并</u>为一个新的集合。</p>
<p>find_set(x)：返回一个指针，指向包含x所在的集合的代表。</p>
<ol>
<li><p><strong>单链表实现</strong></p>
<p>要实现并查集数据结构，一种简单的方法是每一个集合都用一个链表来表示。每个链表的第一个对象作为它所在集合的代表。链表中的每一个对象都包含<u>一个集合成员、 一个指向包含下一个集合成员的对象的指针，以及指向代表的指针</u>。每个链表都含head指针指向链表的代表，以及tail指针指向链表中最后的对象。</p>
</li>
<li><p><strong>并查集森林</strong></p>
<p>并查集的另一种更快的实现是用有根树来表示集合：每棵树表示一个集合， 树中的结点对应一个成员。在下图所示的并查集森林中，每个成员仅指向其父结点，父结点为其代表。<u>每棵树的根为整个集合的代表，并且是它自己的父结点</u>。</p>
<p>图13-8中左侧是两棵表示两个集合的树，左边的树表示集合{b, c, e, h}， 其中c为代表；右边的树表示集合{d, f, g}， 其中f为代表。右侧为union_set(e, g)的结果。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220715191404196.png" alt="image-20220715191404196"></p>
<p>make_set创建一棵仅包含一个结点的树。</p>
<p>在执行find_set操作时，要沿着父结点指针一直找下去，直至找到树根为止。</p>
<p>union_set操作使得一棵树的根指向另一棵树的根。</p>
</li>
<li><p><strong>两种并查集森林的改进策略</strong></p>
<p>第一种是<strong>按秩合并</strong>，其思想是union_set操作使包含较少结点的树的根指向包含较多结点的树的根。</p>
<p>这种方法并不显式记录以每个结点为根的子树的大小，而是采用了一种能够简化分析的方法：对每个结点，<u>用秩表示结点高度的一个上界</u>。<u>在按秩合并中，具有较小秩的根在union_set操作中要指向具有较大秩的根</u>。</p>
<p>第二种是<strong>路径压缩</strong>，这种方法简单有效。它使一棵树的每个结点都直接指向根结点，如图13-9所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220715191816132.png" alt="image-20220715191816132"></p>
</li>
</ol>
<blockquote>
<p>假如已知有n个人和m对好友关系(存于数字r)。如果两个人是直接或间接的好友(好友的好友的好友..)，则认为他们属于同一个朋友圈，请写程序求出这n个人里一共有多少个朋友圈。</p>
<p>假如：n&#x3D;5， m&#x3D;3, r&#x3D;{ {1,2},{2,3},{4,5} }， 表示有5个人，1 和2是好友，2和3是好友，和5是好友，则1、2、3属于一个朋友圈，4、5属于另一个朋友圈，结果为2个朋友圈。</p>
<p>最后请分析所写代码的时间、空间复杂度。评分会参考代码的正确性和效率。<br><code>int friends(int n, int m, int* r[]);</code></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> set [<span class="number">10001</span>];    <span class="comment">// 存储每个元素的代表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*带路径优化的并查集查找算法：查找集合x的代表，并使用路径压缩，让所有结点指向该代表*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j，r;</span><br><span class="line">	r=x;</span><br><span class="line">	<span class="keyword">while</span>(set[r] != r) <span class="comment">//寻找此集合的代表</span></span><br><span class="line">		r=set[r];      <span class="comment">// 只有根结点满足r=set[r]，因此当r=set[r]时，表示找到了该集合的代表，即根结点</span></span><br><span class="line">	i=x;</span><br><span class="line">	<span class="keyword">while</span>(i != r)&#123;     <span class="comment">//使得r代表的集合中，所有结点直接指向r，即路径压缩</span></span><br><span class="line">		j=set[i];</span><br><span class="line">		set[i]=r;</span><br><span class="line">		i=j;       <span class="comment">// 继续更新i原来的代表j</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x , <span class="type">int</span> y)</span> </span>&#123;   <span class="comment">//优化的并查集归并算法</span></span><br><span class="line">	<span class="type">int</span> t=<span class="built_in">find</span>(x);    <span class="comment">// 找到x的代表</span></span><br><span class="line">	<span class="type">int</span> h=<span class="built_in">find</span>(y);    <span class="comment">// 找到y的代表</span></span><br><span class="line">	<span class="keyword">if</span>(t&lt;h)   <span class="comment">// 合并两个集合，令x的代表指向y的代表，或者反过来</span></span><br><span class="line">		set[h]=t;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		set[t]=h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// n个结点，m个关系</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">friends</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m，<span class="type">int</span>* r[])</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i，count;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span> ;i&lt;=n; ++i) <span class="comment">//初始化并查集，分支数为n，各点为孤立点，各结点代表就是自身，所以set[i]=i</span></span><br><span class="line">		set[i]=i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span> ;i&lt;m; ++i)  <span class="comment">//读入r，r[i][0]和r[i][1]为有关系的结点</span></span><br><span class="line">		<span class="built_in">merge</span>(r[i][<span class="number">0</span>], r[i][<span class="number">1</span>]);</span><br><span class="line">	count=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span>(set[i] == i) <span class="comment">//统计代表是自己的结点个数，也即朋友圈</span></span><br><span class="line">			++count;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40378034/article/details/103224445">https://blog.csdn.net/qq_40378034/article/details/103224445</a></p>
<h2 id="4-图"><a href="#4-图" class="headerlink" title="4 图"></a>4 图</h2><h3 id="4-1-图的基本概念"><a href="#4-1-图的基本概念" class="headerlink" title="4.1 图的基本概念"></a>4.1 图的基本概念</h3><p>图G由顶点集V和边集E组成，记为G&#x3D;(V, E)，其中V(G)表示图G中顶点的有限非空集；E(G)表示图G中顶点之间的关系(边)集合。若 V &#x3D; {$v_1$, $v_2$, …, $v_n$}，用|V|表示图G中<u>顶点的个数</u>，也称为<strong>图G的阶</strong>，E&#x3D;{(u, v)|u∈V, v∈ V}，用E表示图G中边的条数。</p>
<p>注意：线性表可以是空表，树可以是空树，但<strong>图不可以是空图</strong>。就是说，图中不能一个顶点也没有，图的顶点集V一定非空，但边集E可以为空，此时图中只有顶点而没有边。</p>
<p><strong>有向图</strong>：若E是有向边（也称为弧）的有限集合时，则图G为有向图。</p>
<p><strong>无向图</strong>：若E是无向边（简称边）的有限集合时，则图G为无向图。</p>
<p>在无向图中，如果<u>任意两个顶点之间都存在边</u>，则称该图为<strong>无向完全图</strong>。含有n个顶点的无向完全图有<strong>n(n-1)&#x2F;2</strong>条边。</p>
<p>在有向图中，如果<u>任意两个顶点之间都存在方向相反的两条弧</u>，则称该图为<strong>有向完全图</strong>。含有n个顶点的有向完全图有**n(n-1)**条有向边。</p>
<p>设有两个图G&#x3D;(V, E)和G’&#x3D;(V’, E’)，若V是V的子集，且E是E的子集，则称G是G的子图。若有满足V(G)&#x3D;V(G’)的子图G，则为G的<strong>生成子图</strong>。</p>
<p><u><strong>在无向图中</strong></u>，若从顶点v到顶点w<u>有路径存在</u>，则称v和w是连通的。若图G中任意两个顶点都是连通的，则称图G为<strong>连通图</strong>，否则称为非连通图。无向图中的极大连通子图称为<strong>连通分量</strong>。<u>如果一个图有n个顶点，并且有小于n-1条边，则此图必是非连通图。</u>如图14-1(a)所示，图G有3个连通分量。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220716124316623.png" alt="image-20220716124316623"></p>
<p><strong><u>在有向图中</u><strong>，若<u>从顶点v到顶点w和从顶点w到顶点v之间都有路径</u>，则称这两个顶点是</strong>强连通</strong>的。若图中任何一对顶点都是强连通的，则称此图为强连通图。<u>有向图中的<strong>极大强连通子图</strong></u>称为有向图的<strong>强连通分量</strong>，图G2的强连通分量如图14-2 所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220716142549034.png" alt="image-20220716142549034"></p>
<p>图中每个<strong>顶点的度</strong>定义为以该顶点为一个端点的边的数目。对于无向图，顶点v的度是指依附于该项点的边的条数，记为TD(1)。在无向图中，**<u>无向图的全部顶点的度之和等于边数的两倍</u>**，这是因为每条边和两个顶点相关联。</p>
<p>对于有向图，顶点v的度分为<strong>入度</strong>和<strong>出度</strong>，入度是以顶点v为终点的有向边的数目；而出度是以顶点v为起点的有向边的数目。 顶点v的度等于其入度和出度之和，在有向图中，**<u>有向图的全部顶点的入度之和与出度之和相等并且等于边数</u>**。这是因为每条有向边都有一个起点和终点。</p>
<h3 id="4-2-图的存储及基本操作"><a href="#4-2-图的存储及基本操作" class="headerlink" title="4.2 图的存储及基本操作"></a>4.2 图的存储及基本操作</h3><h4 id="邻接矩阵法"><a href="#邻接矩阵法" class="headerlink" title="邻接矩阵法"></a>邻接矩阵法</h4><p>所谓邻接矩阵存储，就是用一个二维数组存储图中边的信息( 即各顶点之间的邻接关系)，存储顶点之间邻接关系的二维数组称为邻接矩阵。</p>
<p>结点数为n的图G&#x3D;(V, E)的邻接矩阵A是n*n的。将G的顶点编号为$v_1$, $v_2$, …, $v_n$。若$(v_i, v_j)∈E$，则$A[i][j]&#x3D;1$，否则，$A[i][j]&#x3D;0$。</p>
<p>$A[i][j]&#x3D;\begin{cases} 1,\quad若(v_i, v_j)或&lt;v_i,v_j&gt;是E(G)中的边\ 0,\quad若(v_i, v_j)或&lt;v_i,v_j&gt;不是E(G)中的边 \end{cases}$</p>
<p>对于带权图而言，若顶点$v_i$和$v_j$之间有边相连，则邻接矩阵中对应项存放着该边对应的权值，若顶点$v_i$和$v_j$不相连，则用∞来代表这两个顶点之间不存在边。</p>
<p>$A[i][j]&#x3D;\begin{cases} w_{ij},\quad若(v_i, v_j)或&lt;v_i,v_j&gt;是E(G)中的边\ 0或\infty,\quad若(v_i, v_j)或&lt;v_i,v_j&gt;不是E(G)中的边 \end{cases}$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXV <span class="string">&lt;最大顶点数&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 32767   <span class="comment">// 4字节int型数值的最大数为32767</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;     <span class="comment">// 顶点类型</span></span><br><span class="line">    <span class="type">int</span> no;</span><br><span class="line">    InfoType info;</span><br><span class="line">&#125;VertexType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;     <span class="comment">// 邻接矩阵</span></span><br><span class="line">    <span class="type">int</span> edges[MAXV][MAXV];</span><br><span class="line">    <span class="type">int</span> n, e;       <span class="comment">// 顶点数、边数</span></span><br><span class="line">    VertexType vexs[MAXV];  <span class="comment">// 存放顶点信息</span></span><br><span class="line">&#125;MatGraph;</span><br></pre></td></tr></table></figure>

<p>图的邻接矩阵存储表示法具有以下<strong>特点</strong>:</p>
<ol>
<li><p>无向图的邻接矩阵一定是一个对称矩阵（并且唯一）。</p>
</li>
<li><p>对于无向图，邻接矩阵的第i行（或第i列）非零元素（或非∞元素）的个数正好是第i个顶点的度。</p>
</li>
<li><p>对于有向图，邻接矩阵的第i行（或第i列）非零元素（或非∞元素）的个数正好是第i个顶点的出度（或入度）。</p>
</li>
<li><p>用邻接矩阵方法存储图，很容易确定图中任意两个顶点之间是否有边相连。但是，要确定图中有多少条边，则必须按行、按列对每个元素进行检测，所花费的时间代价很大。</p>
</li>
<li><p>稠密图适合使用邻接矩阵的存储表示。</p>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220716145053866.png" alt="image-20220716145053866"></p>
<h4 id="邻接表法"><a href="#邻接表法" class="headerlink" title="邻接表法"></a>邻接表法</h4><p>所谓邻接表就是对图G中的每个顶点v建立一个单链表， 第i个单链表中的结点表示关联于顶点$v_i$的边(对于有向图则是以顶点$v_i$的起点的边)，这个单链表就称为顶点$v_i$的的边表（对于有向图则称为出边表）。边表的头指针和顶点的数据信息采用顺序存储（称为顶点表），所以在邻接表中存在两种结点：顶点表结点和边表结点，如图144所示。顶点表中，<u>data存储顶点$v_i$的名称或其他信息</u>，<u>firstarc指向顶点$v_i$的单链表中的首结点</u>；边表的<u>adjvex表示与顶点$v_i$邻接的顶点编号</u>，<u>nextarc指向下一个边结点</u>，另外还可以有一个weight数值域，存放边的权值等信息。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220716145613595.png" alt="image-20220716145613595"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顶点表（头结点）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Vnode</span>&#123;</span><br><span class="line">    InfoType info;      <span class="comment">//顶点的其他信息</span></span><br><span class="line">    ArcNode *firstarc;  <span class="comment">//指向第一个边结点</span></span><br><span class="line">&#125;VNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 边表（边结点）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ANode</span>&#123;</span><br><span class="line">    <span class="type">int</span> adjvex;               <span class="comment">//该边的邻接点编号</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ANode</span> *nextarc;    <span class="comment">//指向下一条边的指针</span></span><br><span class="line">    <span class="comment">// int weight;              //该边的相关信息，比如权值</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	VNode adjlist[MAXV];      <span class="comment">//邻接表的头结点数组</span></span><br><span class="line">    <span class="type">int</span> n, e;                 <span class="comment">// 图的顶点数n、边数e</span></span><br><span class="line">&#125;AdjGraph;</span><br></pre></td></tr></table></figure>

<p>图的邻接表存储方法具有以下特点:</p>
<p>1 )如果G为无向图，则所需的存储空间为O (V+2|E|)；如果G为有向图，则所需的存储空间为O (V+|E|)。前者的倍数2是由于无向图中，每条边在邻接表中出现了两次。<br>2) 对于稀疏图，采用邻接表表示将极大地节省存储空间。<br>3) 在邻接表中，给定一顶点，能很容易地找出它的所有邻边，因为只需要读取它的邻接表就可以。在邻接矩阵中，相同的操作则需要扫描一行， 花费的时间为O(n)。但是，如果要确定给定的两个顶点间是否存在边，则在邻接矩阵里可以立刻查到，在邻接表中则需要在相应结点对应的边表中查找另一结点，效率较低。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220716145653449.png" alt="image-20220716145653449"></p>
<h3 id="4-3-图的遍历"><a href="#4-3-图的遍历" class="headerlink" title="4.3 图的遍历"></a>4.3 图的遍历</h3><h4 id="x3D-x3D-深度优先搜索DFS-x3D-x3D"><a href="#x3D-x3D-深度优先搜索DFS-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;深度优先搜索DFS&#x3D;&#x3D;"></a>&#x3D;&#x3D;深度优先搜索DFS&#x3D;&#x3D;</h4><p>深度优先搜索（DFS）类似于树的先序遍历。它的基本思想如下：首先访问图中某一起始顶点v，然后由v出发，访问与v邻接且未被访问的任一顶点$w_1$，再访问与$w_1$邻接且未被访问的任一顶点$w_2$, ……重复上述过程。<u>当不能再继续向下访问时，依次退回到最近被访问的顶点，若它还有邻接顶点未被访问过，则从该点开始继续上述搜索过程</u>，直到图中所有顶点均被访问过为止。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*以邻接表为存储结构的深度优先遍历算法*/</span></span><br><span class="line"><span class="type">int</span> visited[MAX] = &#123;<span class="number">0</span>&#125;;   <span class="comment">// 全局数组，标记顶点是否已被访问</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(AdjGraph *G, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    ArcNode *p;           <span class="comment">// 边结点</span></span><br><span class="line">    visited[v] = <span class="number">1</span>;       <span class="comment">// 访问该结点，置访问标记为1</span></span><br><span class="line">    cout&lt;&lt;v&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    p = G-&gt;adjlist[v].firstarc;  <span class="comment">// p指向顶点v的第一个邻接点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(visited[p-&gt;adjvex] == <span class="number">0</span>)  <span class="comment">//若编号为p-&gt;adjvex的结点p未被访问，则递归访问它，继续遍历它的邻接点</span></span><br><span class="line">            <span class="built_in">DFS</span>(G, p-&gt;adjvex);</span><br><span class="line">        p = p-&gt;nextarc;          <span class="comment">// 一轮深度优先遍历结束后，回退到出发点，继续遍历剩余邻接结点，p指向顶点v的下一个邻接点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="x3D-x3D-广度优先搜索-BFS-x3D-x3D"><a href="#x3D-x3D-广度优先搜索-BFS-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;广度优先搜索 BFS&#x3D;&#x3D;"></a>&#x3D;&#x3D;广度优先搜索 BFS&#x3D;&#x3D;</h4><p>广度优先搜索（BFS）类似于二叉树的层序遍历算法，它的基本思想是：首先访问起始项点v，接着由v出发，依次访问v的各个未访问过的邻接顶点$w_1$, $w_2$, …, $w_i$，然后再依次访问$w_1$, $w_2$, …, $w_i$的所有未被访问过的邻接顶点；再从这些访问过的顶点出发，再访问它们所有未被访问过的邻接顶点…..以此类推，直到图中所有顶点都被访问过为止。类似的思想还将应用于Dijkstra单源最短路径算法和Prim最小生成树算法。</p>
<p>广度优先搜索是一种分层的查找过程，每向前走一步可能访问一批顶点，不像深度优先搜索那样有往回退的情况，因此它不是一个递归的算法。为了实现逐层的访问，算法必须借助一个辅助队列，以记忆正在访问的顶点的下一层顶点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(AdjGraph *G, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> w, i;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    SqQueue *qu;    <span class="comment">// 用于存储下一次广度搜索时要访问的结点</span></span><br><span class="line">    <span class="built_in">InitQueue</span>(qu);</span><br><span class="line">    <span class="type">int</span> visited[MAXV];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; G-&gt;n; i++) visited[i] = <span class="number">0</span>;   <span class="comment">//标记顶点是否已被访问</span></span><br><span class="line">    cout&lt;&lt;v&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    visited[v] = <span class="number">1</span>;          <span class="comment">// 置已访问标记</span></span><br><span class="line">    <span class="built_in">enQueue</span>(qu, v);</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">QueueEmpty</span>(qu))&#123;  <span class="comment">// 队列不为空时</span></span><br><span class="line">		<span class="built_in">deQueue</span>(qu, w);               <span class="comment">// 出队，顶点编号存入w</span></span><br><span class="line">        p = G-&gt;adjlist[w].firstarc;   <span class="comment">// p指向w的第一个邻接结点</span></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;               <span class="comment">// 访问p所有的邻接结点，并将其入队，以进行下一次广度搜索</span></span><br><span class="line">            <span class="keyword">if</span>(visited[p-&gt;adjvex] == <span class="number">0</span>)&#123;</span><br><span class="line">                cout&lt;&lt;p-&gt;adjvex&lt;&lt;<span class="string">&quot; &quot;</span>; <span class="comment">// 访问该邻接结点，并置访问标记为1</span></span><br><span class="line">                visited[p-&gt;adjvex] = <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">enQueue</span>(qu, p-&gt;adjvex);</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;nextarc;   <span class="comment">// 若访问过，则继续遍历其余邻接结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-图遍历算法的应用"><a href="#4-4-图遍历算法的应用" class="headerlink" title="4.4 图遍历算法的应用"></a>4.4 图遍历算法的应用</h3><ol>
<li><strong>判断图的连通性</strong></li>
</ol>
<p>图的遍历算法可以用来判断图的连通性。对于无向图来说，如果无向图是连通的，则从任一结点出发，仅需一次遍历就能够访问图中所有顶点；如果无向图是非连通的，则从某一个顶点出发，一次遍历只能访问到该顶点所在连通分量的所有顶点，而对于图中其他连通分量的顶点，则无法通过这次遍历访问。对于有向图来说，若从初始点到图中的每个顶点都有路径，则能够访问到图中的所有顶点，否则不能访问到所有顶点。</p>
<ol start="2">
<li><strong>遍历解答树</strong></li>
</ol>
<p>在问题求解时，对所有可能的问题解构成一棵树，而最优解或者符合要求的解就是该树的一条路径或者一个结点。这种树称为解答树。</p>
<blockquote>
<p>例1：比如1,2…n的排列一共有n!个，生成它们至少需要n!的时间。图14-6是生成123的全排列的解答树。通过深度优先遍历DFS就可以输出1,2…n的全排列</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220716201706661.png" alt="image-20220716201706661"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">13</span>;   <span class="comment">//n 的最大值</span></span><br><span class="line"><span class="type">int</span> d[N];         <span class="comment">//记录解</span></span><br><span class="line"><span class="type">int</span> v[N];         <span class="comment">//记录某个值是否被遍历过，没遍历过为0，遍历过后为1</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (depth&gt;=n) &#123;     <span class="comment">// 到达叶子结点</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; <span class="number">1</span>!= n; ++i)</span><br><span class="line">			cout&lt;&lt;d[i] ;</span><br><span class="line">		cout&lt; &lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; ++i) &#123;  <span class="comment">// 第一层，1, 2, ……, n</span></span><br><span class="line">		<span class="keyword">if</span>(v[i]= <span class="number">0</span>) &#123;       <span class="comment">// 选择未被访问的数</span></span><br><span class="line">			v[i]=<span class="number">1</span>;         <span class="comment">// 置访问标记为1</span></span><br><span class="line">			d[depth]=i;</span><br><span class="line">			<span class="built_in">dfs</span>(depth+<span class="number">1</span>);   <span class="comment">// 递归遍历下一层</span></span><br><span class="line">			v[i]=<span class="number">0</span>;         <span class="comment">// 回退，标记数i未被访问</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="built_in">memset</span>(v, <span class="number">0</span>, n);   <span class="comment">// 初始化数组v，将v中前n个字节置0</span></span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照相同的原理，输出数组的全排列：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">perm</span><span class="params">(<span class="type">int</span> list[], <span class="type">int</span> k, <span class="type">int</span> m)</span> </span>&#123;    <span class="comment">// k表示遍历解答树的深度，m表示数组下标最大值</span></span><br><span class="line">	<span class="keyword">if</span>(k &gt; m) &#123;</span><br><span class="line">		<span class="built_in">copy</span>(list，list+k, <span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=k ;i &lt;= m; ++i) &#123;</span><br><span class="line">		<span class="built_in">swap</span>(list[k], list[i]);</span><br><span class="line">        <span class="built_in">perm</span>(list, k+<span class="number">1</span>, m);         <span class="comment">// 继续递归遍历解答树的下一层</span></span><br><span class="line">		<span class="built_in">swap</span> (list[k], list[i]);    <span class="comment">// 回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> list[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">	<span class="built_in">perm</span>(list, <span class="number">0</span>, <span class="built_in">sizeof</span>(list)/<span class="built_in">sizeof</span>(<span class="type">int</span>)<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>例2：有1分，2分，5分，10分四种硬币，每种硬币数量无限，给定Target分钱，求有多少种组合可以组合成Target分钱?</p>
</blockquote>
<p>依然是解答树的深度优先遍历DFS问题（回溯法）：</p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/huangxy10/article/details/8026464">https://blog.csdn.net/huangxy10/article/details/8026464</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count=<span class="number">0</span>; <span class="comment">//统计有多少种组合</span></span><br><span class="line"><span class="type">int</span> Target=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> coin[<span class="number">4</span>]=&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>&#125;; <span class="comment">//记录硬币的面值</span></span><br><span class="line"><span class="type">int</span> total=<span class="number">0</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; solution; <span class="comment">//解向量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span> <span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(total == Target) &#123;   <span class="comment">// 满足条件，输出结果</span></span><br><span class="line">		count++;</span><br><span class="line">		cout &lt;&lt; count &lt;&lt;<span class="string">&quot;:&quot;</span> ;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; (<span class="type">int</span>) solution.<span class="built_in">size</span>(); i++)</span><br><span class="line">			cout &lt;&lt; solution[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">if</span> (total &gt; Target)  <span class="comment">// 无解</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=index; i&lt;<span class="number">4</span>; i++) &#123;    <span class="comment">// 币种为4种，也就是解空间树结点有4个分支</span></span><br><span class="line">		total += coin[i] ;</span><br><span class="line">		solution.<span class="function">push_ <span class="title">back</span><span class="params">(coin[i])</span></span>;</span><br><span class="line">		<span class="built_in">dfs</span>(i);                     <span class="comment">// 继续深度优先遍历</span></span><br><span class="line">		solution.<span class="built_in">pop_back</span>();        <span class="comment">// 回溯</span></span><br><span class="line">		total -= coin[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	count=<span class="number">0</span>;</span><br><span class="line">	cin &gt;&gt; Target;      <span class="comment">//需输入大于0的整数</span></span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">	cout &lt;&lt; count &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>01背包问题，使用深度优先遍历的思想解决</p>
</blockquote>
<p>0-1背包问题除了用动态规划解决以外，是不是也可以利用深度优先遍历解决呢?下图为有ABCD若干件物品的背包问题解答树。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220716214309918.png" alt="image-20220716214309918"></p>
<p>我们利用深度优先遍历遍历至每个叶子结点，求出小于背包容量的最大值即可。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100</span>; <span class="comment">//物品最大件数</span></span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;       <span class="comment">//保存解</span></span><br><span class="line"><span class="type">int</span> item_number; <span class="comment">//物品件数</span></span><br><span class="line"><span class="type">int</span> knap_size;   <span class="comment">//背包载重量或者体积容量</span></span><br><span class="line"><span class="type">int</span> weight[N];   <span class="comment">//物品的重量或者体积</span></span><br><span class="line"><span class="type">int</span> value [N];   <span class="comment">//物品的价值</span></span><br><span class="line"><span class="type">int</span> x[N];        <span class="comment">//解向量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cur_depth , <span class="type">int</span> cur_size，<span class="type">int</span> cur_value)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(cur_depth &gt; item_number) &#123;     <span class="comment">//到达叶子结点</span></span><br><span class="line">		<span class="keyword">if</span> (cur_value &gt; ans)          <span class="comment">//更新最优解</span></span><br><span class="line">			ans=cur_value;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">if</span>(cur_size &gt; knap_size) <span class="comment">//超过背包容量，该路径不是问题的解</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(cur_value &gt; ans)      <span class="comment">//保存当前路径解</span></span><br><span class="line">		ans=cur_value;</span><br><span class="line">	<span class="comment">//深度优先搜索，要或不要两种选择而已。</span></span><br><span class="line">    <span class="built_in">dfs</span> (cur_depth+<span class="number">1</span>, cur_size, cur_value);   <span class="comment">// 不放入</span></span><br><span class="line">	<span class="built_in">dfs</span> (cur_ depth+<span class="number">1</span>, cur_size+weight[cur_depth], cur_value+value[cur_depth]);    <span class="comment">//放入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h3 id="4-5-图的基本应用"><a href="#4-5-图的基本应用" class="headerlink" title="4.5 图的基本应用"></a>4.5 图的基本应用</h3><h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><p>连通图的生成树是<u>包含图中全部顶点的一个极小连通子图</u>。若图中顶点数为n，则它的生成树含有n-1条边。对于生成树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路。在非连通图中，连通分量的生成树构成了非连通图的生成森林。</p>
<p>注意区分极大连通子图和极小连通子图：极大连通子图是无向图的连通分量，<u>极大即要求该连通子图包含其所有的边</u>；极小连通子图是连通无向图的生成树，<u>极小既要保持图连通，又要使得边数最少</u>，只有生成树满足条件，砍去生成树的任一条边， 图将不再连通。</p>
<p>构造最小生成树有多种算法，但大多数算法都利用了最小生成树的下列性质：</p>
<p>假设G&#x3D;(V,B)是一个带权连通无向图，U是顶点集V的一个非空子集。若(u,v)是一条具有最小权值的边，其中u∈U，v∈V-U，则必存在一棵包含边(u, v)的最小生成树。</p>
<p>基于该性质的最小生成树算法主要有：Prim 算法和Kruskal算法，它们都基于贪心算法的策略。</p>
<p>**&#x3D;&#x3D;prim算法&#x3D;&#x3D;**（运用BFS）</p>
<p>Prim算法的步骤如下：</p>
<p>初始化：向空树$T&#x3D;(V_T,E_T)$中添加图$G&#x3D;(V,E)$的任一顶点$u_o$，使$V_T&#x3D;{u_0}$，$E_T&#x3D;\emptyset$。</p>
<p>循环（重复下列操作至$V_T&#x3D;V$）：从图G中选择满足${(u,v)|u \in V_T, v \in V-V_T}$且具有最小权值的边(u,v)，并置$V_T &#x3D; V_T \bigcup {v}$，。$E_T &#x3D; E_T \bigcup {(u,v)}$。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220716220813628.png" alt="image-20220716220813628"></p>
<p>Prim算法的时间复杂度为$O(|V|^2)$，不依赖于|E|，因此它<strong>适用于求解边稠密的图的最小生成树</strong>。虽然采用其他方法可以改进Prim算法的时间复杂度，但增加了实现的复杂性。</p>
<p><strong>&#x3D;&#x3D;kruskal算法&#x3D;&#x3D;</strong></p>
<p>与Prim算法从顶点开始扩展最小生成树不同，Kruskal 算法是一种按权值的递增次序选择合适的边来构造最小生成树的方法。假设N&#x3D;(V,E)是连通网，对应的最小生成树$T&#x3D;(V_T,E_T)$，KVruskal 算法的步骤如下：</p>
<p>初始化：使$V_T&#x3D;V$，$E_T&#x3D;\emptyset$。 即每个顶点构成一棵独立的树， T此时是一个仅含|V|个顶点的森林；</p>
<p>循环（重复下列操作至T是一棵树）：按G的边的权值递增顺序依次从$E &#x3D; E_T$中选择一条边，如果这条边加入T后不构成回路，则将其加入E，否则舍弃，直到E中含有n-1条边。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220716221006112.png" alt="image-20220716221006112"></p>
<p>通常在Kruskal算法中，采用堆来存放边的集合，则每次选择最小权值的边只需O(log|E|)的时间。又生成树T中所有边可以视为一个等价类，每次添加新的边的过程类似于求解等价类的过程，由此可以采用并查集的数据结构来描述T，从而构造T的时间复杂度为O(|E|log|E|),因此，<strong>Kruskal 算法适合于边稀疏而顶点较多的图</strong>。</p>
<h4 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h4><p>求解最短路径的算法通常都依赖于一种性质，也就是<u>两点之间的最短路径也包含了路径上其他顶点间的最短路径</u>。这种最优子结构性质是动态规划和贪心算法是否适用的一个标记。</p>
<p>带权有向图G的最短路径问题，一般可分为两类：一是单源最短路径，即求图中某一顶点到其他各顶点的最短路径，可通过经典的Djkstra 算法求解，此算法也是基于贪心算法的策略；二是求每一对顶点间的最短路径，可通过Floyd-Warshall算法来求解，此算法是基于动态规划的思想。</p>
<h5 id="x3D-x3D-Dijkstra算法-x3D-x3D-（BFS-贪心）求单源最短的径问题"><a href="#x3D-x3D-Dijkstra算法-x3D-x3D-（BFS-贪心）求单源最短的径问题" class="headerlink" title="&#x3D;&#x3D;Dijkstra算法&#x3D;&#x3D;（BFS+贪心）求单源最短的径问题"></a>&#x3D;&#x3D;<strong>Dijkstra算法</strong>&#x3D;&#x3D;（BFS+贪心）求单源最短的径问题</h5><p>参考：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1zz4y1m7Nq">https://www.bilibili.com/video/BV1zz4y1m7Nq</a></p>
<p>求带权有向图中某个源点到其余各顶点的最短路径，最常用的是Dijkstra 算法。该算法设置一个集合s，记录已求得的最短路径的顶点，初始时把源点v的放入S中。此外，在构造过程中还设置了两个辅助数组：</p>
<p>**dist[]**：记录了从源点$v_0$到其他各顶点当前的最短路径长度，dist[i]初值为arcs[0][i]。</p>
<p>**path[]**：path[i]表示从源点到顶点i之间的最短路径的前驱结点，在算法结束时，可根据其值追溯得到源点$v_0$到顶点V的最短路径。</p>
<p>假设从顶点0出发，即$v_0&#x3D;0$，<strong>集合S</strong>最初只包含顶点0，<strong>邻接矩阵arcs</strong>表示带权有向图，arcs[i][j]表示有向边&lt;i, j&gt;的权值，若不存在有向边&lt;i, j&gt;，则arcs[i][j]为∞。</p>
<ul>
<li><p><em><strong>Djkstra 算法的步骤如下</strong></em>（不考虑对path[]的操作）：</p>
<ul>
<li><p>初始化：集合S初始为{0}，dist[]的初始值dist[i]&#x3D; arcs[0][i]，i&#x3D;1, 2, …, n-1。</p>
</li>
<li><p><u>从未入选S的顶点集合V-S中选出距离出发点$v_0$最近（即dist最小）的结点$v_j$</u>，也就是满足$dist[j]&#x3D;Min{dist[i]|v_i \in V-S}$，$v_j$就是当前求得的一条从$v_0$出发的最短路径的终点，<u>将其收录进S</u>，即令$S&#x3D;S \bigcup {j}$。</p>
</li>
<li><p><u>修改从$v_0$出发到集合V-S上的$v_k$可达的最短路径长度dist[k]，$v_k$为$v_j$的邻近顶点</u>：如果$v_0$经过结点$v_j$到达$v_k$的距离小于已知的到达$v_k$的距离，即dist[j]+arcs[j][k] &lt; dist[k]，则更新disk[k]，令dist[k]&#x3D;dist[j]+arcs[j][k]。</p>
</li>
<li><p>重复2) ~3)操作共n-1次，直到所有的顶点都包含在S中。</p>
</li>
</ul>
</li>
<li><p><em><strong>算法计算过程举例</strong></em></p>
<p>例如，表14-1所示为应用Djkstra算法对图14-11中的图从顶点1出发，求其到其余顶点的最短路径。</p>
<p><strong>第一趟</strong>：与结点1直接相连的有结点2、5，距离分别为10、5。而其余结点不能直达，所以距离为无限。这样每个结点都有一个初始化的距离。更新结点2、5的距离，并将距离最短的结点5加入S；</p>
<p><strong>第二趟</strong>：上一趟在S中加入了结点5，因此对于与结点5直连且未选入S的结点2、3、4，计算其距离与出发点1的距离。计算时，判断经过结点5的路径和已知路径哪个更短。对于结点2，经过结点5的路径长度为5+3&#x3D;8，不经过则为已知的10，因此更新其最短路径长度为8（path数组中可以更新结点2的值为5，表示到达结点2的最短路径中终点的前驱结点为5）。同理，对于结点3，5+9&#x3D;14&lt;$\infty$，其最短路径长度更新为14。对于结点4，5+2&#x3D;7&lt;$\infty$，其最短路径长度更新为7。接着，选择V-S中有路径长度最短的结点4加入S；</p>
<p><strong>第三趟</strong>：重复第二趟中的过程，更新结点4的邻近结点3（未加入S）的最短路径长度，7+6&#x3D;13&lt;14，因此更新为13，然后选择V-S中路径最短的结点2加入S；</p>
<p><strong>第四趟</strong>：继续重复，更新结点2的邻近结点3（未加入S）的最短路径长度，8+1&#x3D;9&lt;13，因此更新为9，然后选择V-S中路径最短的结点3加入S；</p>
<p>这样所有结点均加入S，计算完毕。</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220717000511386.png" alt="image-20220717000511386"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220717143107988.png" alt="image-20220717143107988"></p>
<ul>
<li><p><em><strong>特点</strong></em></p>
<p>显然，Dijkstra 算法是基于贪心策略的。若使用邻接矩阵表示，它的**<u>时间复杂度为</u><strong>$O(|V|^2)$。若使用带权的邻接表表示，虽然修改dist[]的时间可以减少，但由于在dist[]中选择最小分量的时间不变，其时间复杂度仍为$O(|V|^2)$。注意：</strong>如果边的权值为负，则dijkstra算法不适用。**</p>
</li>
</ul>
<h5 id="x3D-x3D-Floyd算法-x3D-x3D-（动态规划）"><a href="#x3D-x3D-Floyd算法-x3D-x3D-（动态规划）" class="headerlink" title="&#x3D;&#x3D;Floyd算法&#x3D;&#x3D;（动态规划）"></a>&#x3D;&#x3D;<strong>Floyd算法</strong>&#x3D;&#x3D;（动态规划）</h5><p>参考：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1LE411R7CS">https://www.bilibili.com/video/BV1LE411R7CS</a></p>
<ul>
<li><p><em><strong>基本思想</strong></em></p>
<p>Floyd算法的基本思想是：递推产生一个n阶方阵序列$A^{(-1)}$ ,$A^{(0)}$, … , $A^{(K)}$, … ,$A^{(n-1)}$，其中<u>$A^{(K)}[i][j]$表示从顶点$v_i$到顶点$v_j$的最短路径长度，k表示绕行第k个顶点的运算步骤</u>。</p>
<p>初始时，对于任意两个顶点$v_i$和$v_j$，若它们之间存在边，则以此边上的权值作为它们之间的最短路径长度；若它们之间不存在有向边，则以∞作为它们之间的最短路径长度。逐步尝试在原路径中加入顶点k（k&#x3D;0, 1, …, n-1）作为中间顶点。如果增加中间顶点后，得到的路径比原来的路径长度减少了，则以此新路径代替原路径。算法的描述如下：</p>
<p>定义一个<strong>n阶方阵序列</strong>：$A^{(-1)}$ ,$A^{(0)}$, … , $A^{(K)}$, … ,$A^{(n-1)}$，其中：</p>
<p>$A^{(-1)}[i][j]&#x3D;arcs[i][j]$（也就是不经过任何顶点的路径，路径长度就直接等于邻接矩阵的值）</p>
<p>$A^{(k)}[i][j]&#x3D;Min{A^{(k-1)}[i][j], \space A^{(k-1)}[i][k]+A^{(k-1)}[k][j] }, \space k&#x3D;0,1,…,n-1$（经过和不经过顶点$v_k$的路径长度，取最小值，得到考虑k个顶点的情况下的最短路径）</p>
<p><u>Floyd 算法是一个迭代的过程，每迭代一次， 在从$v_i$到$v_j$的最短路径上就多考虑了一个顶点；经过n次迭代后所得到的$A^{(n-1)}[i][j]$考虑了路径上可能遇到的所有结点，所以就得到了从$v_i$到$v_j$的最短路径长度，即方阵$A^{(n-1)}$中就保存了任意一对顶点之间的最短路径长度。</u></p>
</li>
<li><p><em><strong>算法计算过程举例</strong></em></p>
<p>如图14-12 所示为带权有向图G及其邻接矩阵，下面通过实例来说明Floyd算法的过程见表14-2。</p>
<p><strong>第一个矩阵</strong>$dist^{(-1)}$记录所有顶点之间的初始的路径长度，直连的两顶点的dist值就是其边权值，否则为$\infty$。</p>
<p><strong>第二个矩阵</strong>$dist^{(0)}$将顶点$V_0$纳入路径的考虑中。将已知的顶点$V_i$和顶点$V_j$之间的路径长度$dist^{(-1)}[i][j]$与经过顶点$V_0$的路径长度$dist^{(-1)}[i][0]+dist^{(-1)}[0][j]$相比较，取其最小值作为$dist^{(0)}[i][j]$的值。</p>
<p>比如$dist^{(-1)}[2][1]$初始为$\infty$，而考虑经过顶点$V_0$时，路径长度为$dist^{(-1)}[2][0]+dist^{(-1)}[0][1]&#x3D;5+6&#x3D;11&lt;\infty$。因此$dist^{(0)}[2][1]&#x3D;11$。（此处可以有一个<strong>path二维数组</strong>，用于存储顶点之间的最短路径所经过的顶点，默认值为-1。比如这里可以令$path[2][1]&#x3D;0$表示顶点2到顶点1的最短路径要经过顶点0。查找路径时，再继续查找$path[2][0]$和$path[0][1]$即可，这样就可以查找到完整路径）</p>
<p><strong>同理，第三个矩阵</strong>$dist^{(1)}$将顶点$V_1$纳入路径的考虑中。对于顶点$V_i$和顶点$V_j$之间的路径，对比经过$V_1$和不经过$V_1$的情况，取路径长度的最小值得到$dist^{(1)}[i][j]$。</p>
<p><strong>继续循环下去，直到得到矩阵</strong>$dist^{(n-1)}$，考虑了所有的n个顶点。</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220717210915856.png" alt="image-20220717210915856"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220717210925100.png" alt="image-20220717210925100"></p>
<ul>
<li><p><em><strong>代码</strong></em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Floyd</span><span class="params">(<span class="type">int</span> n, <span class="type">float</span> MGraph[ ][n]，<span class="type">int</span> Path[][n])</span> </span>&#123;   <span class="comment">// n为顶点个数</span></span><br><span class="line">	<span class="type">int</span> i, j，v;</span><br><span class="line">	<span class="type">int</span> A[n] [n];</span><br><span class="line">	<span class="comment">// 初始化dist数组和path数组</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">			A[i][j] = MGraph[i][j];</span><br><span class="line">			Path[i][j] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 迭代dist数组</span></span><br><span class="line">	<span class="keyword">for</span>(v=<span class="number">0</span>;V&lt;n;++v)&#123;     <span class="comment">// 考虑路径上可能的n个结点</span></span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)&#123;      <span class="comment">// 所有的顶点对vi、vj</span></span><br><span class="line">			<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">				<span class="keyword">if</span>(A[i][j] &gt; A[i][v]+A[v][j]) &#123;    <span class="comment">// 经过和不经过顶点v，哪个路径更短</span></span><br><span class="line">					A[i][j] = A[i][v] + A[v][j] ;  <span class="comment">// 更新dist矩阵</span></span><br><span class="line">					Path[i][j] = v;                <span class="comment">// 经过顶点v，则将path数组也更新</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据path数组输出路径</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPath</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> V, <span class="type">int</span> path[][max] )</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (path[u][v] == <span class="number">-1</span> )</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;&lt;&quot;</span>&lt;&lt;u&lt;&lt;<span class="string">&quot;, &quot;</span>&lt;&lt;v&lt;&lt;<span class="string">&quot;&gt;&quot;</span>;   <span class="comment">//直接输出</span></span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="type">int</span> mid = path[u] [v] ;</span><br><span class="line">		<span class="built_in">printPath</span>(u, mid, path) ;</span><br><span class="line">		<span class="built_in">printPath</span> (mid, V, path) ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><em><strong>特点</strong></em></p>
<p><strong><u>Floyd算法的时间复杂度为</u></strong>$O(|V|^3)$。不过由于其代码很紧凑，而且并不包含其他复杂的数据结构，因此隐含的常数系数是很小的，即使对于中等<br>规模的输入来说，它仍然是相当有效的。</p>
<p>Floyd算法<strong>允许图中有带负权值的边</strong>，<u>但不允许有包含带负权值的边组成的回路</u>。Floyd 算法同样也适用于带权无向图，因为带权无向图可以视为<br>有往返二重边的有向图。</p>
<p>也可以用单源最短路径算法来解决每对顶点之间最短路径问题。每一次运行时， 轮流将一个顶点作为源点，并且若所有边权值均为非负时，可以采用上面提到的Dijkstral算法，其时间复杂度为$O(|V|^2)*|V|&#x3D;O(|V|^3)$。</p>
</li>
</ul>
<h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><p><strong>有向无环图</strong>：一个有向图中不存在环，则称为有向无环图，简称<strong>DAG图</strong>。</p>
<p><strong>AOV网</strong>：如果用DAG图表示一个工程， 其顶点表示活动，用有向边$&lt;V_i，V_j&gt;$表示活动$V_i$必须先于活动$V_j$进行的这样一种关系， 则将这种有向图称为顶点表示活动的网络，记为AOV网。在AOV网中，活动$V_i$是活动$V_j$的直接前驱，活动$V_j$是活动$V_i$的直接后继，这种前驱和后继关系具有传递性，且任何活动$V_i$不能以它自己作为自己的前驱或后继。</p>
<p><strong>拓扑排序</strong>：在图论中，<u>由一个有向无环图的顶点组成的序列</u>，当且仅当满足下列条件时，称为该图的一个拓扑排序。</p>
<ol>
<li><p><u>每个顶点出现且只出现一次</u>。</p>
</li>
<li><p>若项点A在序列中排在顶点B的前面，则在图中不存在从顶点B到顶点A的路径。或者定义为：拓扑排序是对有向无环图的顶点的一种排序，它使得<u>如果存在一条从顶点A到顶点B的路径，那么在排序中顶点B出现在顶点A的后面</u>。每个DAG图都有一个或多个拓扑排序序列。</p>
</li>
</ol>
<p>对一个DAG图进行拓扑排序的算法有很多，下面介绍比较常用的一种方法的步骤：</p>
<ol>
<li>从DAG图中选择一个没有前驱的顶点并输出。</li>
<li>从图中删除该顶点和所有以它为起点的有向边。</li>
<li>重复1和2直到当前的DAG图为空或当前图中不存在无前驱的顶点为止。而后一种情况，即当前图中不存在无前驱的顶点，则说明有向图中必然存在环。</li>
</ol>
<h2 id="5-排序"><a href="#5-排序" class="headerlink" title="5 排序"></a>5 排序</h2><p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_16775293/article/details/107821256?spm=1001.2014.3001.5502">https://blog.csdn.net/qq_16775293/article/details/107821256?spm=1001.2014.3001.5502</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/ekGdneZrMa23ALxt5mvKpQ">https://mp.weixin.qq.com/s/ekGdneZrMa23ALxt5mvKpQ</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Ur4y1w7tv">https://www.bilibili.com/video/BV1Ur4y1w7tv</a></p>
<p><strong>算法的稳定性</strong>：如果待排序表中有两个元素$R_i$、$R_j$，其对应的关键字$key_i&#x3D;key_j$，且在排序前$R_i$在$R_j$前面，如果使用某排序算法排序后，$R_i$仍然在$R_j$的前面，则称这个排序算法是稳定的，否则称排序算法是不稳定的。</p>
<p>注意：对于不稳定的排序算法，只需举出一组关键字的实例说明它的不稳定性即可。</p>
<p>在排序的过程中，根据数据元素是否完全在内存中，可将排序算法分为两类：<strong>内部排序</strong>是指在排序期间元素全部存放在内存中的排序；<strong>外部排序</strong>是指在排序期间元素无法全部同时存放在内存中，必须在排序的过程中根据要求不断地在内、外存之间移动的排序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 待排序的顺序表中数据元素的类型声明如下 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;    <span class="comment">// 定义关键字类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	KeyType key;        <span class="comment">// 关键字项</span></span><br><span class="line">    InfType data;       <span class="comment">// 其他数据项</span></span><br><span class="line">&#125;RecType;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://uploadfiles.nowcoder.com/images/20220518/674306065_1652858588900/C1F78743F09180F47A6FF8BE443A157F" alt="img"></p>
<h3 id="5-1-插入排序"><a href="#5-1-插入排序" class="headerlink" title="5.1 插入排序"></a>5.1 插入排序</h3><p>基本思想在于每次将一个待排序的记录， 按其关键字大小插入到前面已经排好序的子序列中，直到全部记录插入完成。</p>
<h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/insertionSort.gif" alt="动图演示"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span> <span class="params">(RecType R[], <span class="type">int</span> n)</span></span>&#123;  <span class="comment">// n为数组长度</span></span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">    RecType tmp;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)                    <span class="comment">//依次将R[1]~R[n-1]插入到前面已排序序列</span></span><br><span class="line">		<span class="keyword">if</span> (R[i].key &lt; R[i<span class="number">-1</span>].key) &#123;    <span class="comment">//若R[i]的关键码小于其前驱，即非递增，需将R[i]插入有序表</span></span><br><span class="line">			tmp=R[i];                   <span class="comment">//暂存</span></span><br><span class="line">            j=i<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">                R[j+<span class="number">1</span>] = R[j];           <span class="comment">// 向后挪位</span></span><br><span class="line">                j--;                   <span class="comment">//从后往前查找待插入位置</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (j&gt;=<span class="number">0</span> &amp;&amp; R[j].key &gt; tmp.key) <span class="comment">// 大于tmp时继续往前</span></span><br><span class="line">			R[j+<span class="number">1</span>] = tmp;                <span class="comment">//复制到插入位置</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>复杂度</strong></p>
<p>直接插入排序的<strong>时间复杂度</strong>为$O(n^2)$，空间复杂度为$O(1)$。</p>
<p>在最好情况下，表中元素已经有序，此时每插入一个元素，都只需比较一次而不用移动元素，因而时间复杂度为$O(n)$。</p>
</li>
<li><p><strong>稳定性</strong></p>
<p>由于每次插入元素时总是从后向前先比较再移动，所以不会出现相同元素相对位置发生变化的情况，即直接插入排序是一个<strong>稳定</strong>的排序方法。</p>
</li>
<li><p><strong>缺点</strong>：</p>
<p>1）寻找插入位置（耗时，需要从后往前一个个扫描）；</p>
<p>2）移动元素（需要将插入位置的元素全部后移）；</p>
</li>
<li><p><strong>优化</strong></p>
<p>1）对于寻找插入位置的优化，可以使用二分查找法，由此引出折半插入排序。</p>
<p><strong>折半插入排序</strong>：在有序区查找插入位置时，将从后往前的逐个比较优化为折半查找方法，找到插入位置后再集中将后面的元素后移，最后插入。</p>
<p>折半插入排序其实仅减少了元素的比较次数，对移动元素的性能并没有改善。其平均时间复杂度依然为$O(n^2)$，空间复杂度为$O(1)$，是一种稳定的排序方法。</p>
<p>2）携带多个元素进行插入，每次可以移动更多位数，减少移动次数</p>
<p>3）将数组改为链表结构，无需移动元素</p>
<p>4）希尔排序</p>
</li>
</ul>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p><strong>基本思想</strong>：先将待排序表分割成若干形如$L[i, i+d, i+2d, ……, i+kd]$的“特殊”子表，分别进行直接插入排序，当整个表中元素已呈“基本有序”时，再对全体记录进行一次直接插入排序。</p>
<p>希尔排序的排序过程如下：</p>
<p>先取一个**小于n的步长$d_1$**，把表中全部记录分成$d_1$个组，所有距离为$d_1$的倍数的记录放在同一个组中，在各组中进行直接插入排序；然后取第二个步长$d_2&lt;d_1$，重复上述过程，直到所取到的$d_t&#x3D;1$，即所有记录已放在同一组中，再进行直接插入排序，由于此时已经具有较好的局部有序性，故可以很快得到最终结果。到目前为止，<u>尚未求得一个最好的增量序列，希尔提出的方法是</u>$d_1&#x3D;n&#x2F;2$，$d_{i+1}&#x3D;\lfloor d_i&#x2F;2 \rfloor $，并且最后一个增量等于1。</p>
<p>每一步的步长$d_t$逐渐减小，先让序列大致有序，然后随着$d_t$减小调整分组方式，组序列越来越长，整体序列也逐渐趋向有序。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220718151003466.png" alt="image-20220718151003466" style="zoom:20%;" />

<p>比如，如下图片中，透明方块一行代表待排序序列，总共15个元素，所以$d_1&#x3D;15&#x2F;2&#x3D;7$，步长为7，序列会被划分为7个组，第二行中同色方块代表同组元素（7种颜色），第三行代表在每组中进行直接插入排序后的序列：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220718155519817.png" alt="image-20220718155519817"></p>
<p>接着，$d_2&#x3D;7&#x2F;2&#x3D;3$，步长为3，所有元素被划分为3个组，图中第二行有三种颜色，第三行代表在每组中进行直接插入排序后的序列：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220718155752465.png" alt="image-20220718155752465"></p>
<p>最后，$d_3&#x3D;3&#x2F;2&#x3D;1$，步长为1，所有元素被划分为1个组，也就是对序列整体进行一次直接插入排序，所以图中第二行只有一种颜色，第三行代表直接插入排序后的序列，这样就得到了最终排序好的序列：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220718160200882.png" alt="image-20220718160200882"></p>
<p>希尔排序的 <strong>核心思想</strong> 是化远为近，将相隔较远的元素放在一组，组成短序列进行直接插入排序，逐渐使序列整体趋近有序，减少了查找次数和元素移动的次数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span> <span class="params">(RecType R[], <span class="type">int</span> n)</span></span>&#123;  <span class="comment">// n为数组长度</span></span><br><span class="line">    <span class="type">int</span> i, j, d;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    d = n/<span class="number">2</span>;        <span class="comment">// 增量置初值</span></span><br><span class="line">    <span class="keyword">while</span>(d&gt;<span class="number">0</span>)&#123;     <span class="comment">// 直到增量为0结束，因为最后一个增量必定为1，1/2=0</span></span><br><span class="line">        <span class="comment">// 对步长为d的所有分组采用直接插入排序，i首先定位到所有分组的第二个元素，即R[d]、R[d+1]、……，结束后继续往后定位到第三个元素……直到序列末尾</span></span><br><span class="line">        <span class="keyword">for</span>(i=d;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="comment">// 对R[i]进行直接插入排序</span></span><br><span class="line">            tmp = R[i];         <span class="comment">// 暂存要插入的元素</span></span><br><span class="line">            j = i-d;            <span class="comment">// 前一个元素</span></span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; tmp.key&lt;R[j].key)&#123;</span><br><span class="line">                R[j+d] = R[j];  <span class="comment">// 组内元素后移</span></span><br><span class="line">                j = j-d;        <span class="comment">// 继续比较前一个元素</span></span><br><span class="line">            &#125;</span><br><span class="line">            R[j+d] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        d = d/<span class="number">2</span>;      <span class="comment">// 减小增量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>复杂度</strong></p>
<p>希尔排序的时间复杂度依赖于增量序列的函数，这涉及数学上尚未解决的难题，难以分析，一般认为其平均时间复杂度为$O(n^{1.3})$，最坏情况下为$O(n^2)$。希尔排序空间复杂度为$O(1)$。</p>
</li>
<li><p><strong>稳定性</strong></p>
<p>当相同关键字的元素被划分到不同的分组时，可能会改变它们之间的相对次序，因此,希尔排序是一一个<strong>不稳定</strong>的排序方法。</p>
</li>
</ul>
<h3 id="5-2-交换排序"><a href="#5-2-交换排序" class="headerlink" title="5.2 交换排序"></a>5.2 交换排序</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><ul>
<li><p><strong>基本思想</strong></p>
<p>假设待排序表长为n，从后往前(或从前往后)<u>两两比较相邻元素</u>的值，若为逆序（即R[i-1]&gt;R[i]），则交换它们，直到序列比较完。我们称它为一趟冒泡，结果将最小的元素交换到待排序列的第一个位置。下一趟冒泡时， 前一趟确定的最小元素不再参与比较，待排序列减少一个元素，每趟冒泡的结果把序列中的最小元素放到了序列的最终位置。这样<u>最多做n-1趟冒泡</u>就能把所有元素排好序。</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/bubbleSort.gif" alt="动图演示"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(RecType R[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 从前往后比较,将无序区最大值移到末尾</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)&#123;         <span class="comment">// 最多比较n-1轮</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j&gt;n-i<span class="number">-1</span>; j--)&#123;   <span class="comment">// 第i轮比较到n-i-1位置为止，后面的部分是有序的</span></span><br><span class="line">            <span class="keyword">if</span>(R[j].key &gt; R[j+<span class="number">1</span>].key)&#123;</span><br><span class="line">                tmp = R[j];</span><br><span class="line">                R[j] = R[j+<span class="number">1</span>];</span><br><span class="line">                R[j+<span class="number">1</span>] = tmp;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;         	</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == flase)   <span class="comment">// 本轮没有发生交换，已经完全有序</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>复杂度</strong></p>
<p>最坏情况下时间复杂度为$O(n^2)$，最好情况下(表中元素基本有序)时间复杂度为$O(n)$，其平均时间复杂度为$O(n^2)$。空间复杂度为$O(1)$。</p>
</li>
<li><p><strong>稳定性</strong></p>
<p>冒泡排序是一个<strong>稳定</strong>的排序方法。</p>
<p>注意：冒泡排序中所产生的有序子序列一定是全局有序的(不同于直接插入排序)，也就是说有序子序列中的所有元素的关键字一定小于或大于无序子序列中所有元素的关键字，这样每一趟排序都会将一个元素放置到其最终的位置上。</p>
</li>
</ul>
<h4 id="x3D-x3D-快速排序-x3D-x3D-（常考）"><a href="#x3D-x3D-快速排序-x3D-x3D-（常考）" class="headerlink" title="&#x3D;&#x3D;快速排序&#x3D;&#x3D;（常考）"></a>&#x3D;&#x3D;快速排序&#x3D;&#x3D;（常考）</h4><ul>
<li><p><strong>基本思想</strong></p>
<p>基于**<u>分治法</u><strong>。首先从待排序序列中取一个元素作为</strong>基准数<strong>；然后扫描序列，将比基准数小的元素全部放到它的左边，大于或等于基准数的元素全部放到它的右边，得到</strong>左右两个区间**；接着再对左右区间重复第二步，<u>直到各区间少于两个元素</u>。</p>
<p>代码实现中，采用了**<u>挖坑填数</u>**的方法。首先取出基准数的位置（挖坑），从右往左扫描出小于基准数的元素填坑（得到新坑），再从左往右扫描出大于等于基准数的元素填新坑，这样循环下去直到两指针重合，将基准数填入即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">paritition</span><span class="params">(RecType R[], <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;   <span class="comment">// 一趟划分</span></span><br><span class="line">   <span class="type">int</span> tmp = R[left];     <span class="comment">// 第一个数做为基准数</span></span><br><span class="line">   <span class="keyword">while</span> (left &lt; right) &#123;   <span class="comment">// 指针未重合时</span></span><br><span class="line">       <span class="keyword">while</span> (left &lt; right &amp;&amp; R[right] &gt;= pivot)   <span class="comment">// 定位到右区间中小于基准数的元素</span></span><br><span class="line">           --right;</span><br><span class="line">       R[left] = R[right];    <span class="comment">// 填坑</span></span><br><span class="line">       <span class="keyword">while</span> (left &lt; right &amp;&amp; R[left] &lt;= pivot)    <span class="comment">// 定位到左区间中大于基准数的元素</span></span><br><span class="line">           ++left;</span><br><span class="line">       R[right] = R[left];    <span class="comment">// 填坑</span></span><br><span class="line">   &#125;</span><br><span class="line">   R[left] = tmp;</span><br><span class="line">   <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(RecType R[], <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123; <span class="comment">//快排函数</span></span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        tmp = <span class="built_in">paritition</span>(R, left, right);</span><br><span class="line">        <span class="built_in">QuickSort</span>(R, left, tmp<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">QuickSort</span>(R, tmp+<span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>时间复杂度</strong></p>
<p>快速排序的<strong>运行时间与划分是否对称有关</strong>，而后者又与具体使用的划分算法有关。快速排序的最坏情况发生在两个区域分别包含n-1个元素和0个元素时，这种最大程度的不对称性若发生在每一层递归上，即对应于<strong>初始排序表基本有序或基本逆序时，就得到最坏情况下的时间复杂度为</strong>$O(n^2)$；最好情况下，每次划分都能对称，即<strong>基准数就是区间的中值，那么最好情况下时间复杂度为</strong>$O(nlog_2n)$。</p>
</li>
<li><p><strong>空间复杂度</strong></p>
<p>由于快速排序是递归的，需要<u>借助一个递归工作栈</u>来保存每一层递归调用的必要信息，其容量应与递归调用的最大深度一致。最好情况下，所取基准数就是区间的中值，每次能划分出长度相等的左右区间，所以递归树高度为$\lceil log_2n \rceil$；最坏情况下，因为要进行n-1次递归调用，所以栈的深度为$O(n)$；平均情况下，栈的深度为$O(log_2n)$。因而空间复杂度在<u>最坏情况下为$O(n)$，平均情况下为$O(log_2n)$</u>。</p>
</li>
<li><p><strong>稳定性</strong>：</p>
<p>在划分算法中，若右端区间存在两个关键字相同，且均小于基准值的元素，则在交换到左端区间后，它们的相对位置会发生变化，即快速排序是一个<strong>不稳定</strong>的排序方法。</p>
<p>注意：在快速排序算法中，并不产生有序子序列，但每一趟排序后会将一个元素（基准元素）放到其最终的位置上。</p>
</li>
<li><p><strong>优化</strong></p>
<p>1）当递归过程中划分得到的子序列的规模较小时不要再继续递归调用快速排序，可以采用直接插入排序算法进行后续的排序工作。</p>
<p>2）尽量选取一个可以将数据中分的基准数。如从序列的头尾以及中间选取三个元素，再取这三个元素的中间值作为最终的基准数；或者随机从当前序列中选取基准数，这样做使得最坏情况在实际排序中几乎不会发生。</p>
<p>在最理想的状态下，即partition可能做到最平衡的划分，得到的两个子问题的大小都不可能大于n&#x2F;2，在这种情况下，快速排序的运行速度将大大提升，此时，时间复杂度为$O(nlog_2n)$。 好在<u>快速排序平均情况下运行时间与其最佳情况下的运行时间很接近</u>，而不是接近其最坏情况下的运行时间。<br>快速排序是所有内部排序算法中平均性能最优的排序算法。</p>
</li>
</ul>
<h4 id="快排一次排序的应用"><a href="#快排一次排序的应用" class="headerlink" title="快排一次排序的应用"></a>快排一次排序的应用</h4><blockquote>
<p>例1：一个数组中存储有且仅有大写和小写字母，编写一个函数对数组内的字母重新排列，让小写字母在所有大写字母之前。(2012. 中兴、2013 ●腾讯)</p>
</blockquote>
<p>该题直接使用快排的一次区间划分即可，左右指针索引从两端向中间扫描，挖坑填数。代码略。</p>
<blockquote>
<p>例2：给定含有n个元素的整型数组a,其中包括0元素和非0元素，对数组进行排序，要求：(2012.人民搜索)</p>
<ol>
<li>排序后所有0元素在前，所有非零元素在后，且非零元素排序前后相对位置不变</li>
<li>不能使用额外存储空间</li>
</ol>
</blockquote>
<p>该题需要使用快排的一次空间划分，相当于基准数为0。注意，由于<strong>需要保持非零元素排序前后相对位置不变</strong>，所以不能使用左右指针索引从两端向中间扫描的办法。这里使用的是<strong>将相对位置在左的非0元素依次与在右的0元素交换的方法，这样不会破坏排序前元素的相对位置</strong>，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">partition</span><span class="params">(<span class="type">int</span> R[], <span class="type">int</span> p, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i=r+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=r; j &gt;= p; --j) &#123;    <span class="comment">//从后往前遍历</span></span><br><span class="line">		<span class="keyword">if</span>(R[j]!=<span class="number">0</span>) &#123;   <span class="comment">// 遇到非0元素j就后移，即将其与位置--i的元素互换（两种情况：与自身互换；与0元素互换）</span></span><br><span class="line">			--i;</span><br><span class="line">			<span class="type">int</span> temp=R[i];</span><br><span class="line">			R[i]=R[j] ;</span><br><span class="line">			R[j]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return i-1;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">7</span>]=&#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>，<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">	<span class="built_in">partition</span>(a, <span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者从前往后遍历：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">partition</span><span class="params">(<span class="type">int</span> R[], <span class="type">int</span> p, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i=p<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=p; j &lt;= r<span class="number">-1</span>; ++j) &#123;    <span class="comment">//从前往后遍历</span></span><br><span class="line">		<span class="keyword">if</span>(R[j] == <span class="number">0</span>) &#123;   <span class="comment">// 遇到0元素j就前移，即将其与位置++i的元素互换（两种情况：与自身互换；与0元素互换）</span></span><br><span class="line">			++i;</span><br><span class="line">			<span class="type">int</span> temp=R[i];</span><br><span class="line">			R[i]=R[j] ;</span><br><span class="line">			R[j]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return i+1;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>例3：进阶——荷兰国旗问题</p>
<p>将乱序的红白蓝三色小球排列成同颜色在一起的小球组(按照红白蓝排序)，这个问题称为荷兰国旗问题。这是因为我们可以将红白蓝三色小球想象成条状物，有序排列后正好组成荷兰国旗。序列中，0表示红球，1表示白球，2表示蓝球。</p>
</blockquote>
<p>这个问题类似于快排的区间划分问题，但是这里需要使用3个指针索引，而不是2个。使用begin指针指向0元素应该在的位置，current用于跳过1元素，end用以指向2元素应该在的位置。begin和current都初始化指向数组首部，end初始化指向数组尾部。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (current&lt;=end) &#123;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">	<span class="keyword">if</span> (array[current] == <span class="number">0</span>) &#123;      <span class="comment">// 0元素前移，current与begin交换</span></span><br><span class="line">		tmp = array[current];</span><br><span class="line">        array[current] = array[begin];</span><br><span class="line">        array[begin] = tmp;</span><br><span class="line">		current++;</span><br><span class="line">		begin++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (array[current] == <span class="number">1</span>)&#123;  <span class="comment">// 1元素不动</span></span><br><span class="line">		current++:</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;                          <span class="comment">// 2元素后移，current与end交换</span></span><br><span class="line">		tmp = array[current];</span><br><span class="line">        array[current] = array[end];</span><br><span class="line">        array[end] = tmp;</span><br><span class="line">		end--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>例4：最小的k个数</p>
<p>输入n个整数，输出其中最小的k个。(2012.网易)</p>
<p>例如输入1, 2, 3，4, 5,，6, 7, 8这8个数字，则最小的4个数字为1, 2, 3, 4。</p>
</blockquote>
<p>最简单的思路莫过于把输入的n个整数排序，这样排在最前面的k个数就是最小的k个数。只是这种思路的时间复杂度为O(nlogn)。这里同样可以使用快排区间划分的方法：</p>
<p>我们设最小的k个数中最大的数为A。在快速排序算法中，我们先在数组中随机选择一个数字，然后调整数组中数字的顺序，使得比选中的数字小的数字都排在它的左边，比选中的数字大的数字都排在它的右边( 即快排一次排序)。 如果快排一次划分后这个选中的数字的下标刚好是k-1 (下标从0开始)，那么这个数字(就是A)加上左侧的k-1个数字就是最小的k个数。如果它的下标大于k-I，那么A位于它的左边，我们可以接着在它的左边部分的数组中查找；如果它的下标小于k-1,那么A应该位于它的右边，我们可以接着在它的右边部分的数组中查找。</p>
<p>可见，这是一个递归问题，但是注意我们找到的k个数不一定是有序的。可以用如下代码实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* input是输入的数组，元素个数为n, output是用来保存最小k个数的数组*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getLeastKNum</span> <span class="params">(<span class="type">int</span>* input, <span class="type">int</span> n, <span class="type">int</span>* output, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(input == <span class="literal">NULL</span> || output = NULLI || k &gt; n || k&lt;=<span class="number">0</span> || n&lt;=<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> end = n<span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> index = <span class="built_in">partition</span> (input, start, end) ;   <span class="comment">//一次划分函数见前面</span></span><br><span class="line">	<span class="keyword">while</span> (index != k<span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (index &gt; k<span class="number">-1</span>) &#123;   <span class="comment">// 左区间已包含超过k个数</span></span><br><span class="line">			end=index- <span class="number">1</span>;</span><br><span class="line">			index = <span class="built_in">Partition</span> (input, start , end);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			start = index+<span class="number">1</span>;</span><br><span class="line">			index = <span class="built_in">Partition</span> (input，start, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直到index == k-1 为止</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i &lt; k;++i)</span><br><span class="line">		output[i] = input[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意上述方法平均时间复杂度为O(n)。</p>
<h3 id="5-3-选择排序"><a href="#5-3-选择排序" class="headerlink" title="5.3 选择排序"></a>5.3 选择排序</h3><h4 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h4><p>从头至尾扫描序列，找出最小的一个元素和第一个元素交换，接着从剩下的元素中继续这种选择和交换方式，最终<br>得到一个有序序列。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220719102551096.png" style="zoom:15%;" />

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/selectionSort.gif" alt="动图演示"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(RecType R[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, min_index;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        min_index = i;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>; j&lt;n; j++)&#123;   <span class="comment">// 定位无序区最小元素</span></span><br><span class="line">            <span class="keyword">if</span>(R[j].key &lt; R[min_index].key)</span><br><span class="line">                min_index = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min_index != i)&#123;    <span class="comment">// 无序区第一个元素和无序区最小元素交换</span></span><br><span class="line">            tmp = R[i];</span><br><span class="line">            R[i] = R[min_index];</span><br><span class="line">            R[min_index] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>复杂度</strong>：</p>
<p>简单选择排序过程中，元素移动的操作次数很少，不会超过3(n-1)次（一次swap需要3次元素移动），最好的情况是移动0次，此时对应的表已经有序；但元素间比较的次数与序列的初始状态无关，始终是n(n-1)&#x2F;2次，所以<strong>时间复杂度始终是</strong>$O(n^2)$。<strong>空间复杂度</strong>：$O(1)$。</p>
</li>
<li><p><strong>稳定性</strong>：不稳定。</p>
</li>
<li><p>选择排序中，每一趟选择最小元素前移后，该元素都是处于其最终的位置上。</p>
</li>
</ul>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p><strong>Heapsort</strong> 是指利用堆这种数据结构所设计的一种排序算法。</p>
<p>堆积具有以下特点：</p>
<p>1）完全二叉树</p>
<p>2）子结点的键值或索引总是小于等于（或者大于等于）它的父节点。</p>
<p>在大根堆中，最大元素存放在根结点中，且对其任一非根结点，它的值小于等于其双亲结点值。小根堆的定义刚好相反，根结点是最小元素。</p>
<p>对于关键字序列$(R_1,R_2,…,R_n)$构建的完全二叉树，结点$R[i]$的左孩子为$R[2i]$，右孩子为$R[2i+1]$。由于一般待排序的数组<u>从0开始编号，所以改为结点$R[i]$的左孩子为$R[2i+1]$，右孩子为$R[2i+2]$。</u></p>
<p><strong>算法思想</strong>：</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Ur4y1w7tv?p=20&amp;vd_source=854e3e80724343215a332be36ec7cf83">https://www.bilibili.com/video/BV1Ur4y1w7tv?p=20&amp;vd_source=854e3e80724343215a332be36ec7cf83</a></p>
<ol>
<li>将初始待排序关键字序列$(R_0,R_1,…,R_{n-1})$构建成大顶堆，此堆为初始的无序区；</li>
<li>将堆顶元素R[0]与最后一个元素$R[n-1]$交换，此时得到新的无序区$(R_0,R_1,…,R_{n-2})$和新的有序区$(R_{n-1})$，且满足$R[1,2,…,n-2]&lt;&#x3D;R[n-1]$；</li>
<li>由于交换后新的堆顶$R[0]$可能违反堆的性质，因此需要对当前无序区调$(R_0,R_1,…,R_{n-2})$<strong>调整为新堆</strong>，然后再次将$R[0]$与无序区最后一个元素<strong>交换</strong>，得到新的无序区$(R_0,R_1,…,R_{n-3})$和新的有序区$(R_{n-2}, R_{n-1})$。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/heapSort.gif" alt="动图演示"></p>
<p>下面的代码已经调整为从R[0]开始存储元素，所以左右孩子结点分别为2i+1、2i+2。调整堆后根结点为R[0]。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调整根索引为start，最大结点索引不超过end的完全二叉树为大根堆，或者说从中筛选出最大值作为根结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AdjustDown</span><span class="params">(RecType R[], <span class="type">int</span> start, <span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> dad = start, son = <span class="number">2</span>*dad+<span class="number">1</span>;      <span class="comment">// R[son]定义为R[dad]的左孩子</span></span><br><span class="line">    RecType tmp;</span><br><span class="line">    <span class="comment">// 如果孩子结点的索引未超出范围，继续向下调整，循环继续</span></span><br><span class="line">    <span class="keyword">while</span> (son &lt;= end)&#123;</span><br><span class="line">        <span class="comment">// 比较两个孩子的关键字，选择最大的</span></span><br><span class="line">        <span class="keyword">if</span>(son+<span class="number">1</span>&lt;end &amp;&amp; R[son].key&lt;R[son+<span class="number">1</span>].key)</span><br><span class="line">            son++;</span><br><span class="line">        <span class="comment">// 若根结点的关键字大于孩子结点，表示调整完成，直接跳出函数</span></span><br><span class="line">        <span class="keyword">if</span>(R[dad].key &gt; R[son].key) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 若根结点的关键字小于孩子结点</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            tmp = R[dad];</span><br><span class="line">            R[dad] = R[son];     <span class="comment">// 孩子结点和根结点互换</span></span><br><span class="line">            R[son] = tmp;</span><br><span class="line">            dad = son;           <span class="comment">// 孩子结点作为下一循环的根结点，继续向下调整</span></span><br><span class="line">            son = <span class="number">2</span>*dad+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(RecType R[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    <span class="comment">// 大根堆的初始化：分支结点一共有n/2个，所以调用sift算法n/2次，从下往上（n/2-1到0）将所有以分支节点作为根的子树调整为大根堆</span></span><br><span class="line">    <span class="keyword">for</span>(i=n/<span class="number">2</span><span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">		<span class="built_in">AdjustDown</span>(R, i, n<span class="number">-1</span>);    <span class="comment">// 以i作为根结点，向下调整为大根堆</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将根结点（最大元素）与最右边叶子结点互换，然后不考虑换下的最大元素，继续调整堆为大根堆，循环n-1次</span></span><br><span class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>; i&gt;<span class="number">0</span>; i--)&#123;</span><br><span class="line">        tmp = R[<span class="number">0</span>];      <span class="comment">// 取出根结点R[0]（目前的最大元素），与叶子结点R[i]互换</span></span><br><span class="line">        R[<span class="number">0</span>] = R[i];</span><br><span class="line">        R[i] = tmp;</span><br><span class="line">        <span class="built_in">AdjustDown</span>(R, <span class="number">0</span>, i<span class="number">-1</span>)  <span class="comment">// 根结点被交换，需要调整新堆为大根堆，且不考虑结点R[i]，R[i]已经有序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大根堆的初始化如下图，对应上述代码中的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=n/<span class="number">2</span><span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">	<span class="built_in">AdjustDown</span>(R, i, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220719153149904.png" alt="image-20220719153149904"></p>
<ul>
<li><p><strong>复杂度</strong></p>
<p>大根堆的调整中，即调用sift函数，<strong>向下调整的时间</strong>与树高有关，为O(h)，<strong>即</strong> $O(log_2n)$。建堆过程中每次向下调整时，大部分结点的高度都较小。因此，可以证明在元素个数为n的序列上**建堆的时间复杂度为 O(n)**，这说明可以在线性时间内，将一个无序数组建成一个大顶堆。</p>
<p>在最好、最坏和平均情况下，堆排序的时间复杂度为$O(nlog_2n)$；空间复杂度为$O(1)$。</p>
</li>
<li><p><strong>稳定性</strong>：不稳定。</p>
</li>
<li><p>上述代码中的 <strong>AdjustDown函数</strong> 是<u>向下调整大根堆，适用于根结点被交换（删除），使堆的性质被破环的情况</u>。比如删除堆顶元素后，应该使用最后一个元素替换堆顶，然后比较堆顶和其左右孩子，交换，然后继续向下调整；而如果是作为叶子结点向堆中插入元素，那么就需要<u>向上调整堆，代码如下</u>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AdjustUp</span><span class="params">(RecType R[], <span class="type">int</span> k)</span></span>&#123;   <span class="comment">// n为所插入的结点索引，也为新堆的结点个数，结点索引从0开始编号</span></span><br><span class="line">    R[<span class="number">0</span>] = R[k];        <span class="comment">// 将R[k]暂存到根结点R[0]</span></span><br><span class="line">    <span class="type">int</span> i = (k<span class="number">-1</span>)/<span class="number">2</span>;    <span class="comment">// i始终指向k的父节点</span></span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span> &amp;&amp; R[i].key&lt;R[<span class="number">0</span>].key)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(R[k], R[i]);    <span class="comment">// 父节点下调</span></span><br><span class="line">        k = i;          <span class="comment">// 更新父节点为k，继续向上比较</span></span><br><span class="line">        i = (k<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    R[k] = R[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="堆排序的应用"><a href="#堆排序的应用" class="headerlink" title="堆排序的应用"></a>堆排序的应用</h4><blockquote>
<p>&#x3D;&#x3D;最小的k个数&#x3D;&#x3D;</p>
<p>输入n个整数，输出其中最小的k个。例如输入1, 2, 3, 4, 5, 6, 7和8这8个数字，则最小的4个数字为1, 2, 3和4。(2012. 网易)</p>
</blockquote>
<p>在讲快排的时候，已经提出了利用快排的一次划分来解此题，时间复杂度为O(n)。但此种方法也有其限制，首先我们需要一次性读入所有数据，其次，需要修改输入的数组。</p>
<p>其实此题也可以利用堆排序来解决，此种方法<strong>特别适合于处理海量数据</strong>。</p>
<p>首先我们读入k个数创建一个大小为 k 的大根堆，然后我们依次读入剩余数据，如果当前数据比大根堆的堆顶小，则用这个数替换当前堆顶，并调整堆使其保持大根堆的性质；如果当前数据比堆顶大，那么这个数不可能是最小的k个整数之一，故可以抛弃此数。**此种方法总的时间复杂度是O(nlogk)**。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[n];<span class="comment">// 数组a中存储输入的n个数</span></span><br><span class="line"><span class="type">int</span> R[k+<span class="number">1</span>];<span class="comment">//从a中依次读入k个数a[0]到a[k-1]，第一个数存在R[0]中，依此类推</span></span><br><span class="line"><span class="comment">// 初始化R为大根堆</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=k/<span class="number">2</span><span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">	<span class="built_in">AdjustDown</span>(R, i, k<span class="number">-1</span>);    <span class="comment">// 以i作为根结点，向下调整为大根堆</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=k; i&lt;=n<span class="number">-1</span>; i++) &#123;   <span class="comment">// 依次读入剩余数据</span></span><br><span class="line">	<span class="keyword">if</span>(a[i]&gt; R[<span class="number">0</span>]) <span class="keyword">continue</span>;  <span class="comment">// 大于堆顶，跳过</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		R[<span class="number">0</span>]=a[i];   <span class="comment">// 替换堆顶</span></span><br><span class="line">		<span class="built_in">AdjustDown</span>(R, <span class="number">0</span>, k<span class="number">-1</span>);   <span class="comment">// 调整大根堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当需要求最大的k个数时，只需将大根堆改为小根堆即可，原理相同。</p>
<h3 id="5-4-归并排序"><a href="#5-4-归并排序" class="headerlink" title="5.4 归并排序"></a>5.4 归并排序</h3><p>“归并”的含义是将两个或两个以上的有序表组合成一个新的有序表。</p>
<h4 id="二路归并排序"><a href="#二路归并排序" class="headerlink" title="二路归并排序"></a>二路归并排序</h4><p>参考：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Ur4y1w7tv?p=17">https://www.bilibili.com/video/BV1Ur4y1w7tv?p=17</a></p>
<p>假定待排序表含有n个元素，首先可以视为n个有序的子表，每个子表长度为1，然后<strong>两两归并</strong>，得到$\lceil n&#x2F;2 \rceil$个长度为2或1的有序表；再两两归并，如此重复，直到合并成一个长度为n的有序表为止，这种排序方法称为二路归并排序。如图15-4所示为二路归并排序的例子。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220719164616656.png" alt="image-20220719164616656"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/mergeSort.gif" alt="动图演示"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将有序的R[left…mid]和R[mid +1 …right]归并到辅助数组rf[left…right]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(ElemType R[], ElemType *rf, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> j, k;</span><br><span class="line">    <span class="keyword">for</span>(i=left, j=mid+<span class="number">1</span>, k=i; i&lt;=mid &amp;&amp; j &lt;=right; ++k)&#123;  <span class="comment">// i在前一段有序表扫描，j在另一段有序表扫描</span></span><br><span class="line">        <span class="comment">// 依次比较，将更小的数存入rf，存入后指针索引后移</span></span><br><span class="line">        <span class="keyword">if</span>(R[j] &lt; R[i]) rf[k] = r[j++];</span><br><span class="line">        <span class="keyword">else</span> rf[k] = r[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有一个有序表的指针索引到达末尾，将另一有序表的剩余元素全部存入rf即可</span></span><br><span class="line">    <span class="comment">// 两个while只会有一个执行</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid)  rf[k++] = r[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= right)  rf[k++] = r[j++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 递归写法（分治法） */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(ElemType R[], ElemType *rf, <span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">MergeSort</span>(R, rf, left, mid);</span><br><span class="line">        <span class="built_in">MergeSort</span>(R, rf, mid+<span class="number">1</span>, right);</span><br><span class="line">        <span class="built_in">Merge</span>(R, rf, left, mid, right);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 非递归写法 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(ElemType R[], ElemType *rf, <span class="type">int</span> n)</span></span>&#123;   <span class="comment">// n为待排序表R的长度</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">1</span>;</span><br><span class="line">    ElemType *q = R;</span><br><span class="line">    ElemType *tmp;</span><br><span class="line">    <span class="keyword">while</span>(len &lt; n) &#123;    <span class="comment">// 所归并的序列长度</span></span><br><span class="line">        <span class="type">int</span> s = len;</span><br><span class="line">        len = <span class="number">2</span> * s ;   <span class="comment">// 更新len为原来的2倍，因为是两两合并</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i+len &lt; n)&#123;  <span class="comment">// 要合并的两个序列末尾索引不超过n-1</span></span><br><span class="line">            <span class="built_in">Merge</span>(q, rf,  i, i+s<span class="number">-1</span>, i+len<span class="number">-1</span> ); <span class="comment">//对等长的两个子表合并</span></span><br><span class="line">            i = i+len;  <span class="comment">// 定位i到下一组要合并的序列</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i+s &lt; n)&#123;    <span class="comment">//最后一组不等长的两个子表合并</span></span><br><span class="line">            <span class="built_in">Merge</span>(q, rf,  i, i+s<span class="number">-1</span>, n<span class="number">-1</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一轮归并结束，R所有元素转移到rf，所以要交换q,rf，以保证下一趟归并时，仍从q归并到rf</span></span><br><span class="line">        tmp = q; </span><br><span class="line">        q = rf;</span><br><span class="line">        rf = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">2</span>，<span class="number">3</span>,<span class="number">4</span>，<span class="number">5</span>,<span class="number">15</span>,<span class="number">19</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">36</span>,<span class="number">38</span>,<span class="number">44</span>,<span class="number">46</span>,<span class="number">47</span>,<span class="number">48</span>,<span class="number">50</span>&#125;;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">MergeSort</span>(a, b, <span class="number">15</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>复杂度</strong>：</p>
<p>最坏情况下，合并两个大小为n的已排序数组所需要的比较次数为2n-1，所以每一趟归并的时间复杂度为$O(n)$，共需进行$\lceil log_2n \rceil$趟归并，所以算法的<strong>时间复杂度</strong>为$\lceil nlog_2n \rceil$。</p>
<p>Merge()操作中，由于辅助空间刚好要占用n个单元，但每一趟归并后这些空间就被释放了，所以归并排序的<strong>空间复杂度</strong>为$O(n)$。</p>
</li>
<li><p><strong>稳定性</strong>：由于Merge()操作不会改变相同元素的相对次序，所以二路归并排序算法是一个<strong>稳定</strong>的排序方法。</p>
</li>
<li><p><strong>原地归并排序</strong></p>
</li>
</ul>
<h4 id="多路归并排序"><a href="#多路归并排序" class="headerlink" title="多路归并排序"></a>多路归并排序</h4><p><strong>外部排序</strong>指的是大文件的排序，即待排序的记录存储在外部存储器上，待排序的文件无法一次装入内存，需要在内存和外部存储器之间进行多次数据交换，以达到排序整个文件的目的。</p>
<p><u>外部排序最常用的算法是<strong>多路归并排序</strong></u>，即将原文件分解成多个能够一次性装入内存的部分， 分别把每一部分调入内存完成排序。 然后，对已经排序的子文件进行归并排序。</p>
<p>从二路到多路（k路），增大k可以减少外存信息读写时间，但k个归并段中选取最小的记录需要比较k-1次，为了降低选出每个记录需要的比较次数k，引出了“败者树”的概念。</p>
<p><strong>败者树</strong> 是对树形选择排序的一种变形，可以视为一棵完全二叉树。每个叶结点存放各归并段在归并过程中当前参加比较的记录，内部结点用来记忆左右子树中的“失败者”，而让胜者往上继续进行比较，一直到根结点。如果比较两个数，大的为失败者、小的为胜利者，则根结点指向的数为最小数。</p>
<h3 id="5-5-计数排序"><a href="#5-5-计数排序" class="headerlink" title="5.5 计数排序"></a>5.5 计数排序</h3><p>计数排序统计小于等于该元素值的元素的个数i，于是该元素就放在目标数组的索引i位（i≥0）。</p>
<ul>
<li>计数排序基于一个假设，待排序数列的<strong>所有数均为整数</strong>，且出现在（0，k）的区间之内。</li>
<li>如果 k（待排数组的最大值） 过大则会引起较大的空间复杂度，<strong>不适合数范围大的情况</strong>，一般是用来排序 0 到 100 之间的数字的最好的算法（比如考试分数排名），但是它不适合按字母顺序排序人名。</li>
<li>计数排序不是比较排序，排序的速度快于任何比较排序算法。</li>
<li>计数排序是<strong>稳定</strong>的排序算法。</li>
</ul>
<p><strong>算法思想</strong>：</p>
<ol>
<li>找出待排序的数组中最大元素；</li>
<li>统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项；</li>
<li>向填充目标数组：将每个元素 i 填充进新数组，填充次数为 C[i] ；</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_gif/0m4YX595Fonjcg9PmOPc6g3VnEFMSU9hQNqdTja9dCGls0V9Ve7JolUmUxbVtHlrybsmNC84jWHHibL9kLicw8BQ/640?wx_fmt=gif&wxfrom=5&wx_lazy=1&retryload=1" alt="图片"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CountSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vecRaw, vector&lt;<span class="type">int</span>&gt;&amp; vecObj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 若待排序容器为空</span></span><br><span class="line">	<span class="keyword">if</span> (vecRaw.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">// 使用 vecRaw 的最大值 + 1 作为计数容器 countVec 的大小</span></span><br><span class="line">    <span class="comment">// max_element用于查询容器中最大值第一次出现的位置</span></span><br><span class="line">	<span class="type">int</span> vecCountLength = (*<span class="built_in">max_element</span>(<span class="built_in">begin</span>(vecRaw), <span class="built_in">end</span>(vecRaw))) + <span class="number">1</span>;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vecCount</span><span class="params">(vecCountLength, <span class="number">0</span>)</span></span>;  <span class="comment">// 用于记录所有元素的出现次数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 统计每个键值出现的次数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vecRaw.<span class="built_in">size</span>(); i++)</span><br><span class="line">		vecCount[vecRaw[i]]++;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 后面的键值出现的位置为前面所有键值出现的次数之和</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; vecCountLength; i++)</span><br><span class="line">		vecCount[i] += vecCount[i<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将键值放到目标位置</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = vecRaw.<span class="built_in">size</span>(); i &gt; <span class="number">0</span>; i--)	<span class="comment">// 此处逆序是为了保持相同键值的稳定性</span></span><br><span class="line">		vecObj[--vecCount[vecRaw[i<span class="number">-1</span>]]] = vecRaw[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vecRaw = &#123; <span class="number">0</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">1</span> &#125;;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vecObj</span><span class="params">(vecRaw.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">CountSort</span>(vecRaw, vecObj);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vecObj.<span class="built_in">size</span>(); ++i)</span><br><span class="line">		cout &lt;&lt; vecObj[i] &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>稳定性</strong>：稳定。</li>
<li><strong>缺点</strong>：空间浪费。其需要长度为最大值的计数空间，但是其间的很多数值可能并未出现。</li>
<li><strong>优化</strong>：使用长度为最大值-最小值+1的计数空间。</li>
</ul>
<h3 id="x3D-x3D-5-5-桶排序-x3D-x3D-（重要）"><a href="#x3D-x3D-5-5-桶排序-x3D-x3D-（重要）" class="headerlink" title="&#x3D;&#x3D;5.5 桶排序&#x3D;&#x3D;（重要）"></a>&#x3D;&#x3D;5.5 桶排序&#x3D;&#x3D;（重要）</h3><p>桶排序 (Bucket sort)是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Ur4y1w7tv">https://www.bilibili.com/video/BV1Ur4y1w7tv</a></p>
<p><strong>工作原理</strong>：</p>
<p>假设输入数据<strong>服从均匀分布</strong>，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。</p>
<ol>
<li>设置一个定量的数组当作空桶子。</li>
<li>寻访序列，并且把项目一个一个放到对应的桶子去（比如一位数放到一个桶、两位数放到一个桶、三位数放到一个桶）。</li>
<li>对每个不是空的桶子进行排序（递归或者使用其他排序算法）。</li>
<li>从不是空的桶子里把项目再放回原来的序列中，合并。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_gif/0m4YX595Fonjcg9PmOPc6g3VnEFMSU9hjl4T0fCvUq2zCdEcGqyH1ic9bDXVStxQXWcypoAs5VQ499ABm6dicYbA/640?wx_fmt=gif&wxfrom=5&wx_lazy=1" alt="图片"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BucketSort</span> <span class="keyword">implements</span> <span class="title class_">IArraySort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">InsertSort</span> <span class="variable">insertSort</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InsertSort</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] sourceArray) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 对 arr 进行拷贝，不改变参数内容</span></span><br><span class="line">        <span class="type">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line">        <span class="keyword">return</span> bucketSort(arr, <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] bucketSort(<span class="type">int</span>[] arr, <span class="type">int</span> bucketSize) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">minValue</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value &lt; minValue) &#123;</span><br><span class="line">                minValue = value;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; maxValue) &#123;</span><br><span class="line">                maxValue = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">bucketCount</span> <span class="operator">=</span> (<span class="type">int</span>) Math.floor((maxValue - minValue) / bucketSize) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[][] buckets = <span class="keyword">new</span> <span class="title class_">int</span>[bucketCount][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用映射函数将数据分配到各个桶中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (<span class="type">int</span>) Math.floor((arr[i] - minValue) / bucketSize);</span><br><span class="line">            buckets[index] = arrAppend(buckets[index], arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">arrIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] bucket : buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucket.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对每个桶进行排序，这里使用了插入排序</span></span><br><span class="line">            bucket = insertSort.sort(bucket);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> value : bucket) &#123;</span><br><span class="line">                arr[arrIndex++] = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自动扩容，并保存数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arrAppend(<span class="type">int</span>[] arr, <span class="type">int</span> value) &#123;</span><br><span class="line">        arr = Arrays.copyOf(arr, arr.length + <span class="number">1</span>);</span><br><span class="line">        arr[arr.length - <span class="number">1</span>] = value;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于桶中将要存放多少元素是不确定的，因此最好将桶定义为链表数据结构。</p>
<ul>
<li><strong>复杂度</strong></li>
</ul>
<p>桶排序的时间复杂度取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然,桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少，但相应的空间消耗就会增大。</p>
<h3 id="5-5-基数排序（重要）"><a href="#5-5-基数排序（重要）" class="headerlink" title="5.5 基数排序（重要）"></a>5.5 基数排序（重要）</h3><p>基数排序是桶排序的扩展，是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p>
<p><strong>算法描述</strong>：</p>
<ul>
<li>取得数组中的最大数，并取得位数；</li>
<li>arr为原始数组，从最低位开始取每个位组成radix数组；</li>
<li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li>
</ul>
<ol>
<li>按个位数分配桶：</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220719211404111.png" alt="image-20220719211404111" style="zoom: 67%;" />

<ol start="2">
<li>然后依次从桶中收集元素，同一桶中的元素，<strong>先进桶的在前</strong>，此序列的<strong>个位数是有序的</strong>：</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220719211636628.png" alt="image-20220719211636628" style="zoom: 67%;" />

<ol start="3">
<li>接着，按照第一次收集的序列顺序，再依次入桶，这次按十位数分配桶：</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220719211805074.png" alt="image-20220719211805074" style="zoom:67%;" />

<ol start="4">
<li>然后依次从桶中收集元素，同一桶中的元素，先进桶的在前，此序列的<strong>十位个位组成的数是有序的</strong>：</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220719211923655.png" alt="image-20220719211923655" style="zoom:67%;" />

<ol start="5">
<li>接着，按照第二次收集的序列顺序，再依次入桶，这次按百位数分配桶：</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220719212141666.png" alt="image-20220719212141666" style="zoom:67%;" />

<ol start="6">
<li>然后依次从桶中收集元素，同一桶中的元素，先进桶的在前，此序列的<strong>个十百位组成的数都是有序的</strong>：</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220719212223426.png" alt="image-20220719212223426" style="zoom:67%;" />

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">radix</span>(<span class="params">arr</span>):</span><br><span class="line">    </span><br><span class="line">    digit = <span class="number">0</span></span><br><span class="line">    max_digit = <span class="number">1</span></span><br><span class="line">    max_value = <span class="built_in">max</span>(arr)</span><br><span class="line">    <span class="comment">#找出列表中最大的位数</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">10</span>**max_digit &lt; max_value:</span><br><span class="line">        max_digit = max_digit + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> digit &lt; max_digit:</span><br><span class="line">        temp = [[] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">            <span class="comment">#求出每一个元素的个、十、百位的值</span></span><br><span class="line">            t = <span class="built_in">int</span>((i/<span class="number">10</span>**digit)%<span class="number">10</span>)</span><br><span class="line">            temp[t].append(i)</span><br><span class="line">        </span><br><span class="line">        coll = []</span><br><span class="line">        <span class="keyword">for</span> bucket <span class="keyword">in</span> temp:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> bucket:</span><br><span class="line">                coll.append(i)</span><br><span class="line">                </span><br><span class="line">        arr = coll</span><br><span class="line">        digit = digit + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>稳定性</strong>：稳定。</li>
</ul>
<h3 id="5-6-不同排序算法的比较"><a href="#5-6-不同排序算法的比较" class="headerlink" title="5.6 不同排序算法的比较"></a>5.6 不同排序算法的比较</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220719201134170.png" alt="image-20220719201134170"></p>
<ul>
<li><p><strong>稳定性</strong></p>
<p><u>所有简单排序</u>(时间复杂度为0(n)都是**<u>稳定排序</u><strong>，</strong>选择排序除外**；</p>
<p><u>所有时间复杂度为$O(nlog_2n)$的排序</u>都是<u><strong>不稳定排序</strong></u>，<strong>归并排序、基数排序除外</strong>。希尔排序是不稳定排序，基数排序是稳定排序。</p>
</li>
<li><p><strong>时间复杂度</strong>（比较次数）</p>
<p><u>比较次数<strong>与初始排列无关</strong>的是<strong>选择排序</strong></u>（简单选择排序、堆排序）。</p>
<p>在初始序列<u><strong>基本有序</strong> 的情况下</u>，<u><strong>最优的是插入排序</strong> </u>，此时插入排序时间复杂度为O(n)，其次是冒泡排序，时间复杂度也为O(n)， <strong>快速排序在此时性能最差</strong></u>，时间复杂度为$O(n^2)$。同时，快速排序在初始序列逆序的时候，性能也最差，此时时间复杂度也为$O(n^2)$。</p>
<p><u><strong>堆排序对初始数据集的排列顺序不敏感</strong></u>，在最好、最坏和平均情况下，堆排序的时间复杂度均为$O(nlog_2n)$。</p>
</li>
<li><p><strong>空间复杂度</strong></p>
<p>基于比较的排序算法中（插入排序、交换排序、选择排序、归并排序），归并排序的空间复杂度最高，为$O(n)$，其次为快速排序，为$O(logn)$，其余的为$O(1)$。</p>
</li>
</ul>
<h2 id="6-查找"><a href="#6-查找" class="headerlink" title="6 查找"></a>6 查找</h2><h3 id="6-1-基本概念"><a href="#6-1-基本概念" class="headerlink" title="6.1 基本概念"></a>6.1 基本概念</h3><p>查找结构（查找表）：用于查找的数据集合称为查找结构（查找表），它可以是一个链表，也可以是一个数组或其他数据类型。对于查找表经常进行的操作一般有四种：</p>
<ol>
<li><strong>查询</strong> 某个特定的数据元素是否在查找表中；</li>
<li><strong>检索</strong> 满足条件的某个特定的数据元素的各种<strong>属性</strong>；</li>
<li>在查找表中 <strong>插入</strong> 一个数据元素；</li>
<li>从查找表中 <strong>删除</strong> 某个数据元素。</li>
</ol>
<p>如果一个查找表的操作只涉及1和2的操作，则无须动态地修改查找表，此类查找表称为静态查找表。与此对应，需要动态地修改的查找表则称为动态查找表。</p>
<p>适合静态查找表的查找方法有：顺序查找、折半查找、散列查找等；适合动态查找表的查找方法有二叉排序树的查找、散列查找等。</p>
<p>平均查找长度：在查找的过程中，一次查找的长度是指需要比较的关键码次数，而平均查找长度则是所有查找过程中进行的关键码比较次数的平均值，其定义如下：<br>$$<br>ASL&#x3D;\sum_{i&#x3D;1}^np_ic_i<br>$$<br>式中，$p_i$为查找第i个元素的概率，一般认为每个元素的查找概率相等；$c_i$为找到第i个元素所需的比较次数。平均查找次数ASL是衡量查找算法效率的最主要指标。</p>
<blockquote>
<p>例1：查找一个整数数组中第二大的数。（2012，迅雷）</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> minNum = <span class="number">-32767</span>;     <span class="comment">// int型最小值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_sec_max</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> count)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> maxnumber=data[<span class="number">0</span>];</span><br><span class="line">	<span class="type">int</span> sec_max = minNum;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(data[i] &gt; maxnumber) &#123;</span><br><span class="line">            sec_max = maxnumber;   <span class="comment">// 原来的最大值变成第二大</span></span><br><span class="line">            maxnumber = data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[i] &gt; sec_max)</span><br><span class="line">                sec_max = data[i];  <span class="comment">// 原来的第二大值被换下</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> sec_max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-折半查找"><a href="#6-2-折半查找" class="headerlink" title="6.2 折半查找"></a>6.2 折半查找</h3><p>折半查找又称为 <strong>二分查找</strong>，<u>仅适用于事先已经排好序的顺序表</u>。</p>
<p><strong>基本思路</strong></p>
<p>首先将给定值K与表中中间位置元素的关键字比较，若相等，则查找成功，返回该元素的存储位置；若不等，则所需查找的元素只能在中间数据以外的前半部分或后半部分中。然后在缩小的范围中继续进行同样的查找，如此重复直到找到为止。算法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BinSearch</span> <span class="params">(RecType R[], <span class="type">int</span> n, KeyType k)</span> </span>&#123;</span><br><span class="line"><span class="comment">//在有序表R中查找关键字为key的元素，若存在则返回其位置，不存在则返回-1</span></span><br><span class="line">    <span class="type">int</span> low=<span class="number">0</span>, high=n<span class="number">-1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;     <span class="comment">// 有序表存在元素时循环</span></span><br><span class="line">    	mid= (low+high)/<span class="number">2</span>;</span><br><span class="line">    	<span class="comment">//取中间位置</span></span><br><span class="line">    	<span class="keyword">if</span> (R[mid].key == k)  <span class="comment">// 查找成功，返回其逻辑序号mid+1</span></span><br><span class="line">    		<span class="keyword">return</span> mid+<span class="number">1</span>;</span><br><span class="line">   		<span class="keyword">if</span> (R[mid].key &gt; k)   <span class="comment">// 在前半部分继续查找</span></span><br><span class="line">    		high = mid<span class="number">-1</span>;</span><br><span class="line">    	<span class="keyword">else</span></span><br><span class="line">            low = mid+<span class="number">1</span> ;       <span class="comment">// 在后半部分继续查找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为折半查找需要方便地定位查找区域，所以适合折半查找的存储结构必须具有随机存取的特性。因此，<u>二分查找法仅适合于线性表</u>的顺序存储结构，不适合链式存储结构，<u>且要求元素按关键字有序排列</u>。</p>
<blockquote>
<p>例1：有一个循环有序数组A，如{7, 8, 9, 0, 1, 2, 3, 4, 5, 6}，不知道其最小值的位置。那么如何从这样的数组中寻找一个特定的元素呢? （2012，百度，2012，人民搜索）</p>
</blockquote>
<p>解答：可以将这个循环有序数组看作两个有序子数组，前一个子数组的元素均大于后一个数组。在二分查找的过程中，增加一个判断，确定中间元素位于哪一个子数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">lower为数组首元素下标</span></span><br><span class="line"><span class="comment">high为数组最后的元素下标，但由于是循环有序，所以R[high]并不是最大值</span></span><br><span class="line"><span class="comment">k为要查找的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">int</span> R[], <span class="type">int</span> lower, <span class="type">int</span> high, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (lower &lt;= high) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (lower+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (R[mid] == k)    <span class="comment">// 查找成功，返回其逻辑序号mid+1</span></span><br><span class="line">            <span class="keyword">return</span> mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// lower到mid是有序的，mid到high跨了两个子数组</span></span><br><span class="line">            <span class="keyword">if</span> (R[lower] &lt;= R[mid])&#123;   </span><br><span class="line">            	<span class="keyword">if</span>(k &gt; R[mid])         <span class="comment">// k大于mid</span></span><br><span class="line">                    lower = m+<span class="number">1</span>;</span><br><span class="line">            	<span class="keyword">else</span> <span class="keyword">if</span> (k &gt;= R[lower]) high = mid<span class="number">-1</span>;  <span class="comment">// k在lower和mid之间</span></span><br><span class="line">            	<span class="keyword">else</span> lower = mid+<span class="number">1</span>;    <span class="comment">// k 比 lower 和 mid 均要小，所查找元素在mid之后</span></span><br><span class="line">            &#125;</span><br><span class="line">        	<span class="comment">// lower到mid跨了两个子数组，mid到high是有序的</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; R[mid]) high = mid<span class="number">-1</span>;      <span class="comment">// k在lower和mid之间</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (k &lt;= R[high]) lower = mid+<span class="number">1</span>;   <span class="comment">// k在mid+1和high之间</span></span><br><span class="line">            <span class="keyword">else</span> high = mid<span class="number">-1</span>; <span class="comment">// k 比 mid 和 high 均要大，所查找元素在mid之前</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述算法对数组元素重复的时候不支持，比如{2, 2, 3, 2, 2}，此时只能依次遍历。</p>
<p><strong>判定树</strong></p>
<p>折半查找的过程可用图16-1所示的二叉树来描述，称为 <strong>判定树</strong>。树中每个圆形结点表示一个记录，结点中的值为该记录的关键字值；树中最下面的叶结点都是方形的，它表示查找不成功的情况。从判定树可以看出，查找成功时的查找长度为从根结点到目的结点的路径上的结点数，而查找不成功时的查找长度为从根结点到对应失败结点的父结点路径上的结点数；每个结点值（mid）均大于其左子结点值（low），且均小于其右子结点值（high）。若有序序列有n个元素，则对应的判定树有n个圆形的非叶结点和n+1个方形的叶结点。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220721110749501.png" alt="image-20220721110749501"></p>
<p>图16-1中，n个圆形结点（代表有序序列有n个元素）构成的树的深度与n个结点的<u>完全二叉树</u>的深度(高度)相等，均为$\lfloor log_2N \rfloor +1$ 或者 $\lceil log_2(N+1) \rceil \space$。</p>
<p><strong>折半查找的时间复杂度为$O(log_2N)$ ，最坏的情况下查找次数也不会超过为$\lfloor log_2N \rfloor +1$ ，不管有没有查找成功。</strong>比顺序查找的效率高。</p>
<p>在图16-1所示的判定树中，在等概率的情况下，查找成功的ASL&#x3D;(1x1+2x2+3x4+4x4)&#x2F;11&#x3D;3（每个结点的深度为其查找长度，深度为1的结点有1个，深度为2的结点有2个，深度为3的结点有4个，深度为4的结点有4个），查找不成功的ASL&#x3D;(3x4+4x8)&#x2F;12&#x3D;11&#x2F;3。</p>
<p>由上述的分析可知，用折半查找法查找到给定值或查找失败的比较次数最多不会超过树的高度，如在图16-1中，查找成功与查找不成功，最坏的情况下，都需要比较4次（$\lfloor log_2N \rfloor +1$ ，即树高）。</p>
<blockquote>
<p>例5：有一类数组，例如{1,2, 3, 4, 6, 8, 9, 4, 8, 11, 18, 19, 100}，前半部分是一个递增数组，后半部分还是递增数组，但整个数组不是递增数组，怎么最快地找出其中一个数(有大量查询待进行) ?(2011●百度)</p>
</blockquote>
<p>解答：开始时找出两个数组的分界线，有两个，一个是前一个数组的最末元素，另一个是后一个数组的最初元素，分别设为preMax和aftMin。</p>
<p>然后处理每个查询，查询过程为:</p>
<ol>
<li>分析要查找的数，若此数刚好等于preMax或aftMin，则返回相应位置;</li>
<li>否则，若此数小于preMax，则在前一个数组二分查找；</li>
<li>若此数大于aftMin，则也在后一个数组二分查找；</li>
<li>若此数大于preMax且小于aftMin，则不存在。</li>
</ol>
<h3 id="6-3-键树"><a href="#6-3-键树" class="headerlink" title="6.3 键树"></a>6.3 键树</h3><h4 id="键树的定义与Trie树"><a href="#键树的定义与Trie树" class="headerlink" title="键树的定义与Trie树"></a>键树的定义与Trie树</h4><p>键树又称为数字查找树（Digital Search Trees）。</p>
<p>键树其结构受启发于一部大型字典的“书边标目”。字典中标出首字母是A, B, C, …, Z的单词所在页，再对各部分标出第二字母为A, B, C, …, Z的单词所在的页等。</p>
<p>它是一棵度大于等于2的树，树中的<u>每个结点</u>中不是包含一个或几个关键字， 而是<u>只含有组成关键字的符号</u>。例如，若关键字是数值，则结点中只包含一个数位：若关键字是单词，则结点中只包含一个字母字符。</p>
<p>假设有如下16个关键字的集合：{CAI、CAO、LI、LAN、CHA、CHANG、WEN、CHAO、YUN、YANG、LONG、WANG、ZHAO、LIU、WU、CHEN}。可对此集合作如下的逐层分割，首先按首字母分成不同子集，然后再在子集中按第二个字符进行分割….直到每个小子集中只包含一个关键字为止。如图16-2所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220721153302732.png" alt="image-20220721153302732"></p>
<p><u>从根到叶子结点路径中结点的字符组成的字符串表示一个关键字</u>， <u>叶子结点中的特殊符号S表示字符串的结束</u>。</p>
<p>键树的存储通常有两种方式：</p>
<ul>
<li><p><strong>用树的孩子兄弟链表来表示键树（称为双链树）</strong></p>
<p>每个Node有三个域：</p>
<p>symbol域：存储关键字的一个字符；</p>
<p>son域：存储指向第一棵子树的根的指针；</p>
<p>brother域：存储指向右兄弟的指针。</p>
<p>这时的键树又称为双链树。图16-2所示键树的双链树如图16-3所示。</p>
<p>查找过程是，从根结点出发，顺着son查找，如果相等，继续下一个son。否则沿着brother查找。直到到了空指针为止。此时若仍未完成key的匹配，查找不成功。</p>
<p>在双链树中插入或删除一个关键字，相当于在树中某个结点上插入或删除一棵子树。</p>
</li>
<li><p><strong>用多重链表表示（又称为Trie树，字典树）</strong></p>
<p>如果以树的多重链表表示键树，则树的每个结点中应包含d个（d 为关键字符的基，如：字符集由英文大写字母构成时，则d&#x3D;26）指针域，此时的键树又称为Trie树。</p>
<p>Trie树的思想是<u>利用字符串的公共前缀来降低时空开销</u>。</p>
<p>由hello、her、hi、how、see、so组成的Trie树如下：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220721160707317.png" alt="image-20220721160707317" style="zoom:67%;" />



<p>Trie树的典型应用是用于统计和排序大量的字符串（但不仅限于字符串），<strong>比较适合的是查找前缀匹配的字符串</strong>，所以<u>经常被搜索引擎系统用于文本词频统计</u>。</p>
<p>Trie树的优点是最大限度地减少无谓的字符串比较。</p>
<p>Trie树的缺点是如果存在大量字符串且这些字符串基本没有公共前缀，则相应的Trie树将非常消耗内存。</p>
<p>**构建Trie树时间复杂度是 O(n)*<em>（n是Trie树中所有元素的个数，即单词的个数</em>单词的平均长度）</p>
<p>**查询Trie树时间复杂度是 O(k)**（k 表示要查找的字符串的长度，即单词的平均长度）</p>
</li>
</ul>
<blockquote>
<p>例1：已知n个由小写字母构成的平均长度为10的单词，判断其中是否存在某个串为另一个串的前缀子串。</p>
</blockquote>
<p>解答：使用Trie树。假设要查询的单词是abc，显然以b, c, d…等不是以a开头的字符串就不用查找了。首先建立一棵Trie树，然后将每个单词插入Trie树，时间复杂度为O(n*len)，其中len为单词的平均长度10，然后依次查询每个单词，每个单词查询的时间复杂度为单词的长度。查询时看是否存在有单词与已有单词结点重合即可。</p>
<blockquote>
<p>例2：给定一个单词 a，如果通过交换单词中字母的顺序可以得到另外的单词b，那么定义b是a的兄弟单词，例如单词army和mary互为兄弟单词。现在给定一个字典，用户输入一个单词，如何根据字典找出这个单词有哪些兄弟单词?要求时间和空间效率尽可能高。(2012. 百度)</p>
</blockquote>
<p>解法一：使用hash_map和链表。</p>
<p>首先使兄弟单词具有相同的id，比如army和mary具有相同的id为amry（相当于对单词的字母进行排序）。然后使用hash_map，生成id到链表的映射，链表用来存储id所对应所有兄弟单词。开始时，先遍历字典，将每个单词按照其id加入hash_map对应的链表中去。当需要查找某一单词的兄弟单词时，只需计算其id，然后根据hash_map找到id所对应的链表，这样就可以确定其兄弟单词。其中，创建hash_map的时间复杂度为$O(n)$，查找兄弟单词的时间复杂度为$O(1)$。</p>
<p>解法二：也是使用hash_map和链表。（此方法无需对单词的字母进行排序来生成id）</p>
<p>将每个字母对应一个 <strong>质数</strong>，这样单词就可以对应为其字母的质数之积。将得到的值进行hash，这样兄弟单词就具有相同的hash值。将hash值与其对应的所有兄弟单词组成的链表进行hash_map映射，key单词的乘积，value为链表起始地址。当需要查找某一单词的兄弟单词时，只需计算其单词乘积，然后查找hash_map，遍历链表就能得到所有兄弟单词。其中，创建hash_map的时间复杂度为$O(n)$，查找兄弟单词的时间复杂度为$O(1)$。</p>
<p>解法三：利用Trie树。</p>
<p>单词插入Trie树之前，先按照字母排序，如army与mary排完序都是amry。然后将amry插入Trie树，在Trie树的结点中增加一个vector，记录所有的兄弟单词。这样查询的时候，只需先将查询词排序，然后把排序后的单词拿去查询，当所有字母都遍历后，读出对应结点的vector，里面存储的即是此单词的所有兄弟单词。</p>
<h4 id="键树的两种实现的对比"><a href="#键树的两种实现的对比" class="headerlink" title="键树的两种实现的对比"></a>键树的两种实现的对比</h4><p>双链树和Trie树是键树的两种不同表示方法，它们有各自的特点。</p>
<p>从其不同的存储结构特性可见，若键树中<strong>结点的度较大，则采用Trie树结构较双链树更为合适</strong>。</p>
<p>综上，键树的查找过程都是从根结点出发，走了一条从根到叶子( 或非终端结点)的路径，其<strong>查找时间依赖于单词的长度。</strong></p>
<h3 id="6-4-后缀树与后缀数组"><a href="#6-4-后缀树与后缀数组" class="headerlink" title="6.4 后缀树与后缀数组"></a>6.4 后缀树与后缀数组</h3><h4 id="后缀树"><a href="#后缀树" class="headerlink" title="后缀树"></a>后缀树</h4><p>键树只适合前缀匹配和全字匹配，而后缀树（Sufix Tree）适合后缀和子串匹配。它与键树的最大不同在于，后缀树的单词集合是由指定字符串的后缀子串构成的。</p>
<p>比如字符串“minimize” 的后缀子串分别如下：minimize, inimize, nimize, imize, mize, ize, ze， e<br>然后对这些子串的集合建立一棵键树， 即为“minimize”的后缀树。若字符串s为BIBS，则其建<br>立的后缀树如图16-4所示。含有所有的后缀子串BIBS、IBS、BS、S。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220721163309954.png" alt="image-20220721163309954"></p>
<p>后缀树常用于在串s中查询子串P是否存在。</p>
<p>**查询效率为O(n)**，n为单词长度。</p>
<p>后缀树还可以用来找出字符串S的最长重复子串S1、找出字符串S1和S2的最长公共子串、找出字符串s的最长回文子串S1等。</p>
<h4 id="后缀数组"><a href="#后缀数组" class="headerlink" title="后缀数组"></a>后缀数组</h4><p>后缀树实现较为复杂，通常可以用其变形后缀数组代替，使用数组来存储所有的后缀子串。</p>
<p>比如，若输入字符串为”banana”，该数组将表示这些后缀:</p>
<p>a[0]：banana			a[1]：anana			a[2]：nana			a[3]：ana			a[4]：na			a[5]：a</p>
<p>可见，由于数组a中的指针分别指向字符串中的每个后缀，所以将数组a命名为”后缀数组”。</p>
<blockquote>
<p>找出字符串S的最长重复子串S1，比如abcdabcd的最长重复子串是abcd，abcdabcda的最长重复子串是abcda，最长重复子串可以重叠。</p>
</blockquote>
<p>解法一：直接遍历。时间复杂度为$O(n^3)$。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">comlen</span><span class="params">(<span class="type">char</span> *p, <span class="type">char</span> *q)</span> </span>&#123;   <span class="comment">// 返回p、q数组的最大公共长度</span></span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(*p &amp;&amp; (*p++ = *q++)) ++i;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 逐个遍历所有的子串</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span> ;i&lt;n;++i) &#123;</span><br><span class="line">	<span class="keyword">for</span>(j=i+<span class="number">1</span> ;j&lt;n;++j)&#123;</span><br><span class="line">		<span class="keyword">if</span> ((thislen = <span class="built_in">comlen</span>(&amp;c[i]，&amp;c[j])) &gt; maxlen) &#123;</span><br><span class="line">			maxlen = thislen;</span><br><span class="line">			maxi = i; </span><br><span class="line">			maxj = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解法二：使用后缀数组</p>
<p>生成后缀数组，然后对后缀数组进行快速排序，将后缀相近的子串集中在一一起。比如输入字符串为”banana”，则排序后的后缀数组如下:</p>
<p>a[0]：a			a[1]：ana			a[2]：anana			a[3]：banana			a[4]：na			a[5]：nana</p>
<p>然后通过比较邻接元素，找出最长的重复字符串。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXCHAR 5000 <span class="comment">//最长处理5000个字符</span></span></span><br><span class="line"><span class="type">char</span> C[MAXCHAR], *a [MAXCHAR];     <span class="comment">// c存储字符串，a为指针数组，存储c的所有后缀子串</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">comlen</span><span class="params">(<span class="type">char</span> *p, <span class="type">char</span> *q)</span> </span>&#123;   <span class="comment">// 返回起始地址为p、q的数组的最大公共长度</span></span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(*p &amp;&amp; (*p++ = *q++)) ++i;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pstrcmp</span> <span class="params">(<span class="type">const</span> <span class="type">void</span> *p1, <span class="type">const</span> <span class="type">void</span> *p2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strcmp</span> (*(<span class="type">char</span>**)p1, *(<span class="type">char</span>**)p2);  <span class="comment">// 应用于库函数快排qsort的比较函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>, i, temp, maxlen=<span class="number">0</span>, maxi=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;Please input your string:\n&quot;</span>);</span><br><span class="line">    n=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>( (ch=<span class="built_in">getchar</span>())!=<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">    	a[n] = &amp;c[n];</span><br><span class="line">    	C[n++]=ch;</span><br><span class="line">    &#125;</span><br><span class="line">    c[n]=<span class="string">&#x27;\0&#x27;</span>;    <span class="comment">//将数组c中的最后一个元素设为空字符，以终止所有字符串</span></span><br><span class="line">    <span class="built_in">qsort</span>(a, n, <span class="built_in">sizeof</span>(<span class="type">char</span>*), pstrcmp);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; n<span class="number">-1</span>; ++i) &#123;</span><br><span class="line">    	temp = <span class="built_in">comlen</span>(a[i], a[i+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (temp &gt; maxlen) &#123;</span><br><span class="line">            maxlen = temp;</span><br><span class="line">            maxi = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.*s\n&quot;</span>, maxlen, a [maxi]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度分析：处理过程为先对一个字符串生成相应的后缀数组，然后再排序，排完序依次检测相邻的两个字符串的开头公共部分，其中生成后缀数组时间复杂度为$O(n)$，排序时间复杂度为$O(nlogn<em>n)$，依次检测相邻的两个字符串时间复杂度为$O(n^2)$，故总的时间复杂度是$O(n^2</em>logn)$，优于第一种方法的$O(n)$。</p>
<h3 id="6-5-哈希表-重点"><a href="#6-5-哈希表-重点" class="headerlink" title="6.5 哈希表(重点)"></a>6.5 哈希表(重点)</h3><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><p>哈希表，也叫散列表，它是基于快速存取的角度设计的，是一种典型的“空间换时间”的做法。哈希表是普通数组的一种推广，因为数组可以直接寻址，故可在$O(1)$时间内访问数组的任意元素。</p>
<p>哈希表是根据关键字(Key value)而直接进行访问的数据结构。它将关键字通过某种规则映射到数组中某个位置，以加快查找的速度。这个映射规则称为<strong>哈希函数</strong>（散列函数），<u>存放记录的数组称为 <strong>哈希表</strong></u>。哈希表建立了关键字和存储地址之间的一种直接映射关系。</p>
<p>若多个不同的关键字通过哈希函数计算得到相同的数组下标，称其发生了 <strong>冲突（碰撞）</strong>，这些发生冲突的不同关键字称为 <strong>同义词</strong>。一方面，设计好的Hash函数应尽量减少这样的冲突；另一方面，由于这样的冲突总是不可避免的，所以还要设计好处理冲突的方法。</p>
<h4 id="hash函数"><a href="#hash函数" class="headerlink" title="hash函数"></a>hash函数</h4><p>如果两个散列值是不相同的(根据同一函数)，那么这两个散列值的原始输入也是不相同的。这个特性使散列函数具有确定性的结果，具有这种性质的散列函数称为 <strong>单向散列函数</strong>。</p>
<p>典型的散列函数都有<strong>无限定义域</strong>，比如任意长度的字节字符串，和<strong>有限的值域</strong>，比如固定长度的比特串。</p>
<p>典型的哈希算法包括MD4、MD5和SHA-1，MD5和SHA-1 (安全哈希算法)可以说是目前应用最广泛的Hash算法，而它们都是以MD4为基础设计的。</p>
<ul>
<li><p><strong>MD4</strong></p>
<p>MD是Message Digest的缩写。MD4的摘要长度为<strong>128位</strong>比特，可以用来表示32位的十六进制数字，适用于32位字长的处理器。</p>
</li>
<li><p><strong>MD5</strong></p>
<p>MD5是一种面向工业标准的hash方案，摘要长度为<strong>128位</strong>比特。MD5比MD4要复杂，所以速度也更慢一些，但是更安全，在抗分析和抗差分方面表现更好。</p>
</li>
<li><p><strong>SHA-1</strong></p>
<p>SHA-1是由美国国家安全局(NSA)设计，美国国家标准与技术研究院(NIST)发布的密码散列函数，SHA-1会从一个最大$2^{64}$位元的信息中产生一串<strong>160位</strong>元的摘要，SHA-1设计时基于和MD4相同原理，并且模仿了该算法。</p>
</li>
</ul>
<p>hash函数的应用包括：文件校验、数字签名、鉴权协议。<u>hash函数不能用来加密</u>。</p>
<h4 id="处理冲突（碰撞）的方法"><a href="#处理冲突（碰撞）的方法" class="headerlink" title="处理冲突（碰撞）的方法"></a>处理冲突（碰撞）的方法</h4><p>任何哈希函数都不可能绝对地避免冲突，为此必须考虑冲突发生时应如何进行处理，即为产生冲突的关键字寻找下一个“空”的Hash地址，于是提出了处理冲突的各种方法。</p>
<ul>
<li><p><strong>链地址法</strong>（hash值对应一个链表，存放多个记录）</p>
<p>链地址法是指把所有的冲突关键字（同义词）存储在一个线性链表中，这个链表由其散列地址唯一标识。</p>
</li>
<li><p><strong>开放定址法</strong>（在冲突hash值基础上增量）</p>
<p>开放定址法是指可存放新表项的空闲地址，既向它的同义词表项开放，又向它的非同义词表项开放。一个地址往后的空间按照增量大小依次存放多个hash值。其数学递推公式为（$H_i$表示冲突发生后第$i$次探测的散列地址）：<br>$$<br>H_i&#x3D;(H(key)+d_i)%m<br>$$<br>式中，$i&#x3D;1, 2, …, k (k&lt;&#x3D;m-1)$，m为散列表表长，$d_i$为增量序列，$d_i$通常有以下几种取法：</p>
<p>当$d&#x3D;1, 2, …, m-1$时，称为<strong>线性探测法</strong>。其特点是，冲突发生时顺序查看表中下一个单元，直到找出一个空单元或查遍全表。</p>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220721202104217.png" alt="image-20220721202104217"></p>
</blockquote>
<p>当$d&#x3D;1^2, -1^2, 2^2, -2^2,…,k^2, -k^2$时，其中k&lt;&#x3D;m&#x2F;2，又为<strong>二次探测法</strong>。</p>
<p>当$d_i$&#x3D;伪随机数序列时，称为<strong>伪随机探测法</strong>。</p>
<p>在开放定址的情形下，不能随便删除表中已有元素，因为若删除元素将会截断其他具有相同散列地址的元素的查找地址。所以若想删除一个元素时， 给它做一 个删除标记，进行逻辑删除。但这样做的副作用是，在执行多次删除后，表面上看起来散列表很满，实际上只是逻辑删除，物理上有许多位置没有利用，因此需要定期维护散列表，要把做删除标记的元素物理删除。</p>
</li>
<li><p><strong>再散列法</strong></p>
<p>当发生冲突时，利用另一个哈希函数再次计算一个地址，直到冲突不再发生，这种方法称为再哈希法。</p>
</li>
<li><p><strong>建立一个公共溢出区</strong></p>
<p>一旦由哈希函数得到的地址冲突，就都填入溢出表。</p>
</li>
</ul>
<p>进行hash表的查找时，计算查找成功的平均查找长度ASL时，平均的概念是对表中当前非空元素而言的，并非是整<br>个表长。计算查找失败的平均查找长度ASL时，平均的概念是针对表长。</p>
<h3 id="6-6-一致性哈希"><a href="#6-6-一致性哈希" class="headerlink" title="6.6 一致性哈希"></a>6.6 一致性哈希</h3><p>如何快速定位数据在集群中的存储位置，关系到集群的性能。</p>
<h4 id="普通集群"><a href="#普通集群" class="headerlink" title="普通集群"></a>普通集群</h4><p>普通集群把固定的key映射到固定的结点上，结点只存放各自key的数据，如图16-5所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220721202502130.png" alt="image-20220721202502130"></p>
<p>此种方法将key和结点的关系作为一张单独的表格进行维护，当其中一个结点宕机， 结点上的数据需要迁移，此表格也要重新维护。此种方法的问题是，<u>当需要查找某个key值对应的数据时，必须遍历所有表格</u>，直到寻找到存放<br>此key值的结点，然后再去对应结点读取数据，可见<strong>查找速度慢</strong>。</p>
<h4 id="hash集群"><a href="#hash集群" class="headerlink" title="hash集群"></a>hash集群</h4><p>为了不想维护上节所述的表格，降低复杂性和其他开销，容易想到对数据的key（假设key为整型，如果不是整型，可通过一个哈希函数映射为一个整型）进行哈希（对结点数取模）。</p>
<p>比如我们原本有四个结点，如图16-6所示。图16-6中，nodeA、 node B等为服务器（结点），key1、key2等为数据的key。可见<u>寻找数据时，只需将key值对结点数取模，然后再去访问对应结点即可</u>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220721202909733.png" alt="image-20220721202909733"></p>
<p>此种方法的不足是：假如某个时候其中一个<u>结点宕机</u>了，那这个结点的数据就完全不可用了。如要进行数据迁移的话，因为这时候结点少了，变为3，对key重新模3的话，只能整个集群的数据都<u>重新映射</u>一遍才能达到效果。</p>
<h4 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h4><p>一致性哈希是一种哈希算法，在移除或添加一个结点时，它能够尽可能小地改变已存在key的映射关系。</p>
<p>一致性哈希将整个哈希值空间组织成一个虚拟的圆环，现假设某哈希函数Hash的值空间为0~$2^{32}$-1（即哈希值是一一个32位无符号整型），那么整个哈希空间环如图16-7所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220721204212645.png" alt="image-20220721204212645"></p>
<p><strong>基本思想</strong>：使用相同的哈希算法（即假设的哈希函数Hash）将数据和结点都映射到上图的环形哈希空间中。</p>
<ul>
<li><p><strong>把数据映射到Hash空间</strong></p>
<p>假设有4个数据object1~object4，那么通过哈希函数计算出的哈希值key在环上的分布如图16-8所示。</p>
</li>
<li><p><strong>把结点映射到哈希空间</strong></p>
<p>具体可以选择结点服务器的IP或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置。</p>
<p>假设当前有A, B和C共3台服务器(结点)，那么其映射结果将如图16-9所示，它们在哈希空间中以对应的哈希值排列。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220721204542741.png" alt="image-20220721204542741"></p>
</li>
<li><p><strong>把数据映射到结点</strong></p>
<p>现在结点和数据都已经通过同一个哈希算法Hash映射到哈希数值空间中了，接下来要考虑的就是如何将数据映射到结点上（确定了映射关系，也就确定了存储关系）。<u>在这个环形空间中，如果沿着顺时针方向（当然也可以约定为逆时针）从数据的key值出发，直到遇见一个结点机器，那么就将该数据存储在这个结点上</u>，因为数据和结点的哈希值是固定的，因此这个结点必然是唯一和确定的。这样就确定了一种数据和结点的一对一映射方法。如图16-10所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220721205008404.png" alt="image-20220721205008404"></p>
</li>
<li><p><strong>移除结点</strong></p>
<p>考虑假如node B出现问题，根据上面讲到的映射方法，这时受影响的将仅是那些沿node B逆时针遍历直到下一个node (本例为nodeA)之间的数据，即本来映射到node B上的那些数据。</p>
<p>因此这里仅需要变动数据object4，将其重新映射到nodeC上即可，如图16-11所示。</p>
</li>
<li><p><strong>添加结点</strong></p>
<p>考虑已有nodeA、B、C的情况下，再添加一台新的node D的情况。假设在这个环形哈希空间中，node D被映射在数据object2和object3之间。这时受影响的将仅是那些沿node D逆时针遍历直到下一个node (本例是node B)之间的数据(它们本来是映射到node C)，将这些数据重新映射到node D上即可。因此这里仅需要变动数据object2,将其重新映射到nodeD上，如图16-12所示。</p>
</li>
<li><p><strong>虚拟结点</strong></p>
<p>在上面的例子中，假设仅部署node A和nodeC，那么在4个数据中，node A仅存储了object1，而node C则存储了objec2、object3 和object4，可见<u>分布是很不平衡的</u>。为了解决这种情况，一致性哈希引入了 “虚拟结点”的概念。</p>
<p>“虚拟结点”(Virtual Node)是实际结点在哈希空间的复制品，一个实际结点对应了若干“虚拟结点”，这个对应个数也称为“复制个数”，“虚拟结点”在哈希空间中以哈希值排列。</p>
<p>仍以仅部署node A和node C的情况为例，现在我们引入虚拟结点，并设置“复制个数”为2，这就意味着一共会存在4个“虚拟结点”，node A1, node A2代表了node A；node C1，node C2代表了nodeC。假设一种比较理想的情况，参见图16-13。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220721205230497.png" alt="image-20220721205230497"></p>
<p>此时，数据object1和objec2被映射到了nodeA上，而objec3和object4映射到了nodeC上。平衡性有了很大提高。</p>
</li>
</ul>
<h3 id="6-7-海量数据处理"><a href="#6-7-海量数据处理" class="headerlink" title="6.7 海量数据处理"></a>6.7 海量数据处理</h3><p>所谓海量数据处理，就是基于海量数据的查找、统计、运算等操作。所谓海量数据，就是数据量太大，所以导致要么是<u>无法在较短时间内迅速解决</u>，要么是<u>数据太大导致无法一次性装入内存</u>。从而导致传统的操作无法实现。</p>
<h4 id="分治——hash映射"><a href="#分治——hash映射" class="headerlink" title="分治——hash映射"></a>分治——hash映射</h4><p>所有散列函数都有抗碰撞性：如果两个散列值是不相同的(根据同一函数)，那么这两个散列值的原始输入也是不相同的。这个特性使散列函数具有确定性的结果。</p>
<p>在对大文件进行处理时，若文件过大，无法一次性读入内存，可以考虑采取Hash映射的方法将文件中的元素映射到不同小文件中，然后再依次处理各个小文件，最后合并处理结果，这样就降低了问题规模。</p>
<blockquote>
<p>top K 问题</p>
</blockquote>
<p>在大规模数据处理中，经常会遇到的一类问题：如何寻找出最大的前K个数、或最小的K个数。</p>
<p>若这些数据能一次性读入内存，快排一次排序是时间复杂度为O(n)的解决办法；</p>
<p>但当面对着海量数据时，快排的一次划分就不能再使用。但依然可以使用堆（求最大K个数采用小根堆，求最小K个数采用大根堆），时间复杂度为O(nlogk)，空间复杂度为0(1)。故<strong>堆也是海量数据处理经常采用的工具</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220721211429024.png" alt="image-20220721211429024"></p>
<p>对单词hash后取余，按余数将文件内的单词分散到多个文件，每个文件大小不超过内存限制。然后按照分治法的思想，在每个小文件内对单词进行频率统计（trie树或者hash_map），然后对每个文件的频率前100的单词进行归并排序。</p>
<h4 id="Bit-map"><a href="#Bit-map" class="headerlink" title="Bit-map"></a>Bit-map</h4><p>Bit-map的原理就是<u>使用位数组来表示某些元素是否存在</u>，<strong>一个元素对应一位</strong>，由于采用了bit 为单位来存储数据，因此在存储空间方面，可以大大节省，故适用于海量数据的快速查找、判重、删除等。</p>
<p>假设我们要对值区间为0~7的5个元素(4, 7, 2, 5, 3) 排序(这里假设这些元素没有重复)。那么我们就可以采用Bit-map的方法来达到排序的目的。要表示8个数，我们就只需要8个bit (1Bytes)，首先我们开辟1Byte的空间，bit位依次编号为01234567，将这些空间的所有bit位都置为0，得到00000000。然后遍历待排序表，将元素值所对应的bit位置1，得到00111101。最后依次输出该位为1的编号即可：2, 3, 4, 5, 7。</p>
<p>位图排序的时间复杂度是O(n)，它是以空间换时间（需要一个n位的串）。</p>
<p>在程序设计中，经常需要判断集合中是否存在重复的问题，当数据量比较大时，位图法比较适合。</p>
<blockquote>
<p>例2：已知某个文件内包含一些电话号码， 每个号码为8位数字，统计不同号码的个数。</p>
<p>解答：8位数字表示的最大数为99999，可以理解为从0~99999999的数字，一共10的8次方个数字。用bit-map解决，则每个数字对应一个 bit位，所以只需要约12MB（约等于10的8次方）。这样，就用了只有12M左右的内存表示了所有的8位数的电话。依次读入每个电话号码，然后将bitmap相应位置为1，最后统计bit- map中为1的位数即为不同号码的个数。</p>
</blockquote>
<p>位图法还可用来快速判断集合中某个数据是否存在。</p>
<blockquote>
<p>例3：给40亿个不重复的unsigned int 的整数，没排过序的，然后再给一个数， 如何快速判断这个数是否在40亿个数当中?</p>
<p>解答：unsigned int最多有$2^{32}$个数，用Bit-map的方法，申请512M (512*20*8&#x3D;$2^{32}$) 的内存，一个bit位代表个unsigned int值。读入40亿个数，设置相应的bit位，读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。</p>
<p>本题若限制进一步节省内存，但可以允许一定的错误率，那么可以采用下节将要介绍的Bloom filter。</p>
</blockquote>
<blockquote>
<p>例4：在2.5亿个整数中找出<strong>只出现一次</strong>的整数，内存不足以容纳这2.5亿个整数。</p>
<p>方案1：采用2-Bitmap （每个数分配2bit, 00表示不存在，01表示出现一次， 10表示多次，11无意义）进行，共需内存$2^{32}$*2bit&#x3D;1GB内存，其中$2^{32}$是因为整数最多有$2^{32}$个。然后依次扫描这2.5亿个整数，查看Bitmap中对应位，如果是00变01, 01变10，10 保持不变。扫描结束后，查看bitmap，把对应位是01的整数输出即可。</p>
<p>方案2：也可采用Hash映射的方法，划分成多个小文件。然后在小文件中利用hash_map找出不重复的整数。</p>
</blockquote>
<h4 id="Bloom-Filter"><a href="#Bloom-Filter" class="headerlink" title="Bloom Filter"></a>Bloom Filter</h4><p>Bloom Filter（布隆过滤器）可以视为对Bit-map的扩展。Bit-map的作法是申请一个N位（N为集合中最大整数）的数组，然后每一位对应一个特定整数。</p>
<p>Bloom Filter 的基本原理是<strong>位数组与Hash函数联合使用</strong>，使用多个hash函数将<strong>元素映射到位数组的多个位上，多个置1的位共同表示该元素存在</strong>。具体而言，Bloom Filter 是一个包含了N位的位数组，数组的每一位都初始化为0，然后定义k个不同的Hash函数，每个Hash函数都可以将集合中的元素映射到位数组中的某一位。</p>
<p>当向集合中 <strong>插入</strong> 一个元素时，根据k个Hash函数可以得到位数组中的k个位，将这些位全部设置为1（如果一个位置多次被置为1，那么只有第一次会起作用，后面几次将没有任何效果）；</p>
<p>当要 <strong>查询</strong> 某个元素是否属于集合时，就使用k个哈希函数得到此元素对应的k个位，如果所有点都是1，那么元素在集合内（其实是可能在这个集合，因为有可能某个为1的位是被别的元素置1的，所以<u>存在出错的可能</u>）；如果有0，元素则不在集合内。</p>
<p>Bloom Filter的位数m通常要比集合中的最大元素小得多，可见，Bloom Filter是一种空间效率和时间效率很高的随机数据结构，但这种高效是有一-定代价的：在判断一个元素是否属于某个集合时，有可能会把不属于这个集合的元素误认为属于这个集合。因此，Bloom Filter<u>不适合那些“零错误”应用场合</u>。而在能容忍低错误率的应用场合下，Bloom Filter通过极少的错误换取了存储空间的极大节省。</p>
<h4 id="倒排索引法"><a href="#倒排索引法" class="headerlink" title="倒排索引法"></a>倒排索引法</h4><p>正向索引是用来存储每个文档所包含的单词的列表，在正向索引中，文档占据了中心的位置，每个文档指向了一个它所包含的索引项的序列。倒排索引则相反，其存储包含某个单词的文档列表。</p>
<p>倒排索引也常被称为反向索引、置入档案或反向档案，是一种索引方法，被用来存储在全文检索下某个单词在一个文档或者一组文档中的存储位置的映射。它是文档检索系统中最常用的数据结构。</p>
<p><strong>适用范围</strong>：搜索引擎的关键字查询。</p>
<p>以英文为例，下面是要被索引的文本：</p>
<blockquote>
<p>T0 &#x3D; “it is what it is”<br>T1 &#x3D; “what is it”<br>T2 &#x3D; “it is a banana”</p>
</blockquote>
<p>我们就能得到下面的反向文件索引：（0、1、2代表上述3个文本，集合代表出现了该单词的文本）</p>
<blockquote>
<p>“a”：{2}<br>“banana”：{2}<br>“is”：{0, 1, 2}<br>“it”：{0, 1, 2}<br>“what”：{0, 1}</p>
</blockquote>
<p>那么当用户检索的条件为”what”, “is”和I”it”，则将分别查询这三个关键词对应的文本集合，即{0, 1, 2}、{0, 1, 2}、{0, 1}，然后求对应集合的 <strong>交集</strong>，得到{0, 1}，这样就能确定包含关键字的文本。</p>
<p>可见，倒排索引在处理复杂的<u>多关键字查询</u>时，可在倒排表中先完成查询的<u>并、交等逻辑运算</u>，得到结果后再对记录进行存取。</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">ccb</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://frankcao3.github.io/posts/undefined">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://frankcao3.github.io/posts/undefined')">数据结构</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://frankcao3.github.io/posts/undefined"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=数据结构&amp;url=https://frankcao3.github.io/posts/undefined&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>计算机基础<span class="tagsPageCount">5</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/58062"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">利用hexo+gitHub搭建个人博客</div></div></a></div><div class="next-post pull-right"><a href="/posts/undefined"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">C/C++ 基础知识</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%93%BE%E8%A1%A8"><span class="toc-number">1.1.</span> <span class="toc-text">1 链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 单链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 快慢指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3 双链表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97"><span class="toc-number">1.2.</span> <span class="toc-text">2 栈与队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%A0%88%EF%BC%88%E5%A0%86%E6%A0%88%EF%BC%89"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 栈（堆栈）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">栈的顺序存储结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E9%93%BE%E6%A0%88"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">栈的链式存储结构——链栈</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 栈的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">中缀表达式和后缀表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%B1%82%E5%80%BC"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">后缀表达式的求值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-Catalan%E6%95%B0"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 Catalan数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E5%87%BA%E6%A0%88%E5%BA%8F%E5%88%97"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">进出栈序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">括号序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">二叉树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E9%98%9F%E5%88%97"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.4 队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">队列的顺序存储结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">环形队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E9%93%BE%E9%98%9F"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">队列的链式存储结构——链队</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%A0%91"><span class="toc-number">1.3.</span> <span class="toc-text">3 树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%80%A7%E8%B4%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1 树的基本概念和性质</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%B4%A8"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">性质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">树的存储结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2 二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">满二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">完全二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">二叉树的性质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">二叉树的存储结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x3D-x3D-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-x3D-x3D"><span class="toc-number">1.3.2.5.</span> <span class="toc-text">&#x3D;&#x3D;二叉树的遍历&#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3 二叉树的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.3.4.</span> <span class="toc-text">3.4 树的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91-BST"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">二叉排序树 BST</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-AVL"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">平衡二叉树 AVL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B%E6%A0%91%E5%92%8CB-%E6%A0%91"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">B树和B+树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">1.3.4.4.</span> <span class="toc-text">红黑树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%8F%8A%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-number">1.3.4.5.</span> <span class="toc-text">哈夫曼树及哈夫曼编码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">1.3.5.</span> <span class="toc-text">3.5 并查集</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%9B%BE"><span class="toc-number">1.4.</span> <span class="toc-text">4 图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1 图的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E5%8F%8A%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.2 图的存储及基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E6%B3%95"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">邻接矩阵法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8%E6%B3%95"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">邻接表法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.4.3.</span> <span class="toc-text">4.3 图的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#x3D-x3D-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2DFS-x3D-x3D"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">&#x3D;&#x3D;深度优先搜索DFS&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x3D-x3D-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-BFS-x3D-x3D"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">&#x3D;&#x3D;广度优先搜索 BFS&#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E5%9B%BE%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.4.4.</span> <span class="toc-text">4.4 图遍历算法的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8"><span class="toc-number">1.4.5.</span> <span class="toc-text">4.5 图的基本应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">最小生成树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-number">1.4.5.2.</span> <span class="toc-text">最短路径</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#x3D-x3D-Dijkstra%E7%AE%97%E6%B3%95-x3D-x3D-%EF%BC%88BFS-%E8%B4%AA%E5%BF%83%EF%BC%89%E6%B1%82%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E7%9A%84%E5%BE%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.5.2.1.</span> <span class="toc-text">&#x3D;&#x3D;Dijkstra算法&#x3D;&#x3D;（BFS+贪心）求单源最短的径问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#x3D-x3D-Floyd%E7%AE%97%E6%B3%95-x3D-x3D-%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89"><span class="toc-number">1.4.5.2.2.</span> <span class="toc-text">&#x3D;&#x3D;Floyd算法&#x3D;&#x3D;（动态规划）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">1.4.5.3.</span> <span class="toc-text">拓扑排序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%8E%92%E5%BA%8F"><span class="toc-number">1.5.</span> <span class="toc-text">5 排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">1.5.1.</span> <span class="toc-text">5.1 插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">直接插入排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">希尔排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F"><span class="toc-number">1.5.2.</span> <span class="toc-text">5.2 交换排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x3D-x3D-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-x3D-x3D-%EF%BC%88%E5%B8%B8%E8%80%83%EF%BC%89"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">&#x3D;&#x3D;快速排序&#x3D;&#x3D;（常考）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E6%8E%92%E4%B8%80%E6%AC%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">快排一次排序的应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">1.5.3.</span> <span class="toc-text">5.3 选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">简单选择排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">堆排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">堆排序的应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">1.5.4.</span> <span class="toc-text">5.4 归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E8%B7%AF%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">二路归并排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">多路归并排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">1.5.5.</span> <span class="toc-text">5.5 计数排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#x3D-x3D-5-5-%E6%A1%B6%E6%8E%92%E5%BA%8F-x3D-x3D-%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">1.5.6.</span> <span class="toc-text">&#x3D;&#x3D;5.5 桶排序&#x3D;&#x3D;（重要）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">1.5.7.</span> <span class="toc-text">5.5 基数排序（重要）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-%E4%B8%8D%E5%90%8C%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.5.8.</span> <span class="toc-text">5.6 不同排序算法的比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%9F%A5%E6%89%BE"><span class="toc-number">1.6.</span> <span class="toc-text">6 查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.6.1.</span> <span class="toc-text">6.1 基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE"><span class="toc-number">1.6.2.</span> <span class="toc-text">6.2 折半查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E9%94%AE%E6%A0%91"><span class="toc-number">1.6.3.</span> <span class="toc-text">6.3 键树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%AE%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8ETrie%E6%A0%91"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">键树的定义与Trie树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%AE%E6%A0%91%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">键树的两种实现的对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E5%90%8E%E7%BC%80%E6%A0%91%E4%B8%8E%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84"><span class="toc-number">1.6.4.</span> <span class="toc-text">6.4 后缀树与后缀数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E7%BC%80%E6%A0%91"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">后缀树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84"><span class="toc-number">1.6.4.2.</span> <span class="toc-text">后缀数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-%E5%93%88%E5%B8%8C%E8%A1%A8-%E9%87%8D%E7%82%B9"><span class="toc-number">1.6.5.</span> <span class="toc-text">6.5 哈希表(重点)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1"><span class="toc-number">1.6.5.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hash%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.5.2.</span> <span class="toc-text">hash函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%86%B2%E7%AA%81%EF%BC%88%E7%A2%B0%E6%92%9E%EF%BC%89%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.5.3.</span> <span class="toc-text">处理冲突（碰撞）的方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C"><span class="toc-number">1.6.6.</span> <span class="toc-text">6.6 一致性哈希</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E9%9B%86%E7%BE%A4"><span class="toc-number">1.6.6.1.</span> <span class="toc-text">普通集群</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hash%E9%9B%86%E7%BE%A4"><span class="toc-number">1.6.6.2.</span> <span class="toc-text">hash集群</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C"><span class="toc-number">1.6.6.3.</span> <span class="toc-text">一致性哈希</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86"><span class="toc-number">1.6.7.</span> <span class="toc-text">6.7 海量数据处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%B2%BB%E2%80%94%E2%80%94hash%E6%98%A0%E5%B0%84"><span class="toc-number">1.6.7.1.</span> <span class="toc-text">分治——hash映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bit-map"><span class="toc-number">1.6.7.2.</span> <span class="toc-text">Bit-map</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bloom-Filter"><span class="toc-number">1.6.7.3.</span> <span class="toc-text">Bloom Filter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E6%B3%95"><span class="toc-number">1.6.7.4.</span> <span class="toc-text">倒排索引法</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/undefined" title="Hello World">Hello World</a><time datetime="2023-10-05T11:40:46.695Z" title="Created 2023-10-05 19:40:46">2023-10-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/undefined" title="SQL注入-WAF绕过">SQL注入-WAF绕过</a><time datetime="2022-08-04T16:00:00.000Z" title="Created 2022-08-05 00:00:00">2022-08-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/undefined" title="CRLF注入漏洞（反弹型XSS）">CRLF注入漏洞（反弹型XSS）</a><time datetime="2022-08-04T16:00:00.000Z" title="Created 2022-08-05 00:00:00">2022-08-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/undefined" title="RCE代码及命令执行">RCE代码及命令执行</a><time datetime="2022-08-04T16:00:00.000Z" title="Created 2022-08-05 00:00:00">2022-08-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/undefined" title="文件下载">文件下载</a><time datetime="2022-08-04T16:00:00.000Z" title="Created 2022-08-05 00:00:00">2022-08-05</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2023 By <a class="footer-bar-link" href="/" title="ccb" target="_blank">ccb</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">Articles</div><div class="length-num">40</div></a><a href="/tags/" title="tag"><div class="headline">Tags</div><div class="length-num">6</div></a><a href="/categories/" title="category"><div class="headline">Categories</div><div class="length-num">0</div></a></div><span class="sidebar-menu-item-title">Function</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="Display Mode"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>Display Mode</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/DVWA%E9%9D%B6%E5%9C%BA/" style="font-size: 0.88rem;">DVWA靶场<sup>10</sup></a><a href="/tags/%E5%AE%9E%E8%AE%AD-%E7%BD%91%E7%BB%9C%E5%BB%BA%E8%AE%BE%E9%83%A8%E5%88%86/" style="font-size: 0.88rem;">实训-网络建设部分<sup>7</sup></a><a href="/tags/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/" style="font-size: 0.88rem;">搭建博客<sup>1</sup></a><a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 0.88rem;">机器学习<sup>1</sup></a><a href="/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/" style="font-size: 0.88rem;">渗透测试<sup>15</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" style="font-size: 0.88rem;">计算机基础<sup>5</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.8",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 ccb 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "visitor@anheyu.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>